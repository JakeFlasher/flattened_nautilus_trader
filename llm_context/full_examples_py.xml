<documents><document index="1778">
<source>examples/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1779">
<source>examples/backtest/betfair_backtest_orderbook_imbalance.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.adapters.betfair import BETFAIR_CLIENT_ID
from nautilus_trader.adapters.betfair import BETFAIR_VENUE
from nautilus_trader.adapters.betfair import BetfairParser
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalance
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalanceConfig
from nautilus_trader.model.currencies import GBP
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.objects import Money
from tests.integration_tests.adapters.betfair.test_kit import BetfairDataProvider
from tests.integration_tests.adapters.betfair.test_kit import betting_instrument


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(trader_id=TraderId("BACKTESTER-001"))

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    engine.add_venue(
        venue=BETFAIR_VENUE,
        oms_type=OmsType.NETTING,
        account_type=AccountType.CASH,  # Spot CASH account (not for perpetuals or futures)
        base_currency=GBP,  # Multi-currency account
        starting_balances=[Money(100_000, GBP)],
        book_type=BookType.L2_MBP,
    )

    # Add instruments
    instruments = [
        betting_instrument(
            market_id="1-166811431",
            selection_id=19248890,
            selection_handicap=0.0,
        ),
        betting_instrument(
            market_id="1-166811431",
            selection_id=38848248,
            selection_handicap=0.0,
        ),
    ]
    engine.add_instrument(instruments[0])
    engine.add_instrument(instruments[1])

    # Add data
    raw = list(BetfairDataProvider.market_updates())
    parser = BetfairParser(currency=GBP.code)
    updates = [upd for update in raw for upd in parser.parse(update)]
    engine.add_data(updates, client_id=BETFAIR_CLIENT_ID)

    # Configure your strategy
    strategies = [
        OrderBookImbalance(
            config=OrderBookImbalanceConfig(
                instrument_id=instrument.id,
                max_trade_size=Decimal(10),
                order_id_tag=instrument.selection_id,
            ),
        )
        for instrument in instruments
    ]
    engine.add_strategies(strategies)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(BETFAIR_VENUE))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1780">
<source>examples/backtest/crypto_ema_cross_ethusdt_trade_ticks.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.adapters.binance import BINANCE_VENUE
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import LoggingConfig
from nautilus_trader.examples.algorithms.twap import TWAPExecAlgorithm
from nautilus_trader.examples.strategies.ema_cross_twap import EMACrossTWAP
from nautilus_trader.examples.strategies.ema_cross_twap import EMACrossTWAPConfig
from nautilus_trader.model.currencies import ETH
from nautilus_trader.model.currencies import USDT
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import TradeTickDataWrangler
from nautilus_trader.test_kit.providers import TestDataProvider
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(
            log_level="INFO",
            log_colors=True,
            use_pyo3=False,
        ),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    engine.add_venue(
        venue=BINANCE_VENUE,
        oms_type=OmsType.NETTING,
        book_type=BookType.L1_MBP,
        account_type=AccountType.CASH,  # Spot CASH account (not for perpetuals or futures)
        base_currency=None,  # Multi-currency account
        starting_balances=[Money(1_000_000.0, USDT), Money(10.0, ETH)],
        trade_execution=True,  # Only use with L1_MBP book type or throttled book data
    )

    # Add instruments
    ETHUSDT_BINANCE = TestInstrumentProvider.ethusdt_binance()
    engine.add_instrument(ETHUSDT_BINANCE)

    # Add data
    provider = TestDataProvider()
    wrangler = TradeTickDataWrangler(instrument=ETHUSDT_BINANCE)
    ticks = wrangler.process(provider.read_csv_ticks("binance/ethusdt-trades.csv"))
    engine.add_data(ticks)

    # Configure your strategy
    strategy_config = EMACrossTWAPConfig(
        instrument_id=ETHUSDT_BINANCE.id,
        bar_type=BarType.from_str("ETHUSDT.BINANCE-250-TICK-LAST-INTERNAL"),
        trade_size=Decimal("0.10"),
        fast_ema_period=10,
        slow_ema_period=20,
        twap_horizon_secs=10.0,
        twap_interval_secs=2.5,
    )

    # Instantiate and add your strategy
    strategy = EMACrossTWAP(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    # Instantiate and add your execution algorithm
    exec_algorithm = TWAPExecAlgorithm()
    engine.add_exec_algorithm(exec_algorithm)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(BINANCE_VENUE))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # Generate interactive tearsheet (requires: pip install plotly>=6.3.1)
    try:
        from nautilus_trader.analysis import TearsheetConfig
        from nautilus_trader.analysis.tearsheet import create_tearsheet

        print("\nGenerating tearsheet...")

        # Try different themes: "plotly_white", "plotly_dark", "nautilus", "nautilus_dark"
        tearsheet_config = TearsheetConfig(theme="plotly_white")  # Change this to test themes!

        create_tearsheet(
            engine=engine,
            output_path="crypto_ethusdt_tearsheet.html",
            config=tearsheet_config,
        )
        print("Tearsheet saved to: crypto_ethusdt_tearsheet.html")
        print(f"Theme: {tearsheet_config.theme}")
        print("Open this file in your browser to view interactive charts!")
    except ImportError:
        print("\nPlotly not installed. Install with: pip install plotly>=6.3.1")
        print("  Then re-run to generate tearsheets.")

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1781">
<source>examples/backtest/crypto_ema_cross_ethusdt_trailing_stop.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.adapters.binance import BINANCE_VENUE
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.examples.strategies.ema_cross_trailing_stop import EMACrossTrailingStop
from nautilus_trader.examples.strategies.ema_cross_trailing_stop import EMACrossTrailingStopConfig
from nautilus_trader.model.currencies import ETH
from nautilus_trader.model.currencies import USDT
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import TradeTickDataWrangler
from nautilus_trader.test_kit.providers import TestDataProvider
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(trader_id=TraderId("BACKTESTER-001"))

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    engine.add_venue(
        venue=BINANCE_VENUE,
        oms_type=OmsType.NETTING,
        account_type=AccountType.CASH,  # Spot CASH account (not for perpetuals or futures)
        base_currency=None,  # Multi-currency account
        starting_balances=[Money(1_000_000, USDT), Money(10, ETH)],
    )

    # Add instruments
    ETHUSDT_BINANCE = TestInstrumentProvider.ethusdt_binance()
    engine.add_instrument(ETHUSDT_BINANCE)

    # Add data
    provider = TestDataProvider()
    wrangler = TradeTickDataWrangler(instrument=ETHUSDT_BINANCE)
    ticks = wrangler.process(provider.read_csv_ticks("binance/ethusdt-trades.csv"))
    engine.add_data(ticks)

    # Configure your strategy
    strategy_config = EMACrossTrailingStopConfig(
        instrument_id=ETHUSDT_BINANCE.id,
        bar_type=BarType.from_str("ETHUSDT.BINANCE-100-TICK-LAST-INTERNAL"),
        trade_size=Decimal("0.10"),
        fast_ema_period=10,
        slow_ema_period=20,
        atr_period=20,
        trailing_atr_multiple=3.0,
        trailing_offset_type="PRICE",
        trigger_type="LAST_PRICE",
    )
    # Instantiate and add your strategy
    strategy = EMACrossTrailingStop(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(BINANCE_VENUE))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1782">
<source>examples/backtest/crypto_ema_cross_with_binance_provider.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.adapters.binance import BINANCE_VENUE
from nautilus_trader.adapters.binance import get_cached_binance_http_client
from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
from nautilus_trader.adapters.binance.futures.providers import BinanceFuturesInstrumentProvider
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.common.component import LiveClock
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.examples.strategies.ema_cross_trailing_stop import EMACrossTrailingStop
from nautilus_trader.examples.strategies.ema_cross_trailing_stop import EMACrossTrailingStopConfig
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import Symbol
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import QuoteTickDataWrangler
from nautilus_trader.test_kit.providers import TestDataProvider


async def create_provider():
    """
    Create a provider to load all instrument data from live exchange.
    """
    clock = LiveClock()

    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.USDT_FUTURES,
        is_testnet=True,
    )

    binance_provider = BinanceFuturesInstrumentProvider(
        client=client,
        clock=clock,
        config=InstrumentProviderConfig(load_all=True, log_warnings=False),
    )

    await binance_provider.load_all_async()
    return binance_provider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    # Use actual Binance instrument for backtesting
    provider: BinanceFuturesInstrumentProvider = asyncio.run(create_provider())

    instrument_id = InstrumentId(symbol=Symbol("ETHUSDT-PERP"), venue=BINANCE_VENUE)
    instrument = provider.find(instrument_id)
    if instrument is None:
        raise RuntimeError(f"Unable to find instrument {instrument_id}")

    engine.add_venue(
        venue=BINANCE_VENUE,
        oms_type=OmsType.NETTING,
        account_type=AccountType.MARGIN,
        base_currency=None,
        starting_balances=[Money(1_000_000, instrument.quote_currency)],
    )

    engine.add_instrument(instrument)

    bar_type = BarType.from_str(f"{instrument_id.value}-1-MINUTE-BID-INTERNAL")
    wrangler = QuoteTickDataWrangler(instrument=instrument)
    ticks = wrangler.process_bar_data(
        bid_data=TestDataProvider().read_csv_bars("btc-perp-20211231-20220201_1m.csv"),
        ask_data=TestDataProvider().read_csv_bars("btc-perp-20211231-20220201_1m.csv"),
    )

    engine.add_data(ticks)

    # Configure your strategy
    strategy_config = EMACrossTrailingStopConfig(
        instrument_id=instrument.id,
        bar_type=bar_type,
        trade_size=Decimal(1),
        fast_ema_period=10,
        slow_ema_period=20,
        atr_period=20,
        trailing_atr_multiple=3.0,
        trailing_offset_type="PRICE",
        trigger_type="LAST_PRICE",
    )
    # Instantiate and add your strategy
    strategy = EMACrossTrailingStop(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(BINANCE_VENUE))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1783">
<source>examples/backtest/crypto_orderbook_imbalance.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal
from pathlib import Path

import pandas as pd

from nautilus_trader.adapters.binance import BINANCE_VENUE
from nautilus_trader.adapters.binance.loaders import BinanceOrderBookDeltaDataLoader
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalance
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalanceConfig
from nautilus_trader.model.currencies import BTC
from nautilus_trader.model.currencies import USDT
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.enums import book_type_to_str
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import OrderBookDeltaDataWrangler
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        # logging=LoggingConfig(log_level="DEBUG"),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    # Ensure the book type matches the data
    book_type = BookType.L2_MBP

    engine.add_venue(
        venue=BINANCE_VENUE,
        oms_type=OmsType.NETTING,
        account_type=AccountType.CASH,
        base_currency=None,  # Multi-currency account
        starting_balances=[Money(1_000_000.0, USDT), Money(100.0, BTC)],
        book_type=book_type,  # <-- Venues order book
    )

    # Add instruments
    BTCUSDT_BINANCE = TestInstrumentProvider.btcusdt_binance()
    engine.add_instrument(BTCUSDT_BINANCE)

    # Add data
    data_dir = Path("~/Downloads").expanduser() / "Data" / "Binance"

    path_snap = data_dir / "BTCUSDT_T_DEPTH_2022-11-01_depth_snap.csv"
    print(f"Loading {path_snap} ...")
    df_snap = BinanceOrderBookDeltaDataLoader.load(path_snap)
    print(str(df_snap))

    path_update = data_dir / "BTCUSDT_T_DEPTH_2022-11-01_depth_update.csv"
    print(f"Loading {path_update} ...")
    nrows = 1_000_000
    df_update = BinanceOrderBookDeltaDataLoader.load(path_update, nrows=nrows)
    print(str(df_update))

    print("Wrangling OrderBookDelta objects ...")
    wrangler = OrderBookDeltaDataWrangler(instrument=BTCUSDT_BINANCE)
    deltas = wrangler.process(df_snap)
    deltas += wrangler.process(df_update)
    engine.add_data(deltas)

    # Configure your strategy
    strategy_config = OrderBookImbalanceConfig(
        instrument_id=BTCUSDT_BINANCE.id,
        max_trade_size=Decimal("1.000"),
        min_seconds_between_triggers=1.0,
        book_type=book_type_to_str(book_type),
    )

    # Instantiate and add your strategy
    strategy = OrderBookImbalance(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(BINANCE_VENUE))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1784">
<source>examples/backtest/databento_cme_quoter.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from pathlib import Path

import pandas as pd

from nautilus_trader.adapters.databento import DatabentoDataLoader
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RiskEngineConfig
from nautilus_trader.examples.strategies.simpler_quoter import SimpleQuoterStrategy
from nautilus_trader.examples.strategies.simpler_quoter import SimpleQuoterStrategyConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
        risk_engine=RiskEngineConfig(bypass=True),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    XCME = Venue("XCME")  # <-- ISO 10383 MIC
    engine.add_venue(
        venue=XCME,
        oms_type=OmsType.NETTING,
        account_type=AccountType.MARGIN,
        base_currency=USD,
        starting_balances=[Money(1_000_000.0, USD)],
    )

    # Add instruments
    ESZ5 = TestInstrumentProvider.es_future(
        expiry_year=2025,
        expiry_month=12,
        venue=XCME,
    )
    engine.add_instrument(ESZ5)

    # Add data
    loader = DatabentoDataLoader()

    paths = [
        "~/Downloads/GLBX-20251023-C8KMULLDMW/glbx-mdp3-20251012.mbp-1.dbn.zst",
        # "/Downloads/GLBX-20251023-C8KMULLDMW/glbx-mdp3-20251013.mbp-1.dbn.zst",
    ]

    for path in paths:
        quotes = loader.from_dbn_file(
            path=Path(path).expanduser(),
            instrument_id=ESZ5.id,
        )
        engine.add_data(quotes)

    # Configure your strategy
    config_strategy = SimpleQuoterStrategyConfig(
        instrument_id=ESZ5.id,
        tob_offset_ticks=0,
        log_data=False,
    )

    # Instantiate and add your strategy
    strategy = SimpleQuoterStrategy(config=config_strategy)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(XCME))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1785">
<source>examples/backtest/databento_ema_cross_long_only_aapl_bars.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader import TEST_DATA_DIR
from nautilus_trader.adapters.databento import DatabentoDataLoader
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RiskEngineConfig
from nautilus_trader.examples.strategies.ema_cross_long_only import EMACrossLongOnly
from nautilus_trader.examples.strategies.ema_cross_long_only import EMACrossLongOnlyConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
        risk_engine=RiskEngineConfig(bypass=True),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    NASDAQ = Venue("XNAS")  # <-- ISO 10383 MIC
    engine.add_venue(
        venue=NASDAQ,
        oms_type=OmsType.NETTING,
        account_type=AccountType.CASH,
        base_currency=USD,
        starting_balances=[Money(1_000_000.0, USD)],
    )

    # Add instruments
    AAPL_XNAS = TestInstrumentProvider.equity(symbol="AAPL", venue="XNAS")
    engine.add_instrument(AAPL_XNAS)

    # Add data
    loader = DatabentoDataLoader()

    filenames = [
        "aapl-xnas-ohlcv-1s-2023.dbn.zst",  # <-- Longer load and run time / more accurate execution
        "aapl-xnas-ohlcv-1m-2023.dbn.zst",
    ]

    for filename in filenames:
        bars = loader.from_dbn_file(
            path=TEST_DATA_DIR / "databento" / "temp" / filename,
            instrument_id=AAPL_XNAS.id,
        )
        engine.add_data(bars)

    # Configure your strategy
    strategy_config = EMACrossLongOnlyConfig(
        instrument_id=AAPL_XNAS.id,
        bar_type=BarType.from_str(f"{AAPL_XNAS.id}-1-MINUTE-LAST-EXTERNAL"),
        trade_size=Decimal(100),
        fast_ema_period=10,
        slow_ema_period=20,
    )

    # Instantiate and add your strategy
    strategy = EMACrossLongOnly(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(NASDAQ))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1786">
<source>examples/backtest/databento_ema_cross_long_only_spy_trades.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader import TEST_DATA_DIR
from nautilus_trader.adapters.databento import DatabentoDataLoader
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import LoggingConfig
from nautilus_trader.examples.strategies.ema_cross_long_only import EMACrossLongOnly
from nautilus_trader.examples.strategies.ema_cross_long_only import EMACrossLongOnlyConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    NASDAQ = Venue("XNAS")
    engine.add_venue(
        venue=NASDAQ,
        oms_type=OmsType.NETTING,
        account_type=AccountType.CASH,
        base_currency=USD,
        starting_balances=[Money(1_000_000.0, USD)],
    )

    # Add instruments
    SPY_XNAS = TestInstrumentProvider.equity(symbol="SPY", venue="XNAS")
    engine.add_instrument(SPY_XNAS)

    # Add data
    loader = DatabentoDataLoader()

    filenames = [
        "spy-xnas-trades-2024-01.dbn.zst",
        "spy-xnas-trades-2024-02.dbn.zst",
        "spy-xnas-trades-2024-03.dbn.zst",
    ]

    for filename in filenames:
        trades = loader.from_dbn_file(
            path=TEST_DATA_DIR / "databento" / "temp" / filename,
            instrument_id=SPY_XNAS.id,
        )
        engine.add_data(trades)

    # Configure your strategy
    strategy_config = EMACrossLongOnlyConfig(
        instrument_id=SPY_XNAS.id,
        bar_type=BarType.from_str(f"{SPY_XNAS.id}-1000-TICK-LAST-INTERNAL"),
        trade_size=Decimal(100),
        fast_ema_period=10,
        slow_ema_period=20,
        request_historical_bars=False,  # Using internally aggregated tick bars
    )

    # Instantiate and add your strategy
    strategy = EMACrossLongOnly(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(NASDAQ))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1787">
<source>examples/backtest/databento_ema_cross_long_only_tsla_trades.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader import TEST_DATA_DIR
from nautilus_trader.adapters.databento import DatabentoDataLoader
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import LoggingConfig
from nautilus_trader.examples.strategies.ema_cross_long_only import EMACrossLongOnly
from nautilus_trader.examples.strategies.ema_cross_long_only import EMACrossLongOnlyConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Add a trading venue (multiple venues possible)
    NYSE = Venue("NYSE")
    engine.add_venue(
        venue=NYSE,
        oms_type=OmsType.NETTING,
        account_type=AccountType.CASH,
        base_currency=USD,
        starting_balances=[Money(1_000_000.0, USD)],
    )

    # Add instruments
    TSLA_NYSE = TestInstrumentProvider.equity(symbol="TSLA", venue="NYSE")
    engine.add_instrument(TSLA_NYSE)

    # Add data
    loader = DatabentoDataLoader()

    filenames = [
        "tsla-dbeq-basic-trades-2024-01.dbn.zst",
        "tsla-dbeq-basic-trades-2024-02.dbn.zst",
        "tsla-dbeq-basic-trades-2024-03.dbn.zst",
    ]

    for filename in filenames:
        trades = loader.from_dbn_file(
            path=TEST_DATA_DIR / "databento" / "temp" / filename,
            instrument_id=TSLA_NYSE.id,
        )
        engine.add_data(trades)

    # Configure your strategy
    strategy_config = EMACrossLongOnlyConfig(
        instrument_id=TSLA_NYSE.id,
        bar_type=BarType.from_str(f"{TSLA_NYSE.id}-1-MINUTE-LAST-INTERNAL"),
        trade_size=Decimal(1000),
        fast_ema_period=10,
        slow_ema_period=20,
    )

    # Instantiate and add your strategy
    strategy = EMACrossLongOnly(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(NYSE))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object
    engine.dispose()

</document_content>
</document>
<document index="1789">
<source>examples/backtest/example_01_load_bars_from_custom_csv/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd
from strategy import DemoStrategy

from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import BarDataWrangler
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Step 1: Configure and create backtest engine
    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST_TRADER-001"),
        logging=LoggingConfig(
            log_level="DEBUG",  # set DEBUG log level for console to see loaded bars in logs
        ),
    )
    engine = BacktestEngine(config=engine_config)

    # Step 2: Define exchange and add it to the engine
    XCME = Venue("XCME")
    engine.add_venue(
        venue=XCME,
        oms_type=OmsType.NETTING,  # Order Management System type
        account_type=AccountType.MARGIN,  # Type of trading account
        starting_balances=[Money(1_000_000, USD)],  # Initial account balance
        base_currency=USD,  # Base currency for account
        default_leverage=Decimal(1),  # No leverage used for account
    )

    # Step 3: Create instrument definition and add it to the engine
    EURUSD_FUTURES_INSTRUMENT = TestInstrumentProvider.eurusd_future(
        expiry_year=2024,
        expiry_month=3,
        venue_name="XCME",
    )
    engine.add_instrument(EURUSD_FUTURES_INSTRUMENT)

    # ==========================================================================================
    # POINT OF FOCUS: Loading bars from CSV
    # ------------------------------------------------------------------------------------------

    # Step 4a: Load bar data from CSV file -> into pandas DataFrame
    csv_file_path = r"6EH4.XCME_1min_bars.csv"
    df = pd.read_csv(csv_file_path, sep=";", decimal=".", header=0, index_col=False)

    # Step 4b: Restructure DataFrame into required structure, that can be passed `BarDataWrangler`
    #   - 5 columns: 'open', 'high', 'low', 'close', 'volume' (volume is optional)
    #   - 'timestamp' as index

    # Change order of columns
    df = df.reindex(columns=["timestamp_utc", "open", "high", "low", "close", "volume"])
    # Convert string timestamps into datetime
    df["timestamp_utc"] = pd.to_datetime(df["timestamp_utc"], format="%Y-%m-%d %H:%M:%S")
    # Rename column to required name
    df = df.rename(columns={"timestamp_utc": "timestamp"})
    # Seet column `timestamp` as index
    df = df.set_index("timestamp")

    # Step 4c: Define type of loaded bars
    EURUSD_FUTURES_1MIN_BARTYPE = BarType.from_str(
        f"{EURUSD_FUTURES_INSTRUMENT.id}-1-MINUTE-LAST-EXTERNAL",
    )

    # Step 4d: `BarDataWrangler` converts each row into objects of type `Bar`
    wrangler = BarDataWrangler(EURUSD_FUTURES_1MIN_BARTYPE, EURUSD_FUTURES_INSTRUMENT)
    eurusd_1min_bars_list: list[Bar] = wrangler.process(df)

    # Step 4e: Add loaded data to the engine
    engine.add_data(eurusd_1min_bars_list)

    # ------------------------------------------------------------------------------------------
    # END OF POINT OF FOCUS
    # ==========================================================================================

    # Step 5: Create strategy and add it to the engine
    strategy = DemoStrategy(primary_bar_type=EURUSD_FUTURES_1MIN_BARTYPE)
    engine.add_strategy(strategy)

    # Step 6: Run engine = Run backtest
    engine.run()

    # Step 7: Release system resources
    engine.dispose()

</document_content>
</document>
<document index="1790">
<source>examples/backtest/example_01_load_bars_from_custom_csv/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import datetime as dt

from nautilus_trader.common.enums import LogColor
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.trading.strategy import Strategy


# This is a trivial demo strategy that simply counts all processed 1-minute bars.
class DemoStrategy(Strategy):
    def __init__(self, primary_bar_type: BarType):
        super().__init__()
        self.primary_bar_type = primary_bar_type
        self.bars_processed = 0
        self.start_time = None
        self.end_time = None

    def on_start(self):
        # Remember and log start time of strategy
        self.start_time = dt.datetime.now()
        self.log.info(f"Strategy started at: {self.start_time}")

        # Subscribe to bars
        self.subscribe_bars(self.primary_bar_type)

    def on_bar(self, bar: Bar):
        self.bars_processed += 1
        self.log.info(f"Processed bars: {self.bars_processed}", color=LogColor.YELLOW)

    def on_stop(self):
        # Remember and log end time of strategy
        self.end_time = dt.datetime.now()
        self.log.info(f"Strategy finished at: {self.end_time}")

        # Log count of processed bars
        self.log.info(f"Total bars processed: {self.bars_processed}")

</document_content>
</document>
<document index="1792">
<source>examples/backtest/example_02_use_clock_timer/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import SimpleTimerStrategy

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.core.nautilus_pyo3 import BarType
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":
    """
    This example demonstrates how to use timer functionality in a trading strategy.

    The strategy sets up a timer that triggers every 3 minutes and processes bar data.
    This is useful for implementing periodic actions in your trading strategies.

    """

    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST-TIMER-001"),  # Unique identifier for this backtest
        logging=LoggingConfig(
            log_level="DEBUG",  # Set to DEBUG to see detailed timer and bar processing logs
        ),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype: BarType = prepared_data["bar_type"]
    eurusd_1min_bars: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Use a netting order management system
        account_type=AccountType.MARGIN,  # Use a margin trading account
        starting_balances=[Money(1_000_000, USD)],  # Set initial capital
        base_currency=USD,  # Account currency
        default_leverage=Decimal(1),  # No leverage (1:1)
    )

    # Register the trading instrument
    engine.add_instrument(eurusd_instrument)

    # Load historical market data
    engine.add_data(eurusd_1min_bars)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create and register the timer strategy
    strategy = SimpleTimerStrategy(primary_bar_type=eurusd_1min_bartype)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1793">
<source>examples/backtest/example_02_use_clock_timer/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import datetime as dt

import pandas as pd

from nautilus_trader.common.enums import LogColor
from nautilus_trader.common.events import TimeEvent
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.trading.strategy import Strategy


class SimpleTimerStrategy(Strategy):
    TIMER_NAME = "every_3_minutes"
    TIMER_INTERVAL = pd.Timedelta(minutes=3)

    def __init__(self, primary_bar_type: BarType):
        super().__init__()
        self.primary_bar_type = primary_bar_type
        self.bars_processed = 0
        self.start_time = None
        self.end_time = None

    def on_start(self):
        # Remember and log start time of strategy
        self.start_time = dt.datetime.now()
        self.log.info(f"Strategy started at: {self.start_time}")

        # Subscribe to bars
        self.subscribe_bars(self.primary_bar_type)

        # ==================================================================
        # POINT OF FOCUS: Timer invokes action at regular time intervals
        # ------------------------------------------------------------------

        # Setup recurring timer
        self.clock.set_timer(
            name=self.TIMER_NAME,  # Custom timer name
            interval=self.TIMER_INTERVAL,  # Timer interval
            callback=self.on_timer,  # Custom callback function invoked on timer
        )

    def on_bar(self, bar: Bar):
        # You can implement any action here (like submit order), but for simplicity, we are just counting bars
        self.bars_processed += 1
        self.log.info(f"Processed bars: {self.bars_processed}")

    # ==================================================================
    # POINT OF FOCUS: Custom callback function invoked by Timer
    # ------------------------------------------------------------------

    def on_timer(self, event: TimeEvent):
        if event.name == self.TIMER_NAME:
            event_time_dt = unix_nanos_to_dt(event.ts_event)
            # You can implement any action here (like submit order), which should be executed in regular interval,
            # but for simplicity, we just create a log.
            self.log.info(
                f"TimeEvent received. | Name: {event.name} | Time: {event_time_dt}",
                color=LogColor.YELLOW,
            )

    def on_stop(self):
        # Remember and log end time of strategy
        self.end_time = dt.datetime.now()
        self.log.info(f"Strategy finished at: {self.end_time}")

        # Log count of processed bars
        self.log.info(f"Total bars processed: {self.bars_processed}")

</document_content>
</document>
<document index="1795">
<source>examples/backtest/example_03_bar_aggregation/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import DemoStrategy

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.core.nautilus_pyo3 import BarType
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":

    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST_TRADER-001"),
        logging=LoggingConfig(
            log_level="DEBUG",  # set DEBUG log level for console to see loaded bars in logs
        ),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype: BarType = prepared_data["bar_type"]
    eurusd_1min_bars_list: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Order Management System type
        account_type=AccountType.MARGIN,  # Type of trading account
        starting_balances=[Money(1_000_000, USD)],  # Initial account balance
        base_currency=USD,  # Base currency for account
        default_leverage=Decimal(1),  # No leverage used for account
    )

    # Add instrument and market data to the engine
    engine.add_instrument(eurusd_instrument)
    engine.add_data(eurusd_1min_bars_list)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create and register the bar aggregation strategy
    strategy = DemoStrategy(bar_type_1min=eurusd_1min_bartype)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1796">
<source>examples/backtest/example_03_bar_aggregation/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import datetime as dt

from nautilus_trader.common.enums import LogColor
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.trading.strategy import Strategy


class DemoStrategy(Strategy):

    def __init__(self, bar_type_1min: BarType):
        super().__init__()

        # Extract the trading instrument's ID from the 1-minute bar configuration
        self.instrument_id = bar_type_1min.instrument_id

        # Save the 1-minute bar configuration and create a counter to track how many bars we receive
        self.bar_type_1min = bar_type_1min
        self.count_1min_bars = 0  # This will increment each time we receive a 1-minute bar

        # ==================================================================
        # POINT OF FOCUS: Creating a 5-minute bar configuration
        #
        # The BarType string has this format:
        # "{instrument_id}-{step}-{aggregation}-{price_type}-{source}"
        #
        # For example: "6EH4-5-MINUTE-LAST-INTERNAL" means:
        # - instrument_id: 6EH4 (the trading instrument)
        # - step: 5
        # - aggregation: MINUTE
        # - price_type: LAST (using last traded price)
        # - source of data: INTERNAL (aggregated by Nautilus) | EXTERNAL
        # ------------------------------------------------------------------

        # Aggregated 5-min bar data
        self.bar_type_5min = BarType.from_str(f"{self.instrument_id}-5-MINUTE-LAST-INTERNAL")
        self.count_5min_bars = 0  # Counter for received 5-minute bars

        # Track when the strategy starts and ends
        self.start_time = None
        self.end_time = None

    def on_start(self):
        # Save the exact time when strategy begins
        self.start_time = dt.datetime.now()
        self.log.info(f"Strategy started at: {self.start_time}")

        # Start receiving 1-minute bar updates
        self.subscribe_bars(self.bar_type_1min)

        # ==================================================================
        # POINT OF FOCUS: Setting up 5-minute bar aggregation
        #
        # To create 5-minute bars from 1-minute data, we need a special subscription format:
        # "{target_bar_type}@{source_bar_type}"
        #
        # The '@' symbol separates:
        # - Left side (target): what we want to create (5-minute bars)
        # - Right side (source): what data to use (1-minute external bars)
        #
        # Full format:
        # "{instrument_id}-{interval}-{unit}-{price_type}@{source_interval}-{source_unit}-{source}"
        #
        # Note: instrument_id and price_type are only needed in the left (target) part
        # ------------------------------------------------------------------

        # Start receiving 5-minute bar updates (created from 1-minute external data)
        bar_type_5min_subscribe = BarType.from_str(f"{self.bar_type_5min}@1-MINUTE-EXTERNAL")
        self.subscribe_bars(bar_type_5min_subscribe)

        # The on_bar() method below will handle all bars (both 1-minute and 5-minute bar updates).

    def on_bar(self, bar: Bar):
        # Process each bar based on its type
        match bar.bar_type:
            case self.bar_type_1min:  # if 1-minute bar is handled
                self.count_1min_bars += 1
                self.log.info(
                    f"1min bar detected: {bar} | Bar time: {unix_nanos_to_dt(bar.ts_event)}",
                    color=LogColor.GREEN,
                )
            case self.bar_type_5min:  # if 5-minute bar is handled
                self.count_5min_bars += 1
                self.log.info(
                    f"5min bar detected: {bar} | Bar time: {unix_nanos_to_dt(bar.ts_event)}",
                    color=LogColor.MAGENTA,
                )
            case _:
                raise Exception(f"Bar type not expected: {bar.bar_type}")

    def on_stop(self):
        # Save the exact time when strategy ends
        self.end_time = dt.datetime.now()
        self.log.info(f"Strategy finished at: {self.end_time}")

        # Show summary of how many bars we processed
        self.log.info(f"Total count of 1-MINUTE bars: {self.count_1min_bars}")
        self.log.info(f"Total count of 5-MINUTE bars: {self.count_5min_bars}")

</document_content>
</document>
<document index="1798">
<source>examples/backtest/example_04_using_data_catalog/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import DemoStrategy

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.common.component import Logger
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.core.nautilus_pyo3 import BarType
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.catalog.parquet import ParquetDataCatalog


log = Logger(__name__)


if __name__ == "__main__":

    # ----------------------------------------------------------------------------------
    # Step 1: Configure and Create the Backtest Engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST_TRADER-001"),
        logging=LoggingConfig(
            log_level="DEBUG",  # Set to DEBUG to see detailed timer and bar processing logs
        ),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype: BarType = prepared_data["bar_type"]
    eurusd_1min_bars_list: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Netting: positions are netted against each other
        account_type=AccountType.MARGIN,  # Margin account: allows trading with leverage
        starting_balances=[Money(1_000_000, USD)],  # Initial account balance of $1,000,000 USD
        base_currency=USD,  # Account base currency is USD
        default_leverage=Decimal(1),  # No leverage is used (1:1)
    )

    # Add instrument and market data to the engine
    engine.add_instrument(eurusd_instrument)
    engine.add_data(eurusd_1min_bars_list)

    # ----------------------------------------------------------------------------------
    # 4. Configure and use Data Catalog
    # ----------------------------------------------------------------------------------

    # Create a Data Catalog (folder will be created if it doesn't exist)
    data_catalog = ParquetDataCatalog("./data_catalog")

    # Write data to the catalog
    data_catalog.write_data([eurusd_instrument])  # Store instrument definition(s)
    data_catalog.write_data(eurusd_1min_bars_list)  # Store bar data

    # Read and analyze data from the catalog
    # - Retrieve all instrument definitions
    all_instruments = data_catalog.instruments()
    log.info(f"All instruments:\n{all_instruments}", color=LogColor.YELLOW)

    # - Get all available bars
    all_bars = data_catalog.bars()
    log.info(f"All bars count: {len(all_bars)}", color=LogColor.YELLOW)

    # - Get specific bars with date range filter
    filtered_bars = data_catalog.bars(
        bar_types=[str(eurusd_1min_bartype)],
        start="2024-01-10",  # Filter start date
        end="2024-01-15",  # Filter end date
    )
    log.info(f"Bars between Jan 10-15: {len(filtered_bars)}", color=LogColor.YELLOW)

    # - List all available data types
    data_types_in_catalog = data_catalog.list_data_types()
    log.info(f"Data types stored in catalog\n{data_types_in_catalog}", color=LogColor.YELLOW)

    # ----------------------------------------------------------------------------------
    # 5. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create and register the strategy
    strategy = DemoStrategy(bar_type_1min=eurusd_1min_bartype)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1799">
<source>examples/backtest/example_04_using_data_catalog/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import datetime as dt

from nautilus_trader.common.enums import LogColor
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.trading.strategy import Strategy


class DemoStrategy(Strategy):

    def __init__(self, bar_type_1min: BarType):
        super().__init__()

        # Extract the trading instrument's ID from the 1-minute bar configuration
        self.instrument_id = bar_type_1min.instrument_id

        # Save the 1-minute bar configuration and create a counter to track how many bars we receive
        self.bar_type_1min = bar_type_1min
        self.count_1min_bars = 0  # This will increment each time we receive a 1-minute bar

        # Track when the strategy starts and ends
        self.start_time = None
        self.end_time = None

    def on_start(self):
        # Save the exact time when strategy begins
        self.start_time = dt.datetime.now()
        self.log.info(f"Strategy started at: {self.start_time}")

        # Start receiving 1-minute bar updates
        self.subscribe_bars(self.bar_type_1min)

    def on_bar(self, bar: Bar):
        # You can implement any action here (like submit order), but for simplicity, we are just counting bars
        self.count_1min_bars += 1
        self.log.info(
            f"Bar #{self.count_1min_bars} | Time: {unix_nanos_to_dt(bar.ts_event):%Y-%m-%d %H:%M:%S} | Bar: {bar}",
            color=LogColor.BLUE,
        )

    def on_stop(self):
        # Save the exact time when strategy ends
        self.end_time = dt.datetime.now()
        self.log.info(f"Strategy finished at: {self.end_time}")

        # Show summary of how many bars we processed
        self.log.info(f"Total count of 1-MINUTE bars: {self.count_1min_bars}")

</document_content>
</document>
<document index="1801">
<source>examples/backtest/example_05_using_portfolio/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import DemoStrategy
from strategy import DemoStrategyConfig

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.core.nautilus_pyo3 import BarType
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":
    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST_TRADER-001"),
        logging=LoggingConfig(
            log_level="DEBUG",  # Enable debug logging
        ),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype: BarType = prepared_data["bar_type"]
    eurusd_1min_bars_list: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Order Management System type
        account_type=AccountType.MARGIN,  # Type of trading account
        starting_balances=[Money(1_000_000, USD)],  # Initial account balance
        base_currency=USD,  # Base currency for account
        default_leverage=Decimal(1),  # No leverage used for account
    )

    # Add instrument and market data to the engine
    engine.add_instrument(eurusd_instrument)
    engine.add_data(eurusd_1min_bars_list)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create and register the portfolio strategy with configuration
    strategy_config = DemoStrategyConfig(
        bar_type=eurusd_1min_bartype,
        instrument=eurusd_instrument,
    )
    strategy = DemoStrategy(config=strategy_config)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1802">
<source>examples/backtest/example_05_using_portfolio/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------


from nautilus_trader.common.enums import LogColor
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.events import PositionOpened
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.trading.config import StrategyConfig
from nautilus_trader.trading.strategy import Strategy


class DemoStrategyConfig(StrategyConfig, frozen=True):
    bar_type: BarType
    instrument: Instrument


class DemoStrategy(Strategy):

    def __init__(self, config: DemoStrategyConfig):
        super().__init__(config=config)

        # Track if we've already placed an order
        self.order_placed = False

        # Track total bars seen
        self.count_of_bars: int = 0
        self.show_portfolio_at_bar: int | None = 0

    def on_start(self):
        """
        Handle strategy start event.
        """
        # Subscribe to market data
        self.subscribe_bars(self.config.bar_type)

        # Show initial portfolio state
        self.show_portfolio_info("Portfolio state (Before trade)")

    def on_bar(self, bar: Bar):
        """
        Handle new bar event.
        """
        # Increment total bars seen
        self.count_of_bars += 1

        # Show portfolio state if we reached target bar
        if self.show_portfolio_at_bar == self.count_of_bars:
            self.show_portfolio_info("Portfolio state (2 minutes after position opened)")

        # Only place one order for demonstration
        if not self.order_placed:
            # Prepare values for order
            last_price = bar.close
            tick_size = self.config.instrument.price_increment
            profit_price = self.config.instrument.make_price(last_price + (10 * tick_size))
            stoploss_price = self.config.instrument.make_price(last_price - (10 * tick_size))

            # Create BUY MARKET order with PT and SL (both 10 ticks)
            bracket_order_list = self.order_factory.bracket(
                instrument_id=self.config.instrument.id,
                order_side=OrderSide.BUY,
                quantity=self.config.instrument.make_qty(1),  # Trade size: 1 contract
                time_in_force=TimeInForce.GTC,
                tp_price=profit_price,
                sl_trigger_price=stoploss_price,
            )

            # Submit order and remember it
            self.submit_order_list(bracket_order_list)
            self.order_placed = True
            self.log.info(f"Submitted bracket order: {bracket_order_list}", color=LogColor.GREEN)

    def on_position_opened(self, event: PositionOpened):
        """
        Handle position opened event.
        """
        # Log position details
        self.log.info(f"Position opened: {event}", color=LogColor.GREEN)

        # Show portfolio state when position is opened
        self.show_portfolio_info("Portfolio state (In position):")

        # Set target bar number for next portfolio display
        self.show_portfolio_at_bar = self.count_of_bars + 2  # Show after 2 bars

    def on_stop(self):
        """
        Handle strategy stop event.
        """
        # Show final portfolio state
        self.show_portfolio_info("Portfolio state (After trade)")

    def show_portfolio_info(self, intro_message: str = ""):
        """
        Display current portfolio information.
        """
        if intro_message:
            self.log.info(f"====== {intro_message} ======")

        # POSITION information
        self.log.info("Portfolio -> Position information:", color=LogColor.BLUE)
        is_flat = self.portfolio.is_flat(self.config.instrument.id)
        self.log.info(f"Is flat: {is_flat}", color=LogColor.BLUE)

        net_position = self.portfolio.net_position(self.config.instrument.id)
        self.log.info(f"Net position: {net_position} contract(s)", color=LogColor.BLUE)

        net_exposure = self.portfolio.net_exposure(self.config.instrument.id)
        self.log.info(f"Net exposure: {net_exposure}", color=LogColor.BLUE)

        # -----------------------------------------------------

        # P&L information
        self.log.info("Portfolio -> P&L information:", color=LogColor.YELLOW)

        realized_pnl = self.portfolio.realized_pnl(self.config.instrument.id)
        self.log.info(f"Realized P&L: {realized_pnl}", color=LogColor.YELLOW)

        unrealized_pnl = self.portfolio.unrealized_pnl(self.config.instrument.id)
        self.log.info(f"Unrealized P&L: {unrealized_pnl}", color=LogColor.YELLOW)

        # -----------------------------------------------------

        self.log.info("Portfolio -> Account information:", color=LogColor.CYAN)
        margins_init = self.portfolio.margins_init(self.config.instrument.venue)
        self.log.info(f"Initial margin: {margins_init}", color=LogColor.CYAN)

        margins_maint = self.portfolio.margins_maint(self.config.instrument.venue)
        self.log.info(f"Maintenance margin: {margins_maint}", color=LogColor.CYAN)

        balances_locked = self.portfolio.balances_locked(self.config.instrument.venue)
        self.log.info(f"Locked balance: {balances_locked}", color=LogColor.CYAN)

</document_content>
</document>
<document index="1804">
<source>examples/backtest/example_06_using_cache/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import CacheDemoStrategy

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import CacheConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.core.nautilus_pyo3 import BarType
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":
    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST-001"),
        logging=LoggingConfig(
            log_level="INFO",  # Show Cache operations in logs
        ),
        cache=CacheConfig(
            bar_capacity=5000,  # Store last 5000 bars per bar type
            tick_capacity=10000,  # Store last 10000 ticks per instrument (not used in this strategy)
        ),
    )

    # Create backtest engine
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype: BarType = prepared_data["bar_type"]
    eurusd_1min_bars_list: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Use a netting order management system
        account_type=AccountType.MARGIN,  # Use a margin trading account
        starting_balances=[Money(1_000_000, USD)],  # Set initial capital
        base_currency=USD,  # Account currency
        default_leverage=Decimal(1),  # No leverage (1:1)
    )

    # Add instrument and market data to the engine
    engine.add_instrument(eurusd_instrument)
    engine.add_data(eurusd_1min_bars_list)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create and register the cache demonstration strategy
    strategy = CacheDemoStrategy(bar_type=eurusd_1min_bartype)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1805">
<source>examples/backtest/example_06_using_cache/strategy.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import pickle

from nautilus_trader.common.enums import LogColor
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.events import PositionOpened
from nautilus_trader.trading.strategy import Strategy


class DataContainer:
    """
    Simple container for demonstrating Cache storage of custom objects.
    """

    def __init__(self, name: str):
        self.name = name
        self.xxx = 100
        self.yyy = ["a", "b", "c"]
        self.zzz = {"key1": 1, "key2": 2}

    def __str__(self):
        return f"Container({self.name}, xxx={self.xxx})"


class CacheDemoStrategy(Strategy):

    def __init__(self, bar_type: BarType):
        super().__init__()
        self.bar_type = bar_type
        self.instrument_id = bar_type.instrument_id

        # Trading state
        self.bar_count = 0
        self.order_placed = False  # Flag to ensure, only one order is placed
        self.show_cache_info_at_bar: int | None = None  # Bar number where to output Cache info

    def on_start(self):
        self.subscribe_bars(self.bar_type)

        # =============================================
        # CUSTOM OBJECT STORAGE
        # Cache allows storing and retrieving any arbitrary object using a string key.
        # This is useful for persisting custom data or sharing data between components.
        # =============================================

        self.log.info("=== Custom Object Storage Demo ===", color=LogColor.YELLOW)

        # Store simple object (dictionary)
        # Note: This example uses abstract data to demonstrate Cache storage functionality.
        # The actual content is not important - we're just showing how to store/retrieve data.
        simple_data = {
            "aaa": 123,
            "bbb": "xyz",
            "ccc": [1, 2, 3],
        }

        # Convert dictionary to bytes before storing
        simple_data_key, simple_data_bytes = "simple_data", pickle.dumps(simple_data)
        self.cache.add(simple_data_key, simple_data_bytes)
        self.log.info(f"Stored simple data: {simple_data}")

        # Store complex object (custom class instance)
        # Note: This example shows how to store custom objects.
        # The class structure is kept minimal to focus on the Cache functionality.

        # Create and store complex object
        complex_data = DataContainer("example")
        complex_data_key, complex_data_bytes = "complex_data", pickle.dumps(complex_data)
        self.cache.add(complex_data_key, complex_data_bytes)
        self.log.info(f"Stored complex data: {complex_data}")

        # Retrieve simple object (dictionary)
        # Step 1: Load bytes from cache
        simple_data_bytes = self.cache.get(simple_data_key)
        # Step 2: Deserialize bytes to objects
        simple_retrieved = pickle.loads(simple_data_bytes)  # noqa: S301 (safe pickle usage)
        self.log.info(f"Retrieved simple data: {simple_retrieved}")

        # Retrieve complex object (custom class instance)
        complex_data_bytes = self.cache.get(complex_data_key)
        complex_retrieved = pickle.loads(complex_data_bytes)  # noqa: S301 (safe pickle usage)
        self.log.info(f"Retrieved complex data: {complex_retrieved}")

        # =============================================
        # INSTRUMENT ACCESS
        # Cache provides access to instrument definitions and their properties.
        # Useful for getting instrument details, specifications, and filtering by venue.
        # =============================================

        self.log.info("=== Instrument Operations Demo ===", color=LogColor.YELLOW)

        # Get specific instrument by ID - returns full instrument definition
        # including specifications, tick size, lot size, margins, etc.
        instrument = self.cache.instrument(self.instrument_id)
        self.log.info(f"Single instrument: {instrument}")

        # Get all instruments for a specific venue (exchange)
        # Useful for market scanning or multi-instrument strategies
        venue = self.instrument_id.venue  # Extract venue from instrument ID
        instruments = self.cache.instruments(venue=venue)
        self.log.info("All instruments for venue:")
        for instrument in instruments:
            self.log.info(f"Instrument: {instrument}")

        # =============================================
        # ACCOUNT ACCESS
        # Cache maintains trading account information including balances and states.
        # Provides methods to access account details by venue or ID, useful for:
        # - Checking account balances and margins
        # - Monitoring account state and permissions
        # - Managing multiple accounts across venues
        # =============================================

        self.log.info("=== Account Operations Demo ===", color=LogColor.YELLOW)

        # Get all trading accounts in the system
        # Useful for strategies managing multiple accounts
        accounts = self.cache.accounts()
        self.log.info(f"All trading accounts: {accounts}")

        # Get account for specific venue (exchange)
        # Returns account with balances, margins, and permissions
        account = self.cache.account_for_venue(venue)
        self.log.info(f"Trading account for {venue}: {account}")

    def on_bar(self, bar: Bar):
        """
        Handle new bar events.
        """
        # Count bars
        self.bar_count += 1

        # Place order exactly at bar 100
        if self.bar_count == 100 and not self.order_placed:
            # Prepare values for order
            instrument = self.cache.instrument(self.instrument_id)
            last_price = bar.close
            tick_size = instrument.price_increment
            profit_price = instrument.make_price(
                last_price + (10 * tick_size),
            )  # 10 ticks profit target
            stoploss_price = instrument.make_price(
                last_price - (10 * tick_size),
            )  # 10 ticks stop loss

            # Create BUY MARKET order with PT and SL
            bracket_order_list = self.order_factory.bracket(
                instrument_id=self.instrument_id,
                order_side=OrderSide.BUY,
                quantity=instrument.make_qty(1),  # Trade size: 1 contract
                time_in_force=TimeInForce.GTC,
                tp_price=profit_price,
                sl_trigger_price=stoploss_price,
            )

            # Submit order and remember it
            self.submit_order_list(bracket_order_list)
            self.order_placed = True
            self.log.info(f"Submitted bracket order: {bracket_order_list}", color=LogColor.GREEN)
            return

        # Wait with the Cache demonstration, until 1 bar after position opened
        if self.bar_count != self.show_cache_info_at_bar:
            return

        self.demonstrate_cache_methods()

    def on_position_opened(self, event: PositionOpened):
        """
        Handle position opened event.
        """
        # Log position details
        self.log.info(f"Position opened: {event}", color=LogColor.GREEN)

        # Set target bar number for Cache demonstration
        self.show_cache_info_at_bar = (
            self.bar_count + 1
        )  # Show Cache details one bar after position opens

    def on_stop(self):
        self.log.info("Strategy stopped.", color=LogColor.BLUE)

    def demonstrate_cache_methods(self):
        """
        Demonstrate various Cache methods for market data, orders, and trading
        operations.
        """
        self.log.info(
            f"\nExecuting Cache demonstrations at bar {self.bar_count}",
            color=LogColor.CYAN,
        )

        # =============================================
        # MARKET DATA ACCESS
        # Cache maintains historical market data with methods for:
        # - Accessing latest and historical bars/ticks/quotes
        # - Checking data availability and counts
        # - Managing different data types (bars, ticks, quotes, order books)
        # Similar methods exist for Ticks (trade_tick/quote_tick) and OrderBook
        # =============================================

        self.log.info("=== Market Data Operations Demo ===", color=LogColor.YELLOW)

        # Get and show bars from cache
        bars = self.cache.bars(self.bar_type)
        self.log.info("Bars in cache:")
        self.log.info(f"Total bars: {len(bars)}")

        # Show latest bars
        last_bar = self.cache.bar(self.bar_type)
        previous_bar = self.cache.bar(self.bar_type, index=1)
        self.log.info(f"Last bar:  {last_bar}")
        self.log.info(f"Previous bar: {previous_bar}")

        # Show data availability
        has_bars = self.cache.has_bars(self.bar_type)
        bar_count = self.cache.bar_count(self.bar_type)
        self.log.info(f"Bars available: {has_bars}, Count: {bar_count}")

        # =============================================
        # ORDER MANAGEMENT
        # Cache provides comprehensive order tracking with:
        # - Filtering by venue/instrument/strategy/state
        # - Order state monitoring (open/closed/emulated)
        # - Order statistics and counts
        # - Parent/child order relationships
        # =============================================

        self.log.info("=== Order Management Demo ===", color=LogColor.YELLOW)

        # Query orders with different filters to monitor trading activity
        # Get complete list of orders for detailed inspection
        all_orders = self.cache.orders()  # Complete order history
        open_orders = self.cache.orders_open()  # Pending execution orders
        closed_orders = self.cache.orders_closed()  # Completed orders

        # Log detailed order information
        self.log.info("Order details from Cache:")

        # Show all orders
        self.log.info("All orders:", color=LogColor.BLUE)
        for order in all_orders:
            self.log.info(f"{order}")

        # Show currently open orders
        self.log.info("Open orders:", color=LogColor.BLUE)
        for order in open_orders:
            self.log.info(f"{order}")

        # Show completed orders
        self.log.info("Closed orders:", color=LogColor.BLUE)
        for order in closed_orders:
            self.log.info(f"{order}")

        # Get order counts directly (more efficient than len() when only count is needed)
        total = self.cache.orders_total_count()
        open_count = self.cache.orders_open_count()
        closed_count = self.cache.orders_closed_count()
        self.log.info(f"Order counts - Total: {total}, Open: {open_count}, Closed: {closed_count}")

        # =============================================
        # POSITION MANAGEMENT
        # Cache tracks all positions with functionality for:
        # - Position filtering by venue/instrument/strategy
        # - State monitoring (open/closed)
        # - Position metrics and statistics
        # - Historical position analysis
        # =============================================

        self.log.info("=== Position Management Demo ===", color=LogColor.YELLOW)

        # Query positions with different filters
        # Get complete list of positions for detailed inspection
        all_positions = self.cache.positions()  # All positions
        open_positions = self.cache.positions_open()  # Active positions
        closed_positions = self.cache.positions_closed()  # Completed positions

        # Show all positions
        self.log.info("All positions:", color=LogColor.BLUE)
        for pos in all_positions:
            self.log.info(f"{pos}")

        # Show currently open positions
        self.log.info("Open positions:", color=LogColor.BLUE)
        for pos in open_positions:
            self.log.info(f"{pos}")

        # Show completed positions
        self.log.info("\nClosed positions:", color=LogColor.BLUE)
        for pos in closed_positions:
            self.log.info(f"{pos}")

        # Get position counts and show statistics
        total = self.cache.positions_total_count()
        open_count = self.cache.positions_open_count()
        closed_count = self.cache.positions_closed_count()
        self.log.info(
            f"Position counts - Total: {total}, Open: {open_count}, Closed: {closed_count}",
        )

        # =============================================
        # SYSTEM STATE ACCESS
        # Cache provides access to various system identifiers and collections.
        # Useful for querying system state and finding specific objects.
        # Includes methods for accessing different types of IDs.
        # =============================================

        self.log.info("=== System State Access Demo ===", color=LogColor.YELLOW)

        # Show active strategies
        strategy_ids = self.cache.strategy_ids()
        self.log.info(f"Active Strategies: {strategy_ids}")

        # Show actor IDs
        actor_ids = self.cache.actor_ids()
        self.log.info(f"Active Actors: {actor_ids}")

</document_content>
</document>
<document index="1807">
<source>examples/backtest/example_07_using_indicators/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import DemoStrategy

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":

    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST-INDICATOR-001"),  # Unique identifier for this backtest
        logging=LoggingConfig(
            log_level="INFO",  # Set to INFO to see indicator values
        ),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype = prepared_data["bar_type"]
    eurusd_1min_bars: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Use a netting order management system
        account_type=AccountType.MARGIN,  # Use a margin trading account
        starting_balances=[Money(1_000_000, USD)],  # Set initial capital
        base_currency=USD,  # Account currency
        default_leverage=Decimal(1),  # No leverage (1:1)
    )

    # Register the trading instrument
    engine.add_instrument(eurusd_instrument)

    # Load historical market data
    engine.add_data(eurusd_1min_bars)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create and register the strategy
    strategy = DemoStrategy(bar_type=eurusd_1min_bartype)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1808">
<source>examples/backtest/example_07_using_indicators/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import datetime as dt
from collections import deque

from nautilus_trader.common.enums import LogColor
from nautilus_trader.indicators import MovingAverageFactory
from nautilus_trader.indicators import MovingAverageType
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.trading.strategy import Strategy


class DemoStrategy(Strategy):
    """
    A simple demonstration strategy showing how to use technical indicators in
    NautilusTrader.
    """

    def __init__(self, bar_type: BarType):
        super().__init__()

        # The bar_type parameter defines what market data we'll be working with
        self.bar_type = bar_type

        # Simple counter to track how many bars we've processed
        self.bars_processed = 0

        # Create a 10-period Exponential Moving Average (EMA) indicator
        self.ema10 = MovingAverageFactory.create(10, MovingAverageType.EXPONENTIAL)

        # Create a storage for the most recent 100 EMA values
        # We use Python's deque (double ended queue), because:
        # 1. It automatically removes old values when we reach 100 items
        # 2. It's very fast when adding new values at the start
        # 3. It keeps data in chronological order
        self.ema10_history: deque[float] = deque(maxlen=100)

        # Strategy execution timestamps for performance tracking
        self.start_time = None
        self.end_time = None

    def on_start(self):
        # Record strategy start time
        self.start_time = dt.datetime.now()
        self.log.info(f"Strategy started at: {self.start_time}")

        # Subscribe to market data
        # This tells NautilusTrader what data we want to receive in our on_bar method
        # Without this subscription, we won't receive any market data updates
        self.subscribe_bars(self.bar_type)
        self.log.info(f"Subscribed to {self.bar_type}")

        # Connect our EMA indicator to the market data stream
        # This is a key NautilusTrader feature that:
        # 1. Automatically updates the indicator when new bars arrive
        # 2. Ensures indicator values are current before our on_bar method is called
        # 3. Maintains proper data synchronization
        self.register_indicator_for_bars(self.bar_type, self.ema10)
        self.log.info("EMA(10) indicator registered")

    def on_bar(self, bar: Bar):
        # Track the number of bars we've processed
        self.bars_processed += 1

        # Thanks to our indicator registration in on_start,
        # self.ema10.value is already updated with the latest calculation

        # Most indicators need some initial data before they can produce valid results
        # For EMA(10), we need 10 bars of data to initialize the calculation
        if self.ema10.initialized:
            # Store the new EMA value in our historical record
            # We use `deque.appendleft()` to maintain a consistent order where:
            # - index [0] = latest value (newest)
            # - index [1] = previous value
            # - index [2] = two bars ago
            # This matches how NautilusTrader's Cache stores bar data
            self.ema10_history.appendleft(self.ema10.value)

            # Log current market data and indicator value
            self.log.info(
                f"Bar #{self.bars_processed} | "
                f"Close: {bar.close} | "
                f"EMA(10): {self.ema10.value:.5f}",
                color=LogColor.YELLOW,
            )

            # This demonstrates how to access previously calculated historical indicator values
            if len(self.ema10_history) > 1:
                previous_ema = self.ema10_history[1]
                self.log.info(f"Previous EMA(10): {previous_ema:.5f}", color=LogColor.BLUE)
        else:
            # During initialization phase, we still log the incoming data
            # but note that we're waiting for enough data to calculate the EMA
            self.log.info(
                f"Bar #{self.bars_processed} | "
                f"Close: {bar.close} | "
                "Waiting for EMA initialization...",
                color=LogColor.RED,
            )

    def on_stop(self):
        # Record strategy end time
        self.end_time = dt.datetime.now()
        self.log.info(
            f"Strategy finished at: {self.end_time} | "
            f"Duration: {(self.end_time - self.start_time).total_seconds():.2f} seconds.",
        )

        # Report how many bars were processed
        self.log.info(f"Strategy stopped. Processed {self.bars_processed} bars.")

</document_content>
</document>
<document index="1810">
<source>examples/backtest/example_08_cascaded_indicator/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import DemoStrategy
from strategy import DemoStrategyConfig

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":

    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST-CASCADED-IND-001"),  # Unique identifier for this backtest
        logging=LoggingConfig(
            log_level="INFO",  # Set to INFO to see indicator values
        ),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype = prepared_data["bar_type"]
    eurusd_1min_bars: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Use a netting order management system
        account_type=AccountType.MARGIN,  # Use a margin trading account
        starting_balances=[Money(1_000_000, USD)],  # Set initial capital
        base_currency=USD,  # Account currency
        default_leverage=Decimal(1),  # No leverage (1:1)
    )

    # Register the trading instrument
    engine.add_instrument(eurusd_instrument)

    # Load historical market data
    engine.add_data(eurusd_1min_bars)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create strategy configuration
    strategy_config = DemoStrategyConfig(
        instrument=eurusd_instrument,
        primary_bar_type=eurusd_1min_bartype,
        primary_ema_period=10,  # Period for primary EMA indicator
        secondary_ema_period=20,  # Period for secondary cascaded EMA indicator
    )

    # Create and register the strategy
    strategy = DemoStrategy(config=strategy_config)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1811">
<source>examples/backtest/example_08_cascaded_indicator/strategy.py</source>
<document_content>
from collections import deque

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.indicators import MovingAverageFactory
from nautilus_trader.indicators import MovingAverageType
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading.strategy import Strategy


class DemoStrategyConfig(StrategyConfig, frozen=True):
    """
    Configuration for the demo strategy.
    """

    instrument: Instrument
    primary_bar_type: BarType
    primary_ema_period: int = 10  # Period for primary EMA indicator
    secondary_ema_period: int = 20  # Period for secondary cascaded EMA indicator


class DemoStrategy(Strategy):
    """
    A simple strategy demonstrating the use of cascaded indicators.
    """

    def __init__(self, config: DemoStrategyConfig):
        super().__init__(config)

        # Count processed bars
        self.bars_processed = 0

        # Store bar type from config
        self.bar_type = config.primary_bar_type

        # Primary indicator: EMA calculated on 1-min bars
        self.primary_ema = MovingAverageFactory.create(
            config.primary_ema_period,  # Period for primary EMA indicator
            MovingAverageType.EXPONENTIAL,  # Type of moving average
        )
        self.primary_ema_history: deque[float] = deque()  # Store historical values here

        # Cascaded indicator: EMA calculated on primary EMA values
        self.secondary_ema = MovingAverageFactory.create(
            config.secondary_ema_period,  # Period for secondary cascaded EMA indicator
            MovingAverageType.EXPONENTIAL,  # Type of moving average
        )
        self.secondary_ema_history: deque[float] = deque()  # Store historical values here

    def on_start(self):
        # Subscribe to bars
        self.subscribe_bars(self.bar_type)

        # Register primary indicator to receive bar data
        self.register_indicator_for_bars(self.bar_type, self.primary_ema)

        self.log.info("Strategy started.")

    def on_bar(self, bar: Bar):
        # Count processed bars
        self.bars_processed += 1
        self.log.info(
            f"Bar #{self.bars_processed} | "
            f"Bar: {bar} | "
            f"Time={unix_nanos_to_dt(bar.ts_event)}",
            color=LogColor.YELLOW,
        )

        # Store latest primary EMA value
        # Since primary EMA is registered, it's automatically updated with new bars
        primary_ema_value = self.primary_ema.value
        self.primary_ema_history.appendleft(primary_ema_value)

        # Update cascaded EMA with the latest primary EMA value
        # We need to wait until primary EMA is initialized
        if self.primary_ema.initialized:
            # Manually feed primary EMA value into secondary EMA
            self.secondary_ema.update_raw(self.primary_ema.value)
            # Store latest secondary EMA value
            self.secondary_ema_history.appendleft(self.secondary_ema.value)

        # Wait until both indicators are initialized
        # - Primary EMA needs first `primary_ema_period` bars to initialize
        # - Secondary EMA needs `secondary_ema_period` values from primary EMA to initialize
        # So in total we need at least `primary_ema_period + secondary_ema_period` bars before both indicators are ready
        if not self.primary_ema.initialized or not self.secondary_ema.initialized:
            self.log.info("Waiting for indicators to initialize...", color=LogColor.RED)
            return

        # Access and log indicator values
        primary_ema_latest = self.primary_ema.value
        secondary_ema_latest = self.secondary_ema.value

        # Log latest indicator values
        self.log.info(
            f"Latest values. | "
            f"Primary EMA({self.config.primary_ema_period}) = {primary_ema_latest:.7f}, "
            f"Secondary EMA({self.config.secondary_ema_period}) = {secondary_ema_latest:.7f}",
            color=LogColor.BLUE,
        )

        # Check history and log previous values if available
        if len(self.primary_ema_history) > 1 and len(self.secondary_ema_history) > 1:
            primary_ema_prev = self.primary_ema_history[1]
            secondary_ema_prev = self.secondary_ema_history[1]
            self.log.info(
                f"Previous values | "
                f"Primary EMA({self.config.primary_ema_period}) = {primary_ema_prev:.7f}, "
                f"Secondary EMA({self.config.secondary_ema_period}) = {secondary_ema_prev:.7f}",
            )

    def on_stop(self):
        self.log.info(f"Strategy stopped. Processed {self.bars_processed} bars.")

</document_content>
</document>
<document index="1813">
<source>examples/backtest/example_09_messaging_with_msgbus/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import DemoStrategy
from strategy import DemoStrategyConfig

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":

    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST-EVENTS-001"),  # Unique identifier for this backtest
        logging=LoggingConfig(log_level="INFO"),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype = prepared_data["bar_type"]
    eurusd_1min_bars: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Use a netting order management system
        account_type=AccountType.MARGIN,  # Use a margin trading account
        starting_balances=[Money(1_000_000, USD)],  # Set initial capital
        base_currency=USD,  # Account currency
        default_leverage=Decimal(1),  # No leverage (1:1)
    )

    # Register the trading instrument
    engine.add_instrument(eurusd_instrument)

    # Load historical market data
    engine.add_data(eurusd_1min_bars)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create strategy configuration
    strategy_config = DemoStrategyConfig(
        instrument=eurusd_instrument,
        bar_type=eurusd_1min_bartype,
    )

    # Create and register the strategy
    strategy = DemoStrategy(config=strategy_config)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1814">
<source>examples/backtest/example_09_messaging_with_msgbus/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from dataclasses import dataclass

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.core.message import Event
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading.strategy import Strategy


@dataclass
class Each10thBarEvent(Event):
    """
    A custom event that is published every 10th bar.

    By inheriting from `Event` class, we automatically get important attributes:
     - `id`: A unique string identifier for each event (in UUID format)
     - `ts_event`: Timestamp when the event occurred (used for event ordering)
     - `ts_init`: Timestamp when the event was initialized

    These attributes are crucial for correct event processing and ordering in the message bus,
    especially during backtesting where event timing is important.

    Event class offers complete flexibility in terms of attributes:
    - Can contain attributes of any Python type (int, float, str, custom objects, etc.)

    """

    bar: Bar  # The 10th bar related to this event
    TOPIC: str = "each_10th_bar_event"  # Topic name for message bus publish/subscribe


class DemoStrategyConfig(StrategyConfig, frozen=True):
    """
    Configuration for the demo strategy.
    """

    instrument: Instrument
    bar_type: BarType


class DemoStrategy(Strategy):
    """
    A demonstration strategy showing how to use custom events and the message bus.
    """

    def __init__(self, config: DemoStrategyConfig):
        super().__init__(config)

        # Counter for processed bars
        self.bars_processed = 0

    def on_start(self):
        # Subscribe to market data
        self.subscribe_bars(self.config.bar_type)
        self.log.info(f"Subscribed to {self.config.bar_type}", color=LogColor.YELLOW)

        # The message bus implements a topic-based publish/subscribe pattern:
        # - Publishers can publish events to one or more named topics
        # - Subscribers can subscribe to one or more topics of interest

        # Subscribe to our custom event
        # First argument is the topic name to subscribe to, second is the custom handler method
        self.msgbus.subscribe(Each10thBarEvent.TOPIC, self.on_each_10th_bar)
        self.log.info(f"Subscribed to {Each10thBarEvent.TOPIC}", color=LogColor.YELLOW)

    def on_bar(self, bar: Bar):
        # Count processed bars
        self.bars_processed += 1
        self.log.info(
            f"Bar #{self.bars_processed} | "
            f"Bar: {bar} | "
            f"Time={unix_nanos_to_dt(bar.ts_event)}",
        )

        # Every 10th bar, publish our custom event
        if self.bars_processed % 10 == 0:
            # Log our plans
            self.log.info(
                f"Going to publish event for topic: {Each10thBarEvent.TOPIC}",
                color=LogColor.GREEN,
            )

            # Create and publish the event
            # This demonstrates how to use the message bus to send events
            event = Each10thBarEvent(bar=bar)
            self.msgbus.publish(Each10thBarEvent.TOPIC, event)

    def on_each_10th_bar(self, event: Each10thBarEvent):
        """
        Handle each 10th bar event received from the message bus.
        """
        # Log the event details
        self.log.info(
            f"Received event for topic: {Each10thBarEvent.TOPIC} at bar # {self.bars_processed}| "
            f"Bar detail: {event.bar}",
            color=LogColor.RED,
        )

    def on_stop(self):
        self.log.info(f"Strategy stopped. Processed {self.bars_processed} bars.")

</document_content>
</document>
<document index="1816">
<source>examples/backtest/example_10_messaging_with_actor_data/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import DemoStrategy
from strategy import DemoStrategyConfig

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":

    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST-DATA-PUB-001"),  # Unique identifier for this backtest
        logging=LoggingConfig(log_level="INFO"),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype = prepared_data["bar_type"]
    eurusd_1min_bars: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Use a netting order management system
        account_type=AccountType.MARGIN,  # Use a margin trading account
        starting_balances=[Money(1_000_000, USD)],  # Set initial capital
        base_currency=USD,  # Account currency
        default_leverage=Decimal(1),  # No leverage (1:1)
    )

    # Register the trading instrument
    engine.add_instrument(eurusd_instrument)

    # Load historical market data
    engine.add_data(eurusd_1min_bars)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create strategy configuration
    strategy_config = DemoStrategyConfig(
        instrument=eurusd_instrument,
        bar_type=eurusd_1min_bartype,
    )

    # Create and register the strategy
    strategy = DemoStrategy(config=strategy_config)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1817">
<source>examples/backtest/example_10_messaging_with_actor_data/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.data import Data
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.model import InstrumentId
from nautilus_trader.model.custom import customdataclass
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import DataType
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading.strategy import Strategy


class Last10BarsStats(Data):
    """
    A data class for storing statistics of the last 10 bars.

    This class inherits from Data class which is required for using Actor/Strategy publish/subscribe methods.
    The Data class inheritance automatically provides:
    - `ts_event` attribute: Used for proper data ordering in backtests
    - `ts_init` attribute: Used for initialization time tracking

    Since this class doesn't use @customdataclass decorator, it can have attributes of any Python types
    (like the complex BarType attribute). This is suitable for strategies where data
    doesn't need to be serialized, transferred between nodes or persisted.

    """

    bar_type: BarType
    last_bar_index: int = 0
    max_price: float = 0.0
    min_price: float = 0.0
    volume_total: float = 0.0


# Just an example of a serializable data class, we don't use it in this strategy
@customdataclass
class Last10BarsStatsSerializable(Data):
    """
    A serializable data class for storing statistics of the last 10 bars.

    This class uses the @customdataclass decorator which adds serialization capabilities
    required for:
    - Data persistence in the catalog system
    - Data transfer between different nodes
    - Automatic serialization methods: to_dict(), from_dict(), to_bytes(), to_arrow()

    Note: When using @customdataclass, attributes must be of supported types only:
    - InstrumentId
    - Basic types: str, bool, float, int, bytes, ndarray

    This example demonstrates proper usage of @customdataclass, though in this simple
    strategy we use `Last10BarsStats` instead as we don't need serialization capabilities.

    """

    instrument_id: InstrumentId
    last_bar_index: int = 0
    max_price: float = 0.0
    min_price: float = 0.0
    volume_total: float = 0.0


class DemoStrategyConfig(StrategyConfig, frozen=True):
    instrument: Instrument
    bar_type: BarType


class DemoStrategy(Strategy):
    """
    A demonstration strategy showing how to publish and subscribe to custom data.
    """

    def __init__(self, config: DemoStrategyConfig):
        super().__init__(config)

        # Counter for processed bars
        self.bars_processed = 0

    def on_start(self):
        # Subscribe to market data
        self.subscribe_bars(self.config.bar_type)
        self.log.info(f"Subscribed to {self.config.bar_type}", color=LogColor.YELLOW)

        # Subscribe to our custom data type
        self.subscribe_data(DataType(Last10BarsStats))
        self.log.info("Subscribed to data of type: Last10BarsStatistics", color=LogColor.YELLOW)

    def on_bar(self, bar: Bar):
        # Count processed bars
        self.bars_processed += 1
        self.log.info(
            f"Bar #{self.bars_processed} | "
            f"Bar: {bar} | "
            f"Time={unix_nanos_to_dt(bar.ts_event)}",
        )

        # Every 10th bar, publish our custom data
        if self.bars_processed % 10 == 0:
            # Log our plans
            self.log.info(
                "Going to publish data of type: Last10BarsStatistics",
                color=LogColor.GREEN,
            )

            # Get the last 10 bars from the cache
            last_10_bars_list = self.cache.bars(self.config.bar_type)[:10]
            # Create data object
            data = Last10BarsStats(
                bar_type=bar.bar_type,
                last_bar_index=self.bars_processed - 1,
                max_price=max(bar.high for bar in last_10_bars_list),
                min_price=min(bar.low for bar in last_10_bars_list),
                volume_total=sum(bar.volume for bar in last_10_bars_list),
                ts_event=bar.ts_event,  # This field was added by @customdataclass decorator
                ts_init=bar.ts_init,  # This field was added by @customdataclass decorator
            )
            # Publish the data
            self.publish_data(DataType(Last10BarsStats), data)

    def on_data(self, data: Data):
        """
        Process received data from subscribed data sources.
        """
        if isinstance(data, Last10BarsStats):
            self.log.info(
                f"Received Last10BarsStatistics data: {data}",
                color=LogColor.RED,
            )

    def on_stop(self):
        self.log.info(f"Strategy stopped. Processed {self.bars_processed} bars.")

</document_content>
</document>
<document index="1819">
<source>examples/backtest/example_11_messaging_with_actor_signals/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from strategy import DemoStrategy
from strategy import DemoStrategyConfig

from examples.utils.data_provider import prepare_demo_data_eurusd_futures_1min
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.model import Bar
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.objects import Money


if __name__ == "__main__":

    # ----------------------------------------------------------------------------------
    # 1. Configure and create backtest engine
    # ----------------------------------------------------------------------------------

    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST-SIGNALS-001"),  # Unique identifier for this backtest
        logging=LoggingConfig(log_level="INFO"),
    )
    engine = BacktestEngine(config=engine_config)

    # ----------------------------------------------------------------------------------
    # 2. Prepare market data
    # ----------------------------------------------------------------------------------

    prepared_data: dict = prepare_demo_data_eurusd_futures_1min()
    venue_name: str = prepared_data["venue_name"]
    eurusd_instrument: Instrument = prepared_data["instrument"]
    eurusd_1min_bartype = prepared_data["bar_type"]
    eurusd_1min_bars: list[Bar] = prepared_data["bars_list"]

    # ----------------------------------------------------------------------------------
    # 3. Configure trading environment
    # ----------------------------------------------------------------------------------

    # Set up the trading venue with a margin account
    engine.add_venue(
        venue=Venue(venue_name),
        oms_type=OmsType.NETTING,  # Use a netting order management system
        account_type=AccountType.MARGIN,  # Use a margin trading account
        starting_balances=[Money(1_000_000, USD)],  # Set initial capital
        base_currency=USD,  # Account currency
        default_leverage=Decimal(1),  # No leverage (1:1)
    )

    # Register the trading instrument
    engine.add_instrument(eurusd_instrument)

    # Load historical market data
    engine.add_data(eurusd_1min_bars)

    # ----------------------------------------------------------------------------------
    # 4. Configure and run strategy
    # ----------------------------------------------------------------------------------

    # Create strategy configuration
    strategy_config = DemoStrategyConfig(
        instrument=eurusd_instrument,
        bar_type=eurusd_1min_bartype,
    )

    # Create and register the strategy
    strategy = DemoStrategy(config=strategy_config)
    engine.add_strategy(strategy)

    # Execute the backtest
    engine.run()

    # Clean up resources
    engine.dispose()

</document_content>
</document>
<document index="1820">
<source>examples/backtest/example_11_messaging_with_actor_signals/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import types

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading.strategy import Strategy


class DemoStrategyConfig(StrategyConfig, frozen=True):
    instrument: Instrument
    bar_type: BarType


# Signal names for price extremes
signals = types.SimpleNamespace()
signals.NEW_HIGHEST_PRICE = "NewHighestPriceReached"
signals.NEW_LOWEST_PRICE = "NewLowestPriceReached"


class DemoStrategy(Strategy):
    """
    A demonstration strategy showing how to use Actor-Based Signal messaging.

    This example demonstrates the simplest messaging approach in NautilusTrader:
    - Using signals for lightweight notifications (price extremes in this case)
    - Publishing signals with single string values
    - Subscribing to signals and handling them in on_signal

    Two signals are used:
    - NewHighestPriceReached: Published when a new maximum price is detected
    - NewLowestPriceReached: Published when a new minimum price is detected

    """

    def __init__(self, config: DemoStrategyConfig):
        super().__init__(config)

        # Initialize price tracking
        self.highest_price = float("-inf")
        self.lowest_price = float("inf")

    def on_start(self):
        # Subscribe to market data
        self.subscribe_bars(self.config.bar_type)
        self.log.info(f"Subscribed to {self.config.bar_type}", color=LogColor.YELLOW)

        # Subscribe to signals - each signal subscription will trigger on_signal when that signal is published
        self.subscribe_signal(signals.NEW_HIGHEST_PRICE)
        self.subscribe_signal(signals.NEW_LOWEST_PRICE)
        self.log.info("Subscribed to price extreme signals", color=LogColor.YELLOW)

    def on_bar(self, bar: Bar):
        # Check for new highest price
        if bar.close > self.highest_price:
            self.highest_price = bar.close
            self.log.info(f"New highest price detected: {bar.close}")
            # Publish a lightweight signal (can only contain a single value of type str/int/float)
            self.publish_signal(
                name=signals.NEW_HIGHEST_PRICE,  # Signal name
                value=signals.NEW_HIGHEST_PRICE,  # Signal value
                ts_event=bar.ts_event,
            )

        # Check for new lowest price
        if bar.close < self.lowest_price:
            self.lowest_price = bar.close
            self.log.info(f"New lowest price detected: {bar.close}")
            # Publish a lightweight signal (can only contain a single value of type str/int/float)
            self.publish_signal(
                name=signals.NEW_LOWEST_PRICE,
                value=signals.NEW_LOWEST_PRICE,  # Using same string as name for simplicity
                ts_event=bar.ts_event,
            )

    def on_signal(self, signal):
        """
        Handle incoming signals.

        This method is automatically called when any signal we're subscribed to is published.
        Important: In the signal handler, we can only match against signal.value
        (signal.name is not accessible in the handler).

        """
        match signal.value:
            case signals.NEW_HIGHEST_PRICE:
                self.log.info(
                    f"New highest price was reached. | "
                    f"Signal value: {signal.value} | "
                    f"Signal time: {unix_nanos_to_dt(signal.ts_event)}",
                    color=LogColor.GREEN,
                )
            case signals.NEW_LOWEST_PRICE:
                self.log.info(
                    f"New lowest price was reached. | "
                    f"Signal value: {signal.value} | "
                    f"Signal time: {unix_nanos_to_dt(signal.ts_event)}",
                    color=LogColor.RED,
                )

    def on_stop(self):
        self.log.info("Strategy stopped.")

</document_content>
</document>
<document index="1821">
<source>examples/backtest/fx_ema_cross_audusd_bars_from_ticks.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.backtest.modules import FXRolloverInterestConfig
from nautilus_trader.backtest.modules import FXRolloverInterestModule
from nautilus_trader.examples.strategies.ema_cross import EMACross
from nautilus_trader.examples.strategies.ema_cross import EMACrossConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import QuoteTickDataWrangler
from nautilus_trader.test_kit.providers import TestDataProvider
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Optional plug in module to simulate rollover interest,
    # the data is coming from packaged test data.
    provider = TestDataProvider()
    interest_rate_data = provider.read_csv("short-term-interest.csv")
    config = FXRolloverInterestConfig(interest_rate_data)
    fx_rollover_interest = FXRolloverInterestModule(config=config)

    # Add a trading venue (multiple venues possible)
    SIM = Venue("SIM")
    engine.add_venue(
        venue=SIM,
        oms_type=OmsType.HEDGING,  # Venue will generate position IDs
        account_type=AccountType.MARGIN,
        base_currency=USD,  # Standard single-currency account
        starting_balances=[Money(1_000_000, USD)],  # Single-currency or multi-currency accounts
        modules=[fx_rollover_interest],
    )

    # Add instruments
    AUDUSD_SIM = TestInstrumentProvider.default_fx_ccy("AUD/USD", SIM)
    engine.add_instrument(AUDUSD_SIM)

    # Add data
    wrangler = QuoteTickDataWrangler(instrument=AUDUSD_SIM)
    ticks = wrangler.process(provider.read_csv_ticks("truefx/audusd-ticks.csv"))
    engine.add_data(ticks)

    # Configure your strategy
    strategy_config = EMACrossConfig(
        instrument_id=AUDUSD_SIM.id,
        bar_type=BarType.from_str("AUD/USD.SIM-1-MINUTE-MID-INTERNAL"),
        fast_ema_period=10,
        slow_ema_period=20,
        trade_size=Decimal(1_000_000),
    )
    # Instantiate and add your strategy
    strategy = EMACross(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(SIM))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object when done
    engine.dispose()

</document_content>
</document>
<document index="1822">
<source>examples/backtest/fx_ema_cross_audusd_ticks.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.backtest.models import FillModel
from nautilus_trader.backtest.modules import FXRolloverInterestConfig
from nautilus_trader.backtest.modules import FXRolloverInterestModule
from nautilus_trader.examples.strategies.ema_cross import EMACross
from nautilus_trader.examples.strategies.ema_cross import EMACrossConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import QuoteTickDataWrangler
from nautilus_trader.test_kit.providers import TestDataProvider
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Firstly, add a trading venue (multiple venues possible)
    # Create a fill model (optional)
    fill_model = FillModel(
        prob_fill_on_limit=0.2,
        prob_fill_on_stop=0.95,
        prob_slippage=0.5,
        random_seed=42,
    )

    # Optional plug in module to simulate rollover interest,
    # the data is coming from packaged test data.
    provider = TestDataProvider()
    interest_rate_data = provider.read_csv("short-term-interest.csv")
    config = FXRolloverInterestConfig(interest_rate_data)
    fx_rollover_interest = FXRolloverInterestModule(config=config)

    # Add a trading venue (multiple venues possible)
    SIM = Venue("SIM")
    engine.add_venue(
        venue=SIM,
        oms_type=OmsType.HEDGING,  # Venue will generate position IDs
        account_type=AccountType.MARGIN,
        base_currency=USD,  # Standard single-currency account
        starting_balances=[Money(1_000_000, USD)],  # single-currency or multi-currency accounts
        fill_model=fill_model,
        modules=[fx_rollover_interest],
    )

    # Add instruments
    AUDUSD_SIM = TestInstrumentProvider.default_fx_ccy("AUD/USD", SIM)
    engine.add_instrument(AUDUSD_SIM)

    # Add data
    wrangler = QuoteTickDataWrangler(instrument=AUDUSD_SIM)
    ticks = wrangler.process(provider.read_csv_ticks("truefx/audusd-ticks.csv"))
    engine.add_data(ticks)

    # Configure your strategy
    strategy_config = EMACrossConfig(
        instrument_id=AUDUSD_SIM.id,
        bar_type=BarType.from_str("AUD/USD.SIM-100-TICK-MID-INTERNAL"),
        trade_size=Decimal(1_000_000),
        fast_ema_period=10,
        slow_ema_period=20,
        close_positions_on_stop=True,
    )
    # Instantiate and add your strategy
    strategy = EMACross(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(SIM))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object when done
    engine.dispose()

</document_content>
</document>
<document index="1823">
<source>examples/backtest/fx_ema_cross_bracket_gbpusd_bars_external.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.backtest.models import FillModel
from nautilus_trader.backtest.modules import FXRolloverInterestConfig
from nautilus_trader.backtest.modules import FXRolloverInterestModule
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RiskEngineConfig
from nautilus_trader.examples.strategies.ema_cross_bracket import EMACrossBracket
from nautilus_trader.examples.strategies.ema_cross_bracket import EMACrossBracketConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import BarDataWrangler
from nautilus_trader.test_kit.providers import TestDataProvider
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
        risk_engine=RiskEngineConfig(
            bypass=True,  # Example of bypassing pre-trade risk checks for backtests
        ),
    )

    # Build backtest engine
    engine = BacktestEngine(config=config)

    # Optional plug in module to simulate rollover interest,
    # the data is coming from packaged test data.
    provider = TestDataProvider()
    interest_rate_data = provider.read_csv("short-term-interest.csv")
    config = FXRolloverInterestConfig(interest_rate_data)
    fx_rollover_interest = FXRolloverInterestModule(config=config)

    # Create a fill model (optional)
    fill_model = FillModel(
        prob_fill_on_limit=0.2,
        prob_fill_on_stop=0.95,
        prob_slippage=0.5,
        random_seed=42,
    )

    # Add a trading venue (multiple venues possible)
    SIM = Venue("SIM")
    engine.add_venue(
        venue=SIM,
        oms_type=OmsType.HEDGING,  # Venue will generate position IDs
        account_type=AccountType.MARGIN,
        base_currency=USD,  # Standard single-currency account
        starting_balances=[Money(100_000, USD)],  # Single-currency or multi-currency accounts
        fill_model=fill_model,
        modules=[fx_rollover_interest],
        bar_execution=True,  # If bar data should move the market (True by default)
    )

    # Add instruments
    GBPUSD_SIM = TestInstrumentProvider.default_fx_ccy("GBP/USD", SIM)
    engine.add_instrument(GBPUSD_SIM)

    # Set up wranglers
    bid_wrangler = BarDataWrangler(
        bar_type=BarType.from_str("GBP/USD.SIM-1-MINUTE-BID-EXTERNAL"),
        instrument=GBPUSD_SIM,
    )
    ask_wrangler = BarDataWrangler(
        bar_type=BarType.from_str("GBP/USD.SIM-1-MINUTE-ASK-EXTERNAL"),
        instrument=GBPUSD_SIM,
    )

    # Add data
    bid_bars = bid_wrangler.process(
        data=provider.read_csv_bars("fxcm/gbpusd-m1-bid-2012.csv")[:10_000],
    )
    ask_bars = ask_wrangler.process(
        data=provider.read_csv_bars("fxcm/gbpusd-m1-ask-2012.csv")[:10_000],
    )
    engine.add_data(bid_bars)
    engine.add_data(ask_bars)

    # Configure your strategy
    strategy_config = EMACrossBracketConfig(
        instrument_id=GBPUSD_SIM.id,
        bar_type=BarType.from_str("GBP/USD.SIM-1-MINUTE-BID-EXTERNAL"),
        fast_ema_period=10,
        slow_ema_period=20,
        bracket_distance_atr=3.0,
        trade_size=Decimal(1_000),
    )
    # Instantiate and add your strategy
    strategy = EMACrossBracket(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(SIM))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object when done
    engine.dispose()

</document_content>
</document>
<document index="1824">
<source>examples/backtest/fx_ema_cross_bracket_gbpusd_bars_internal.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.backtest.models import FillModel
from nautilus_trader.backtest.modules import FXRolloverInterestConfig
from nautilus_trader.backtest.modules import FXRolloverInterestModule
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RiskEngineConfig
from nautilus_trader.examples.strategies.ema_cross_bracket import EMACrossBracket
from nautilus_trader.examples.strategies.ema_cross_bracket import EMACrossBracketConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import QuoteTickDataWrangler
from nautilus_trader.test_kit.providers import TestDataProvider
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
        risk_engine=RiskEngineConfig(
            bypass=True,  # Example of bypassing pre-trade risk checks for backtests
        ),
    )

    # Build backtest engine
    engine = BacktestEngine(config=config)

    # Optional plug in module to simulate rollover interest,
    # the data is coming from packaged test data.
    provider = TestDataProvider()
    interest_rate_data = provider.read_csv("short-term-interest.csv")
    config = FXRolloverInterestConfig(interest_rate_data)
    fx_rollover_interest = FXRolloverInterestModule(config=config)

    # Create a fill model (optional)
    fill_model = FillModel(
        prob_fill_on_limit=0.2,
        prob_fill_on_stop=0.95,
        prob_slippage=0.5,
        random_seed=42,
    )

    # Add a trading venue (multiple venues possible)
    SIM = Venue("SIM")
    engine.add_venue(
        venue=SIM,
        oms_type=OmsType.HEDGING,  # Venue will generate position IDs
        account_type=AccountType.MARGIN,
        base_currency=USD,  # Standard single-currency account
        starting_balances=[Money(1_000_000, USD)],  # Single-currency or multi-currency accounts
        fill_model=fill_model,
        modules=[fx_rollover_interest],
        bar_execution=True,  # If bar data should move the market (True by default)
    )

    # Add instruments
    GBPUSD_SIM = TestInstrumentProvider.default_fx_ccy("GBP/USD", SIM)
    engine.add_instrument(GBPUSD_SIM)

    # Add data
    wrangler = QuoteTickDataWrangler(instrument=GBPUSD_SIM)
    ticks = wrangler.process_bar_data(
        bid_data=provider.read_csv_bars("fxcm/gbpusd-m1-bid-2012.csv"),
        ask_data=provider.read_csv_bars("fxcm/gbpusd-m1-ask-2012.csv"),
    )
    engine.add_data(ticks)

    # Configure your strategy
    strategy_config = EMACrossBracketConfig(
        instrument_id=GBPUSD_SIM.id,
        bar_type=BarType.from_str("GBP/USD.SIM-5-MINUTE-BID-INTERNAL"),
        fast_ema_period=10,
        slow_ema_period=20,
        bracket_distance_atr=3.0,
        trade_size=Decimal(1_000_000),
    )
    # Instantiate and add your strategy
    strategy = EMACrossBracket(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run()

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(SIM))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object when done
    engine.dispose()

</document_content>
</document>
<document index="1825">
<source>examples/backtest/fx_market_maker_gbpusd_bars.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import time
from datetime import datetime
from decimal import Decimal

import pandas as pd

from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.backtest.models import FillModel
from nautilus_trader.backtest.modules import FXRolloverInterestConfig
from nautilus_trader.backtest.modules import FXRolloverInterestModule
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMaker
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMakerConfig
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.objects import Money
from nautilus_trader.persistence.wranglers import QuoteTickDataWrangler
from nautilus_trader.test_kit.providers import TestDataProvider
from nautilus_trader.test_kit.providers import TestInstrumentProvider


if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
    )

    # Build the backtest engine
    engine = BacktestEngine(config=config)

    # Optional plug in module to simulate rollover interest,
    # the data is coming from packaged test data.
    provider = TestDataProvider()
    interest_rate_data = provider.read_csv("short-term-interest.csv")
    config = FXRolloverInterestConfig(interest_rate_data)
    fx_rollover_interest = FXRolloverInterestModule(config=config)

    # Create a fill model (optional)
    fill_model = FillModel(
        prob_fill_on_limit=0.2,
        prob_fill_on_stop=0.95,
        prob_slippage=0.5,
        random_seed=42,
    )

    # Add a trading venue (multiple venues possible)
    SIM = Venue("SIM")
    engine.add_venue(
        venue=SIM,
        oms_type=OmsType.NETTING,
        account_type=AccountType.MARGIN,
        base_currency=USD,  # Standard single-currency account
        starting_balances=[Money(10_000_000, USD)],  # Single-currency or multi-currency accounts
        fill_model=fill_model,
        modules=[fx_rollover_interest],
        bar_execution=True,  # If bar data should move the market (True by default)
    )

    # Add instruments
    GBPUSD_SIM = TestInstrumentProvider.default_fx_ccy("GBP/USD", SIM)
    engine.add_instrument(GBPUSD_SIM)

    # Add data
    wrangler = QuoteTickDataWrangler(GBPUSD_SIM)
    ticks = wrangler.process_bar_data(
        bid_data=provider.read_csv_bars("fxcm/gbpusd-m1-bid-2012.csv"),
        ask_data=provider.read_csv_bars("fxcm/gbpusd-m1-ask-2012.csv"),
    )
    engine.add_data(ticks)

    # Configure your strategy
    strategy_config = VolatilityMarketMakerConfig(
        instrument_id=GBPUSD_SIM.id,
        bar_type=BarType.from_str("GBP/USD.SIM-5-MINUTE-BID-INTERNAL"),
        atr_period=20,
        atr_multiple=3.0,
        trade_size=Decimal(500_000),
        emulation_trigger="NO_TRIGGER",
    )
    # Instantiate and add your strategy
    strategy = VolatilityMarketMaker(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    time.sleep(0.1)
    input("Press Enter to continue...")

    # Run the engine (from start to end of data)
    engine.run(end=datetime(2012, 2, 10))

    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(SIM))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())

    # For repeated backtest runs make sure to reset the engine
    engine.reset()

    # Good practice to dispose of the object when done
    engine.dispose()

</document_content>
</document>
<document index="1826">
<source>examples/backtest/model_configs_example.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------


from nautilus_trader.backtest.config import BacktestDataConfig
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.config import BacktestRunConfig
from nautilus_trader.backtest.config import BacktestVenueConfig
from nautilus_trader.backtest.config import ImportableFeeModelConfig
from nautilus_trader.backtest.config import ImportableFillModelConfig
from nautilus_trader.backtest.config import ImportableLatencyModelConfig
from nautilus_trader.backtest.node import BacktestNode
from nautilus_trader.config import ImportableStrategyConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


if __name__ == "__main__":
    # Example strategy configuration
    strategy_config = ImportableStrategyConfig(
        strategy_path="nautilus_trader.examples.strategies.ema_cross:EMACross",
        config_path="nautilus_trader.examples.strategies.ema_cross:EMACrossConfig",
        config={
            "instrument_id": "AAPL.NASDAQ",
            "bar_type": "AAPL.NASDAQ-1-MINUTE-LAST-EXTERNAL",
            "fast_ema_period": 10,
            "slow_ema_period": 20,
            "trade_size": 100,
        },
    )

    # Configure backtest engine
    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
        strategies=[strategy_config],
    )

    # Create importable fill model configs
    fill_model_config = ImportableFillModelConfig(
        fill_model_path="nautilus_trader.backtest.models:FillModel",
        config_path="nautilus_trader.backtest.config:FillModelConfig",
        config={
            "prob_fill_on_limit": 0.95,  # 95% chance of limit orders filling
            "prob_fill_on_stop": 0.98,  # 98% chance of stop orders filling
            "prob_slippage": 0.05,  # 5% chance of slippage
            "random_seed": 42,  # For reproducibility
        },
    )

    # Create importable latency model configs
    latency_model_config = ImportableLatencyModelConfig(
        latency_model_path="nautilus_trader.backtest.models:LatencyModel",
        config_path="nautilus_trader.backtest.config:LatencyModelConfig",
        config={
            "base_latency_nanos": 5_000_000,  # 5 milliseconds base latency
            "insert_latency_nanos": 2_000_000,  # Additional 2ms for inserts
            "update_latency_nanos": 3_000_000,  # Additional 3ms for updates
            "cancel_latency_nanos": 1_000_000,  # Additional 1ms for cancels
        },
    )

    # Example of different importable fee models
    maker_taker_fee_model_config = ImportableFeeModelConfig(
        fee_model_path="nautilus_trader.backtest.models:MakerTakerFeeModel",
        config_path="nautilus_trader.backtest.config:MakerTakerFeeModelConfig",
        config={},  # Empty config for MakerTakerFeeModel as it doesn't require parameters
    )

    fixed_fee_model_config = ImportableFeeModelConfig(
        fee_model_path="nautilus_trader.backtest.models:FixedFeeModel",
        config_path="nautilus_trader.backtest.config:FixedFeeModelConfig",
        config={
            "commission": "1.50 USD",
            "charge_commission_once": True,
        },
    )

    per_contract_fee_model_config = ImportableFeeModelConfig(
        fee_model_path="nautilus_trader.backtest.models:PerContractFeeModel",
        config_path="nautilus_trader.backtest.config:PerContractFeeModelConfig",
        config={
            "commission": "0.01 USD",
        },
    )

    # Another example with different parameters
    custom_fixed_fee_model_config = ImportableFeeModelConfig(
        fee_model_path="nautilus_trader.backtest.models:FixedFeeModel",
        config_path="nautilus_trader.backtest.config:FixedFeeModelConfig",
        config={
            "commission": "2.00 USD",
            "charge_commission_once": False,
        },
    )

    # Create venue configs with different models
    venue_config1 = BacktestVenueConfig(
        name="NASDAQ",
        oms_type="NETTING",
        account_type="CASH",
        base_currency="USD",
        starting_balances=["1000000 USD"],
        book_type="L1_MBP",
        fill_model=fill_model_config,
        latency_model=latency_model_config,
        fee_model=maker_taker_fee_model_config,
    )

    venue_config2 = BacktestVenueConfig(
        name="NYSE",
        oms_type="NETTING",
        account_type="CASH",
        base_currency="USD",
        starting_balances=["1000000 USD"],
        book_type="L1_MBP",
        fill_model=fill_model_config,
        latency_model=latency_model_config,
        fee_model=fixed_fee_model_config,
    )

    venue_config3 = BacktestVenueConfig(
        name="CME",
        oms_type="NETTING",
        account_type="MARGIN",
        base_currency="USD",
        starting_balances=["1000000 USD"],
        book_type="L1_MBP",
        fill_model=fill_model_config,
        latency_model=latency_model_config,
        fee_model=per_contract_fee_model_config,
    )

    # Create venue config with custom fixed fee model
    venue_config4 = BacktestVenueConfig(
        name="BATS",
        oms_type="NETTING",
        account_type="CASH",
        base_currency="USD",
        starting_balances=["1000000 USD"],
        book_type="L1_MBP",
        fill_model=fill_model_config,
        latency_model=latency_model_config,
        fee_model=custom_fixed_fee_model_config,
    )

    # Create data config (this is just a placeholder - you would need actual data)
    data_config = BacktestDataConfig(
        catalog_path="./data",
        data_cls=QuoteTick,
        instrument_id=InstrumentId.from_str("AAPL.NASDAQ"),
    )

    # Create BacktestRunConfig
    run_config = BacktestRunConfig(
        engine=engine_config,
        venues=[venue_config1, venue_config2, venue_config3, venue_config4],
        data=[data_config],
    )

    # Create and run the backtest node
    node = BacktestNode(configs=[run_config])

    # Note: This example won't actually run without proper data
    # results = node.run()

    print("Example of using importable model configs in BacktestVenueConfig")
    print(
        f"Venue 1 uses ImportableFeeModelConfig with MakerTakerFeeModel: {venue_config1.fee_model}",
    )
    print(
        f"Venue 2 uses ImportableFeeModelConfig with FixedFeeModel: {venue_config2.fee_model.config}",
    )
    print(
        f"Venue 3 uses ImportableFeeModelConfig with PerContractFeeModel: {venue_config3.fee_model.config}",
    )
    print(
        f"Venue 4 uses ImportableFeeModelConfig with custom FixedFeeModel: {venue_config4.fee_model.config}",
    )
    print(f"Fill model config: {venue_config1.fill_model.config}")
    print(f"Latency model config: {venue_config1.latency_model.config}")

</document_content>
</document>
<document index="1827">
<source>examples/backtest/notebooks/databento_backtest_with_data_client.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.17.3
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% [markdown]
# # Databento Data Client with Backtest Node
#
# This example demonstrates how to use the Databento data client with a backtest node.

# %% [markdown]
# ## Imports

# %%
# Note: Use the jupytext python extension to be able to open this python file in jupyter as a notebook

# %%
import asyncio

import nautilus_trader.adapters.databento.data_utils as db_data_utils
from nautilus_trader.adapters.databento.config import DatabentoDataClientConfig
from nautilus_trader.adapters.databento.factories import DatabentoLiveDataClientFactory
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.config import BacktestRunConfig
from nautilus_trader.backtest.config import BacktestVenueConfig
from nautilus_trader.backtest.node import BacktestNode
from nautilus_trader.common.config import LoggingConfig
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import ImportableStrategyConfig
from nautilus_trader.config import RoutingConfig
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.datetime import unix_nanos_to_iso8601
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.objects import Quantity
from nautilus_trader.persistence.config import DataCatalogConfig
from nautilus_trader.trading.strategy import Strategy


# %%
# We need to use nest_asyncio in a jupyter notebook to be able to run async code as sync for market data
# requests in a backtest
try:
    asyncio.get_running_loop()
except RuntimeError:
    pass  # No loop running
else:
    import nest_asyncio

    nest_asyncio.apply()

# %% [markdown]
# ## Parameters

# %%
# Set the data path for Databento data
# DATA_PATH = "/path/to/your/data"  # Use your own value here
# db_data_utils.DATA_PATH = DATA_PATH

catalog_folder = "futures_catalog"
catalog = db_data_utils.load_catalog(catalog_folder)

future_symbols = ["ESM4"]

# Small amount of data for testing
start_time = "2024-05-09T10:00"
end_time = "2024-05-09T10:01"

# A valid databento key can be entered here (or as an env variable of the same name)
# DATABENTO_API_KEY = None
# db_data_utils.init_databento_client(DATABENTO_API_KEY)

# # # Ensure data is available
# futures_data = databento_data(
#     future_symbols,
#     start_time,
#     end_time,
#     "definition",  # "ohlcv-1m"
#     "futures",
#     catalog_folder,
# )

# %% [markdown]
# ## Strategy


# %%
class FuturesStrategyConfig(StrategyConfig, frozen=True):
    """
    Configuration for the FuturesStrategy.
    """

    future_id: InstrumentId


class FuturesStrategy(Strategy):
    """
    A simple futures trading strategy that subscribes to bar data.
    """

    def __init__(self, config: FuturesStrategyConfig) -> None:
        super().__init__(config=config)
        self.bar_type: BarType | None = None
        self.position_opened = False
        self.n_depths = 0

    def on_start(self) -> None:
        self.bar_type = BarType.from_str(f"{self.config.future_id}-1-MINUTE-LAST-EXTERNAL")

        # Request instrument
        now = self.clock.utc_now()
        self.request_instrument(self.bar_type.instrument_id, end=now, update_catalog=True)
        # instrument = self.cache.instrument(self.bar_type.instrument_id)
        # self.log.warning(f"{instrument=}")

        # Subscribe to bar data
        self.subscribe_bars(self.bar_type, update_catalog=True)

        # Subscribe order book depth
        self.subscribe_order_book_depth(self.config.future_id, depth=10, update_catalog=True)

        self.user_log(f"Strategy started, subscribed to {self.bar_type}")

    def on_order_book_depth(self, depth):
        if self.n_depths > 0:
            return

        self.user_log(
            f"Depth received: ts_init={unix_nanos_to_iso8601(depth.ts_init)}, {depth=}",
        )
        self.n_depths += 1

    def on_bar(self, bar: Bar) -> None:
        self.user_log(
            f"Bar received: ts_init={unix_nanos_to_iso8601(bar.ts_init)}, close={bar.close}",
        )

        # Simple strategy: open a position on the first bar
        if not self.position_opened:
            self.user_log("Opening a position")
            self.submit_market_order(self.config.future_id, 1)
            self.position_opened = True

    def submit_market_order(self, instrument_id: InstrumentId, quantity: int) -> None:
        order = self.order_factory.market(
            instrument_id=instrument_id,
            order_side=(OrderSide.BUY if quantity > 0 else OrderSide.SELL),
            quantity=Quantity.from_int(abs(quantity)),
        )
        self.submit_order(order)
        self.user_log(f"Submitted order: {order}")

    def user_log(self, msg: str) -> None:
        self.log.warning(str(msg), color=LogColor.GREEN)

    def on_stop(self) -> None:
        self.unsubscribe_bars(self.bar_type)
        self.user_log("Strategy stopped")


# %% [markdown]
# ## Backtest Configuration

# %%
# Create BacktestEngineConfig
strategies = [
    ImportableStrategyConfig(
        strategy_path=FuturesStrategy.fully_qualified_name(),
        config_path=FuturesStrategyConfig.fully_qualified_name(),
        config={
            "future_id": InstrumentId.from_str(f"{future_symbols[0]}.XCME"),
        },
    ),
]

logging = LoggingConfig(
    bypass_logging=False,
    log_colors=True,
    log_level="WARN",
    log_level_file="WARN",
    log_directory=".",
    log_file_format=None,
    log_file_name="databento_backtest_with_data_client",
    clear_log_file=True,
    print_config=False,
    use_pyo3=False,
)

# Configure the data catalog
catalogs = [
    DataCatalogConfig(
        path=catalog.path,
    ),
]

engine_config = BacktestEngineConfig(
    logging=logging,
    strategies=strategies,
    catalogs=catalogs,
)

# Create BacktestRunConfig
venues = [
    BacktestVenueConfig(
        name="XCME",
        oms_type="NETTING",
        account_type="MARGIN",
        base_currency="USD",
        starting_balances=["1_000_000 USD"],
    ),
]

data_clients: dict = {
    "databento-001": DatabentoDataClientConfig(
        api_key=None,  # 'DATABENTO_API_KEY' env var is used
        routing=RoutingConfig(
            default=False,
            venues=frozenset(["XCME"]),
        ),
    ),
}

config = BacktestRunConfig(
    engine=engine_config,
    venues=venues,
    data=[],  # Empty data list since we're using data clients
    start=start_time,
    end=end_time,
    data_clients=data_clients,
)

configs = [config]

# Create the backtest node
node = BacktestNode(configs=configs)

# Register the Databento data client factory
node.add_data_client_factory("databento", DatabentoLiveDataClientFactory)

# Build the node (this will create and register the data clients)
node.build()

# node.get_engine(configs[0].id).kernel.data_engine.default_client
# node.get_engine(configs[0].id).kernel.data_engine.routing_map

# %%
# Run the backtest
node.run()

# %%
# # Display results
# engine = node.get_engine(configs[0].id)
# engine.trader.generate_order_fills_report()
# engine.trader.generate_positions_report()
# engine.trader.generate_account_report(Venue("GLBX"))

# %%
# # Clean up
# node.dispose()

</document_content>
</document>
<document index="1828">
<source>examples/backtest/notebooks/databento_download.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.17.3
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% [markdown]
# # Databento Data Client with Backtest Node
#
# This example demonstrates how to use the Databento data client with a backtest node.

# %% [markdown]
# ## Imports

# %%
# Note: Use the jupytext python extension to be able to open this python file in jupyter as a notebook

# %%
import asyncio

import nautilus_trader.adapters.databento.data_utils as db_data_utils
from nautilus_trader.adapters.databento.config import DatabentoDataClientConfig
from nautilus_trader.adapters.databento.factories import DatabentoLiveDataClientFactory
from nautilus_trader.backtest.node import BacktestNode
from nautilus_trader.core.datetime import time_object_to_dt
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.persistence.config import DataCatalogConfig


# from nautilus_trader.live.config import RoutingConfig


# %%
# We need to use nest_asyncio in a jupyter notebook to be able to run async code as sync for market data
# requests in a backtest
try:
    asyncio.get_running_loop()
except RuntimeError:
    pass  # No loop running
else:
    import nest_asyncio

    nest_asyncio.apply()

# %% [markdown]
# ## Parameters

# %%
# Set the data path for Databento data
# DATA_PATH = "/path/to/your/data"  # Use your own value here
# db_data_utils.DATA_PATH = DATA_PATH

catalog_folder = "download_catalog"
catalog = db_data_utils.load_catalog(catalog_folder)

# Small amount of data for testing
start_time_1 = "2024-05-07T10:00"
start_time_2 = "2024-05-08T10:00"
end_time_1 = "2024-05-08T10:01"
end_time_2 = "2024-05-08T10:04"
end_time_3 = "2024-05-08T10:06"

# %% [markdown]
# ## Strategy

# %%
# Configure the data catalog
catalog_config = DataCatalogConfig(path=catalog.path)

data_clients: dict = {
    "databento-001": DatabentoDataClientConfig(),
}
# api_key=None,  # 'DATABENTO_API_KEY' env var
# routing=RoutingConfig(
#     default=False,
#     venues=frozenset(["XCME"]),
# ),

# Create the backtest node
node = BacktestNode([])

# Register the Databento data client factory
node.add_data_client_factory("databento", DatabentoLiveDataClientFactory)

# Build download engine
node.setup_download_engine(catalog_config, data_clients)

# %%
node.download_data(
    "request_instrument",
    instrument_id=InstrumentId.from_str("ESM4.XCME"),
    start=time_object_to_dt(start_time_1),
    end=time_object_to_dt(end_time_1),
)

node.download_data(
    "request_bars",
    bar_type=BarType.from_str("ESM4.XCME-1-MINUTE-LAST-EXTERNAL"),
    start=time_object_to_dt(start_time_2),
    end=time_object_to_dt(end_time_3),
)

# %%
node.download_data(
    "request_order_book_depth",
    instrument_id=InstrumentId.from_str("ESM4.XCME"),
    start=time_object_to_dt(start_time_2),
    end=time_object_to_dt(end_time_1),
)

# %%
# # Clean up
node.dispose()

</document_content>
</document>
<document index="1829">
<source>examples/backtest/notebooks/databento_option_greeks.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.18.1
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% [markdown]
# ## imports

# %%
# Note: Use the jupytext python extension to be able to open this python file in jupyter as a notebook

# %%
import numpy as np

from nautilus_trader.adapters.databento.data_utils import data_path
from nautilus_trader.adapters.databento.data_utils import databento_data
from nautilus_trader.adapters.databento.data_utils import load_catalog
from nautilus_trader.analysis.config import TearsheetConfig
from nautilus_trader.analysis.tearsheet import create_bars_with_fills
from nautilus_trader.analysis.tearsheet import create_tearsheet
from nautilus_trader.backtest.config import MarginModelConfig
from nautilus_trader.backtest.node import BacktestNode
from nautilus_trader.backtest.option_exercise import OptionExerciseConfig
from nautilus_trader.backtest.option_exercise import OptionExerciseModule
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import BacktestDataConfig
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import BacktestRunConfig
from nautilus_trader.config import BacktestVenueConfig
from nautilus_trader.config import ImportableActorConfig
from nautilus_trader.config import ImportableFillModelConfig
from nautilus_trader.config import ImportableStrategyConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import StrategyConfig
from nautilus_trader.config import StreamingConfig
from nautilus_trader.core.datetime import unix_nanos_to_iso8601
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import DataType
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.greeks_data import GreeksData
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments import FuturesContract
from nautilus_trader.model.objects import Price
from nautilus_trader.model.objects import Quantity
from nautilus_trader.model.tick_scheme import TieredTickScheme
from nautilus_trader.model.tick_scheme import register_tick_scheme
from nautilus_trader.persistence.config import DataCatalogConfig
from nautilus_trader.persistence.loaders import InterestRateProvider
from nautilus_trader.persistence.loaders import InterestRateProviderConfig
from nautilus_trader.trading.strategy import Strategy


# %%
# Configure ES Options tick scheme based on CME specifications
# ES options have different tick sizes based on price level:
# - Below $10.00: $0.05 increments
# - $10.00 and above: $0.25 increments
ES_OPTIONS_TICK_SCHEME = TieredTickScheme(
    name="ES_OPTIONS",
    tiers=[
        (0.05, 10.00, 0.05),  # Below $10.00: $0.05 increments
        (10.00, np.inf, 0.25),  # $10.00 and above: $0.25 increments
    ],
    price_precision=2,
    max_ticks_per_tier=1000,
)

# Register the tick scheme so it can be used by instruments
register_tick_scheme(ES_OPTIONS_TICK_SCHEME)

# %% [markdown]
# ## parameters

# %%
# Set the data path for Databento data
# import nautilus_trader.adapters.databento.data_utils as db_data_utils
# DATA_PATH = "/path/to/your/data"  # Use your own value here
# db_data_utils.DATA_PATH = DATA_PATH

catalog_folder = "options_catalog"
catalog = load_catalog(catalog_folder)

future_symbols = ["ESM4"]
option_symbols = ["ESM4 P5230", "ESM4 P5250"]

# small amount of data to download for testing, very cheap
# Note that the example below doesn't need any download as the test data is included in the repository
start_time = "2024-05-09T10:00"
end_time = "2024-05-09T10:05"

# A valid databento key can be entered here (or as an env variable of the same name)
# DATABENTO_API_KEY = None
# db_data_utils.init_databento_client(DATABENTO_API_KEY)

# https://databento.com/docs/schemas-and-data-formats/whats-a-schema
futures_data = databento_data(
    future_symbols,
    start_time,
    end_time,
    "ohlcv-1m",
    "futures",
    catalog_folder,
)
options_data = databento_data(
    option_symbols,
    start_time,
    end_time,
    "bbo-1m",
    "options",
    catalog_folder,
)


# %% [markdown]
# ## strategy


# %%
class OptionConfig(StrategyConfig, frozen=True):
    future_id: InstrumentId
    option_id: InstrumentId
    option_id2: InstrumentId
    spread_id: InstrumentId
    load_greeks: bool = False


class OptionStrategy(Strategy):
    """
    An options trading strategy that calculates and displays the portfolio greeks.

    The strategy subscribes to quotes for two options and a futures contract, and
    initializes a portfolio with some trades. It can optionally load greeks from a
    catalog, or compute them on the fly. The strategy logs the portfolio greeks at
    regular intervals.

    """

    def __init__(self, config: OptionConfig):
        super().__init__(config=config)
        self.start_orders_done = False
        self.spread_order_submitted = False
        self.spread_quotes_received = 0

    def on_start(self):
        self.bar_type = BarType.from_str(f"{self.config.future_id}-1-MINUTE-LAST-EXTERNAL")

        if not self.config.load_greeks:
            self.bar_type_2 = BarType.from_str(
                f"{self.config.future_id}-2-MINUTE-LAST-INTERNAL@1-MINUTE-EXTERNAL",
            )
        else:
            self.bar_type_2 = BarType.from_str(f"{self.config.future_id}-2-MINUTE-LAST-EXTERNAL")

        self.request_instrument(self.config.option_id)
        self.request_instrument(self.config.option_id2)
        self.request_instrument(self.bar_type.instrument_id)

        # Subscribe to individual option quotes
        self.subscribe_quote_ticks(self.config.option_id)
        self.subscribe_quote_ticks(self.config.option_id2)
        self.subscribe_bars(self.bar_type)
        self.subscribe_bars(self.bar_type_2)

        # Request spread instrument with ES options tick scheme properties
        self.request_instrument(
            instrument_id=self.config.spread_id,
            params={
                "instrument_properties": {
                    "tick_scheme_name": "ES_OPTIONS",
                },
            },
        )
        self.subscribe_quote_ticks(self.config.spread_id)

        # Subscribing to custom greeks data if it's already stored
        self.subscribe_data(
            DataType(GreeksData),
            instrument_id=self.config.option_id,
            params={
                "append_data": False,
            },  # prepending data ensures that greeks are cached and available before on_bar
        )
        self.subscribe_data(
            DataType(GreeksData),
            instrument_id=self.config.option_id2,
            params={"append_data": False},
        )
        self.greeks.subscribe_greeks(
            InstrumentId.from_str("ES*.XCME"),
        )  # adds all ES greeks read from the message bus to the cache

    def on_instrument(self, instrument):
        self.user_log(f"Received instrument: {instrument}")

    def init_portfolio(self):
        self.submit_market_order(instrument_id=self.config.option_id, quantity=-10)
        self.submit_market_order(instrument_id=self.config.option_id2, quantity=10)
        self.submit_market_order(instrument_id=self.config.future_id, quantity=1)

        self.start_orders_done = True

    def on_quote_tick(self, tick):
        # Submit spread order when we have spread quotes available
        if tick.instrument_id == self.config.spread_id and not self.spread_order_submitted:
            self.user_log(f"Spread quote received: {tick}")

            # Try submitting order immediately - the exchange should have processed the quote by now
            self.user_log(f"Submitting spread order for {self.config.spread_id}")
            self.submit_market_order(instrument_id=self.config.spread_id, quantity=5)
            self.spread_order_submitted = True

    # def on_data(self, greeks):
    #     self.log.warning(f"{greeks=}")
    #     self.cache.add_greeks(greeks)

    def on_bar(self, bar):
        self.user_log(
            f"bar ts_init = {unix_nanos_to_iso8601(bar.ts_init)}, bar close = {bar}",
        )

        if not self.start_orders_done:
            self.user_log("Initializing the portfolio with some trades")
            self.init_portfolio()
            return

        self.display_greeks()

    def display_greeks(self, alert=None):
        portfolio_greeks = self.greeks.portfolio_greeks(
            use_cached_greeks=self.config.load_greeks,
            publish_greeks=(not self.config.load_greeks),
            # underlyings=["ES"],
            # spot_shock=10.,
            # vol_shock=0.0,
            # percent_greeks=True,
            # index_instrument_id=self.config.future_id,
            # beta_weights={self.config.future_id: 2.}
        )
        self.user_log(f"{portfolio_greeks=}")

    def submit_market_order(self, instrument_id, quantity):
        order = self.order_factory.market(
            instrument_id=instrument_id,
            order_side=(OrderSide.BUY if quantity > 0 else OrderSide.SELL),
            quantity=Quantity.from_int(abs(quantity)),
        )

        self.submit_order(order)

    def submit_limit_order(self, instrument_id, price, quantity):
        order = self.order_factory.limit(
            instrument_id=instrument_id,
            order_side=(OrderSide.BUY if quantity > 0 else OrderSide.SELL),
            quantity=Quantity.from_int(abs(quantity)),
            price=Price.from_str(f"{price:.2f}"),
        )

        self.submit_order(order)

    def user_log(self, msg):
        self.log.warning(f"{msg}", color=LogColor.GREEN)

    def on_stop(self):
        self.unsubscribe_bars(self.bar_type)
        self.unsubscribe_quote_ticks(self.config.option_id)
        self.unsubscribe_quote_ticks(self.config.option_id2)
        self.unsubscribe_data(DataType(GreeksData), instrument_id=self.config.option_id)
        self.unsubscribe_data(DataType(GreeksData), instrument_id=self.config.option_id2)
        self.unsubscribe_quote_ticks(self.config.spread_id)


# %% [markdown]
# ## backtest node

# %%
# BacktestEngineConfig

# When load_greeks is False, the streamed greeks and bars can be saved after the backtest to the catalog
# When load_greeks is True, the greeks and previously internal bars are loaded from the catalog
load_greeks = False

actors = [
    ImportableActorConfig(
        actor_path=InterestRateProvider.fully_qualified_name(),
        config_path=InterestRateProviderConfig.fully_qualified_name(),
        config={
            "interest_rates_file": str(data_path(catalog_folder, "usd_short_term_rate.xml")),
        },
    ),
]

future_instrument_id = InstrumentId.from_str(f"{future_symbols[0]}.XCME")
option1_id = InstrumentId.from_str(f"{option_symbols[0]}.XCME")
option2_id = InstrumentId.from_str(f"{option_symbols[1]}.XCME")
spread_instrument_id = InstrumentId.new_spread(
    [
        (option1_id, -1),  # Short ESM4 P5230
        (option2_id, 1),  # Long ESM4 P5250
    ],
)

strategies = [
    ImportableStrategyConfig(
        strategy_path=OptionStrategy.fully_qualified_name(),
        config_path=OptionConfig.fully_qualified_name(),
        config={
            "future_id": future_instrument_id,
            "option_id": option1_id,
            "option_id2": option2_id,
            "spread_id": spread_instrument_id,
            "load_greeks": load_greeks,
        },
    ),
]

streaming = StreamingConfig(
    catalog_path=catalog.path,
    fs_protocol="file",
    include_types=[GreeksData, Bar, FuturesContract],
)

logging = LoggingConfig(
    log_level="WARNING",  # "DEBUG"
    log_level_file="WARNING",
    log_directory=".",
    log_file_name="databento_option_greeks",
    log_file_format=None,  # "json" or None
    # log_component_levels={"SpreadQuoteAggregator": "DEBUG"},
    bypass_logging=False,
    print_config=False,
    use_pyo3=False,
    clear_log_file=True,
    # log_components_only=True,
)

catalogs = [
    DataCatalogConfig(
        path=catalog.path,
    ),
]

engine_config = BacktestEngineConfig(
    logging=logging,
    actors=actors,
    strategies=strategies,
    streaming=(streaming if not load_greeks else None),
    catalogs=catalogs,
)

# BacktestRunConfig

data = [
    # Note: use instrument_id and bar_spec, or instrument_ids and bar_spec, or bar_types, or nothing
    BacktestDataConfig(
        data_cls=Bar,
        catalog_path=catalog.path,
        # instrument_id=InstrumentId.from_str(f"{future_symbols[0]}.XCME"),
        # instrument_ids=[InstrumentId.from_str(f"{future_symbols[0]}.XCME")],
        # bar_spec="1-MINUTE-LAST",
        # bar_types=[f"{future_symbols[0]}.XCME-1-MINUTE-LAST-EXTERNAL"],
        # start_time=start_time,
        # end_time=end_time,
    ),
    BacktestDataConfig(
        data_cls=QuoteTick,
        catalog_path=catalog.path,
        # instrument_ids=[InstrumentId.from_str(f"{option_symbols[0]}.XCME"), InstrumentId.from_str(f"{option_symbols[1]}.XCME")],
    ),
]

if load_greeks:
    # Important note: when prepending custom data to usual market data, it will reach actors/strategies earlier
    data = [
        BacktestDataConfig(
            data_cls=GreeksData.fully_qualified_name(),
            catalog_path=catalog.path,
            client_id="GreeksDataProvider",
            # metadata={"instrument_id": "ES"}, # not used anymore, reminder on syntax
        ),
        *data,
    ]

# Configure venue with enhanced SizeAwareFillModel for realistic option execution
# This fill model provides different execution behavior based on order size:
# - Small orders (<=10 contracts): Good liquidity at best prices
# - Large orders: Experience price impact with partial fills at worse prices
fill_model = ImportableFillModelConfig(
    fill_model_path="nautilus_trader.backtest.models:SizeAwareFillModel",
    config_path="nautilus_trader.backtest.config:FillModelConfig",
    config={},
)

margin_model = MarginModelConfig(
    model_type="standard",
)  # Use standard margin model for options trading

modules = [
    ImportableActorConfig(
        actor_path=OptionExerciseModule.fully_qualified_name(),
        config_path=OptionExerciseConfig.fully_qualified_name(),
        config={
            "auto_exercise_enabled": True,
        },
    ),
]

venues = [
    BacktestVenueConfig(
        name="XCME",
        oms_type="NETTING",
        account_type="MARGIN",
        base_currency="USD",
        starting_balances=["1_000_000 USD"],
        margin_model=margin_model,
        fill_model=fill_model,
        modules=modules,
    ),
]

configs = [
    BacktestRunConfig(
        engine=engine_config,
        data=[],  # data
        venues=venues,
        chunk_size=None,  # use None when loading custom data, else a value of 10_000 for example
        start=start_time,
        end=end_time,
        raise_exception=True,
    ),
]

node = BacktestNode(configs=configs)

# %%
results = node.run()

# %%
if not load_greeks:
    catalog.convert_stream_to_data(
        results[0].instance_id,
        GreeksData,
    )

    catalog.convert_stream_to_data(
        results[0].instance_id,
        Bar,
        identifiers=["2-MINUTE"],
    )

    catalog.convert_stream_to_data(
        results[0].instance_id,
        FuturesContract,
    )

# %% [markdown]
# ## backtest results

# %%
engine = node.get_engine(configs[0].id)
engine.trader.generate_order_fills_report()

# %%
engine.trader.generate_positions_report()

# %%
engine.trader.generate_account_report(Venue("XCME"))

# %%
# Create visualization with bars and order fills (standalone)
bar_type = BarType.from_str(f"{future_symbols[0]}.XCME-1-MINUTE-LAST-EXTERNAL")
fig = create_bars_with_fills(
    engine=engine,
    bar_type=bar_type,
    title=f"{future_symbols[0]} - Price Bars with Order Fills",
)
fig

# %%
# Test tearsheet integration with bars_with_fills chart using node and instance_id
tearsheet_config = TearsheetConfig(
    charts=["stats_table", "equity", "bars_with_fills"],
    chart_args={
        "bars_with_fills": {
            "bar_type": f"{future_symbols[0]}.XCME-1-MINUTE-LAST-EXTERNAL",
        },
    },
)

create_tearsheet(
    engine,
    config=tearsheet_config,
    output_path="tearsheet_with_bars_fills.html",
)

# %%
node.dispose()

</document_content>
</document>
<document index="1830">
<source>examples/backtest/notebooks/databento_test_request_bars.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.18.1
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% [markdown]
# ## imports

# %%
# Note: Use the jupytext python extension to be able to open this python file in jupyter as a notebook

# %%
import pandas as pd

from nautilus_trader.adapters.databento.data_utils import databento_data
from nautilus_trader.adapters.databento.data_utils import load_catalog
from nautilus_trader.backtest.node import BacktestNode
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import BacktestDataConfig
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import BacktestRunConfig
from nautilus_trader.config import BacktestVenueConfig
from nautilus_trader.config import DataEngineConfig
from nautilus_trader.config import ImportableStrategyConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.datetime import unix_nanos_to_iso8601
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarAggregation
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.persistence.config import DataCatalogConfig
from nautilus_trader.trading.strategy import Strategy


# %% [markdown]
# ## parameters

# %%
# Set the data path for Databento data
# import nautilus_trader.adapters.databento.data_utils as db_data_utils
# DATA_PATH = "/path/to/your/data"  # Use your own value here
# db_data_utils.DATA_PATH = DATA_PATH

catalog_folder = "historical_bars_catalog"
catalog = load_catalog(catalog_folder)

future_symbols = ["ESU4"]

# small amount of data to download for testing, very cheap
# Note that the example below doesn't need any download as the test data is included in the repository
start_time = "2024-07-01T23:40"
end_time = "2024-07-02T00:10"

# A valid databento key can be entered here (or as an env variable of the same name)
# DATABENTO_API_KEY = None
# db_data_utils.init_databento_client(DATABENTO_API_KEY)

# https://databento.com/docs/schemas-and-data-formats/whats-a-schema
futures_data_bars = databento_data(
    ["ESU4", "NQU4"],
    start_time,
    end_time,
    "ohlcv-1m",
    "futures",
    catalog_folder,
)

futures_data_quotes = databento_data(
    future_symbols,
    "2024-07-01T23:58",
    "2024-07-02T00:02",
    "mbp-1",
    "futures",
    catalog_folder,
)

futures_data_trades = databento_data(
    future_symbols,
    "2024-07-01T23:58",
    "2024-07-02T00:02",
    "trades",
    "futures",
    catalog_folder,
)

# %% [markdown]
# ## strategy


# %%
class TestHistoricalAggConfig(StrategyConfig, frozen=True):
    symbol_id: InstrumentId
    historical_start_delay: int = 10
    historical_end_delay: int = 1
    data_type: str = "bars"


class TestHistoricalAggStrategy(Strategy):
    def __init__(self, config: TestHistoricalAggConfig):
        super().__init__(config=config)
        self.bars_subscribed = False

        # self.external_sma = SimpleMovingAverage(2)
        # self.composite_sma = SimpleMovingAverage(2)

    def on_start(self):
        if self.config.data_type == "bars":
            # Define start and end historical request times
            utc_now = self.clock.utc_now()
            start_historical_bars = utc_now - pd.Timedelta(
                minutes=self.config.historical_start_delay,
            )
            end_historical_bars = utc_now - pd.Timedelta(minutes=self.config.historical_end_delay)
            self.user_log(f"on_start: {start_historical_bars=}, {end_historical_bars=}")

            # Define bar types
            symbol_id = self.config.symbol_id
            self.external_bar_type = BarType.from_str(f"{symbol_id}-1-MINUTE-LAST-EXTERNAL")
            self.bar_type_1 = BarType.from_str(
                f"{symbol_id}-2-MINUTE-LAST-INTERNAL@1-MINUTE-EXTERNAL",
            )
            self.bar_type_2 = BarType.from_str(
                f"{symbol_id}-4-MINUTE-LAST-INTERNAL@2-MINUTE-INTERNAL",
            )
            self.bar_type_3 = BarType.from_str(
                f"{symbol_id}-5-MINUTE-LAST-INTERNAL@1-MINUTE-EXTERNAL",
            )

            # Requesting instruments
            # self.request_instrument(symbol_id)
            # self.request_instrument(InstrumentId.from_str("NQU4.XCME"))
            self.request_instruments(symbol_id.venue)

            # Test registering bar types with indicators, request_aggregated_bars below will update both indicators
            # self.register_indicator_for_bars(self.external_bar_type, self.external_sma)
            # self.register_indicator_for_bars(self.bar_type_1, self.composite_sma)

            # Test request_aggregated_bars
            self.request_aggregated_bars(
                [self.bar_type_1, self.bar_type_2, self.bar_type_3],
                start=start_historical_bars,
                end=end_historical_bars,
                update_subscriptions=True,
                include_external_data=True,
                params={
                    "time_range_generator": "",  # Use default time range generator
                    "durations_seconds": [120],  # Request 2-minute chunks
                },
                callback=self.strategy_subscribe_bars,
            )

            # Test request_join
            # self.external_bar_type_2 = BarType.from_str("NQU4.XCME-1-MINUTE-LAST-EXTERNAL")
            # uuid_1 = self.request_bars(
            #     self.external_bar_type,
            #     unix_nanos_to_dt(0),
            #     join_request=True,
            #     callback=lambda x: self.user_log("join bars ES done", log_color=LogColor.BLUE),
            # )
            # uuid_2 = self.request_bars(
            #     self.external_bar_type_2,
            #     unix_nanos_to_dt(0),
            #     join_request=True,
            #     callback=lambda x: self.user_log("join bars NQ done", log_color=LogColor.BLUE),
            # )
            # self.request_join(
            #     (uuid_1, uuid_2),
            #     start_historical_bars,
            #     end_historical_bars,
            #     params={
            #         "time_range_generator": "",  # Use default time range generator
            #         "durations_seconds": [120],  # Request 2-minute chunks
            #     },
            #     callback=lambda x: self.user_log("join bars done", log_color=LogColor.BLUE),
            # )
        elif self.config.data_type == "quotes":
            utc_now = self.clock.utc_now()
            start_historical_bars = utc_now - pd.Timedelta(
                minutes=self.config.historical_start_delay,
            )
            end_historical_bars = utc_now - pd.Timedelta(
                minutes=self.config.historical_end_delay,
                milliseconds=1,
            )
            self.user_log(f"on_start: {start_historical_bars=}, {end_historical_bars=}")

            self.bar_type_1 = BarType.from_str(f"{self.config.symbol_id}-1-MINUTE-BID-INTERNAL")
            self.bar_type_2 = BarType.from_str(
                f"{self.config.symbol_id}-2-MINUTE-BID-INTERNAL@1-MINUTE-INTERNAL",
            )

            self.request_aggregated_bars(
                [self.bar_type_1, self.bar_type_2],
                start=start_historical_bars,
                end=end_historical_bars,
                update_subscriptions=True,
                include_external_data=False,
                callback=self.strategy_subscribe_bars,
            )
        if self.config.data_type == "trades":
            utc_now = self.clock.utc_now()
            start_historical_bars = utc_now - pd.Timedelta(
                minutes=self.config.historical_start_delay,
            )
            end_historical_bars = utc_now - pd.Timedelta(
                minutes=self.config.historical_end_delay,
                milliseconds=1,
            )
            self.user_log(f"on_start: {start_historical_bars=}, {end_historical_bars=}")

            self.bar_type_1 = BarType.from_str(f"{self.config.symbol_id}-1-MINUTE-LAST-INTERNAL")
            self.bar_type_2 = BarType.from_str(
                f"{self.config.symbol_id}-2-MINUTE-LAST-INTERNAL@1-MINUTE-INTERNAL",
            )

            self.request_aggregated_bars(
                [self.bar_type_1, self.bar_type_2],
                start=start_historical_bars,
                end=end_historical_bars,
                update_subscriptions=True,
                include_external_data=False,
                callback=self.strategy_subscribe_bars,
            )

        self.user_log("request_aggregated_bars done")

    def on_instrument(self, data):
        self.user_log(f"instrument received {data}", log_color=LogColor.BLUE)

    def strategy_subscribe_bars(self, uuid):
        if self.config.data_type == "bars":
            self.subscribe_bars(self.external_bar_type)
            self.subscribe_bars(self.bar_type_1)
            self.subscribe_bars(self.bar_type_2)
            self.subscribe_bars(self.bar_type_3)
        elif self.config.data_type == "quotes":
            self.subscribe_bars(self.bar_type_1)
            self.subscribe_bars(self.bar_type_2)
        if self.config.data_type == "trades":
            self.subscribe_bars(self.bar_type_1)
            self.subscribe_bars(self.bar_type_2)

        self.bars_subscribed = True

    def on_historical_data(self, data):
        if type(data) is Bar:
            self.user_log(
                f"historical bar ts_init = {unix_nanos_to_iso8601(data.ts_init)}, {data.ts_init}",
            )
            self.user_log(data)

            # self.user_log(f"{self.external_sma.value=}, {self.external_sma.initialized=}")
            # self.user_log(f"{self.composite_sma.value=}, {self.composite_sma.initialized=}")

    def on_bar(self, bar):
        self.user_log(f"bar ts_init = {unix_nanos_to_iso8601(bar.ts_init)}, {bar.ts_init}")
        self.user_log(bar)

        # self.user_log(f"{self.external_sma.value=}, {self.external_sma.initialized=}")
        # self.user_log(f"{self.composite_sma.value=}, {self.composite_sma.initialized=}")

    def user_log(self, msg, log_color=LogColor.GREEN):
        self.log.warning(str(msg), color=log_color)

    def on_stop(self):
        if self.bars_subscribed:
            if self.config.data_type == "bars":
                self.unsubscribe_bars(self.external_bar_type)
                self.unsubscribe_bars(self.bar_type_1)
                self.unsubscribe_bars(self.bar_type_2)
                self.unsubscribe_bars(self.bar_type_3)
            elif self.config.data_type in ["quote", "trades"]:
                self.unsubscribe_bars(self.bar_type_1)
                self.unsubscribe_bars(self.bar_type_2)


# %% [markdown]
# ## backtest node

# %%
# BacktestEngineConfig
tested_market_data = "bars"  # "bars" | "quotes" | "trades"

historical_start_delay = 10 if tested_market_data == "bars" else 2
historical_end_delay = 1 if tested_market_data == "bars" else 0

backtest_start = "2024-07-01T23:55" if tested_market_data == "bars" else "2024-07-02T00:00"
backtest_end = "2024-07-02T00:10" if tested_market_data == "bars" else "2024-07-02T00:02"

strategies = [
    ImportableStrategyConfig(
        strategy_path=TestHistoricalAggStrategy.fully_qualified_name(),
        config_path=TestHistoricalAggConfig.fully_qualified_name(),
        config={
            "symbol_id": InstrumentId.from_str(f"{future_symbols[0]}.XCME"),
            "historical_start_delay": historical_start_delay,
            "historical_end_delay": historical_end_delay,
            "data_type": tested_market_data,
        },
    ),
]

logging = LoggingConfig(
    bypass_logging=False,
    log_colors=True,
    log_level="WARN",
    log_level_file="WARN",
    log_directory=".",
    log_file_format=None,  # "json" or None
    log_file_name="databento_test_request_bars",
    clear_log_file=True,
    print_config=False,
    use_pyo3=False,
)

catalogs = [
    DataCatalogConfig(
        path=catalog.path,
    ),
]

data_engine = DataEngineConfig(
    time_bars_origin_offset={
        BarAggregation.MINUTE: pd.Timedelta(seconds=0),
    },
    time_bars_build_delay=0,
)

engine_config = BacktestEngineConfig(
    strategies=strategies,
    logging=logging,
    catalogs=catalogs,
    data_engine=data_engine,
)

# BacktestRunConfig

data = []

if tested_market_data == "bars":
    data.append(
        BacktestDataConfig(
            data_cls=Bar,
            catalog_path=catalog.path,
            instrument_id=InstrumentId.from_str(f"{future_symbols[0]}.XCME"),
            bar_spec="1-MINUTE-LAST",
            start_time=backtest_start,
            end_time=backtest_end,
        ),
    )
elif tested_market_data == "quotes":
    data.append(
        BacktestDataConfig(
            data_cls=QuoteTick,
            catalog_path=catalog.path,
            instrument_id=InstrumentId.from_str(f"{future_symbols[0]}.XCME"),
            start_time=backtest_start,
            end_time=backtest_end,
        ),
    )
elif tested_market_data == "trades":
    data.append(
        BacktestDataConfig(
            data_cls=TradeTick,
            catalog_path=catalog.path,
            instrument_id=InstrumentId.from_str(f"{future_symbols[0]}.XCME"),
            start_time=backtest_start,
            end_time=backtest_end,
        ),
    )

venues = [
    BacktestVenueConfig(
        name="XCME",
        oms_type="NETTING",
        account_type="MARGIN",
        base_currency="USD",
        starting_balances=["1_000_000 USD"],
    ),
]

configs = [
    BacktestRunConfig(
        engine=engine_config,
        data=data,
        venues=venues,
        chunk_size=None,  # use None when loading custom data
        start=backtest_start,
        end=backtest_end,
    ),
]

node = BacktestNode(configs=configs)

# %%
results = node.run()

# %%

# %%

</document_content>
</document>
<document index="1831">
<source>examples/backtest/polymarket_simple_quoter.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
"""
Example script demonstrating how to fetch and use historical Polymarket data for
backtesting.

This example uses an active Polymarket market for demonstration.
You can find active markets at: https://polymarket.com

Data sources:
- Markets API: https://gamma-api.polymarket.com/markets
- Order book history: https://clob.polymarket.com/orderbook-history
- Trades/Prices: https://clob.polymarket.com/prices-history

"""

import asyncio
import time
from decimal import Decimal

import pandas as pd

from nautilus_trader.adapters.polymarket import POLYMARKET_VENUE
from nautilus_trader.adapters.polymarket import PolymarketDataLoader
from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalance
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalanceConfig
from nautilus_trader.model.currencies import USDC_POS
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.objects import Money


# Market slug to fetch data for
# To find active markets, run:
#   python nautilus_trader/adapters/polymarket/scripts/active_markets.py
# To find BTC/ETH UpDown markets specifically, run:
#   python nautilus_trader/adapters/polymarket/scripts/list_updown_markets.py
MARKET_SLUG = "fed-rate-hike-in-2025"


async def run_backtest(
    market_slug: str,
    lookback_hours: int = 24,
) -> None:
    """
    Run a backtest using historical Polymarket data.

    Parameters
    ----------
    market_slug : str
        The Polymarket market slug.
    lookback_hours : int
        How many hours of historical data to fetch.

    """
    # Create loader by market slug (automatically fetches and parses instrument)
    loader = await PolymarketDataLoader.from_market_slug(market_slug)
    instrument = loader.instrument

    print(f"\nMarket loaded: {instrument.description or market_slug}")
    print(f"Instrument ID: {instrument.id}")
    print(f"Outcome: {instrument.outcome}\n")

    # Calculate time range for historical data (last N hours)
    end = pd.Timestamp.now(tz="UTC")
    start = end - pd.Timedelta(hours=lookback_hours)

    print(f"Fetching data from {start} to {end}")

    # Load historical data using convenience methods
    print("Loading orderbook snapshots...")

    deltas = await loader.load_orderbook_snapshots(
        start=start,
        end=end,
    )
    print(f"Loaded {len(deltas)} OrderBookDeltas")

    print("Loading trade ticks...")
    trades = await loader.load_trades(
        start=start,
        end=end,
    )
    print(f"Loaded {len(trades)} TradeTicks")

    if not deltas and not trades:
        raise ValueError("No historical data available for the specified time range")

    # Configure backtest engine
    config = BacktestEngineConfig(trader_id=TraderId("BACKTESTER-001"))
    engine = BacktestEngine(config=config)

    # Add venue
    engine.add_venue(
        venue=POLYMARKET_VENUE,
        oms_type=OmsType.NETTING,
        account_type=AccountType.CASH,
        base_currency=USDC_POS,
        starting_balances=[Money(10_000, USDC_POS)],
        book_type=BookType.L2_MBP,
    )

    # Add instrument
    engine.add_instrument(instrument)

    # Add data
    if deltas:
        engine.add_data(deltas)
    if trades:
        engine.add_data(trades)

    # Configure strategy
    strategy_config = OrderBookImbalanceConfig(
        instrument_id=instrument.id,
        max_trade_size=Decimal(20),
        min_seconds_between_triggers=1.0,
    )

    strategy = OrderBookImbalance(config=strategy_config)
    engine.add_strategy(strategy=strategy)

    print("\nStarting backtest...")
    time.sleep(0.1)

    # Run backtest
    engine.run()

    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(POLYMARKET_VENUE))
        print("\n")
        print(engine.trader.generate_order_fills_report())
        print("\n")
        print(engine.trader.generate_positions_report())

    # Cleanup
    engine.reset()
    engine.dispose()


if __name__ == "__main__":
    try:
        asyncio.run(
            run_backtest(
                market_slug=MARKET_SLUG,
                lookback_hours=24,  # Fetch last 24 hours of data
            ),
        )
    except Exception as e:
        print(f"Error running backtest: {e}")
        raise

</document_content>
</document>
<document index="1832">
<source>examples/backtest/synthetic_data_pnl_test.py</source>
<document_content>
from datetime import UTC
from datetime import datetime
from decimal import Decimal

from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.backtest.models import PerContractFeeModel
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.datetime import dt_to_unix_nanos
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarSpecification
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import AssetClass
from nautilus_trader.model.enums import BarAggregation
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import PriceType
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import Symbol
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments import FuturesContract
from nautilus_trader.model.objects import Money
from nautilus_trader.model.objects import Price
from nautilus_trader.model.objects import Quantity
from nautilus_trader.trading.strategy import Strategy


def create_6E_instrument(venue: Venue) -> FuturesContract:
    symbol = Symbol("6E")
    return FuturesContract(
        # Core identification parameters for the Euro FX futures contract
        instrument_id=InstrumentId(symbol, venue),  # 6E is CME's code for EUR/USD futures
        raw_symbol=symbol,  # Symbol as used on the exchange
        asset_class=AssetClass.FX,  # Indicates this is an FX futures contract
        currency=USD,  # Contract is denominated in USD
        # Price and size specifications from CME
        price_precision=5,  # 5 decimal places for EUR/USD pricing
        price_increment=Price(
            Decimal("0.00005"),
            precision=5,
        ),  # Minimum tick = 0.00005 ($6.25 value)
        multiplier=Quantity(Decimal(125000), precision=0),  # Each contract = 125,000 EUR
        lot_size=Quantity(Decimal(1), precision=0),  # Minimum trading size is 1 contract
        # Contract specifications and expiration details
        underlying="EUR/USD",  # The underlying forex pair
        activation_ns=0,  # Contract start time (0 = active now)
        expiration_ns=int(datetime(2024, 12, 17, 14, 16, tzinfo=UTC).timestamp() * 1e9),
        # 3rd Wednesday at 9:16 AM CT
        # System timestamps for internal tracking
        ts_event=0,  # Event creation time
        ts_init=0,  # Initialization time
        margin_init=Decimal("0.21818181812"),
        # $3_000 per contract (at price 1.1000). This amount must be available to open new position.
        # It is not block, it is only entry requirement check.
        margin_maint=Decimal("0.18181818182"),
        # $2,500 per contract (at price 1.1000). This amount is really locked on account, while we have open position
        maker_fee=Decimal(
            0,
        ),  # CME Futures don't use maker/taker fee model. They have fixed fee per contract.
        taker_fee=Decimal(0),  # same as above
        # Additional contract specifications
        exchange="SIM",  # Chicago Mercantile Exchange rules
    )


class MinimalStrategyConfig(StrategyConfig, frozen=True):
    instrument_id: InstrumentId
    bar_type: BarType


class MinimalStrategy(Strategy):
    def __init__(self, config: MinimalStrategyConfig):
        super().__init__(config)
        self.bars_processed = -1

        self.portfolio_realized_pnl_values[int, Money] = {}
        self.portfolio_unrealized_pnl_values[int, Money] = {}

    def on_start(self):
        self.subscribe_bars(self.config.bar_type)

    def on_bar(self, bar: Bar):
        self.bars_processed += 1

        bar_dt = unix_nanos_to_dt(bar.ts_event)

        # Collect value of realized/unrealized pnl from Portfolio
        self.portfolio_realized_pnl_values[bar_dt] = self.portfolio.realized_pnl(
            self.config.instrument_id,
        )
        self.portfolio_unrealized_pnl_values[bar_dt] = self.portfolio.unrealized_pnl(
            self.config.instrument_id,
        )

        is_flat = self.portfolio.is_completely_flat()

        # Debug point 1: Open position
        # Problem is, that , but Portfolio return None: `self.portfolio.unrealized_pnl(self.config.instrument_id)`
        if self.bars_processed == 5:
            # See value of 2 variables:
            realized_pnl = self.portfolio.realized_pnl(
                self.config.instrument_id,
            )  # Has only commission -2.50. Is OK as no trade was closed yet.
            unrealized_pnl = self.portfolio.unrealized_pnl(self.config.instrument_id)
            self.log.info(f"{self.bars_processed=}, {realized_pnl=}, {unrealized_pnl=}")
            # <------------------- PUT DEBUG POINT HERE

        # Debug point 2: Closed position
        # Problem is, that , but Portfolio return None: `self.portfolio.unrealized_pnl(self.config.instrument_id)`
        if self.bars_processed == 10:
            # See value of 2 variables:
            realized_pnl = self.portfolio.realized_pnl(self.config.instrument_id)
            unrealized_pnl = self.portfolio.unrealized_pnl(
                self.config.instrument_id,
            )  # Returns 0, that is OK when closed position
            self.log.info(f"{self.bars_processed=}, {realized_pnl=}, {unrealized_pnl=}")
            # <------------------- PUT DEBUG POINT HERE

        # Open positions at bar(s): 1
        if is_flat and self.bars_processed in {1}:
            order = self.order_factory.market(
                instrument_id=self.config.instrument_id,
                order_side=OrderSide.BUY,
                quantity=Quantity.from_str("1"),
                time_in_force=TimeInForce.GTC,
            )
            self.submit_order(order)
            self.order_placed = True
            self.log.info(f"Market order placed at {bar.close}")

        # Close positions at bar(s): 7
        if (not is_flat) and self.bars_processed in {7}:
            order = self.order_factory.market(
                instrument_id=self.config.instrument_id,
                order_side=OrderSide.SELL,
                quantity=Quantity.from_str("1"),
                time_in_force=TimeInForce.GTC,
            )
            self.submit_order(order)

    def on_stop(self) -> None:
        pass


if __name__ == "__main__":

    engine = BacktestEngine(
        config=BacktestEngineConfig(
            trader_id="TESTER-001",
            logging=LoggingConfig(log_level="debug"),
        ),
    )

    # Venue
    venue = Venue("SIM")
    engine.add_venue(
        venue=venue,
        oms_type=OmsType.NETTING,
        account_type=AccountType.MARGIN,
        base_currency=USD,
        fee_model=PerContractFeeModel(Money(2.50, USD)),
        starting_balances=[Money(1_000_000, USD)],
    )

    # Instrument
    instrument = create_6E_instrument(venue)
    engine.add_instrument(instrument)

    # Add data = just 5 bars with same OHLC prices
    bar_type = BarType(
        instrument_id=instrument.id,
        bar_spec=BarSpecification(
            step=1,
            aggregation=BarAggregation.MINUTE,
            price_type=PriceType.LAST,
        ),
    )

    timestamp_base = dt_to_unix_nanos(datetime(2024, 1, 1, tzinfo=UTC))
    bars = []
    for i in range(12):
        bar = Bar(
            bar_type=bar_type,
            open=instrument.make_price(1.10000 + i * 0.0001),
            high=instrument.make_price(1.20000 + i * 0.0001),
            low=instrument.make_price(1.10000 + i * 0.0001),
            close=instrument.make_price(1.10000 + i * 0.0001),
            volume=Quantity.from_str("100"),
            ts_event=timestamp_base + (i * 60_000_000_000),  # +1 minute
            ts_init=timestamp_base + (i * 60_000_000_000),
        )
        bars.append(bar)
    # Add all created bars
    engine.add_data(bars)

    # Create strategy
    config = MinimalStrategyConfig(
        instrument_id=instrument.id,
        bar_type=bar_type,
    )
    strategy = MinimalStrategy(config=config)
    engine.add_strategy(strategy)

    # Run backtest
    engine.run()

    # Results
    print(engine.trader.generate_order_fills_report())
    print(engine.trader.generate_positions_report())

    account_report = engine.trader.generate_account_report(venue)
    print(account_report)

    # Cleanup
    engine.dispose()

</document_content>
</document>
<document index="1833">
<source>examples/live/betfair/betfair.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
import traceback
from decimal import Decimal

from nautilus_trader.adapters.betfair import BETFAIR
from nautilus_trader.adapters.betfair import BetfairDataClientConfig
from nautilus_trader.adapters.betfair import BetfairExecClientConfig
from nautilus_trader.adapters.betfair import BetfairInstrumentProviderConfig
from nautilus_trader.adapters.betfair import BetfairLiveDataClientFactory
from nautilus_trader.adapters.betfair import BetfairLiveExecClientFactory
from nautilus_trader.adapters.betfair import get_cached_betfair_client
from nautilus_trader.adapters.betfair import get_cached_betfair_instrument_provider
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalance
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalanceConfig
from nautilus_trader.live.node import TradingNode


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


async def main(
    instrument_config: BetfairInstrumentProviderConfig,
    log_level: str = "INFO",
) -> TradingNode:
    # from nautilus_trader.common.component import init_logging
    # from nautilus_trader.common.component import log_level_from_str
    # Connect to Betfair client early to load instruments and account currency
    # Keep a reference to the log guard to prevent it from being immediately garbage collected
    # _ = init_logging(level_stdout=log_level_from_str(log_level), print_config=True)
    client = get_cached_betfair_client(
        username=None,  # Pass here or will source from the `BETFAIR_USERNAME` env var
        password=None,  # Pass here or will source from the `BETFAIR_PASSWORD` env var
        app_key=None,  # Pass here or will source from the `BETFAIR_APP_KEY` env var
    )
    await client.connect()

    # Find instruments for a particular market_id
    provider = get_cached_betfair_instrument_provider(
        client=client,
        config=instrument_config,
    )
    await provider.load_all_async()
    instruments = provider.list_all()
    print(f"Found instruments:\n{[inst.id for inst in instruments]}")

    # Determine account currency - used in execution client
    account = await client.get_account_details()

    # Configure trading node
    config = TradingNodeConfig(
        timeout_connection=30.0,
        timeout_disconnection=10.0,
        timeout_post_stop=5.0,
        logging=LoggingConfig(log_level=log_level, use_pyo3=True),
        # cache=CacheConfig(
        #     database=DatabaseConfig(),
        #     timestamps_as_iso8601=True,
        #     buffer_interval_ms=100,
        #     flush_on_start=False,
        # ),
        exec_engine=LiveExecEngineConfig(
            reconciliation=True,
            open_check_interval_secs=5.0,
            open_check_open_only=False,
            position_check_interval_secs=5.0,
            snapshot_orders=True,
            snapshot_positions=True,
            snapshot_positions_interval_secs=5.0,
        ),
        data_clients={
            BETFAIR: BetfairDataClientConfig(
                account_currency=account.currency_code,
                instrument_config=instrument_config,
                # username=None, # 'BETFAIR_USERNAME' env var
                # password=None, # 'BETFAIR_PASSWORD' env var
                # app_key=None, # 'BETFAIR_APP_KEY' env var
                # certs_dir=None, # 'BETFAIR_CERTS_DIR' env var
                stream_conflate_ms=0,  # Ensures no stream conflation
            ),
        },
        exec_clients={
            BETFAIR: BetfairExecClientConfig(
                account_currency=account.currency_code,
                instrument_config=instrument_config,
                # username=None, # 'BETFAIR_USERNAME' env var
                # password=None, # 'BETFAIR_PASSWORD' env var
                # app_key=None, # 'BETFAIR_APP_KEY' env var
                # certs_dir=None, # 'BETFAIR_CERTS_DIR' env var
                # calculate_account_state=False,
                # request_account_state_secs=0,
                reconcile_market_ids_only=True,
            ),
        },
    )
    strategies = [
        OrderBookImbalance(
            config=OrderBookImbalanceConfig(
                instrument_id=instrument.id,
                max_trade_size=Decimal(10),
                trigger_min_size=2,
                order_id_tag=instrument.selection_id,
                dry_run=True,  # Change to False to submit new orders
            ),
        )
        for instrument in instruments
    ]

    # Set up TradingNode
    node = TradingNode(config=config)
    node.trader.add_strategies(strategies)

    # Register your client factories with the node (can take user-defined factories)
    node.add_data_client_factory(BETFAIR, BetfairLiveDataClientFactory)
    node.add_exec_client_factory(BETFAIR, BetfairLiveExecClientFactory)
    node.build()

    try:
        await node.run_async()
    except Exception as e:
        print(e)
        print(traceback.format_exc())

    return node


if __name__ == "__main__":
    # Update the market ID with something coming up in `Next Races` from
    # https://www.betfair.com.au/exchange/plus/
    # The market ID will appear in the browser query string.
    config = BetfairInstrumentProviderConfig(
        account_currency="AUD",
        market_ids=["1.250955700"],
    )
    node = asyncio.run(main(instrument_config=config, log_level="INFO"))
    node.dispose()

</document_content>
</document>
<document index="1834">
<source>examples/live/binance/binance_futures_testnet_ema_cross.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.binance import BINANCE
from nautilus_trader.adapters.binance import BinanceAccountType
from nautilus_trader.adapters.binance import BinanceDataClientConfig
from nautilus_trader.adapters.binance import BinanceExecClientConfig
from nautilus_trader.adapters.binance import BinanceLiveDataClientFactory
from nautilus_trader.adapters.binance import BinanceLiveExecClientFactory
from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.ema_cross import EMACross
from nautilus_trader.examples.strategies.ema_cross import EMACrossConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Strategy config params
symbol = "ETHUSDT-PERP"
instrument_id = InstrumentId.from_str(f"{symbol}.{BINANCE}")
order_qty = Decimal("0.02")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO"),
    exec_engine=LiveExecEngineConfig(
        # debug=True,
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(timeout=2),
        timestamps_as_iso8601=True,
        flush_on_start=False,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(timeout=2),
    #     timestamps_as_iso8601=True,
    #     use_instance_id=False,
    #     # types_filter=[QuoteTick],
    #     stream_per_topic=False,
    #     external_streams=["bybit"],
    #     autotrim_mins=30,
    # ),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
            use_position_ids=False,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = EMACrossConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    bar_type=BarType.from_str(f"{instrument_id}-1-MINUTE-LAST-EXTERNAL"),
    fast_ema_period=10,
    slow_ema_period=20,
    trade_size=order_qty,
    order_id_tag="001",
    oms_type="HEDGING",
    subscribe_trade_ticks=True,
    subscribe_quote_ticks=True,
)

# Instantiate your strategy
strategy = EMACross(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1835">
<source>examples/live/binance/binance_futures_testnet_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.binance import BINANCE
from nautilus_trader.adapters.binance import BinanceAccountType
from nautilus_trader.adapters.binance import BinanceDataClientConfig
from nautilus_trader.adapters.binance import BinanceExecClientConfig
from nautilus_trader.adapters.binance import BinanceInstrumentProviderConfig
from nautilus_trader.adapters.binance import BinanceLiveDataClientFactory
from nautilus_trader.adapters.binance import BinanceLiveExecClientFactory
from nautilus_trader.config import CacheConfig
from nautilus_trader.config import LiveDataEngineConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import ClientId
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Strategy config params
symbol = "ETHUSDT-PERP"
instrument_id = InstrumentId.from_str(f"{symbol}.{BINANCE}")
order_qty = Decimal("0.02")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        # log_file_format="json",
        log_colors=True,
        use_pyo3=True,
    ),
    data_engine=LiveDataEngineConfig(
        external_clients=[ClientId(BINANCE)],
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        purge_closed_orders_interval_mins=1,  # Example of purging closed orders for HFT
        purge_closed_orders_buffer_mins=0,  # Purged orders closed for at least an hour
        purge_closed_positions_interval_mins=1,  # Example of purging closed positions for HFT
        purge_closed_positions_buffer_mins=0,  # Purge positions closed for at least an hour
        purge_account_events_interval_mins=1,  # Example of purging account events for HFT
        purge_account_events_lookback_mins=0,  # Purge account events occurring more than an hour ago
        purge_from_database=True,  # Set True with caution
        graceful_shutdown_on_exception=True,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(),
        timestamps_as_iso8601=True,
        flush_on_start=False,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(timeout=2),
    #     timestamps_as_iso8601=True,
    #     use_instance_id=False,
    #     # types_filter=[QuoteTick],
    #     stream_per_topic=False,
    #     external_streams=["bybit"],
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    # streaming=StreamingConfig(catalog_path="catalog"),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=BinanceInstrumentProviderConfig(
                load_ids=frozenset([instrument_id]),
                query_commission_rates=True,
            ),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=BinanceInstrumentProviderConfig(
                load_ids=frozenset([instrument_id]),
                query_commission_rates=True,
            ),
            max_retries=3,
            log_rejected_due_post_only_as_warning=False,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    # subscribe_book=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    order_qty=order_qty,
    open_position_on_start_qty=order_qty,
    # order_params={"price_match": "QUEUE_5"},
    # enable_limit_buys=False,
    # enable_limit_sells=False,
    # tob_offset_ticks=0,
    enable_stop_buys=True,
    enable_stop_sells=True,
    # modify_orders_to_maintain_tob_offset=True,
    # use_batch_cancel_on_stop=True,
    # use_individual_cancels_on_stop=True,
    use_post_only=True,
    # close_positions_on_stop=False,
    # log_rejected_due_post_only_as_warning=False,
    # test_reject_post_only=True,
    log_data=False,
)

# Instantiate your strategy
strategy = ExecTester(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1836">
<source>examples/live/binance/binance_spot_and_futures_market_maker.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.binance import BinanceAccountType
from nautilus_trader.adapters.binance import BinanceDataClientConfig
from nautilus_trader.adapters.binance import BinanceExecClientConfig
from nautilus_trader.adapters.binance import BinanceLiveDataClientFactory
from nautilus_trader.adapters.binance import BinanceLiveExecClientFactory
from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMaker
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMakerConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import ClientId
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.venues import Venue


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="DEBUG",
        # log_level_file="DEBUG",
        # log_file_format="json",
        use_pyo3=True,
    ),
    # data_engine=LiveDataEngineConfig(debug=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(),
        timestamps_as_iso8601=True,
        buffer_interval_ms=100,
        flush_on_start=False,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     types_filter=[QuoteTick],
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    # streaming=StreamingConfig(catalog_path="catalog"),
    data_clients={
        "BINANCE_SPOT": BinanceDataClientConfig(
            venue=Venue("BINANCE_SPOT"),
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
        "BINANCE_FUTURES": BinanceDataClientConfig(
            venue=Venue("BINANCE_FUTURES"),
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        "BINANCE_SPOT": BinanceExecClientConfig(
            venue=Venue("BINANCE_SPOT"),
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
        "BINANCE_FUTURES": BinanceExecClientConfig(
            venue=Venue("BINANCE_FUTURES"),
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategies
spot_symbol = "ETHUSDT"
strat_config_spot = VolatilityMarketMakerConfig(
    instrument_id=InstrumentId.from_str(f"{spot_symbol}.BINANCE_SPOT"),
    external_order_claims=[InstrumentId.from_str(f"{spot_symbol}.BINANCE_SPOT")],
    bar_type=BarType.from_str(f"{spot_symbol}.BINANCE_SPOT-1-MINUTE-LAST-INTERNAL"),
    atr_period=20,
    atr_multiple=6.0,
    trade_size=Decimal("0.010"),
    client_id=ClientId("BINANCE_SPOT"),
)

futures_symbol = "ETHUSDT-PERP"
strat_config_futures = VolatilityMarketMakerConfig(
    instrument_id=InstrumentId.from_str(f"{futures_symbol}.BINANCE_FUTURES"),
    external_order_claims=[InstrumentId.from_str(f"{futures_symbol}.BINANCE_FUTURES")],
    bar_type=BarType.from_str(f"{futures_symbol}.BINANCE_FUTURES-1-MINUTE-LAST-EXTERNAL"),
    atr_period=20,
    atr_multiple=6.0,
    trade_size=Decimal("0.010"),
    client_id=ClientId("BINANCE_FUTURES"),
)

# Instantiate your strategies
strategy_spot = VolatilityMarketMaker(config=strat_config_spot)
strategy_futures = VolatilityMarketMaker(config=strat_config_futures)

# Add your strategies and modules
node.trader.add_strategies([strategy_spot, strategy_futures])

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory("BINANCE_SPOT", BinanceLiveDataClientFactory)
node.add_exec_client_factory("BINANCE_SPOT", BinanceLiveExecClientFactory)
node.add_data_client_factory("BINANCE_FUTURES", BinanceLiveDataClientFactory)
node.add_exec_client_factory("BINANCE_FUTURES", BinanceLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1837">
<source>examples/live/binance/binance_spot_ema_cross.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.binance import BINANCE
from nautilus_trader.adapters.binance import BinanceAccountType
from nautilus_trader.adapters.binance import BinanceDataClientConfig
from nautilus_trader.adapters.binance import BinanceExecClientConfig
from nautilus_trader.adapters.binance import BinanceLiveDataClientFactory
from nautilus_trader.adapters.binance import BinanceLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.ema_cross import EMACross
from nautilus_trader.examples.strategies.ema_cross import EMACrossConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO"),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    # cache=CacheConfig(
    #     database=DatabaseConfig(),
    #     buffer_interval_ms=100,
    # ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     timestamps_as_iso8601=True,
    #     # types_filter=[QuoteTick],
    #     autotrim_mins=1,
    #     heartbeat_interval_secs=1,
    # ),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = EMACrossConfig(
    instrument_id=InstrumentId.from_str("ETHUSDT.BINANCE"),
    external_order_claims=[InstrumentId.from_str("ETHUSDT.BINANCE")],
    bar_type=BarType.from_str("ETHUSDT.BINANCE-1-MINUTE-LAST-EXTERNAL"),
    fast_ema_period=10,
    slow_ema_period=20,
    trade_size=Decimal("0.010"),
    order_id_tag="001",
)
# Instantiate your strategy
strategy = EMACross(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1838">
<source>examples/live/binance/binance_spot_ema_cross_bracket_algo.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.binance import BINANCE
from nautilus_trader.adapters.binance import BinanceAccountType
from nautilus_trader.adapters.binance import BinanceDataClientConfig
from nautilus_trader.adapters.binance import BinanceExecClientConfig
from nautilus_trader.adapters.binance import BinanceLiveDataClientFactory
from nautilus_trader.adapters.binance import BinanceLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.algorithms.twap import TWAPExecAlgorithm
from nautilus_trader.examples.strategies.ema_cross_bracket_algo import EMACrossBracketAlgo
from nautilus_trader.examples.strategies.ema_cross_bracket_algo import EMACrossBracketAlgoConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import ExecAlgorithmId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        log_level_file="INFO",
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,
        reconciliation_lookback_mins=1440,
    ),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
symbol = "ETHUSDT"
strat_config = EMACrossBracketAlgoConfig(
    order_id_tag="001",
    instrument_id=f"{symbol}.BINANCE",
    external_order_claims=[f"{symbol}.BINANCE"],
    bar_type=f"{symbol}.BINANCE-1-MINUTE-LAST-EXTERNAL",
    fast_ema_period=10,
    slow_ema_period=20,
    bracket_distance_atr=1.0,
    trade_size=Decimal("0.05"),
    emulation_trigger="BID_ASK",
    entry_exec_algorithm_id=ExecAlgorithmId("TWAP"),
    entry_exec_algorithm_params={
        "horizon_secs": 10.0,
        "interval_secs": 2.5,
    },
)
# Instantiate your strategy and execution algorithm
strategy = EMACrossBracketAlgo(config=strat_config)
exec_algorithm = TWAPExecAlgorithm()

# Add your strategies and modules
node.trader.add_strategy(strategy)
node.trader.add_exec_algorithm(exec_algorithm)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1839">
<source>examples/live/binance/binance_spot_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.binance import BINANCE
from nautilus_trader.adapters.binance import BinanceAccountType
from nautilus_trader.adapters.binance import BinanceDataClientConfig
from nautilus_trader.adapters.binance import BinanceExecClientConfig
from nautilus_trader.adapters.binance import BinanceLiveDataClientFactory
from nautilus_trader.adapters.binance import BinanceLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Strategy config params
symbol = "ETHUSDT"
instrument_id = InstrumentId.from_str(f"{symbol}.{BINANCE}")
order_qty = Decimal("0.01")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        # log_file_format="json",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        open_check_interval_secs=5.0,
        # manage_own_order_books=True,
    ),
    # cache=CacheConfig(
    #     # database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     flush_on_start=False,
    # ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     types_filter=[QuoteTick],
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    # streaming=StreamingConfig(catalog_path="catalog"),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            # key_type=BinanceKeyType.ED25519,
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            # key_type=BinanceKeyType.ED25519,
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
config_strat = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    order_qty=order_qty,
    # enable_stop_buys=True,
    # enable_stop_sells=True,
    # open_position_on_start_qty=order_qty,
    # tob_offset_ticks=0,
    # log_data=False,
)

# Instantiate your strategy
strategy = ExecTester(config=config_strat)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1840">
<source>examples/live/binance/binance_spot_testnet_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.binance import BINANCE
from nautilus_trader.adapters.binance import BinanceAccountType
from nautilus_trader.adapters.binance import BinanceDataClientConfig
from nautilus_trader.adapters.binance import BinanceExecClientConfig
from nautilus_trader.adapters.binance import BinanceLiveDataClientFactory
from nautilus_trader.adapters.binance import BinanceLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Strategy config params
symbol = "ETHUSDT"
instrument_id = InstrumentId.from_str(f"{symbol}.{BINANCE}")
order_qty = Decimal("0.01")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO"),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
    ),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
config_strat = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    order_qty=order_qty,
    open_position_on_start_qty=order_qty,
    use_post_only=True,
    # tob_offset_ticks=0,
    # log_data=False,
)

# Instantiate your strategy
strategy = ExecTester(config=config_strat)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1841">
<source>examples/live/bitmex/bitmex_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.bitmex import BITMEX
from nautilus_trader.adapters.bitmex import BitmexDataClientConfig
from nautilus_trader.adapters.bitmex import BitmexLiveDataClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Example symbols for different BitMEX products
# Perpetual swap: XBTUSD (Bitcoin perpetual)
# Futures: XBTH25 (Bitcoin futures expiring March 2025)
# Alt perpetuals: ETHUSD, SOLUSD, etc.

testnet = False  # If client uses the testnet API
symbol = "XBTUSD"  # Bitcoin perpetual swap
# symbol = "SOLUSDT"  # Solana spot
# symbol = "ETHUSDT"  # Ethereum spot
# symbol = ".BXBT"  # Bitcoin index

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,  # Not applicable
    ),
    data_clients={
        BITMEX: BitmexDataClientConfig(
            api_key=None,  # 'BITMEX_API_KEY' env var
            api_secret=None,  # 'BITMEX_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            testnet=testnet,  # If client uses the testnet API
        ),
    },
    timeout_connection=10.0,
    timeout_reconciliation=10.0,
    timeout_disconnection=2.0,
    timeout_post_stop=1.0,
)

# Configure the data tester actor
config_tester = DataTesterConfig(
    instrument_ids=[InstrumentId.from_str(f"{symbol}.{BITMEX}")],
    bar_types=[BarType.from_str(f"{symbol}.{BITMEX}-1-MINUTE-LAST-EXTERNAL")],
    subscribe_instrument=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    subscribe_mark_prices=True,
    subscribe_index_prices=True,
    subscribe_funding_rates=True,
    subscribe_bars=True,
    # subscribe_book_deltas=True,
    # subscribe_book_depth=True,  # Not yet supported
    # subscribe_book_at_interval=True,
    # book_type=BookType.L2_MBP,
    # book_depth=25,
    # book_interval_ms=10,
    # request_trades=True,
    # request_bars=True,
)

# Setup and run the trading node
node = TradingNode(config=config_node)

# Add the strategy to the node
node.trader.add_actor(DataTester(config=config_tester))

# Register the data client factory
node.add_data_client_factory(BITMEX, BitmexLiveDataClientFactory)
node.build()

# Run the node
try:
    node.run()
except KeyboardInterrupt:
    node.stop()
finally:
    node.dispose()

</document_content>
</document>
<document index="1842">
<source>examples/live/bitmex/bitmex_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.bitmex import BITMEX
from nautilus_trader.adapters.bitmex import BitmexDataClientConfig
from nautilus_trader.adapters.bitmex import BitmexExecClientConfig
from nautilus_trader.adapters.bitmex import BitmexLiveDataClientFactory
from nautilus_trader.adapters.bitmex import BitmexLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Example symbols for different BitMEX products
# Perpetual swap: XBTUSD (Bitcoin perpetual)
# Futures: XBTZ25 (Bitcoin futures expiring December 2025)
# Alt perpetuals: ETHUSD, SOLUSD, etc.

testnet = True  # If clients use the testnet API
# symbol = "XBTUSD"  # Bitcoin perpetual swap
symbol = "ETHUSD"  # Ether perpetual swap
order_qty = Decimal(1)  # Contract size in USD

# symbol = "SOLUSDT"  # Solana quoted in USDT spot
# order_qty = Decimal("0.1")  # Fractional size

instrument_id = InstrumentId.from_str(f"{symbol}.{BITMEX}")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_instrument_ids=[instrument_id],  # Only reconcile this instrument
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        # position_check_interval_secs=60.0,
        # manage_own_order_books=True,
        # own_books_audit_interval_secs=1.0,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    data_clients={
        BITMEX: BitmexDataClientConfig(
            api_key=None,  # 'BITMEX_API_KEY' env var
            api_secret=None,  # 'BITMEX_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            testnet=testnet,  # If client uses the testnet API
        ),
    },
    exec_clients={
        BITMEX: BitmexExecClientConfig(
            api_key=None,  # 'BITMEX_API_KEY' env var
            api_secret=None,  # 'BITMEX_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            testnet=testnet,  # If client uses the testnet API
            submitter_pool_size=1,
            canceller_pool_size=3,
        ),
    },
    timeout_connection=10.0,
    timeout_reconciliation=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
    timeout_shutdown=2.0,
)

# Configure the execution tester strategy
config_tester = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    order_qty=order_qty,
    # order_params={"submit_tries": 3},
    # order_display_qty=Decimal(0),  # Must be zero (hidden) or a positive multiple of lot size 100
    # subscribe_book=True,
    enable_limit_buys=True,
    enable_limit_sells=True,
    use_post_only=True,
    tob_offset_ticks=0,
    # modify_orders_to_maintain_tob_offset=True,
    open_position_on_start_qty=order_qty,
    open_position_time_in_force=TimeInForce.IOC,  # Market orders must be IOC
    close_positions_time_in_force=TimeInForce.IOC,  # Market orders must be IOC
    # enable_stop_buys=True,
    # enable_stop_sells=True,
    # stop_order_type=OrderType.STOP_MARKET,
    # stop_trigger_type=TriggerType.MARK_PRICE,
    # enable_brackets=True,
    # test_reject_post_only=True,
    # cancel_orders_on_stop=False,
    # close_positions_on_stop=False,
    # use_batch_cancel_on_stop=True,
    # use_individual_cancels_on_stop=True,
    log_data=False,
    # dry_run=True,
)
tester = ExecTester(config=config_tester)

# Setup and run the trading node
node = TradingNode(config=config_node)

# Add the strategy to the node
node.trader.add_strategy(tester)

# Register the client factories
node.add_data_client_factory(BITMEX, BitmexLiveDataClientFactory)
node.add_exec_client_factory(BITMEX, BitmexLiveExecClientFactory)
node.build()

# Run the node
try:
    node.run()
except KeyboardInterrupt:
    node.stop()
finally:
    node.dispose()

</document_content>
</document>
<document index="1844">
<source>examples/live/bybit/bybit_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.bybit import BYBIT
from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory
from nautilus_trader.adapters.bybit import BybitLiveExecClientFactory
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# SPOT/LINEAR
product_type = BybitProductType.LINEAR
symbol = f"ETHUSDT-{product_type.value.upper()}"
instrument_id = InstrumentId.from_str(f"{symbol}.{BYBIT}")

# INVERSE
# product_type = BybitProductType.INVERSE
# symbol = f"XRPUSD-{product_type.value.upper()}"  # Use for inverse
# trade_size = Decimal("100")  # Use for inverse

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        # log_file_max_size=1_000_000_000,
        use_pyo3=True,
    ),
    data_clients={
        BYBIT: BybitDataClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),  # Will load all instruments
            demo=False,  # If client uses the demo API
            testnet=False,  # If client uses the testnet API
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=1.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
config_tester = DataTesterConfig(
    instrument_ids=[instrument_id],
    bar_types=[BarType.from_str(f"{instrument_id}-1-MINUTE-LAST-EXTERNAL")],
    subscribe_instrument=True,
    # subscribe_book_at_interval=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    subscribe_funding_rates=True,
    subscribe_bars=True,
    # book_interval_ms=1,
    # request_bars=True,
)

# Instantiate your actor
tester = DataTester(config=config_tester)

# Add your actors and modules
node.trader.add_actor(tester)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BYBIT, BybitLiveDataClientFactory)
node.add_exec_client_factory(BYBIT, BybitLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1845">
<source>examples/live/bybit/bybit_ema_cross.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.bybit import BYBIT
from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitExecClientConfig
from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory
from nautilus_trader.adapters.bybit import BybitLiveExecClientFactory
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.ema_cross import EMACross
from nautilus_trader.examples.strategies.ema_cross import EMACrossConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# SPOT/LINEAR
product_type = BybitProductType.LINEAR
symbol = f"ETHUSDT-{product_type.value.upper()}"
trade_size = Decimal("0.010")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    # cache=CacheConfig(
    #     database=DatabaseConfig(),
    #     buffer_interval_ms=100,
    # ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     timestamps_as_iso8601=True,
    #     # types_filter=[QuoteTick),
    #     autotrim_mins=1,
    #     heartbeat_interval_secs=1,
    # ),
    data_clients={
        BYBIT: BybitDataClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),  # Will load all instruments
            testnet=False,  # If client uses the testnet
        ),
    },
    exec_clients={
        BYBIT: BybitExecClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws_private=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),
            testnet=False,  # If client uses the testnet
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = EMACrossConfig(
    instrument_id=InstrumentId.from_str(f"{symbol}.BYBIT"),
    external_order_claims=[InstrumentId.from_str(f"{symbol}.BYBIT")],
    bar_type=BarType.from_str(f"{symbol}.BYBIT-1-MINUTE-LAST-EXTERNAL"),
    fast_ema_period=10,
    slow_ema_period=20,
    trade_size=Decimal("0.010"),
    order_id_tag="001",
)
# Instantiate your strategy
strategy = EMACross(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BYBIT, BybitLiveDataClientFactory)
node.add_exec_client_factory(BYBIT, BybitLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1846">
<source>examples/live/bybit/bybit_ema_cross_bracket_algo.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.bybit import BYBIT
from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitExecClientConfig
from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory
from nautilus_trader.adapters.bybit import BybitLiveExecClientFactory
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LiveRiskEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.algorithms.twap import TWAPExecAlgorithm
from nautilus_trader.examples.strategies.ema_cross_bracket_algo import EMACrossBracketAlgo
from nautilus_trader.examples.strategies.ema_cross_bracket_algo import EMACrossBracketAlgoConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# SPOT/LINEAR
product_type = BybitProductType.LINEAR
symbol = f"ETHUSDT-{product_type.value.upper()}"
trade_size = Decimal("0.010")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    risk_engine=LiveRiskEngineConfig(debug=True),
    # cache=CacheConfig(
    #     database=DatabaseConfig(),
    #     buffer_interval_ms=100,
    # ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     timestamps_as_iso8601=True,
    #     # types_filter=[QuoteTick),
    #     autotrim_mins=1,
    #     heartbeat_interval_secs=1,
    # ),
    data_clients={
        BYBIT: BybitDataClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),  # Will load all instruments
            testnet=False,  # If client uses the testnet
        ),
    },
    exec_clients={
        BYBIT: BybitExecClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws_private=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),
            testnet=False,  # If client uses the testnet
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=3.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = EMACrossBracketAlgoConfig(
    order_id_tag="001",
    instrument_id=InstrumentId.from_str(f"{symbol}.BYBIT"),
    external_order_claims=[InstrumentId.from_str(f"{symbol}.BYBIT")],
    bar_type=BarType.from_str(f"{symbol}.BYBIT-1-MINUTE-LAST-EXTERNAL"),
    fast_ema_period=10,
    slow_ema_period=20,
    bracket_distance_atr=1.0,
    trade_size=trade_size,
)

# Instantiate your strategy and execution algorithm
strategy = EMACrossBracketAlgo(config=strat_config)
exec_algorithm = TWAPExecAlgorithm()

# Add your strategy and execution algorithm and modules
node.trader.add_strategy(strategy)
node.trader.add_exec_algorithm(exec_algorithm)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BYBIT, BybitLiveDataClientFactory)
node.add_exec_client_factory(BYBIT, BybitLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1847">
<source>examples/live/bybit/bybit_ema_cross_stop_entry.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.bybit import BYBIT
from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitExecClientConfig
from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory
from nautilus_trader.adapters.bybit import BybitLiveExecClientFactory
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.ema_cross_stop_entry import EMACrossStopEntry
from nautilus_trader.examples.strategies.ema_cross_stop_entry import EMACrossStopEntryConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# SPOT/LINEAR
product_type = BybitProductType.SPOT
symbol = f"ETHUSDT-{product_type.value.upper()}"
trade_size = Decimal("0.010")

# INVERSE
# product_type = BybitProductType.INVERSE
# symbol = f"XRPUSD-{product_type.value.upper()}"  # Use for inverse
# trade_size = Decimal("100")  # Use for inverse

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
    ),
    data_clients={
        BYBIT: BybitDataClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),
            testnet=False,  # If client uses the testnet
        ),
    },
    exec_clients={
        BYBIT: BybitExecClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws_private=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),
            testnet=False,  # If client uses the testnet
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = EMACrossStopEntryConfig(
    instrument_id=InstrumentId.from_str(f"{symbol}.BYBIT"),
    external_order_claims=[InstrumentId.from_str(f"{symbol}.BYBIT")],
    bar_type=BarType.from_str(f"{symbol}.BYBIT-1-MINUTE-LAST-EXTERNAL"),
    fast_ema_period=10,
    slow_ema_period=20,
    atr_period=20,
    trailing_atr_multiple=3.0,
    trailing_offset=Decimal("0.010"),
    trailing_offset_type="BASIS_POINTS",
    trigger_type="LAST_PRICE",
    trade_size=trade_size,
)
# Instantiate your strategy
strategy = EMACrossStopEntry(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BYBIT, BybitLiveDataClientFactory)
node.add_exec_client_factory(BYBIT, BybitLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1848">
<source>examples/live/bybit/bybit_ema_cross_with_trailing_stop.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.bybit import BYBIT
from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitExecClientConfig
from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory
from nautilus_trader.adapters.bybit import BybitLiveExecClientFactory
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.ema_cross_trailing_stop import EMACrossTrailingStop
from nautilus_trader.examples.strategies.ema_cross_trailing_stop import EMACrossTrailingStopConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# SPOT/LINEAR
product_type = BybitProductType.LINEAR
symbol = f"ETHUSDT-{product_type.value.upper()}"
trade_size = Decimal("0.010")

# INVERSE
# product_type = BybitProductType.INVERSE
# symbol = f"XRPUSD-{product_type.value.upper()}"  # Use for inverse
# trade_size = Decimal("100")  # Use for inverse

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
    ),
    data_clients={
        BYBIT: BybitDataClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),
            testnet=False,  # If client uses the testnet
        ),
    },
    exec_clients={
        BYBIT: BybitExecClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws_private=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            product_types=(product_type,),
            testnet=False,  # If client uses the testnet
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = EMACrossTrailingStopConfig(
    instrument_id=InstrumentId.from_str(f"{symbol}.BYBIT"),
    external_order_claims=[InstrumentId.from_str(f"{symbol}.BYBIT")],
    bar_type=BarType.from_str(f"{symbol}.BYBIT-1-MINUTE-LAST-EXTERNAL"),
    fast_ema_period=10,
    slow_ema_period=20,
    atr_period=20,
    trailing_atr_multiple=3.0,
    trailing_offset_type="BASIS_POINTS",
    trigger_type="LAST_PRICE",
    trade_size=trade_size,
)
# Instantiate your strategy
strategy = EMACrossTrailingStop(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BYBIT, BybitLiveDataClientFactory)
node.add_exec_client_factory(BYBIT, BybitLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1849">
<source>examples/live/bybit/bybit_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.bybit import BYBIT
from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitExecClientConfig
from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory
from nautilus_trader.adapters.bybit import BybitLiveExecClientFactory
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.config import LiveRiskEngineConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.portfolio.config import PortfolioConfig
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# SPOT/LINEAR
product_type = BybitProductType.LINEAR

if product_type == BybitProductType.SPOT:
    symbol = f"ETHUSDT-{product_type.value.upper()}"
    order_qty = Decimal("0.01")
    order_params = {"is_leverage": True}
    enable_limit_sells = False
    use_spot_position_reports = True
elif product_type == BybitProductType.LINEAR:
    symbol = f"ETHUSDT-{product_type.value.upper()}"
    order_qty = Decimal("0.01")
    order_params = {}
    enable_limit_sells = True
    use_spot_position_reports = False
elif product_type == BybitProductType.INVERSE:
    symbol = f"XRPUSD-{product_type.value.upper()}"
    order_qty = Decimal(50)
    enable_limit_sells = True
    use_spot_position_reports = False
else:
    raise NotImplementedError

instrument_id = InstrumentId.from_str(f"{symbol}.{BYBIT}")
# instrument_id2 = InstrumentId.from_str(f"ETHUSDT-LINEAR.{BYBIT}")

# Only reconcile these instruments
reconciliation_instrument_ids = [instrument_id]
# reconciliation_instrument_ids = [instrument_id, instrument_id2]

# product_types: tuple[BybitProductType, ...] = (product_type,)
# product_types: tuple[BybitProductType, ...] = (product_type, BybitProductType.LINEAR)
product_types: tuple[BybitProductType, ...] = (
    BybitProductType.SPOT,
    BybitProductType.LINEAR,
    BybitProductType.INVERSE,
    BybitProductType.OPTION,
)

# INVERSE
# product_type = BybitProductType.INVERSE
# symbol = f"XRPUSD-{product_type.value.upper()}"  # Use for inverse
# trade_size = Decimal("100")  # Use for inverse

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        # log_file_max_size=1_000_000_000,
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        # reconciliation_lookback_mins=2880,
        reconciliation_instrument_ids=reconciliation_instrument_ids,
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        position_check_interval_secs=5.0,
        # filtered_client_order_ids=[ClientOrderId("1757985206157")],  # For demonstration
        # own_books_audit_interval_secs=2.0,
        # manage_own_order_books=True,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        # purge_closed_orders_interval_mins=1,  # Example of purging closed orders for HFT
        # purge_closed_orders_buffer_mins=0,  # Purged orders closed for at least an hour
        # purge_closed_positions_interval_mins=1,  # Example of purging closed positions for HFT
        # purge_closed_positions_buffer_mins=0,  # Purge positions closed for at least an hour
        # purge_account_events_interval_mins=1,  # Example of purging account events for HFT
        # purge_account_events_lookback_mins=0,  # Purge account events occurring more than an hour ago
        # purge_from_database=True,  # Set True with caution
        graceful_shutdown_on_exception=True,
    ),
    risk_engine=LiveRiskEngineConfig(bypass=True),
    # cache=CacheConfig(
    #     database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     persist_account_events=False,  # Useful for HFT ops where this can quickly accumulate
    #     buffer_interval_ms=100,
    # ),
    portfolio=PortfolioConfig(min_account_state_logging_interval_ms=1_000),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="bybit",
    #     use_trader_prefix=False,
    #     use_trader_id=False,
    #     use_instance_id=False,
    #     stream_per_topic=False,
    #     types_filter=[QuoteTick),
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    data_clients={
        BYBIT: BybitDataClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            # instrument_provider=InstrumentProviderConfig(load_all=True),
            instrument_provider=InstrumentProviderConfig(
                load_all=False,
                load_ids=frozenset(reconciliation_instrument_ids),
            ),
            product_types=product_types,
            demo=False,  # If client uses the demo API
            testnet=False,  # If client uses the testnet API
        ),
    },
    exec_clients={
        BYBIT: BybitExecClientConfig(
            api_key=None,  # 'BYBIT_API_KEY' env var
            api_secret=None,  # 'BYBIT_API_SECRET' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws_private=None,  # Override with custom endpoint
            # instrument_provider=InstrumentProviderConfig(load_all=True),
            instrument_provider=InstrumentProviderConfig(
                load_all=False,
                load_ids=frozenset(reconciliation_instrument_ids),
            ),
            product_types=product_types,
            use_spot_position_reports=use_spot_position_reports,
            demo=False,  # If client uses the demo API
            testnet=False,  # If client uses the testnet API
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
config_tester = ExecTesterConfig(
    instrument_id=InstrumentId.from_str(f"{symbol}.{BYBIT}"),
    external_order_claims=[InstrumentId.from_str(f"{symbol}.{BYBIT}")],
    subscribe_quotes=True,
    subscribe_trades=True,
    # subscribe_book=True,
    enable_limit_sells=enable_limit_sells,
    # enable_stop_buys=True,  # Test stop orders
    # enable_stop_sells=True,  # Test stop orders
    # enable_brackets=True,
    order_qty=order_qty,
    open_position_on_start_qty=order_qty,  # Positive quantity to open LONG position
    # tob_offset_ticks=0,
    use_post_only=True,
    # test_reject_post_only=True,
    reduce_only_on_stop=False,  # Not supported for Bybit SPOT
    # cancel_orders_on_stop=False,
    # close_positions_on_stop=False,
    # use_batch_cancel_on_stop=True,
    # use_individual_cancels_on_stop=True,
    log_data=False,
    log_rejected_due_post_only_as_warning=False,
)

# Instantiate your strategy
tester = ExecTester(config=config_tester)

# Add your strategies and modules
node.trader.add_strategy(tester)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BYBIT, BybitLiveDataClientFactory)
node.add_exec_client_factory(BYBIT, BybitLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1850">
<source>examples/live/bybit/bybit_options_data_collector.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import logging
import os
import time
import warnings
from datetime import datetime
from decimal import Decimal
from pathlib import Path

import pandas as pd

from nautilus_trader.adapters.bybit import BYBIT
from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import InstrumentClass
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading.config import StrategyConfig
from nautilus_trader.trading.strategy import Strategy


warnings.simplefilter(action="ignore", category=FutureWarning)


class BybitOptionsDataCollectorConfig(StrategyConfig, frozen=True):
    """
    Configuration for the Bybit Options Data Collector Strategy.
    """

    spot_instrument_id: InstrumentId  # Spot instrument ID (required)
    underlying_asset: str = "BTC"  # The underlying asset (e.g., "BTC")
    options_depth: int = 25  # Options support 25 or 100 levels
    spot_depth: int = 50  # Spot supports 1, 50, or 200 levels
    batch_size: int = 1000  # Number of records to batch before writing to parquet
    data_dir: str = "data"  # Directory to store parquet files
    log_interval: float = 60.0  # Log and save data every N seconds
    verbose_logging: bool = True  # Enable verbose logging for debugging
    save_logs: bool = True  # Save logs to file
    log_level: str = "INFO"  # Log level for file logging


class BybitOptionsDataCollector(Strategy):
    """
    A strategy that discovers all available options for a given underlying asset,
    subscribes to their data, and stores them in parquet files.
    """

    def __init__(self, config: BybitOptionsDataCollectorConfig) -> None:
        super().__init__(config)

        # Configuration
        self.underlying_asset = config.underlying_asset
        self.batch_size = config.batch_size
        self.data_dir = config.data_dir
        self.log_interval = config.log_interval

        # Create hierarchical data directory structure
        self.base_data_dir = os.path.join(self.data_dir, self.underlying_asset, "USDT")
        self.spot_data_dir = os.path.join(self.base_data_dir, "spot")
        self.options_data_dir = os.path.join(self.base_data_dir, "options")

        # Create directories
        os.makedirs(self.spot_data_dir, exist_ok=True)
        os.makedirs(self.options_data_dir, exist_ok=True)

        # Setup file logging if enabled
        self._setup_file_logging()

        # Data storage
        self.quote_ticks_data: dict[str, list[dict]] = {}
        self.order_book_deltas_data: dict[str, list[dict]] = {}

        # File paths for each instrument - will be created dynamically
        self.quote_ticks_files: dict[str, str] = {}
        self.order_book_deltas_files: dict[str, str] = {}

        # Order books for each instrument
        self.books: dict[str, OrderBook] = {}

        # Counters
        self.quote_count = 0
        self.delta_count = 0
        self.spot_quote_count = 0
        self.last_log_time = 0.0
        self.last_spot_price: Decimal | None = None

        # Connection monitoring
        self.last_data_time = time.time()
        self.connection_warnings = 0

        # Per-instrument counters for logging
        self.instrument_quote_counts: dict[str, int] = {}
        self.instrument_delta_counts: dict[str, int] = {}

        # Discovered options
        self.discovered_options: list[InstrumentId] = []

        # File logging attributes
        self.file_handler: logging.FileHandler | None = None
        self.log_filepath: str | None = None

        # Initialize data storage for spot instrument
        self._initialize_spot_data_storage()

    def _setup_file_logging(self) -> None:
        """
        Set up file logging to save logs alongside data.
        """
        # Skip custom file logging setup - use NautilusTrader's built-in logging
        if not self.config.save_logs:
            return

        # Create logs directory for reference
        logs_dir = os.path.join(self.base_data_dir, "logs")
        os.makedirs(logs_dir, exist_ok=True)

        # Log that file logging is handled by NautilusTrader kernel
        self.log.info(f"File logging directory: {logs_dir}")
        self.log.info("File logging is handled by NautilusTrader kernel configuration")

    def _initialize_spot_data_storage(self) -> None:
        """
        Initialize data storage for spot instrument.
        """
        # Initialize spot instrument
        spot_key = str(self.config.spot_instrument_id)
        self.quote_ticks_data[spot_key] = []
        self.order_book_deltas_data[spot_key] = []
        self.instrument_quote_counts[spot_key] = 0
        self.instrument_delta_counts[spot_key] = 0

        # Create file paths for spot instrument (in spot folder)
        spot_name = spot_key.replace(".", "_")
        self.quote_ticks_files[spot_key] = os.path.join(
            self.spot_data_dir,
            f"{spot_name}_quote.parquet",
        )
        self.order_book_deltas_files[spot_key] = os.path.join(
            self.spot_data_dir,
            f"{spot_name}_orderbook.parquet",
        )

        # Log file creation for spot
        self.log.info("Data will be saved to the following directory structure:")
        self.log.info(f"Base directory: {self.base_data_dir}")
        self.log.info(f"Spot quote ticks: {self.quote_ticks_files[spot_key]}")
        self.log.info(f"Spot order book deltas: {self.order_book_deltas_files[spot_key]}")

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.log.info("Starting Bybit Options Data Collector Strategy")

        # Discover all available options for the underlying asset
        self._discover_options()

        # Initialize data storage for discovered options
        self._initialize_options_data_storage()

        # Validate and get instruments
        if not self._validate_instruments():
            return

        # Initialize order books
        self._initialize_order_books()

        # Subscribe to data streams
        self._subscribe_to_data_streams()

    def _discover_options(self) -> None:
        """
        Discover all available options for the underlying asset.
        """
        self.log.info(f"Discovering all available {self.underlying_asset} options...")

        # Get and filter options from cache instead of client
        all_instruments = self.cache.instruments()
        options = [
            instrument
            for instrument in all_instruments
            if (
                str(instrument.symbol).startswith(self.underlying_asset)
                and instrument.instrument_class
                == InstrumentClass.OPTION  # Changed from InstrumentType.OPTION
            )
        ]

        # Group by expiry and subscribe
        expiry_groups: dict[str, list[Instrument]] = {}
        for option in options:
            # Convert expiration_ns to a readable date format for grouping
            from nautilus_trader.core.datetime import unix_nanos_to_dt

            expiry_dt = unix_nanos_to_dt(option.expiration_ns)
            expiry = expiry_dt.strftime("%d%b%y").upper()  # e.g., "02AUG25"

            if expiry not in expiry_groups:
                expiry_groups[expiry] = []
            expiry_groups[expiry].append(option)

        # Store discovered options for later use
        self.discovered_options = [option.id for option in options]

        self.log.info(f"Discovered {len(options)} options across {len(expiry_groups)} expiries")

    def _initialize_options_data_storage(self) -> None:
        """
        Initialize data storage for all discovered options.
        """
        for instrument_id in self.discovered_options:
            instrument_key = str(instrument_id)
            self.quote_ticks_data[instrument_key] = []
            self.order_book_deltas_data[instrument_key] = []
            self.instrument_quote_counts[instrument_key] = 0
            self.instrument_delta_counts[instrument_key] = 0

            # Create file paths for options instruments (in options folder)
            instrument_name = instrument_key.replace(".", "_")
            self.quote_ticks_files[instrument_key] = os.path.join(
                self.options_data_dir,
                f"{instrument_name}_quote.parquet",
            )
            self.order_book_deltas_files[instrument_key] = os.path.join(
                self.options_data_dir,
                f"{instrument_name}_orderbook.parquet",
            )

        # Log summary of options data files
        options_count = len(
            [k for k in self.quote_ticks_files if k != str(self.config.spot_instrument_id)],
        )
        self.log.info(f"Will create data files for {options_count} options instruments")

        # Show detailed file paths only if verbose logging is enabled
        if self.config.verbose_logging:
            self.log.info("Options data files:")
            for instrument_key in self.quote_ticks_files:
                if instrument_key != str(self.config.spot_instrument_id):
                    self.log.info(f"  Quote ticks: {self.quote_ticks_files[instrument_key]}")
                    self.log.info(
                        f"  Order book deltas: {self.order_book_deltas_files[instrument_key]}",
                    )

    def _validate_instruments(self) -> bool:
        """
        Validate that all instruments exist in cache.
        """
        # Validate spot instrument
        self.spot_instrument = self.cache.instrument(self.config.spot_instrument_id)
        if self.spot_instrument is None:
            self.log.error(f"Could not find spot instrument for {self.config.spot_instrument_id}")
            self.stop()
            return False

        self.log.info(f"Found spot instrument: {self.spot_instrument}")

        # Validate options instruments
        self.instruments = {}
        valid_options = []

        for instrument_id in self.discovered_options:
            instrument = self.cache.instrument(instrument_id)
            if instrument is None:
                self.log.warning(f"Could not find instrument for {instrument_id}")
                continue

            # Additional validation for options instruments
            if instrument.instrument_class != InstrumentClass.OPTION:
                self.log.warning(
                    f"Instrument {instrument_id} is not an option: {instrument.instrument_class}",
                )
                continue

            # Check if instrument is active/tradeable
            if hasattr(instrument, "is_active") and not instrument.is_active:
                self.log.warning(f"Instrument {instrument_id} is not active")
                continue

            self.instruments[str(instrument_id)] = instrument
            valid_options.append(instrument_id)

        # Update discovered options to only include valid ones
        self.discovered_options = valid_options
        self.log.info(f"Validated {len(self.discovered_options)} options instruments")

        if len(self.discovered_options) == 0:
            self.log.error("No valid options instruments found - stopping strategy")
            self.stop()
            return False

        return True

    def _initialize_order_books(self) -> None:
        """
        Initialize order books for all instruments (options and spot).
        """
        # Initialize order books for options instruments
        for instrument_id in self.discovered_options:
            instrument_key = str(instrument_id)
            self.books[instrument_key] = OrderBook(
                instrument_id=instrument_id,
                book_type=BookType.L2_MBP,
            )

        # Initialize order book for spot instrument
        spot_key = str(self.config.spot_instrument_id)
        self.books[spot_key] = OrderBook(
            instrument_id=self.config.spot_instrument_id,
            book_type=BookType.L2_MBP,
        )

    def _subscribe_to_data_streams(self) -> None:
        """
        Subscribe to all data streams.
        """
        # Subscribe to quote ticks for all options instruments FIRST
        for instrument_id in self.discovered_options:
            self.subscribe_quote_ticks(instrument_id=instrument_id)

        # Subscribe to spot quote ticks
        self.subscribe_quote_ticks(instrument_id=self.config.spot_instrument_id)

        # Subscribe to order book deltas for all options instruments AFTER quotes
        for instrument_id in self.discovered_options:
            self.subscribe_order_book_deltas(
                instrument_id=instrument_id,
                book_type=BookType.L2_MBP,
                depth=self.config.options_depth,
            )

        # Subscribe to spot order book deltas
        self.subscribe_order_book_deltas(
            instrument_id=self.config.spot_instrument_id,
            book_type=BookType.L2_MBP,
            depth=self.config.spot_depth,
        )

        # Get expiry groups for detailed logging
        expiry_groups = self._get_expiry_groups()

        # Log subscription summary with maturity breakdown
        self.log.info(f"Subscribed to {len(self.discovered_options)} options and 1 spot instrument")
        self.log.info(
            f"Monitoring {len(self.discovered_options)} options across {len(expiry_groups)} maturities:",
        )

        # Log each maturity with option count
        for expiry in sorted(expiry_groups.keys()):
            count = expiry_groups[expiry]
            self.log.info(f"  {expiry}: {count} options")

        self.log.info("Data collection started - waiting for market data...")

    def _get_expiry_groups(self) -> dict[str, int]:
        """
        Get expiry groups for logging summary.
        """
        expiry_groups = {}
        for instrument_id in self.discovered_options:
            symbol = str(instrument_id.symbol)
            parts = symbol.split("-")
            if len(parts) >= 4:
                expiry = parts[1]  # e.g., "02AUG25"
                if expiry not in expiry_groups:
                    expiry_groups[expiry] = 0
                expiry_groups[expiry] += 1
        return expiry_groups

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        """
        Handle incoming order book deltas.
        """
        # Update last data time
        self.last_data_time = time.time()

        instrument_key = str(deltas.instrument_id)

        if instrument_key not in self.books:
            self.log.error(f"No order book initialized for {instrument_key}")
            return

        # Apply deltas to maintain the order book
        self.books[instrument_key].apply_deltas(deltas)
        self.delta_count += 1
        self.instrument_delta_counts[instrument_key] += 1

        # Store delta data
        self._store_order_book_delta(deltas, instrument_key)

        # Check if we need to log and save data
        self._check_and_log_data()

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Handle incoming quote ticks (both options and spot).
        """
        # Update last data time
        self.last_data_time = time.time()

        instrument_key = str(tick.instrument_id)

        # Add validation for quote data
        if tick.bid_price.as_double() <= 0 or tick.ask_price.as_double() <= 0:
            self.log.warning(
                f"Invalid quote prices for {instrument_key}: bid={tick.bid_price}, ask={tick.ask_price}",
            )
            return

        if tick.bid_price.as_double() >= tick.ask_price.as_double():
            self.log.warning(
                f"Invalid quote spread for {instrument_key}: bid={tick.bid_price}, ask={tick.ask_price}",
            )
            return

        # Store quote tick data
        self._store_quote_tick(tick, instrument_key)

        # Update counters
        self._update_counters(tick, instrument_key)

        # Check if we need to log and save data
        self._check_and_log_data()

    def _store_order_book_delta(self, deltas: OrderBookDeltas, instrument_key: str) -> None:
        """
        Store order book delta data.
        """
        book = self.books[instrument_key]
        delta_data = {
            "timestamp": pd.Timestamp.now(),
            "instrument_id": str(deltas.instrument_id),
            "sequence": deltas.sequence,
            "delta_count": len(deltas.deltas),
            "best_bid": book.best_bid_price().as_double() if book.best_bid_price() else None,
            "best_ask": book.best_ask_price().as_double() if book.best_ask_price() else None,
            "bid_size": book.best_bid_size().as_double() if book.best_bid_size() else None,
            "ask_size": book.best_ask_size().as_double() if book.best_ask_size() else None,
        }

        self.order_book_deltas_data[instrument_key].append(delta_data)

    def _store_quote_tick(self, tick: QuoteTick, instrument_key: str) -> None:
        """
        Store quote tick data.
        """
        quote_data = {
            "timestamp": pd.Timestamp.now(),
            "instrument_id": str(tick.instrument_id),
            "bid_price": tick.bid_price.as_double(),
            "ask_price": tick.ask_price.as_double(),
            "bid_size": tick.bid_size.as_double(),
            "ask_size": tick.ask_size.as_double(),
            "ts_event": tick.ts_event,
            "ts_init": tick.ts_init,
        }

        self.quote_ticks_data[instrument_key].append(quote_data)

    def _update_counters(self, tick: QuoteTick, instrument_key: str) -> None:
        """
        Update counters for the instrument.
        """
        if instrument_key == str(self.config.spot_instrument_id):
            self.spot_quote_count += 1
            self.last_spot_price = (tick.bid_price + tick.ask_price) / 2  # Mid price
        else:
            self.quote_count += 1

        self.instrument_quote_counts[instrument_key] += 1

    def _check_and_log_data(self) -> None:
        """
        Check if it's time to log and save data.
        """
        current_time = time.time()

        # Check for data timeout (no data for 2 minutes)
        if current_time - self.last_data_time > 120:  # 2 minutes
            self.connection_warnings += 1
            if self.connection_warnings <= 3:  # Only warn first 3 times
                self.log.warning(
                    f"No data received for {int(current_time - self.last_data_time)} seconds - possible connection issue",
                )
            elif self.connection_warnings == 4:
                self.log.error("Multiple connection warnings - consider restarting the strategy")
        else:
            # Reset warnings if we're getting data
            self.connection_warnings = 0

        if current_time - self.last_log_time >= self.log_interval:
            self._log_and_save_data()
            self.last_log_time = current_time

    def _log_and_save_data(self) -> None:
        """
        Log statistics and save all data to parquet files.
        """
        # Log statistics for each instrument
        self.log.info(f"=== {self.log_interval} SECOND UPDATE ===")

        # Calculate totals
        options_quote_total = 0
        options_delta_total = 0
        active_options = 0

        for instrument_key in self.instrument_quote_counts:
            if instrument_key != str(self.config.spot_instrument_id):
                quote_count = self.instrument_quote_counts[instrument_key]
                delta_count = self.instrument_delta_counts.get(instrument_key, 0)
                options_quote_total += quote_count
                options_delta_total += delta_count
                if quote_count > 0 or delta_count > 0:
                    active_options += 1

        # Log spot instrument
        spot_key = str(self.config.spot_instrument_id)
        spot_quote_count = self.instrument_quote_counts.get(spot_key, 0)
        spot_delta_count = self.instrument_delta_counts.get(spot_key, 0)

        # Log summary
        total_quotes = options_quote_total + spot_quote_count
        total_deltas = options_delta_total + spot_delta_count

        # Get current expiry groups for status
        expiry_groups = self._get_expiry_groups()

        self.log.info(
            f"Active instruments: {active_options}/{len(self.discovered_options)} options, 1/1 spot",
        )
        self.log.info(
            f"Monitoring {len(expiry_groups)} maturities: {', '.join(sorted(expiry_groups.keys()))}",
        )
        self.log.info(f"Data received: {total_quotes} quotes, {total_deltas} deltas")
        self.log.info(f"  Options: {options_quote_total} quotes, {options_delta_total} deltas")
        self.log.info(f"  Spot: {spot_quote_count} quotes, {spot_delta_count} deltas")

        # Save all data to parquet files
        self._save_all_data_to_parquet()

        # Reset counters for next interval
        self._reset_counters()

    def _save_all_data_to_parquet(self) -> None:
        """
        Save all accumulated data to parquet files.
        """
        # Count data being saved
        total_quotes_saved = 0
        total_deltas_saved = 0
        instruments_with_quotes = 0
        instruments_with_deltas = 0

        # Save quote ticks data for each instrument
        for instrument_key, data in self.quote_ticks_data.items():
            if data:
                filepath = self.quote_ticks_files[instrument_key]
                self._append_to_parquet_file(data, filepath, "quote_ticks", instrument_key)
                total_quotes_saved += len(data)
                instruments_with_quotes += 1
                # Clear the data after saving to prevent duplicate appending
                self.quote_ticks_data[instrument_key].clear()

        # Save order book deltas data for each instrument
        for instrument_key, data in self.order_book_deltas_data.items():
            if data:
                filepath = self.order_book_deltas_files[instrument_key]
                self._append_to_parquet_file(data, filepath, "order_book_deltas", instrument_key)
                total_deltas_saved += len(data)
                instruments_with_deltas += 1
                # Clear the data after saving to prevent duplicate appending
                self.order_book_deltas_data[instrument_key].clear()

        # Log data saving summary
        if total_quotes_saved > 0 or total_deltas_saved > 0:
            self.log.info(
                f"Data saved: {total_quotes_saved} quotes ({instruments_with_quotes} instruments), "
                f"{total_deltas_saved} deltas ({instruments_with_deltas} instruments)",
            )

    def _append_to_parquet_file(
        self,
        data: list[dict],
        filepath: str,
        data_type: str,
        instrument_key: str,
    ) -> None:
        """
        Append data to a parquet file.
        """
        if not data:
            return

        # Ensure directory exists
        Path(filepath).parent.mkdir(parents=True, exist_ok=True)

        # Convert to DataFrame
        df = pd.DataFrame(data)

        try:
            if df.empty:
                return

            # If existing file exists and has data, read and concat
            if Path(filepath).exists():
                try:
                    existing_df = pd.read_parquet(filepath)
                    if existing_df.empty:
                        combined_df = df
                    else:
                        # Align columns safely
                        all_columns = sorted(set(existing_df.columns) | set(df.columns))
                        for col in all_columns:
                            if col not in existing_df:
                                existing_df[col] = pd.NA
                            if col not in df:
                                df[col] = pd.NA
                        combined_df = pd.concat(
                            [existing_df[all_columns], df[all_columns]],
                            ignore_index=True,
                        )
                except Exception as e:
                    self.log.error(f"Failed to read existing parquet file: {e}")
                    combined_df = df
            else:
                combined_df = df

            # Save to file
            combined_df.to_parquet(filepath, index=False)

            self.log.debug(f"Saved {len(df)} {data_type} records to {filepath}")

        except Exception as e:
            self.log.error(f"Error saving {data_type} to {filepath}: {e}")

    def _reset_counters(self) -> None:
        """
        Reset counters for next interval.
        """
        for key in self.instrument_quote_counts:
            self.instrument_quote_counts[key] = 0
        for key in self.instrument_delta_counts:
            self.instrument_delta_counts[key] = 0

    def on_stop(self) -> None:
        """
        Actions to be performed on strategy stop.
        """
        # Calculate final statistics
        active_options = 0
        total_options_quotes = 0
        total_options_deltas = 0

        for instrument_key in self.instrument_quote_counts:
            if instrument_key != str(self.config.spot_instrument_id):
                quote_count = self.instrument_quote_counts[instrument_key]
                delta_count = self.instrument_delta_counts.get(instrument_key, 0)
                total_options_quotes += quote_count
                total_options_deltas += delta_count
                if quote_count > 0 or delta_count > 0:
                    active_options += 1

        # Log final statistics
        self.log.info("=== FINAL STATISTICS ===")
        self.log.info(
            f"Active instruments: {active_options}/{len(self.discovered_options)} options, 1/1 spot",
        )
        self.log.info("Total data processed:")
        self.log.info(f"  Options: {total_options_quotes} quotes, {total_options_deltas} deltas")
        self.log.info(
            f"  Spot: {self.spot_quote_count} quotes, {self.instrument_delta_counts.get(str(self.config.spot_instrument_id), 0)} deltas",
        )

        # Write any remaining data to parquet
        self._save_all_data_to_parquet()

        self.log.info(
            f"Strategy stopped. "
            f"Processed {self.delta_count} order book deltas, "
            f"{self.quote_count} options quote ticks, and "
            f"{self.spot_quote_count} spot quote ticks.",
        )

        # Cleanup file logging if enabled
        if hasattr(self, "file_handler") and self.file_handler:
            self.log.info(f"Logs saved to: {self.log_filepath}")
            self.file_handler.close()
            self.log.removeHandler(self.file_handler)

    def get_log_filepath(self) -> str | None:
        """
        Get the current log file path.

        Returns
        -------
        Optional[str]
            The log file path if file logging is enabled, None otherwise

        """
        return getattr(self, "log_filepath", None)

    def rotate_log_file(self) -> str | None:
        """
        Rotate the current log file and create a new one. Useful for long-running
        sessions to manage log file sizes.

        Returns
        -------
        Optional[str]
            The new log file path if successful, None otherwise

        """
        if not hasattr(self, "file_handler") or not self.file_handler:
            return None

        try:
            # Close current handler
            self.file_handler.close()
            self.log.removeHandler(self.file_handler)

            # Create new log filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            logs_dir = os.path.join(self.base_data_dir, "logs")
            log_filename = f"bybit_options_collector_{self.underlying_asset}_{timestamp}.log"
            new_log_filepath = os.path.join(logs_dir, log_filename)

            # Create new file handler
            new_file_handler = logging.FileHandler(new_log_filepath)
            new_file_handler.setLevel(getattr(logging, self.config.log_level))

            # Create formatter
            formatter = logging.Formatter(
                "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                datefmt="%Y-%m-%d %H:%M:%S",
            )
            new_file_handler.setFormatter(formatter)

            # Add new handler to logger
            self.log.addHandler(new_file_handler)

            # Update stored references
            self.file_handler = new_file_handler
            old_log_filepath = self.log_filepath
            self.log_filepath = new_log_filepath

            # Log the rotation
            self.log.info(f"Log file rotated: {old_log_filepath} -> {new_log_filepath}")

            return new_log_filepath

        except Exception as e:
            self.log.error(f"Failed to rotate log file: {e}")
            return None


def main():
    """
    Run the Bybit options data collector.
    """
    # Configuration for Bybit options and spot
    product_types = [BybitProductType.OPTION, BybitProductType.SPOT]

    # Create spot symbol for the underlying asset
    underlying = "BTC"
    spot_symbol = f"{underlying}USDT-SPOT.BYBIT"

    # Configure the trading node
    config_node = TradingNodeConfig(
        trader_id=TraderId("OPTIONS-COLLECTOR-001"),
        logging=LoggingConfig(
            log_level="INFO",
            log_level_file="INFO",  # Enable file logging
            log_directory="data/logs",  # Set log directory
            log_file_name="bybit_options_collector",  # Set log file name
            use_pyo3=True,
            log_colors=True,
        ),
        data_clients={
            BYBIT: BybitDataClientConfig(
                api_key=os.getenv("BYBIT_API_KEY"),
                api_secret=os.getenv("BYBIT_API_SECRET"),
                instrument_provider=InstrumentProviderConfig(
                    load_all=True,  # Load all instruments
                    filters={
                        "base_coin": underlying,  # Filter for BTC base coin only
                    },
                ),
                product_types=product_types,  # Load both options and spot
                testnet=False,  # Use mainnet
            ),
        },
        timeout_connection=30.0,
        timeout_reconciliation=10.0,
        timeout_portfolio=10.0,
        timeout_disconnection=10.0,
        timeout_post_stop=5.0,
    )

    # Instantiate the node
    node = TradingNode(config=config_node)

    # Configure the strategy
    strategy_config = BybitOptionsDataCollectorConfig(
        underlying_asset=underlying,  # Collect data for BTC options
        spot_instrument_id=InstrumentId.from_str(spot_symbol),
        options_depth=25,  # Use 25 levels for options
        spot_depth=50,  # Use 50 levels for spot
        batch_size=1000,  # Write to parquet every 1000 records
        data_dir="data",  # Store parquet files in 'data' directory
        log_interval=60.0,  # Log and save every 60 seconds
        save_logs=True,  # Save logs to file
        log_level="INFO",  # Log level for file logging
    )

    # Instantiate the strategy
    strategy = BybitOptionsDataCollector(config=strategy_config)

    # Add the strategy to the node
    node.trader.add_strategy(strategy)

    # Register the data client factory
    from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory

    node.add_data_client_factory(BYBIT, BybitLiveDataClientFactory)

    # Build the node
    node.build()

    # Run the node
    if __name__ == "__main__":
        try:
            print("Starting Bybit Options Data Collector")
            print(f"Will discover and collect data for all {underlying} options")
            print("Press Ctrl+C to stop...")
            node.run()
        except KeyboardInterrupt:
            print("\nStopping...")
        finally:
            node.dispose()


if __name__ == "__main__":
    main()

</document_content>
</document>
<document index="1851">
<source>examples/live/bybit/bybit_request_custom_endpoint.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import os
from datetime import timedelta

from nautilus_trader.adapters.bybit import BYBIT
from nautilus_trader.adapters.bybit import BYBIT_CLIENT_ID
from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitExecClientConfig
from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory
from nautilus_trader.adapters.bybit import BybitLiveExecClientFactory
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.adapters.bybit import BybitTickerData
from nautilus_trader.common import Environment
from nautilus_trader.common.events import TimeEvent
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import StrategyConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.core.data import Data
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import DataType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.trading import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class RequestDemoStrategyConfig(StrategyConfig, frozen=True):
    instrument_id: InstrumentId
    interval: int


class RequestDemoStrategy(Strategy):
    """
    Strategy showcases how to request custom data from bybit adapter. BybitTickerData is
    specific to Bybit adapter and you can request it with `request_data` method.

    Also this strategy demonstrate:
    - how to request BybitTickerData
    - how to use clock to schedule this request periodically by time interval in seconds.

    """

    def __init__(self, config: RequestDemoStrategyConfig):
        super().__init__()

    def on_start(self):
        seconds_delta = timedelta(seconds=self.config.interval)
        self.clock.set_timer(
            name="fetch_ticker",
            interval=seconds_delta,
            callback=self.send_tickers_request,
        )

    def send_tickers_request(self, time_event: TimeEvent) -> None:
        data_type = DataType(
            BybitTickerData,
            metadata={"symbol": self.config.instrument_id.symbol},
        )
        self.request_data(data_type, BYBIT_CLIENT_ID)

    def on_historical_data(self, data: Data) -> None:
        if isinstance(data, BybitTickerData):
            self.log.info(f"{data}")


api_key = os.getenv("BYBIT_TESTNET_API_KEY")
api_secret = os.getenv("BYBIT_TESTNET_API_SECRET")

config_node = TradingNodeConfig(
    trader_id="TESTER-001",
    environment=Environment.LIVE,
    logging=LoggingConfig(log_level="INFO"),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
    ),
    data_clients={
        BYBIT: BybitDataClientConfig(
            api_key=api_key,
            api_secret=api_secret,
            product_types=(BybitProductType.LINEAR,),
            instrument_provider=InstrumentProviderConfig(load_all=True),
            testnet=True,
        ),
    },
    exec_clients={
        BYBIT: BybitExecClientConfig(
            api_key=api_key,
            api_secret=api_secret,
            product_types=(BybitProductType.LINEAR,),
            instrument_provider=InstrumentProviderConfig(load_all=True),
            testnet=True,
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

node = TradingNode(config=config_node)

instrument_id = InstrumentId.from_str("ETHUSDT-LINEAR.BYBIT")
strategy_config = RequestDemoStrategyConfig(
    instrument_id=instrument_id,
    interval=10,
)
strategy_config = RequestDemoStrategy(config=strategy_config)

node.trader.add_strategy(strategy_config)
node.add_data_client_factory(BYBIT, BybitLiveDataClientFactory)
node.add_exec_client_factory(BYBIT, BybitLiveExecClientFactory)
node.build()

if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1852">
<source>examples/live/coinbase_intx/coinbase_intx_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.coinbase_intx import COINBASE_INTX
from nautilus_trader.adapters.coinbase_intx import CoinbaseIntxDataClientConfig
from nautilus_trader.adapters.coinbase_intx import CoinbaseIntxLiveDataClientFactory
from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,  # Not applicable
        inflight_check_interval_ms=0,  # Not applicable
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(),
        encoding="msgpack",
        timestamps_as_iso8601=True,
        buffer_interval_ms=100,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     # types_filter=[QuoteTick],
    #     autotrim_mins=30,
    # ),
    # heartbeat_interval=1.0,
    data_clients={
        COINBASE_INTX: CoinbaseIntxDataClientConfig(
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,  # Not applicable
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=0.0,  # Not required as no order state
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)


instrument_ids = [
    InstrumentId.from_str("ETH-PERP.COINBASE_INTX"),
]

# Configure your actor
config_tester = DataTesterConfig(
    instrument_ids=instrument_ids,
    subscribe_quotes=True,
    subscribe_trades=True,
    subscribe_mark_prices=True,
    subscribe_index_prices=True,
    # subscribe_book_deltas=True,
    # manage_book=True,
    # book_levels_to_print=3,
    # subscribe_book_at_interval=True,
    # book_depth=20,
    # book_interval_ms=1000,
    log_data=True,
)

# Instantiate your actor
data_tester = DataTester(config=config_tester)

# Add your actors and modules
node.trader.add_actor(data_tester)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(COINBASE_INTX, CoinbaseIntxLiveDataClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1853">
<source>examples/live/coinbase_intx/coinbase_intx_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

# This example demonstrates using the ExecTester strategy for testing
# execution functionality with Coinbase International Exchange.
# The strategy places limit orders at a specified offset from the market.

from decimal import Decimal

from nautilus_trader.adapters.coinbase_intx import COINBASE_INTX
from nautilus_trader.adapters.coinbase_intx import CoinbaseIntxDataClientConfig
from nautilus_trader.adapters.coinbase_intx import CoinbaseIntxExecClientConfig
from nautilus_trader.adapters.coinbase_intx import CoinbaseIntxLiveDataClientFactory
from nautilus_trader.adapters.coinbase_intx import CoinbaseIntxLiveExecClientFactory
from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


instrument_id = InstrumentId.from_str("BTC-PERP.COINBASE_INTX")
offset_ticks = 10  # Number of ticks to offset limit orders from the market
trade_size = Decimal("0.01")
dry_run = False  # Set this to True to prevent trading

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(),
        encoding="msgpack",
        timestamps_as_iso8601=True,
        buffer_interval_ms=100,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     # types_filter=[QuoteTick],
    #     autotrim_mins=30,
    # ),
    # heartbeat_interval=1.0,
    data_clients={
        COINBASE_INTX: CoinbaseIntxDataClientConfig(
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        COINBASE_INTX: CoinbaseIntxExecClientConfig(
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    timeout_connection=60.0,
    timeout_reconciliation=20.0,
    timeout_portfolio=10.0,
    timeout_disconnection=5.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
config_tester = ExecTesterConfig(
    use_uuid_client_order_ids=True,  # <-- Required for Coinbase Intx
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    order_qty=trade_size,
    tob_offset_ticks=offset_ticks,
    subscribe_quotes=True,
    subscribe_trades=True,
    use_post_only=True,
    close_positions_time_in_force=TimeInForce.IOC,  # <-- Required for Coinbase Intx
    dry_run=dry_run,
    log_data=True,
)

# Instantiate your strategy
strategy = ExecTester(config=config_tester)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(COINBASE_INTX, CoinbaseIntxLiveDataClientFactory)
node.add_exec_client_factory(COINBASE_INTX, CoinbaseIntxLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1854">
<source>examples/live/databento/databento_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.databento import DATABENTO
from nautilus_trader.adapters.databento import DatabentoDataClientConfig
from nautilus_trader.adapters.databento import DatabentoLiveDataClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# For correct subscription operation, you must specify all instruments to be immediately
# subscribed for as part of the data client configuration
instrument_ids = [
    # InstrumentId.from_str("ES.c.0.GLBX"),  # TODO: Continuous contracts only work with GLBX for now
    InstrumentId.from_str("ESH6.XCME"),
    # InstrumentId.from_str("ES.FUT.XCME"),
    # InstrumentId.from_str("CL.FUT.NYMEX"),
    # InstrumentId.from_str("LO.OPT.NYMEX"),
    # InstrumentId.from_str("AAPL.XNAS"),
    # InstrumentId.from_str("AAPL.IEXG"),
]

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,  # Not applicable
    ),
    data_clients={
        DATABENTO: DatabentoDataClientConfig(
            api_key=None,  # 'DATABENTO_API_KEY' env var
            http_gateway=None,
            instrument_provider=InstrumentProviderConfig(load_all=True),
            use_exchange_as_venue=True,
            mbo_subscriptions_delay=10.0,
            instrument_ids=instrument_ids,
            parent_symbols={"GLBX.MDP3": {"ES.FUT"}},
            # venue_dataset_map={"XNAS": "EQUS.MINI"},
        ),
    },
    timeout_connection=30.0,
    timeout_disconnection=10.0,
    timeout_post_stop=1.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure and initialize the tester
config_tester = DataTesterConfig(
    instrument_ids=instrument_ids,
    bar_types=[BarType.from_str(f"{instrument_ids[0]}-1-SECOND-LAST-EXTERNAL")],
    # bar_types=[BarType.from_str(f"{instrument_ids[0]}-1-DAY-LAST-EXTERNAL")],
    # subscribe_params={"schema": "bbo-1s"},
    # subscribe_params={"schema": "ohlcv-eod"},
    # subscribe_book_deltas=True,
    # subscribe_book_depth=True,
    # subscribe_book_at_interval=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    subscribe_bars=True,
    subscribe_instrument_status=True,
    subscribe_instrument_close=False,
    can_unsubscribe=False,  # Unsubscribing not supported by Databento
    # request_bars=True,  # Requires knowing the available time range `end`
    book_type=BookType.L3_MBO,
    # book_interval_ms=100,
)
tester = DataTester(config=config_tester)

node.trader.add_actor(tester)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(DATABENTO, DatabentoLiveDataClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1855">
<source>examples/live/databento/notebooks/databento_historical_data.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.17.3
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% [markdown]
# ## imports

# %% [markdown]
# Note: Use the jupytext python package to be able to open this python file in jupyter as a notebook.
# Also run `jupytext-config set-default-viewer` to open jupytext python files as notebooks by default.

# %%
from nautilus_trader.adapters.databento import DATABENTO
from nautilus_trader.adapters.databento import DatabentoDataClientConfig
from nautilus_trader.adapters.databento import DatabentoLiveDataClientFactory
from nautilus_trader.adapters.databento.data_utils import load_catalog
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveDataClientConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import StrategyConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.core.datetime import time_object_to_dt
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.persistence.config import DataCatalogConfig
from nautilus_trader.trading.strategy import Strategy


# %% [markdown]
# ## parameters

# %%
catalog_folder = "live_catalog"
catalog = load_catalog(catalog_folder)


# %% [markdown]
# ## strategy


# %%
class DataSubscriberConfig(StrategyConfig, frozen=True):
    instrument_ids: list[InstrumentId] | None = None


class DataSubscriber(Strategy):
    def __init__(self, config: DataSubscriberConfig) -> None:
        super().__init__(config)

    def on_start(self) -> None:
        start_time = time_object_to_dt("2024-05-09T10:00")
        end_time = time_object_to_dt("2024-05-09T10:05")

        self.request_quote_ticks(
            InstrumentId.from_str("ESM4.XCME"),  # or "ESM4.GLBX"
            start_time,
            end_time,
            params={"schema": "bbo-1m"},
            update_catalog=True,
        )

        # for instrument_id in self.config.instrument_ids:
        # from nautilus_trader.model.enums import BookType

        # self.subscribe_order_book_deltas(
        #     instrument_id=instrument_id,
        #     book_type=BookType.L3_MBO,
        #     client_id=DATABENTO_CLIENT_ID,
        # )
        # self.subscribe_order_book_at_interval(
        #     instrument_id=instrument_id,
        #     book_type=BookType.L2_MBP,
        #     depth=10,
        #     client_id=DATABENTO_CLIENT_ID,
        #     interval_ms=1000,
        # )

        # self.subscribe_quote_ticks(instrument_id, client_id=DATABENTO_CLIENT_ID)
        # self.subscribe_trade_ticks(instrument_id, client_id=DATABENTO_CLIENT_ID)
        # self.subscribe_instrument_status(instrument_id, client_id=DATABENTO_CLIENT_ID)
        # self.request_quote_ticks(instrument_id)
        # self.request_trade_ticks(instrument_id)

        # from nautilus_trader.model.data import DataType
        # from nautilus_trader.model.data import InstrumentStatus
        #
        # status_data_type = DataType(
        #     type=InstrumentStatus,
        #     metadata={"instrument_id": instrument_id},
        # )
        # self.request_data(status_data_type, client_id=DATABENTO_CLIENT_ID)

        # from nautilus_trader.model.data import BarType
        # self.request_bars(BarType.from_str(f"{instrument_id}-1-MINUTE-LAST-EXTERNAL"))

        # # Imbalance
        # from nautilus_trader.adapters.databento import DatabentoImbalance
        #
        # metadata = {"instrument_id": instrument_id}
        # self.request_data(
        #     data_type=DataType(type=DatabentoImbalance, metadata=metadata),
        #     client_id=DATABENTO_CLIENT_ID,
        # )

        # # Statistics
        # from nautilus_trader.adapters.databento import DatabentoStatistics
        #
        # metadata = {"instrument_id": instrument_id}
        # self.subscribe_data(
        #     data_type=DataType(type=DatabentoStatistics, metadata=metadata),
        #     client_id=DATABENTO_CLIENT_ID,
        # )
        # self.request_data(
        #     data_type=DataType(type=DatabentoStatistics, metadata=metadata),
        #     client_id=DATABENTO_CLIENT_ID,
        # )

        # self.request_instruments(venue=Venue("GLBX"), client_id=DATABENTO_CLIENT_ID)
        # self.request_instruments(venue=Venue("XCHI"), client_id=DATABENTO_CLIENT_ID)
        # self.request_instruments(venue=Venue("XNAS"), client_id=DATABENTO_CLIENT_ID)

    def on_stop(self) -> None:
        # Databento does not support live data unsubscribing
        pass

    def on_historical_data(self, data) -> None:
        self.log.info(repr(data), LogColor.CYAN)

    def on_order_book_deltas(self, deltas) -> None:
        self.log.info(repr(deltas), LogColor.CYAN)

    def on_order_book(self, order_book) -> None:
        self.log.info(f"\n{order_book.instrument_id}\n{order_book.pprint(10)}", LogColor.CYAN)

    def on_quote_tick(self, tick) -> None:
        self.log.info(repr(tick), LogColor.CYAN)

    def on_trade_tick(self, tick) -> None:
        self.log.info(repr(tick), LogColor.CYAN)


# %% [markdown]
# ## backtest node

# %%
# For correct subscription operation, you must specify all instruments to be immediately
# subscribed for as part of the data client configuration
instrument_ids = None

# %%
strat_config = DataSubscriberConfig(instrument_ids=instrument_ids)
strategy = DataSubscriber(config=strat_config)

catalogs = [
    DataCatalogConfig(
        path=catalog.path,
    ),
]

exec_engine = LiveExecEngineConfig(
    reconciliation=False,  # Not applicable
    inflight_check_interval_ms=0,  # Not applicable
)

logging = LoggingConfig(
    log_level="INFO",
)

data_clients: dict[str, LiveDataClientConfig] = {
    DATABENTO: DatabentoDataClientConfig(
        api_key=None,  # 'DATABENTO_API_KEY' env var
        http_gateway=None,
        instrument_provider=InstrumentProviderConfig(load_all=True),
        instrument_ids=instrument_ids,
        parent_symbols={"GLBX.MDP3": {"ES.FUT"}},
        mbo_subscriptions_delay=10.0,
    ),
}

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    catalogs=catalogs,
    exec_engine=exec_engine,
    logging=logging,
    data_clients=data_clients,
    # other settings
    timeout_connection=20.0,
    timeout_reconciliation=10.0,  # Not applicable
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=0.0,  # Not required as no order state
)

# %%
node = TradingNode(config=config_node)
node.trader.add_strategy(strategy)
node.add_data_client_factory(DATABENTO, DatabentoLiveDataClientFactory)
node.build()

# %%
node.run()

# %%
node.stop()

# %%
node.dispose()

# %%

</document_content>
</document>
<document index="1856">
<source>examples/live/dydx/dydx_market_maker.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.dydx import DYDXDataClientConfig
from nautilus_trader.adapters.dydx import DYDXExecClientConfig
from nautilus_trader.adapters.dydx import DYDXLiveDataClientFactory
from nautilus_trader.adapters.dydx import DYDXLiveExecClientFactory
from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMaker
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMakerConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Perpetual
symbol = "ETH-USD-PERP"
trade_size = Decimal("0.010")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(),
        timestamps_as_iso8601=True,
        buffer_interval_ms=100,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="bybit",
    #     use_trader_prefix=False,
    #     use_trader_id=False,
    #     use_instance_id=False,
    #     stream_per_topic=False,
    #     # types_filter=[QuoteTick],
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    data_clients={
        "DYDX": DYDXDataClientConfig(
            wallet_address=None,  # 'DYDX_WALLET_ADDRESS' env var
            instrument_provider=InstrumentProviderConfig(load_all=True),
            is_testnet=True,  # If client uses the testnet API
        ),
    },
    exec_clients={
        "DYDX": DYDXExecClientConfig(
            wallet_address=None,  # 'DYDX_WALLET_ADDRESS' env var
            mnemonic=None,  # 'DYDX_MNEMONIC' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            is_testnet=True,  # If client uses the testnet API
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = VolatilityMarketMakerConfig(
    instrument_id=InstrumentId.from_str(f"{symbol}.DYDX"),
    external_order_claims=[InstrumentId.from_str(f"{symbol}.DYDX")],
    bar_type=BarType.from_str(f"{symbol}.DYDX-1-MINUTE-LAST-EXTERNAL"),
    atr_period=20,
    atr_multiple=3.0,
    trade_size=trade_size,
)
# Instantiate your strategy
strategy = VolatilityMarketMaker(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory("DYDX", DYDXLiveDataClientFactory)
node.add_exec_client_factory("DYDX", DYDXLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1857">
<source>examples/live/dydx/dydx_v4_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
"""
DYdX v4 DataTester example using the Rust-backed adapter.

This script demonstrates how to use the DataTester actor to validate
market data functionality for the dYdX v4 adapter.

Prerequisites:
  - Environment variables:
      DYDX_WALLET_ADDRESS (or DYDX_TESTNET_WALLET_ADDRESS for testnet)

Usage:
  python dydx_v4_data_tester.py

"""

from nautilus_trader.adapters.dydx_v4 import DYDX_VENUE
from nautilus_trader.adapters.dydx_v4 import DYDXv4DataClientConfig
from nautilus_trader.adapters.dydx_v4 import DYDXv4LiveDataClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# dYdX v4 perpetual markets
# All instruments follow {BASE}-{QUOTE}-PERP.DYDX naming
symbol = "ETH-USD-PERP"
instrument_id = InstrumentId.from_str(f"{symbol}.{DYDX_VENUE}")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("DYDX-DATA-TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        use_pyo3=True,
    ),
    data_clients={
        "DYDX": DYDXv4DataClientConfig(
            wallet_address=None,  # 'DYDX_WALLET_ADDRESS' or 'DYDX_TESTNET_WALLET_ADDRESS' env var
            instrument_provider=InstrumentProviderConfig(load_all=True),
            is_testnet=False,  # Mainnet by default; flip to True for testnet
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=1.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your data tester
config_tester = DataTesterConfig(
    instrument_ids=[instrument_id],
    bar_types=[BarType.from_str(f"{instrument_id}-1-MINUTE-LAST-EXTERNAL")],
    subscribe_instrument=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    subscribe_book_deltas=True,
    subscribe_funding_rates=True,
    manage_book=True,
    book_levels_to_print=10,
    log_data=True,
)

# Instantiate your actor
tester = DataTester(config=config_tester)

# Add your actors and modules
node.trader.add_actor(tester)

# Register your client factories with the node (using v4 Rust-backed factory)
node.add_data_client_factory("DYDX", DYDXv4LiveDataClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1858">
<source>examples/live/dydx/dydx_v4_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
"""
DYdX v4 ExecTester example using the Rust-backed adapter.

This script demonstrates how to use the ExecTester strategy to validate
execution functionality for the dYdX v4 adapter.

Prerequisites:
  - Environment variables:
      DYDX_WALLET_ADDRESS (or DYDX_TESTNET_WALLET_ADDRESS for testnet)
      DYDX_MNEMONIC (or DYDX_TESTNET_MNEMONIC for testnet)

dYdX v4 order semantics:
  - Short-term orders: Live only in validator memory (~20 blocks / ~30 seconds)
  - Long-term orders: Required for conditional orders (STOP_MARKET, STOP_LIMIT)
  - All markets are perpetual futures (-PERP suffix)
  - Uses DYDXOrderTags to control short-term vs long-term, block lifetime, etc.

Note on DYDXOrderTags:
  The ExecTester uses short-term orders by default. For custom tag configuration
  (e.g., long-term orders for stop orders), see the dydx_v4_market_maker.py example
  which demonstrates passing tags via the order_factory.limit() method:

    order = self.order_factory.limit(
        ...
        tags=[DYDXOrderTags(is_short_term_order=False).value],
    )

Usage:
  python dydx_v4_exec_tester.py

"""

from decimal import Decimal

from nautilus_trader.adapters.dydx_v4 import DYDX_VENUE
from nautilus_trader.adapters.dydx_v4 import DYDXv4DataClientConfig
from nautilus_trader.adapters.dydx_v4 import DYDXv4ExecClientConfig
from nautilus_trader.adapters.dydx_v4 import DYDXv4LiveDataClientFactory
from nautilus_trader.adapters.dydx_v4 import DYDXv4LiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.config import LiveRiskEngineConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.portfolio.config import PortfolioConfig
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# dYdX v4 perpetual markets
# All instruments follow {BASE}-{QUOTE}-PERP.DYDX naming
symbol = "ETH-USD-PERP"
instrument_id = InstrumentId.from_str(f"{symbol}.{DYDX_VENUE}")

# Order parameters
order_qty = Decimal("0.01")

# Only reconcile these instruments
reconciliation_instrument_ids = [instrument_id]

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("DYDX-EXEC-TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,  # 24 hours
        reconciliation_instrument_ids=reconciliation_instrument_ids,
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        position_check_interval_secs=5.0,
        graceful_shutdown_on_exception=True,
    ),
    risk_engine=LiveRiskEngineConfig(bypass=True),
    portfolio=PortfolioConfig(min_account_state_logging_interval_ms=1_000),
    data_clients={
        "DYDX": DYDXv4DataClientConfig(
            wallet_address=None,  # 'DYDX_WALLET_ADDRESS' or 'DYDX_TESTNET_WALLET_ADDRESS' env var
            instrument_provider=InstrumentProviderConfig(
                load_all=False,
                load_ids=frozenset(reconciliation_instrument_ids),
            ),
            is_testnet=False,  # Mainnet by default; flip to True for testnet
        ),
    },
    exec_clients={
        "DYDX": DYDXv4ExecClientConfig(
            wallet_address=None,  # 'DYDX_WALLET_ADDRESS' or 'DYDX_TESTNET_WALLET_ADDRESS' env var
            mnemonic=None,  # 'DYDX_MNEMONIC' or 'DYDX_TESTNET_MNEMONIC' env var
            subaccount=0,  # Default subaccount (created after first deposit/trade)
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            base_url_grpc=None,  # Override with custom gRPC endpoint
            instrument_provider=InstrumentProviderConfig(
                load_all=False,
                load_ids=frozenset(reconciliation_instrument_ids),
            ),
            is_testnet=False,  # Mainnet by default; flip to True for testnet
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your execution tester
# Note: dYdX v4 does NOT support:
#   - Batch submit/modify/cancel
#   - OCO, iceberg, or bracket orders (emulated only)
#   - Trailing stop orders
#   - MKT_IF_TOUCHED, LMT_IF_TOUCHED (only STOP_MARKET, STOP_LIMIT)
config_tester = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    subscribe_quotes=True,
    subscribe_trades=True,
    enable_limit_buys=True,
    enable_limit_sells=True,
    enable_stop_buys=False,  # Stop orders require long-term orders with DYDXOrderTags
    enable_stop_sells=False,  # Stop orders require long-term orders with DYDXOrderTags
    order_qty=order_qty,
    tob_offset_ticks=500,  # Definitely out of the market
    use_post_only=True,  # dYdX supports post-only for maker orders
    reduce_only_on_stop=True,  # dYdX supports reduce-only
    cancel_orders_on_stop=True,
    close_positions_on_stop=True,
    log_data=False,
)

# Instantiate your strategy
tester = ExecTester(config=config_tester)

# Add your strategies and modules
node.trader.add_strategy(tester)

# Register your client factories with the node (using v4 Rust-backed factories)
node.add_data_client_factory("DYDX", DYDXv4LiveDataClientFactory)
node.add_exec_client_factory("DYDX", DYDXv4LiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1859">
<source>examples/live/dydx/dydx_v4_market_maker.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
"""
DYdX v4 Market Maker example using the Rust-backed adapter.

This example demonstrates the volatility market maker strategy on dYdX v4
using the new Rust-backed HTTP, WebSocket, and gRPC clients.

Prerequisites:
  - Environment variables:
      DYDX_WALLET_ADDRESS (or DYDX_TESTNET_WALLET_ADDRESS for testnet)
      DYDX_MNEMONIC (or DYDX_TESTNET_MNEMONIC for testnet)

Usage:
  python dydx_v4_market_maker.py

"""

from decimal import Decimal

from nautilus_trader.adapters.dydx_v4 import DYDXv4DataClientConfig
from nautilus_trader.adapters.dydx_v4 import DYDXv4ExecClientConfig
from nautilus_trader.adapters.dydx_v4 import DYDXv4LiveDataClientFactory
from nautilus_trader.adapters.dydx_v4 import DYDXv4LiveExecClientFactory
from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMaker
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMakerConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# dYdX v4 perpetual market
symbol = "ETH-USD-PERP"
trade_size = Decimal("0.010")

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("DYDX-V4-MM-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
    ),
    cache=CacheConfig(
        timestamps_as_iso8601=True,
        buffer_interval_ms=100,
    ),
    data_clients={
        "DYDX": DYDXv4DataClientConfig(
            wallet_address=None,  # 'DYDX_WALLET_ADDRESS' or 'DYDX_TESTNET_WALLET_ADDRESS' env var
            instrument_provider=InstrumentProviderConfig(load_all=True),
            is_testnet=False,  # Mainnet
        ),
    },
    exec_clients={
        "DYDX": DYDXv4ExecClientConfig(
            wallet_address=None,  # 'DYDX_WALLET_ADDRESS' or 'DYDX_TESTNET_WALLET_ADDRESS' env var
            mnemonic=None,  # 'DYDX_MNEMONIC' or 'DYDX_TESTNET_MNEMONIC' env var
            subaccount=0,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            base_url_grpc=None,  # Override with custom gRPC endpoint
            instrument_provider=InstrumentProviderConfig(load_all=True),
            is_testnet=False,  # Mainnet
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = VolatilityMarketMakerConfig(
    instrument_id=InstrumentId.from_str(f"{symbol}.DYDX"),
    external_order_claims=[InstrumentId.from_str(f"{symbol}.DYDX")],
    bar_type=BarType.from_str(f"{symbol}.DYDX-1-MINUTE-LAST-EXTERNAL"),
    atr_period=20,
    atr_multiple=3.0,
    trade_size=trade_size,
)

# Instantiate your strategy
strategy = VolatilityMarketMaker(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (using v4 Rust-backed factories)
node.add_data_client_factory("DYDX", DYDXv4LiveDataClientFactory)
node.add_exec_client_factory("DYDX", DYDXv4LiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1860">
<source>examples/live/hyperliquid/hyperliquid_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.hyperliquid import HYPERLIQUID
from nautilus_trader.adapters.hyperliquid import HyperliquidDataClientConfig
from nautilus_trader.adapters.hyperliquid import HyperliquidLiveDataClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# *** THIS INTEGRATION IS STILL UNDER CONSTRUCTION. ***
# *** CONSIDER IT TO BE IN AN UNSTABLE BETA PHASE AND EXERCISE CAUTION. ***

instrument_ids = [
    InstrumentId.from_str("BTC-USD-PERP.HYPERLIQUID"),
    InstrumentId.from_str("ETH-USD-PERP.HYPERLIQUID"),
    InstrumentId.from_str("HYPE-USDC-SPOT.HYPERLIQUID"),
]

bar_types = [
    BarType.from_str("BTC-USD-PERP.HYPERLIQUID-1-MINUTE-LAST-EXTERNAL"),
    BarType.from_str("HYPE-USDC-SPOT.HYPERLIQUID-1-MINUTE-LAST-EXTERNAL"),
]

if __name__ == "__main__":
    # Configure the trading node
    config_node = TradingNodeConfig(
        trader_id=TraderId("TESTER-001"),
        logging=LoggingConfig(
            log_level="INFO",
            # log_level_file="DEBUG",
            use_pyo3=True,
        ),
        exec_engine=LiveExecEngineConfig(
            reconciliation=False,  # Not required for data testing
        ),
        data_clients={
            HYPERLIQUID: HyperliquidDataClientConfig(
                instrument_provider=InstrumentProviderConfig(load_all=True),
                testnet=False,  # If client uses the testnet
            ),
        },
        timeout_connection=20.0,
        timeout_reconciliation=10.0,
        timeout_portfolio=10.0,
        timeout_disconnection=10.0,
        timeout_post_stop=2.0,
    )

    # Instantiate the node with a configuration
    node = TradingNode(config=config_node)

    # Configure your strategy
    config_strat = DataTesterConfig(
        instrument_ids=instrument_ids,
        bar_types=bar_types,
        # subscribe_book_at_interval=True,
        # book_interval_ms=10,
        # subscribe_quotes=True,
        subscribe_trades=True,
        subscribe_mark_prices=True,
        subscribe_index_prices=True,
        subscribe_funding_rates=True,
        # subscribe_bars=True,
        # request_bars=True,
    )
    # Instantiate your strategy
    strategy = DataTester(config=config_strat)

    # Add your actors and modules
    node.trader.add_actor(strategy)

    # Register your client factories with the node (can take user-defined factories)
    node.add_data_client_factory(HYPERLIQUID, HyperliquidLiveDataClientFactory)
    node.build()

    # Stop and dispose of the node with SIGINT/CTRL+C
    if __name__ == "__main__":
        try:
            node.run()
        finally:
            node.dispose()

</document_content>
</document>
<document index="1861">
<source>examples/live/hyperliquid/hyperliquid_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.hyperliquid import HYPERLIQUID
from nautilus_trader.adapters.hyperliquid import HyperliquidDataClientConfig
from nautilus_trader.adapters.hyperliquid import HyperliquidExecClientConfig
from nautilus_trader.adapters.hyperliquid import HyperliquidLiveDataClientFactory
from nautilus_trader.adapters.hyperliquid import HyperliquidLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# *** THIS INTEGRATION IS STILL UNDER CONSTRUCTION. ***
# *** CONSIDER IT TO BE IN AN UNSTABLE BETA PHASE AND EXERCISE CAUTION. ***

# *** HYPERLIQUID TESTNET SETUP ***
# To use Hyperliquid testnet, you need to:
# 1. Get testnet credentials from https://app.hyperliquid-testnet.xyz/
# 2. Set environment variables:
#    - HYPERLIQUID_TESTNET_PK: Your testnet private key (required)
#    - HYPERLIQUID_TESTNET_VAULT: Your testnet vault address (optional)
# 3. Ensure 'testnet=True' is set in both data and exec client configs below
# 4. Run the script: python hyperliquid_exec_tester.py

# Strategy config params
symbol = "BTC-USD-PERP"
instrument_id = InstrumentId.from_str(f"{symbol}.{HYPERLIQUID}")
order_qty = Decimal("0.001")  # Small test order for BTC

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        purge_closed_orders_interval_mins=15,  # Example of purging closed orders for HFT
        purge_closed_orders_buffer_mins=60,  # Purged orders closed for at least an hour
        purge_closed_positions_interval_mins=15,  # Example of purging closed positions for HFT
        purge_closed_positions_buffer_mins=60,  # Purge positions closed for at least an hour
        purge_account_events_interval_mins=15,  # Example of purging account events for HFT
        purge_account_events_lookback_mins=60,  # Purge account events occurring more than an hour ago
        graceful_shutdown_on_exception=True,
    ),
    data_clients={
        HYPERLIQUID: HyperliquidDataClientConfig(
            instrument_provider=InstrumentProviderConfig(load_all=True),
            testnet=True,  # If client uses the testnet
        ),
    },
    exec_clients={
        HYPERLIQUID: HyperliquidExecClientConfig(
            private_key=None,  # 'HYPERLIQUID_TESTNET_PK' env var for testnet
            vault_address=None,  # 'HYPERLIQUID_TESTNET_VAULT' env var (optional)
            instrument_provider=InstrumentProviderConfig(load_all=True),
            testnet=True,  # If client uses the testnet
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    # subscribe_quotes=True,
    # subscribe_trades=True,
    # subscribe_book=False,
    # enable_limit_buys=True,
    # enable_limit_sells=True,
    order_qty=order_qty,
    # open_position_on_start_qty=order_qty,
    # tob_offset_ticks=0,  # Ticks away from top of book (0 = at market)
    use_post_only=True,  # Use post-only orders to get maker fees
    # manage_gtd_expiry=False,
    # cancel_orders_on_stop=True,
    # close_positions_on_stop=True,  # Close all positions when stopping
    # reduce_only_on_stop=True,
    log_data=False,  # Set to True for verbose data logging
)

# Instantiate your strategy
strategy = ExecTester(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(HYPERLIQUID, HyperliquidLiveDataClientFactory)
node.add_exec_client_factory(HYPERLIQUID, HyperliquidLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1862">
<source>examples/live/interactive_brokers/connect_with_dockerized_gateway.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------



import os

from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
from nautilus_trader.adapters.interactive_brokers.common import IBContract
from nautilus_trader.adapters.interactive_brokers.config import DockerizedIBGatewayConfig
from nautilus_trader.adapters.interactive_brokers.config import IBMarketDataTypeEnum
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory
from nautilus_trader.config import LiveDataEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RoutingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.subscribe import SubscribeStrategy
from nautilus_trader.examples.strategies.subscribe import SubscribeStrategyConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# *** THIS INTEGRATION IS STILL UNDER CONSTRUCTION. ***
# *** CONSIDER IT TO BE IN AN UNSTABLE BETA PHASE AND EXERCISE CAUTION. ***

ib_contracts = [
    IBContract(
        secType="STK",
        symbol="SPY",
        exchange="SMART",
        primaryExchange="ARCA",
        build_options_chain=True,
        min_expiry_days=7,
        max_expiry_days=14,
    ),
    IBContract(
        secType="CONTFUT",
        exchange="CME",
        symbol="ES",
        build_futures_chain=True,
    ),
    IBContract(secType="FUT", exchange="NYMEX", localSymbol="CLV7", build_futures_chain=False),
]

dockerized_gateway = DockerizedIBGatewayConfig(
    username=os.environ["TWS_USERNAME"],
    password=os.environ["TWS_PASSWORD"],
    trading_mode="paper",
    read_only_api=True,
)

instrument_provider = InteractiveBrokersInstrumentProviderConfig(
    build_futures_chain=False,
    build_options_chain=False,
    min_expiry_days=10,
    max_expiry_days=60,
    load_ids=frozenset(
        [
            "EUR/USD.IDEALPRO",
            "BTC/USD.PAXOS",
            "SPY.ARCA",
            "V.NYSE",
            "YMH4.CBOT",
            "CLZ7.NYMEX",
            "ESZ7.CME",
        ],
    ),
    load_contracts=frozenset(ib_contracts),
)

# Configure the trading node

config_node = TradingNodeConfig(
    trader_id="TESTER-001",
    logging=LoggingConfig(log_level="INFO"),
    data_clients={
        IB: InteractiveBrokersDataClientConfig(
            ibg_client_id=1,
            handle_revised_bars=False,
            use_regular_trading_hours=True,
            market_data_type=IBMarketDataTypeEnum.DELAYED_FROZEN,  # If unset default is REALTIME
            instrument_provider=instrument_provider,
            dockerized_gateway=dockerized_gateway,
        ),
    },
    exec_clients={
        IB: InteractiveBrokersExecClientConfig(
            ibg_client_id=1,
            account_id="DU123456",  # This must match with the IB Gateway/TWS node is connecting to
            dockerized_gateway=dockerized_gateway,
            instrument_provider=instrument_provider,
            routing=RoutingConfig(
                default=True,
            ),
        ),
    },
    data_engine=LiveDataEngineConfig(
        time_bars_timestamp_on_close=False,  # Will use opening time as `ts_event` (same like IB)
        validate_data_sequence=True,  # Will make sure DataEngine discards any Bars received out of sequence
    ),
    timeout_connection=90.0,
    timeout_reconciliation=5.0,
    timeout_portfolio=5.0,
    timeout_disconnection=5.0,
    timeout_post_stop=2.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strategy_config = SubscribeStrategyConfig(
    instrument_id=InstrumentId.from_str("EUR/USD.IDEALPRO"),
    # book_type=None,
    # snapshots=True,
    trade_ticks=False,
    quote_ticks=True,
    # bars=True,
)
# Instantiate your strategy
strategy = SubscribeStrategy(config=strategy_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(IB, InteractiveBrokersLiveDataClientFactory)
node.add_exec_client_factory(IB, InteractiveBrokersLiveExecClientFactory)
node.build()
node.portfolio.set_specific_venue(IB_VENUE)

# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1863">
<source>examples/live/interactive_brokers/connect_with_tws.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------



from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.config import IBMarketDataTypeEnum
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.config import SymbologyMethod
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory
from nautilus_trader.config import LiveDataEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RoutingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.subscribe import SubscribeStrategy
from nautilus_trader.examples.strategies.subscribe import SubscribeStrategyConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# *** THIS INTEGRATION IS STILL UNDER CONSTRUCTION. ***
# *** CONSIDER IT TO BE IN AN UNSTABLE BETA PHASE AND EXERCISE CAUTION. ***


instrument_provider = InteractiveBrokersInstrumentProviderConfig(
    symbology_method=SymbologyMethod.IB_SIMPLIFIED,
    load_ids=frozenset(
        [
            "EUR/USD.IDEALPRO",
            "BTC/USD.PAXOS",
            "SPY.ARCA",
            "AAPL.NASDAQ",
            "V.NYSE",
            "CLZ8.NYMEX",
            "ESZ8.CME",
        ],
    ),
)

# Configure the trading node

config_node = TradingNodeConfig(
    trader_id="TESTER-001",
    logging=LoggingConfig(log_level="INFO"),
    data_clients={
        IB: InteractiveBrokersDataClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=1,
            handle_revised_bars=False,
            use_regular_trading_hours=True,
            market_data_type=IBMarketDataTypeEnum.DELAYED_FROZEN,  # If unset default is REALTIME
            instrument_provider=instrument_provider,
        ),
    },
    exec_clients={
        IB: InteractiveBrokersExecClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=1,
            account_id="DU123456",  # This must match with the IB Gateway/TWS node is connecting to
            instrument_provider=instrument_provider,
            routing=RoutingConfig(
                default=True,
            ),
        ),
    },
    data_engine=LiveDataEngineConfig(
        time_bars_timestamp_on_close=False,  # Will use opening time as `ts_event` (same like IB)
        validate_data_sequence=True,  # Will make sure DataEngine discards any Bars received out of sequence
    ),
    timeout_connection=90.0,
    timeout_reconciliation=5.0,
    timeout_portfolio=5.0,
    timeout_disconnection=5.0,
    timeout_post_stop=2.0,
)


# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strategy_config = SubscribeStrategyConfig(
    instrument_id=InstrumentId.from_str("EUR/USD.IDEALPRO"),
    trade_ticks=False,
    quote_ticks=True,
    bars=True,
)
# Instantiate your strategy
strategy = SubscribeStrategy(config=strategy_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(IB, InteractiveBrokersLiveDataClientFactory)
node.add_exec_client_factory(IB, InteractiveBrokersLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1864">
<source>examples/live/interactive_brokers/contract_download.py</source>
<document_content>
import asyncio

from nautilus_trader.adapters.interactive_brokers.common import IBContract
from nautilus_trader.adapters.interactive_brokers.historical import HistoricInteractiveBrokersClient


async def main() -> None:
    host: str = "localhost"
    port: int = 7497

    client = HistoricInteractiveBrokersClient(host=host, port=port, log_level="DEBUG")
    await client.connect()
    await asyncio.sleep(1)

    nse_nifty_fut_contract = IBContract(
        secType="FUT",
        exchange="NSE",
        symbol="NIFTY50",
        lastTradeDateOrContractMonth="20250327",
    )
    ce_contract = IBContract(
        secType="OPT",
        exchange="NSE",
        symbol="NIFTY50",
        lastTradeDateOrContractMonth="20250227",
        strike=25000,
        right="C",
        includeExpired=True,
    )
    pe_contract = IBContract(
        secType="OPT",
        exchange="NSE",
        symbol="NIFTY50",
        lastTradeDateOrContractMonth="20250227",
        strike=25000,
        right="P",
        includeExpired=True,
    )
    contracts = [nse_nifty_fut_contract, ce_contract, pe_contract]

    instruments = await client.request_instruments(
        contracts=contracts,
    )
    print(instruments)


if __name__ == "__main__":
    asyncio.run(main())

</document_content>
</document>
<document index="1865">
<source>examples/live/interactive_brokers/historical_download.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
import datetime
import os

from nautilus_trader.adapters.interactive_brokers.common import IBContract
from nautilus_trader.adapters.interactive_brokers.config import DockerizedIBGatewayConfig
from nautilus_trader.adapters.interactive_brokers.gateway import DockerizedIBGateway
from nautilus_trader.adapters.interactive_brokers.historical import HistoricInteractiveBrokersClient
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.persistence.catalog import ParquetDataCatalog


async def main(
    host: str | None = None,
    port: int | None = None,
    dockerized_gateway: DockerizedIBGatewayConfig | None = None,
) -> None:
    if dockerized_gateway:
        PyCondition.none(host, "Ensure `host` is set to None when using DockerizedIBGatewayConfig.")
        PyCondition.none(port, "Ensure `port` is set to None when using DockerizedIBGatewayConfig.")
        PyCondition.type(dockerized_gateway, DockerizedIBGatewayConfig, "dockerized_gateway")
        gateway = DockerizedIBGateway(config=dockerized_gateway)
        gateway.start(dockerized_gateway.timeout)
        host = gateway.host
        port = gateway.port
    else:
        gateway = None
        PyCondition.not_none(
            host,
            "Please provide the `host` IP address for the IB TWS or Gateway.",
        )
        PyCondition.not_none(port, "Please provide the `port` for the IB TWS or Gateway.")

    contract = IBContract(
        secType="STK",
        symbol="AAPL",
        exchange="SMART",
        primaryExchange="NASDAQ",
    )
    instrument_id = "TSLA.NASDAQ"

    client = HistoricInteractiveBrokersClient(host=host, port=port, client_id=5)
    await client.connect()
    await asyncio.sleep(2)

    instruments = await client.request_instruments(
        contracts=[contract],
        instrument_ids=[instrument_id],
    )

    bars = await client.request_bars(
        bar_specifications=["1-HOUR-LAST", "30-MINUTE-MID"],
        start_date_time=datetime.datetime(2025, 11, 6, 9, 30),
        end_date_time=datetime.datetime(2025, 11, 6, 16, 30),
        tz_name="America/New_York",
        contracts=[contract],
        instrument_ids=[instrument_id],
    )

    trade_ticks = await client.request_ticks(
        tick_type="TRADES",
        start_date_time=datetime.datetime(2025, 11, 6, 10, 0),
        end_date_time=datetime.datetime(2025, 11, 6, 10, 1),
        tz_name="America/New_York",
        contracts=[contract],
        instrument_ids=[instrument_id],
    )

    quote_ticks = await client.request_ticks(
        tick_type="BID_ASK",
        start_date_time=datetime.datetime(2025, 11, 6, 10, 0),
        end_date_time=datetime.datetime(2025, 11, 6, 10, 1),
        tz_name="America/New_York",
        contracts=[contract],
        instrument_ids=[instrument_id],
    )

    if gateway:
        gateway.stop()

    catalog = ParquetDataCatalog("./catalog")
    catalog.write_data(instruments)
    catalog.write_data(bars)
    catalog.write_data(trade_ticks)
    catalog.write_data(quote_ticks)


if __name__ == "__main__":
    gateway_config = DockerizedIBGatewayConfig(
        username=os.environ["TWS_USERNAME"],
        password=os.environ["TWS_PASSWORD"],
        trading_mode="paper",
    )
    asyncio.run(main(dockerized_gateway=gateway_config))

    # To connect to an existing TWS or Gateway instance without the use of automated dockerized gateway,
    # follow this format:
    # asyncio.run(main(host="127.0.0.1", port=7497))

</document_content>
</document>
<document index="1866">
<source>examples/live/interactive_brokers/notebooks/run_ratio_spread_1x2_qty3.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.17.3
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %%
# Note: Use the jupytext python extension to be able to open this python file in jupyter as a notebook

# %%
"""
Test 1x2 Ratio Spread with Quantity 3.

This test places a market order for 3 units of a 1x2 ratio spread:
- Long 1 E4DN5 P6350 per spread unit
- Long 2 E4DN5 P6355 per spread unit
- Total order: 3 spread units = Long 3 P6350, Long 6 P6355

This will test the new spread execution functionality and verify:
1. Proper spread instrument creation
2. Order submission and acceptance
3. Fill event handling for ratio spreads
4. Portfolio position tracking

"""

# %%

import os
import threading
import time

from ibapi.common import MarketDataTypeEnum as IBMarketDataTypeEnum

from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.config import SymbologyMethod
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RoutingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.events import OrderAccepted
from nautilus_trader.model.events import OrderFilled
from nautilus_trader.model.events import OrderRejected
from nautilus_trader.model.events import OrderSubmitted
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.trading.config import StrategyConfig
from nautilus_trader.trading.strategy import Strategy


# %%
class RatioSpreadTestConfig(StrategyConfig, frozen=True):
    """
    Configuration for 1x2 ratio spread test.
    """

    spread_instrument_id: InstrumentId


# %%
class RatioSpreadTestStrategy(Strategy):
    """
    Strategy to test 1x2 ratio spread execution with quantity 3.
    """

    def __init__(self, config: RatioSpreadTestConfig):
        super().__init__(config=config)
        self.order_placed = False
        self.execution_events: list[OrderFilled] = []
        self.order_events: list[OrderAccepted | OrderSubmitted | OrderRejected] = []
        self.quote_tick_count = 0
        self.instrument_loaded = False

    def on_start(self):
        """
        Handle strategy start event.
        """
        self.log.info("=" * 80, color=LogColor.BLUE)
        self.log.info(
            "1x2 RATIO SPREAD TEST (Quantity 3) - DYNAMIC LOADING",
            color=LogColor.BLUE,
        )
        self.log.info("=" * 80, color=LogColor.BLUE)

        self.log.info(f"Testing spread: {self.config.spread_instrument_id}")
        self.log.info("Expected execution:")
        self.log.info("  - 3 spread units")
        self.log.info("  - Long 3 contracts of E1AQ5 C6400")
        self.log.info("  - Long 6 contracts of E1AQ5 P6440")

        # Request the spread instrument dynamically (not pre-loaded)
        self.log.info("Requesting spread instrument dynamically...")
        self.request_instrument(self.config.spread_instrument_id)

    def on_instrument(self, instrument):
        """
        Handle instrument response and place order.
        """
        self.log.info(f"Received instrument: {instrument.id}")
        self.log.info(f"Instrument type: {type(instrument)}")

        # Mark instrument as loaded and subscribe to quote ticks
        self.instrument_loaded = True
        self.log.info("Subscribing to quote ticks for spread instrument...")
        self.subscribe_quote_ticks(instrument.id)

        # Place order immediately after getting instrument
        if not self.order_placed:
            self._place_ratio_spread_order(instrument)

    def _place_ratio_spread_order(self, instrument):
        """
        Place a market order for the 1x2 ratio spread.
        """
        self.log.info("=" * 60, color=LogColor.GREEN)
        self.log.info("PLACING 1x2 RATIO SPREAD MARKET ORDER (DAY)", color=LogColor.GREEN)
        self.log.info("=" * 60, color=LogColor.GREEN)

        # Create market order for 3 spread units (DAY required for combo orders)
        order = self.order_factory.market(
            instrument_id=self.config.spread_instrument_id,
            order_side=OrderSide.BUY,  # Buy the spread
            quantity=instrument.make_qty(3),  # 3 spread units
            time_in_force=TimeInForce.DAY,  # DAY required for combo orders by IB
        )

        self.log.info("Order details:")
        self.log.info(f"   Client Order ID: {order.client_order_id}")
        self.log.info(f"   Instrument: {order.instrument_id}")
        self.log.info(f"   Side: {order.side}")
        self.log.info(f"   Quantity: {order.quantity}")
        self.log.info(f"   Order Type: {order.order_type}")

        # Submit the order
        self.submit_order(order)
        self.order_placed = True

        self.log.info(
            "Market order submitted for 1x2 ratio spread",
            color=LogColor.GREEN,
        )

    def on_quote_tick(self, tick):
        """
        Handle quote tick events for the spread instrument.
        """
        self.quote_tick_count += 1

        # Log first few quote ticks to verify subscription is working
        if self.quote_tick_count <= 5:
            self.log.info("=" * 60, color=LogColor.CYAN)
            self.log.info(f"QUOTE TICK #{self.quote_tick_count} RECEIVED", color=LogColor.CYAN)
            self.log.info("=" * 60, color=LogColor.CYAN)
            self.log.info(f"   Instrument: {tick.instrument_id}")
            self.log.info(f"   Bid: {tick.bid_price} @ {tick.bid_size}")
            self.log.info(f"   Ask: {tick.ask_price} @ {tick.ask_size}")
            self.log.info(f"   Spread: {float(tick.ask_price) - float(tick.bid_price):.4f}")
            self.log.info(f"   Event Time: {tick.ts_event}")
        elif self.quote_tick_count == 6:
            self.log.info(
                f"Quote tick subscription working! Received {self.quote_tick_count} ticks so far...",
                color=LogColor.GREEN,
            )
        elif self.quote_tick_count % 10 == 0:
            # Log every 10th tick after the first 5
            self.log.info(
                f"Quote tick #{self.quote_tick_count}: Bid={tick.bid_price}, Ask={tick.ask_price}",
                color=LogColor.CYAN,
            )

    def on_order_submitted(self, event: OrderSubmitted):
        """
        Handle order submitted events.
        """
        self.order_events.append(("SUBMITTED", event))
        self.log.info(
            f"ORDER SUBMITTED: {event.client_order_id} | Account: {event.account_id}",
            color=LogColor.BLUE,
        )

    def on_order_accepted(self, event: OrderAccepted):
        """
        Handle order accepted events.
        """
        self.order_events.append(("ACCEPTED", event))
        self.log.info(
            f"ORDER ACCEPTED: {event.client_order_id} | Venue Order ID: {event.venue_order_id}",
            color=LogColor.GREEN,
        )

    def on_order_rejected(self, event: OrderRejected):
        """
        Handle order rejected events.
        """
        self.order_events.append(("REJECTED", event))
        self.log.error(f"ORDER REJECTED: {event.client_order_id} | Reason: {event.reason}")

    def on_order_filled(self, event: OrderFilled):
        """Handle order filled events - KEY for understanding ratio spread execution."""
        self.execution_events.append(event)

        self.log.info("=" * 80, color=LogColor.MAGENTA)
        self.log.info(f"FILL #{len(self.execution_events)} RECEIVED", color=LogColor.MAGENTA)
        self.log.info("=" * 80, color=LogColor.MAGENTA)

        self.log.info(f"   Client Order ID: {event.client_order_id}")
        self.log.info(f"   Venue Order ID: {event.venue_order_id}")
        self.log.info(f"   Instrument: {event.instrument_id}")
        self.log.info(f"   Order Side: {event.order_side}")
        self.log.info(f"   Fill Quantity: {event.last_qty}")
        self.log.info(f"   Fill Price: {event.last_px}")
        self.log.info(f"   Commission: {event.commission}")
        self.log.info(f"   Trade ID: {event.trade_id}")

        # Analyze fill quantity interpretation
        self._analyze_fill(event)

        # Check portfolio state
        self._check_portfolio_state()

    def _analyze_fill(self, event: OrderFilled):
        """
        Analyze what the fill represents.
        """
        self.log.info("FILL ANALYSIS:", color=LogColor.YELLOW)

        fill_qty = int(event.last_qty.as_double())

        if event.order_side == OrderSide.BUY:
            self.log.info(f"   LONG leg fill: {fill_qty} contracts", color=LogColor.CYAN)
            self.log.info("   Expected: 1 contract per spread unit", color=LogColor.CYAN)
        elif event.order_side == OrderSide.SELL:
            self.log.info(f"   SHORT leg fill: {fill_qty} contracts", color=LogColor.CYAN)
            self.log.info("   Expected: 2 contracts per spread unit", color=LogColor.CYAN)

        # Check if this is spread-level or leg-level fill
        if str(event.instrument_id) == str(self.config.spread_instrument_id):
            self.log.info("   SPREAD-LEVEL FILL", color=LogColor.GREEN)
        else:
            self.log.info(f"   LEG-LEVEL FILL: {event.instrument_id}", color=LogColor.YELLOW)

    def _check_portfolio_state(self):
        """
        Check current portfolio positions.
        """
        self.log.info("PORTFOLIO STATE:", color=LogColor.CYAN)

        cache = self.cache
        all_positions = list(cache.positions_open()) + list(cache.positions_closed())

        if not all_positions:
            self.log.info("   No positions in portfolio")
            return

        for position in all_positions:
            self.log.info(f"   {position.instrument_id}: {position.side} {position.quantity}")

    def on_stop(self):
        """
        Handle strategy stop and provide final analysis.
        """
        self.log.info("\n" + "=" * 80, color=LogColor.BLUE)
        self.log.info("FINAL TEST ANALYSIS", color=LogColor.BLUE)
        self.log.info("=" * 80, color=LogColor.BLUE)

        # Dynamic loading analysis
        self.log.info(
            f"Instrument loaded dynamically: {'YES' if self.instrument_loaded else 'NO'}",
        )
        self.log.info(f"Quote ticks received: {self.quote_tick_count}")

        # Order and execution analysis
        self.log.info(f"Total fills received: {len(self.execution_events)}")
        self.log.info(f"Total order events: {len(self.order_events)}")

        if self.execution_events:
            buy_fills = [e for e in self.execution_events if e.order_side == OrderSide.BUY]
            sell_fills = [e for e in self.execution_events if e.order_side == OrderSide.SELL]

            buy_qty = sum(int(f.last_qty.as_double()) for f in buy_fills)
            sell_qty = sum(int(f.last_qty.as_double()) for f in sell_fills)

            self.log.info(f"BUY fills: {len(buy_fills)} (total qty: {buy_qty})")
            self.log.info(f"SELL fills: {len(sell_fills)} (total qty: {sell_qty})")

            # Expected: 3 long, 6 short for 3 spread units
            self.log.info("Expected for 3 spread units: 3 long, 6 short")

            if buy_qty == 3 and sell_qty == 6:
                self.log.info("EXECUTION MATCHES EXPECTED RATIOS", color=LogColor.GREEN)
            else:
                self.log.info("EXECUTION PATTERN UNCLEAR", color=LogColor.YELLOW)
        else:
            self.log.info("No fills received")


# %%
# Create 1x2 ratio spread
leg1_id = InstrumentId.from_str("E1CU5 P6440.XCME")  # Long put
leg2_id = InstrumentId.from_str("E1CU5 P6450.XCME")  # Short put

spread_id = InstrumentId.new_spread(
    [
        (leg1_id, 1),
        (leg2_id, -1),
    ],
)

print(f"Testing 1x2 ratio spread: {spread_id}")
print("Order: 3 spread units")
print("Expected execution: Long 3 P6350, Long 6 P6355")
print()

# Configure instrument provider (no pre-loaded spread IDs)
instrument_provider = InteractiveBrokersInstrumentProviderConfig(
    symbology_method=SymbologyMethod.IB_SIMPLIFIED,
    convert_exchange_to_mic_venue=True,
    build_futures_chain=False,
    build_options_chain=False,
    min_expiry_days=0,
    max_expiry_days=30,
    # load_ids=frozenset([spread_id]),  # Removed - testing dynamic loading
)

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id="RATIO-SPREAD-TEST",
    logging=LoggingConfig(log_level="INFO"),
    data_clients={
        IB: InteractiveBrokersDataClientConfig(
            ibg_port=7497,
            instrument_provider=instrument_provider,
            market_data_type=IBMarketDataTypeEnum.DELAYED_FROZEN,
        ),
    },
    exec_clients={
        IB: InteractiveBrokersExecClientConfig(
            ibg_port=7497,
            instrument_provider=instrument_provider,
            routing=RoutingConfig(default=True),
            account_id=os.environ.get("TWS_ACCOUNT"),
        ),
    },
    timeout_connection=90.0,
    timeout_reconciliation=5.0,
    timeout_portfolio=5.0,
    timeout_disconnection=5.0,
    timeout_post_stop=2.0,
)

# Create and configure node
node = TradingNode(config=config_node)
strategy_config = RatioSpreadTestConfig(spread_instrument_id=spread_id)
strategy = RatioSpreadTestStrategy(config=strategy_config)

node.trader.add_strategy(strategy)
node.add_data_client_factory(IB, InteractiveBrokersLiveDataClientFactory)
node.add_exec_client_factory(IB, InteractiveBrokersLiveExecClientFactory)
node.build()

# %%
print("Starting 1x2 Ratio Spread Test (Dynamic Loading + Quote Ticks)...")
print("This will:")
print("1. Connect to Interactive Brokers")
print("2. Dynamically request the 1x2 ratio spread instrument (not pre-loaded)")
print("3. Subscribe to quote ticks for the spread")
print("4. Place a market order for 3 spread units")
print("5. Monitor execution events and quote ticks for 60 seconds")
print("6. Auto-stop and analyze results")
print()
print("IMPORTANT: Make sure TWS/IB Gateway is running!")
print("IMPORTANT: This will place a REAL market order in paper trading!")
print()


# %%
def auto_stop_node(node, delay_seconds=15):
    """
    Automatically stop the node after a delay.
    """

    def stop_after_delay():
        time.sleep(delay_seconds)
        node.stop()

    thread = threading.Thread(target=stop_after_delay)
    thread.daemon = True
    thread.start()


# %%
# Start auto-stop timer
auto_stop_node(node, delay_seconds=60)

try:
    node.run()
except KeyboardInterrupt:
    node.stop()
finally:
    node.dispose()

</document_content>
</document>
<document index="1867">
<source>examples/live/interactive_brokers/notebooks/test_bracket_order.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.17.3
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% [markdown]
# Note: Use the jupytext python package to be able to open this python file in jupyter as a notebook.
# Also run `jupytext-config set-default-viewer` to open jupytext python files as notebooks by default.

# %%
import datetime
import os
import sys

import pandas as pd

from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.common import IBContract
from nautilus_trader.adapters.interactive_brokers.common import IBOrderTags
from nautilus_trader.adapters.interactive_brokers.config import IBMarketDataTypeEnum
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.config import SymbologyMethod
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory
from nautilus_trader.common.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig

# from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.live.config import LiveDataEngineConfig
from nautilus_trader.live.config import RoutingConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model import BarType
from nautilus_trader.model import TraderId
from nautilus_trader.model.enums import ContingencyType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import OrderType
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.enums import TriggerType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.orders import OrderList
from nautilus_trader.trading import Strategy
from nautilus_trader.trading.config import StrategyConfig


# %%
class Strat_mre_config(StrategyConfig, frozen=True):
    tradable_instrument_id: str | None = "NQZ5.CME"


class Strat_mre(Strategy):
    def __init__(self, config: Strat_mre_config) -> None:
        super().__init__(config)
        self.bar_type_m1: dict[InstrumentId, BarType] = {}
        self.tradable_instrument_id = config.tradable_instrument_id

    def on_start(self) -> None:
        self.log.info(f"instrument_id in cache : {self.cache.instrument_ids()}")
        self.log.info(f"instruments in cache : {self.cache.instruments()}")

        for instrument in self.cache.instruments():
            if str(instrument.id) == self.tradable_instrument_id:
                self.log.info(
                    f"instrument {instrument.info['contract']['tradingClass']}: \n{instrument}",
                )
                self.bar_type_m1[instrument.id] = BarType.from_str(
                    str(instrument.id) + "-1-MINUTE-LAST-EXTERNAL",
                )
                self.log.info(f"subscribing to : {self.bar_type_m1[instrument.id]}")
                # self.subscribe_bars(self.bar_type_m1[instrument.id])

                self.buy_bracket(instrument.id, instrument.make_price(6650))

                self.clock.set_time_alert(
                    "sl",
                    self.clock.utc_now() + pd.Timedelta(seconds=10),
                    lambda event, instrument=instrument: self.modify_sl(instrument.id, instrument.make_price(6600)),
                )

    def buy_bracket(self, instrument_id, low):
        instrument = self.cache.instrument(instrument_id)

        if not instrument:
            self.log.error(f"No instrument loaded for instrument id : {instrument_id}")
            sys.exit(1)

        order_list: OrderList = self.order_factory.bracket(
            instrument_id=instrument_id,
            order_side=OrderSide.BUY,
            quantity=instrument.make_qty(2),
            time_in_force=TimeInForce.GTC,
            entry_post_only=False,
            contingency_type=ContingencyType.OCO,
            sl_trigger_price=instrument.make_price(low - 10),
            sl_tags=[IBOrderTags(outsideRth=True).value],
            tp_order_type=OrderType.LIMIT,
            tp_price=instrument.make_price(low * 2),
            tp_post_only=False,
            entry_order_type=OrderType.MARKET,
            emulation_trigger=TriggerType.NO_TRIGGER,
        )
        self.log.info(f"orderlist : {order_list}")
        self.submit_order_list(order_list)

    def modify_sl(self, instrument_id, low):
        sl_order = self.get_sl_order(instrument_id)
        self.log.info(f"modifying sl order for {instrument_id} to : {low}")
        self.modify_order(sl_order, trigger_price=low)

    def get_sl_order(self, instrument_id):
        list_orders_for_instrument = self.cache.orders(instrument_id=instrument_id)

        for _order in list_orders_for_instrument:
            if _order.is_open and _order.order_type == 3:
                return _order

        self.log.error(
            f"Error : sl not found for instrument {instrument_id}\n list of orders found : {list_orders_for_instrument}",
        )
        sys.exit(1)

    # def on_bar(self, bar: Bar) -> None:
    #     dt_utc_now = self.clock().utc_now()

    #     if dt_utc_now - pd.Timedelta(seconds=90) > unix_nanos_to_dt(bar.ts_event):
    #         self.log.error(
    #             f"histo bar reception \n{bar}\n dt now : {dt_utc_now} bar dt: {unix_nanos_to_dt(bar.ts_event)}")
    #         return

    #     self.log.info(f"bar : {bar}")
    #     instrument_id = bar.bar_type.instrument_id

    #     if str(instrument_id) != self.tradable_instrument_id:
    #         return

    #     if not self.portfolio.is_flat(instrument_id):
    #         self.modify_sl(instrument_id, bar.low)
    #     else:
    #         self.buy_bracket(instrument_id, bar.low)


# %%
es_contract = IBContract(
    secType="FUT",
    exchange="CME",
    localSymbol="ESZ5",
    lastTradeDateOrContractMonth="20251219",
)

contracts = [es_contract]
tradable_instrument_id = "ESZ5.CME"


# Configure the trading node
instrument_provider = InteractiveBrokersInstrumentProviderConfig(
    load_contracts=frozenset(contracts),
    symbology_method=SymbologyMethod.IB_SIMPLIFIED,
)

config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        log_level_file="INFO",
        log_file_name=datetime.datetime.strftime(
            datetime.datetime.now(tz=datetime.UTC),
            "%Y-%m-%d_%H-%M",
        )
        + "_mre_modify_order.log",
        log_directory="./logs/",
        print_config=True,
    ),
    data_clients={
        IB: InteractiveBrokersDataClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=9003,
            market_data_type=IBMarketDataTypeEnum.DELAYED_FROZEN,
            instrument_provider=instrument_provider,
            use_regular_trading_hours=False,
        ),
    },
    exec_clients={
        IB: InteractiveBrokersExecClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=9003,
            account_id=os.environ.get("TWS_ACCOUNT"),
            instrument_provider=instrument_provider,
            routing=RoutingConfig(
                default=True,
            ),
        ),
    },
    data_engine=LiveDataEngineConfig(
        time_bars_timestamp_on_close=False,  # Will use opening time as `ts_event` (same like IB)
        validate_data_sequence=True,  # Will make sure DataEngine discards any Bars received out of sequence
        time_bars_build_with_no_updates=False,
    ),
)
strat_config = Strat_mre_config(tradable_instrument_id=tradable_instrument_id)
# Instantiate your strategy
strategy = Strat_mre(config=strat_config)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(IB, InteractiveBrokersLiveDataClientFactory)
node.add_exec_client_factory(IB, InteractiveBrokersLiveExecClientFactory)
node.build()

# %%
node.run()

# %%
node.stop()

# %%
node.dispose()

# %%

</document_content>
</document>
<document index="1868">
<source>examples/live/interactive_brokers/notebooks/test_oca_group.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.17.3
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% [markdown]
# Note: Use the jupytext python package to be able to open this python file in jupyter as a notebook.
# Also run `jupytext-config set-default-viewer` to open jupytext python files as notebooks by default.

# %%
import datetime
import os
import sys

import pandas as pd

from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.common import IBContract
from nautilus_trader.adapters.interactive_brokers.common import IBOrderTags
from nautilus_trader.adapters.interactive_brokers.config import IBMarketDataTypeEnum
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.config import SymbologyMethod
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory
from nautilus_trader.common.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig

# from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.live.config import LiveDataEngineConfig
from nautilus_trader.live.config import RoutingConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model import BarType
from nautilus_trader.model import TraderId
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import OrderType
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.trading import Strategy
from nautilus_trader.trading.config import StrategyConfig


# %%
class Strat_oca_test_config(StrategyConfig, frozen=True):
    tradable_instrument_id: str | None = "ESZ5.CME"


class Strat_oca_test(Strategy):
    def __init__(self, config: Strat_oca_test_config) -> None:
        super().__init__(config)
        self.bar_type_m1: dict[InstrumentId, BarType] = {}
        self.tradable_instrument_id = config.tradable_instrument_id

    def on_start(self) -> None:
        self.log.info(f"instrument_id in cache : {self.cache.instrument_ids()}")
        self.log.info(f"instruments in cache : {self.cache.instruments()}")

        for instrument in self.cache.instruments():
            if str(instrument.id) == self.tradable_instrument_id:
                self.log.info(
                    f"instrument {instrument.info['contract']['tradingClass']}: \n{instrument}",
                )
                self.bar_type_m1[instrument.id] = BarType.from_str(
                    str(instrument.id) + "-1-MINUTE-LAST-EXTERNAL",
                )
                self.log.info(f"subscribing to : {self.bar_type_m1[instrument.id]}")
                # self.subscribe_bars(self.bar_type_m1[instrument.id])

                # Test explicit OCA groups - create two separate orders with explicit OCA group
                self.create_oca_orders(instrument.id)

                self.clock.set_time_alert(
                    "modify_test",
                    self.clock.utc_now() + pd.Timedelta(seconds=10),
                    lambda event, instrument=instrument: self.test_oca_modification(instrument.id),
                )

    def create_oca_orders(self, instrument_id):
        """
        Create two separate orders with explicit OCA group to test OCA functionality.
        """
        instrument = self.cache.instrument(instrument_id)

        if not instrument:
            self.log.error(f"No instrument loaded for instrument id : {instrument_id}")
            sys.exit(1)

        # Create explicit OCA group name
        oca_group_name = f"TEST_OCA_{self.clock.utc_now().strftime('%H%M%S')}"

        # Create first order with explicit OCA group
        order1 = self.order_factory.stop_market(
            instrument_id=instrument_id,
            order_side=OrderSide.SELL,
            quantity=instrument.make_qty(1),
            trigger_price=instrument.make_price(6600),
            time_in_force=TimeInForce.GTC,
            tags=[
                IBOrderTags(ocaGroup=oca_group_name, ocaType=1).value,
            ],  # ocaType=1 means cancel all others
        )

        # Create second order with same OCA group
        order2 = self.order_factory.limit(
            instrument_id=instrument_id,
            order_side=OrderSide.SELL,
            quantity=instrument.make_qty(1),
            price=instrument.make_price(6800),
            time_in_force=TimeInForce.GTC,
            tags=[IBOrderTags(ocaGroup=oca_group_name, ocaType=1).value],  # Same OCA group
        )

        self.log.info(f"Creating OCA orders with group: {oca_group_name}")
        self.log.info(f"Order 1 (Stop): {order1}")
        self.log.info(f"Order 2 (Limit): {order2}")

        # Submit both orders
        self.submit_order(order1)
        self.submit_order(order2)

    def test_oca_modification(self, instrument_id):
        """
        Test if we can modify orders that are part of explicit OCA groups.
        """
        instrument = self.cache.instrument(instrument_id)
        list_orders_for_instrument = self.cache.orders(instrument_id=instrument_id)

        self.log.info(f"Testing OCA modification for {instrument_id}")
        self.log.info(f"Found {len(list_orders_for_instrument)} orders")

        # Find the stop order to modify
        stop_order = None
        for order in list_orders_for_instrument:
            if order.is_open and order.order_type == OrderType.STOP_MARKET:
                stop_order = order
                break

        if stop_order:
            new_trigger_price = instrument.make_price(6550)
            self.log.info(
                f"Attempting to modify OCA stop order from {stop_order.trigger_price} to {new_trigger_price}",
            )
            try:
                self.modify_order(stop_order, trigger_price=new_trigger_price)
                self.log.info("OCA order modification command sent successfully")
            except Exception as e:
                self.log.error(f"Failed to modify OCA order: {e}")
        else:
            self.log.error("No stop order found to modify")


# %%
es_contract = IBContract(
    secType="FUT",
    exchange="CME",
    localSymbol="ESZ5",
    lastTradeDateOrContractMonth="20251219",
)

contracts = [es_contract]
tradable_instrument_id = "ESZ5.CME"


# Configure the trading node
instrument_provider = InteractiveBrokersInstrumentProviderConfig(
    load_contracts=frozenset(contracts),
    symbology_method=SymbologyMethod.IB_SIMPLIFIED,
)

config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        log_level_file="INFO",
        log_file_name=datetime.datetime.strftime(
            datetime.datetime.now(tz=datetime.UTC),
            "%Y-%m-%d_%H-%M",
        )
        + "_oca_test.log",
        log_directory="./logs/",
        print_config=True,
    ),
    data_clients={
        IB: InteractiveBrokersDataClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=9004,  # Different client ID to avoid conflicts
            market_data_type=IBMarketDataTypeEnum.DELAYED_FROZEN,
            instrument_provider=instrument_provider,
            use_regular_trading_hours=False,
        ),
    },
    exec_clients={
        IB: InteractiveBrokersExecClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=9004,  # Different client ID to avoid conflicts
            account_id=os.environ.get("TWS_ACCOUNT"),
            instrument_provider=instrument_provider,
            routing=RoutingConfig(
                default=True,
            ),
        ),
    },
    data_engine=LiveDataEngineConfig(
        time_bars_timestamp_on_close=False,  # Will use opening time as `ts_event` (same like IB)
        validate_data_sequence=True,  # Will make sure DataEngine discards any Bars received out of sequence
        time_bars_build_with_no_updates=False,
    ),
)
strat_config = Strat_oca_test_config(tradable_instrument_id=tradable_instrument_id)
# Instantiate your strategy
strategy = Strat_oca_test(config=strat_config)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(IB, InteractiveBrokersLiveDataClientFactory)
node.add_exec_client_factory(IB, InteractiveBrokersLiveExecClientFactory)
node.build()

# %%
node.run()

# %%
node.stop()

# %%
node.dispose()

# %%

</document_content>
</document>
<document index="1869">
<source>examples/live/interactive_brokers/notebooks/test_simple_conditions.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.17.3
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %% [markdown]
# Note: Use the jupytext python package to be able to open this python file in jupyter as a notebook.
# Also run `jupytext-config set-default-viewer` to open jupytext python files as notebooks by default.

# %%
import datetime
import os

from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.common import IBContract
from nautilus_trader.adapters.interactive_brokers.common import IBOrderTags
from nautilus_trader.adapters.interactive_brokers.config import IBMarketDataTypeEnum
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.config import SymbologyMethod
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory
from nautilus_trader.common.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.core.uuid import UUID4
from nautilus_trader.live.config import LiveDataEngineConfig
from nautilus_trader.live.config import RoutingConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model import BarType
from nautilus_trader.model import TraderId
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.orders import LimitOrder
from nautilus_trader.trading import Strategy
from nautilus_trader.trading.config import StrategyConfig


# %%
class SimpleConditionsConfig(StrategyConfig, frozen=True):
    tradable_instrument_id: str | None = "ESZ5.CME"


class SimpleConditionsStrategy(Strategy):
    def __init__(self, config: SimpleConditionsConfig) -> None:
        super().__init__(config)
        self.bar_type_m1: dict[InstrumentId, BarType] = {}
        self.tradable_instrument_id = config.tradable_instrument_id
        self.order_count = 0

    def on_start(self) -> None:
        self.log.info(f"instrument_id in cache : {self.cache.instrument_ids()}")
        self.log.info(f"instruments in cache : {self.cache.instruments()}")

        for instrument in self.cache.instruments():
            if str(instrument.id) == self.tradable_instrument_id:
                self.log.info(
                    f"instrument {instrument.info['contract']['tradingClass']}: \n{instrument}",
                )

                # Test all condition types
                self.test_volume_condition_order(instrument)
                self.test_time_condition_order(instrument)
                self.test_execution_condition_order(instrument)
                self.test_margin_condition_order(instrument)
                self.test_percent_change_condition_order(instrument)
                self.test_price_condition_order(instrument)

    def test_price_condition_order(self, instrument):
        """
        Test a simple limit order with price condition.
        """
        self.order_count += 1

        # Get the actual contract ID from the instrument
        contract_id = instrument.info.get("contract", {}).get("conId", 495512563)

        # Price condition: trigger when ES goes above 6000
        price_condition = {
            "type": "price",
            "conId": contract_id,  # Use actual ES contract ID
            "exchange": "CME",
            "isMore": True,
            "price": 6000.0,
            "triggerMethod": 0,
            "conjunction": "and",
        }

        order_tags = IBOrderTags(
            conditions=[price_condition],
            conditionsCancelOrder=False,  # Transmit order when condition is met
        )

        order = LimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=instrument.id,
            client_order_id=self.order_factory.generate_client_order_id(),
            order_side=OrderSide.BUY,
            quantity=instrument.make_qty(1),
            price=instrument.make_price(5950),  # Below current market
            init_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            time_in_force=TimeInForce.GTC,
            tags=[order_tags.value],
        )

        self.log.info(f"Submitting PRICE CONDITION order: {order}")
        self.submit_order(order)

    def test_time_condition_order(self, instrument):
        """
        Test a simple limit order with time condition.
        """
        self.order_count += 1

        # Time condition: trigger 5 minutes from now
        # IB accepts two formats:
        # 1. "yyyymmdd hh:mm:ss US/Eastern" (with timezone)
        # 2. "yyyymmddd-hh:mm:ss" (UTC with dash)
        future_time = datetime.datetime.now() + datetime.timedelta(minutes=5)

        # Try UTC format with dash (as mentioned in IB error message)
        time_str = future_time.strftime("%Y%m%d-%H:%M:%S")
        self.log.info(f"Time condition string (UTC format): '{time_str}'")

        time_condition = {
            "type": "time",
            "time": time_str,
            "isMore": True,
            "conjunction": "and",
        }

        order_tags = IBOrderTags(
            conditions=[time_condition],
            conditionsCancelOrder=False,
        )

        order = LimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=instrument.id,
            client_order_id=self.order_factory.generate_client_order_id(),
            order_side=OrderSide.SELL,
            quantity=instrument.make_qty(1),
            price=instrument.make_price(6100),  # Above current market
            init_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            time_in_force=TimeInForce.GTC,
            tags=[order_tags.value],
        )

        self.log.info(f"Submitting TIME CONDITION order (triggers at {time_str}): {order}")
        self.submit_order(order)

    def test_volume_condition_order(self, instrument):
        """
        Test a simple limit order with volume condition.
        """
        self.order_count += 1

        # Get the actual contract ID from the instrument
        contract_id = instrument.info.get("contract", {}).get("conId", 495512563)

        # Volume condition: trigger when volume exceeds 100,000
        volume_condition = {
            "type": "volume",
            "conId": contract_id,  # Use actual ES contract ID
            "exchange": "CME",
            "isMore": True,
            "volume": 100000,
            "conjunction": "and",
        }

        order_tags = IBOrderTags(
            conditions=[volume_condition],
            conditionsCancelOrder=True,  # Cancel order when condition is met
        )

        order = LimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=instrument.id,
            client_order_id=self.order_factory.generate_client_order_id(),
            order_side=OrderSide.BUY,
            quantity=instrument.make_qty(1),
            price=instrument.make_price(5900),  # Below current market
            init_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            time_in_force=TimeInForce.GTC,
            tags=[order_tags.value],
        )

        self.log.info(f"Submitting VOLUME CONDITION order: {order}")
        self.submit_order(order)

    def test_execution_condition_order(self, instrument):
        """
        Test a simple limit order with execution condition.
        """
        self.order_count += 1

        # Execution condition: trigger when another symbol executes
        execution_condition = {
            "type": "execution",
            "symbol": "SPY",
            "secType": "STK",
            "exchange": "SMART",
            "conjunction": "and",
        }

        order_tags = IBOrderTags(
            conditions=[execution_condition],
            conditionsCancelOrder=False,
        )

        order = LimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=instrument.id,
            client_order_id=self.order_factory.generate_client_order_id(),
            order_side=OrderSide.BUY,
            quantity=instrument.make_qty(1),
            price=instrument.make_price(5800),  # Below current market
            init_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            time_in_force=TimeInForce.GTC,
            tags=[order_tags.value],
        )

        self.log.info(f"Submitting EXECUTION CONDITION order: {order}")
        self.submit_order(order)

    def test_margin_condition_order(self, instrument):
        """
        Test a simple limit order with margin condition.
        """
        self.order_count += 1

        # Margin condition: trigger when margin cushion is greater than 75%
        margin_condition = {
            "type": "margin",
            "percent": 75,
            "isMore": True,
            "conjunction": "and",
        }

        order_tags = IBOrderTags(
            conditions=[margin_condition],
            conditionsCancelOrder=False,
        )

        order = LimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=instrument.id,
            client_order_id=self.order_factory.generate_client_order_id(),
            order_side=OrderSide.BUY,
            quantity=instrument.make_qty(1),
            price=instrument.make_price(5700),  # Below current market
            init_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            time_in_force=TimeInForce.GTC,
            tags=[order_tags.value],
        )

        self.log.info(f"Submitting MARGIN CONDITION order: {order}")
        self.submit_order(order)

    def test_percent_change_condition_order(self, instrument):
        """
        Test a simple limit order with percent change condition.
        """
        self.order_count += 1

        # Get contract ID from instrument
        contract_id = instrument.info.get("contract", {}).get("conId", 495512563)

        # Percent change condition: trigger when contract increases by 5%
        percent_change_condition = {
            "type": "percent_change",
            "conId": contract_id,
            "exchange": "CME",
            "changePercent": 5.0,
            "isMore": True,
            "conjunction": "and",
        }

        order_tags = IBOrderTags(
            conditions=[percent_change_condition],
            conditionsCancelOrder=False,
        )

        order = LimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=instrument.id,
            client_order_id=self.order_factory.generate_client_order_id(),
            order_side=OrderSide.BUY,
            quantity=instrument.make_qty(1),
            price=instrument.make_price(5600),  # Below current market
            init_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            time_in_force=TimeInForce.GTC,
            tags=[order_tags.value],
        )

        self.log.info(f"Submitting PERCENT CHANGE CONDITION order: {order}")
        self.submit_order(order)

    def on_order_submitted(self, event):
        self.log.info(f"Order submitted: {event}")

    def on_order_accepted(self, event):
        self.log.info(f"Order accepted: {event}")

    def on_order_rejected(self, event):
        self.log.error(f"Order rejected: {event}")

    def on_order_canceled(self, event):
        self.log.info(f"Order canceled: {event}")

    def on_order_filled(self, event):
        self.log.info(f"Order filled: {event}")


# %%
es_contract = IBContract(
    secType="FUT",
    exchange="CME",
    localSymbol="ESZ5",
    lastTradeDateOrContractMonth="20251219",
)

contracts = [es_contract]
tradable_instrument_id = "ESZ5.CME"


# Configure the trading node
instrument_provider = InteractiveBrokersInstrumentProviderConfig(
    load_contracts=frozenset(contracts),
    symbology_method=SymbologyMethod.IB_SIMPLIFIED,
)

config_node = TradingNodeConfig(
    trader_id=TraderId("CONDITIONS-TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        log_level_file="INFO",
        log_file_name=datetime.datetime.strftime(
            datetime.datetime.now(tz=datetime.UTC),
            "%Y-%m-%d_%H-%M",
        )
        + "_simple_conditions_test.log",
        log_directory="./logs/",
        print_config=True,
    ),
    data_clients={
        IB: InteractiveBrokersDataClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=9005,  # Different client ID
            market_data_type=IBMarketDataTypeEnum.DELAYED_FROZEN,
            instrument_provider=instrument_provider,
            use_regular_trading_hours=False,
        ),
    },
    exec_clients={
        IB: InteractiveBrokersExecClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=9005,  # Different client ID
            account_id=os.environ.get("TWS_ACCOUNT"),
            instrument_provider=instrument_provider,
            routing=RoutingConfig(
                default=True,
            ),
        ),
    },
    data_engine=LiveDataEngineConfig(
        time_bars_timestamp_on_close=False,
        validate_data_sequence=True,
        time_bars_build_with_no_updates=False,
    ),
)

strat_config = SimpleConditionsConfig(tradable_instrument_id=tradable_instrument_id)
strategy = SimpleConditionsStrategy(config=strat_config)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node
node.add_data_client_factory(IB, InteractiveBrokersLiveDataClientFactory)
node.add_exec_client_factory(IB, InteractiveBrokersLiveExecClientFactory)
node.build()

# %%
node.run()

# %%
# node.stop()

# %%
# node.dispose()

# %%

</document_content>
</document>
<document index="1870">
<source>examples/live/interactive_brokers/notebooks/with_databento_instrument_id.py</source>
<document_content>
# ---
# jupyter:
#   jupytext:
#     formats: py:percent
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.18.1
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# %%
# Note: Use the jupytext python extension to be able to open this python file in jupyter as a notebook

# %%
import os
import threading
import time

from ibapi.common import MarketDataTypeEnum as IBMarketDataTypeEnum

from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.config import SymbologyMethod
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import CacheConfig
from nautilus_trader.config import DatabaseConfig
from nautilus_trader.config import LiveDataEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RoutingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.events import PositionOpened
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.trading.config import StrategyConfig
from nautilus_trader.trading.strategy import Strategy


# %%
class DemoStrategyConfig(StrategyConfig, frozen=True):
    bar_type: BarType
    instrument_id: InstrumentId


class DemoStrategy(Strategy):
    def __init__(self, config: DemoStrategyConfig):
        super().__init__(config=config)

        # Track if we've already placed an order
        self.order_placed = False

        # Track total bars seen
        self.count_of_bars: int = 0
        self.show_portfolio_at_bar: int | None = 0

    def on_start(self):
        """
        Handle strategy start event.
        """
        self.request_instrument(self.config.instrument_id)

        # self.request_instruments(
        #     venue=IB_VENUE,
        #     params={
        #         "ib_contracts": (
        #             {
        #                 "secType": "CONTFUT",
        #                 "exchange": "CME",
        #                 "symbol": "ES",
        #                 "build_futures_chain": True,
        #                 "build_options_chain": True,
        #                 "min_expiry_days": 10,
        #                 "max_expiry_days": 11,
        #             },
        #         ),
        #     },
        # )

    def on_instrument(self, instrument):
        self.log.info(f"Instrument ID: {instrument.id}")

        self.instrument = self.cache.instrument(self.config.instrument_id)

        # utc_now = self._clock.utc_now()
        # start = utc_now - pd.Timedelta(
        #     minutes=30,
        # )
        # self.request_bars(
        #     BarType.from_str(f"{self.config.instrument_id}-1-MINUTE-LAST-EXTERNAL"),
        #     start,
        # )

        # utc_now = self.clock.utc_now()
        # self.subscribe_bars(self.config.bar_type, params={"start_ns":(utc_now - pd.Timedelta(minutes=2)).value})

        # Prepare values for order
        last_price = self.instrument.make_price(46745)
        tick_size = self.instrument.price_increment
        profit_price = self.instrument.make_price(last_price + (10 * tick_size))
        stoploss_price = self.instrument.make_price(last_price - (10 * tick_size))

        # Create BUY MARKET order with PT and SL (both 10 ticks)
        bracket_order_list = self.order_factory.bracket(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(1),  # Trade size: 1 contract
            time_in_force=TimeInForce.GTC,
            tp_price=profit_price,
            sl_trigger_price=stoploss_price,
            entry_post_only=False,
            tp_post_only=False,
        )

        # Submit order and remember it
        self.submit_order_list(bracket_order_list)
        self.order_placed = True
        self.log.info(f"Submitted bracket order: {bracket_order_list}", color=LogColor.GREEN)

    def on_bar(self, bar: Bar):
        """
        Handle new bar event.
        """
        # Increment total bars seen
        self.count_of_bars += 1

        # Show portfolio state if we reached target bar
        if self.show_portfolio_at_bar == self.count_of_bars:
            self.show_portfolio_info("Portfolio state (2 minutes after position opened)")

        # Only place one order for demonstration
        if not self.order_placed:
            # Prepare values for order
            last_price = bar.close
            tick_size = self.instrument.price_increment
            profit_price = self.instrument.make_price(last_price + (10 * tick_size))
            stoploss_price = self.instrument.make_price(last_price - (10 * tick_size))

            # Create BUY MARKET order with PT and SL (both 10 ticks)
            bracket_order_list = self.order_factory.bracket(
                instrument_id=self.config.instrument_id,
                order_side=OrderSide.BUY,
                quantity=self.instrument.make_qty(1),  # Trade size: 1 contract
                time_in_force=TimeInForce.GTC,
                tp_price=profit_price,
                sl_trigger_price=stoploss_price,
                entry_post_only=False,
                tp_post_only=False,
            )

            # Submit order and remember it
            self.submit_order_list(bracket_order_list)
            self.order_placed = True
            self.log.info(f"Submitted bracket order: {bracket_order_list}", color=LogColor.GREEN)

    def on_position_opened(self, event: PositionOpened):
        """
        Handle position opened event.
        """
        # Log position details
        self.log.info(f"Position opened: {event}", color=LogColor.GREEN)

        # Show portfolio state when position is opened
        self.show_portfolio_info("Portfolio state (In position):")

        # Set target bar number for next portfolio display
        self.show_portfolio_at_bar = self.count_of_bars + 2  # Show after 2 bars

    def on_stop(self):
        """
        Handle strategy stop event.
        """
        # Show final portfolio state
        self.show_portfolio_info("Portfolio state (After trade)")

    def show_portfolio_info(self, intro_message: str = ""):
        """
        Display current portfolio information.
        """
        if intro_message:
            self.log.info(f"====== {intro_message} ======")

        # POSITION information
        self.log.info("Portfolio -> Position information:", color=LogColor.BLUE)
        is_flat = self.portfolio.is_flat(self.config.instrument_id)
        self.log.info(f"Is flat: {is_flat}", color=LogColor.BLUE)

        net_position = self.portfolio.net_position(self.config.instrument_id)
        self.log.info(f"Net position: {net_position} contract(s)", color=LogColor.BLUE)

        net_exposure = self.portfolio.net_exposure(self.config.instrument_id)
        self.log.info(f"Net exposure: {net_exposure}", color=LogColor.BLUE)

        # -----------------------------------------------------

        # P&L information
        self.log.info("Portfolio -> P&L information:", color=LogColor.YELLOW)

        realized_pnl = self.portfolio.realized_pnl(self.config.instrument_id)
        self.log.info(f"Realized P&L: {realized_pnl}", color=LogColor.YELLOW)

        unrealized_pnl = self.portfolio.unrealized_pnl(self.config.instrument_id)
        self.log.info(f"Unrealized P&L: {unrealized_pnl}", color=LogColor.YELLOW)

        # -----------------------------------------------------

        self.log.info("Portfolio -> Account information:", color=LogColor.CYAN)
        margins_init = self.portfolio.margins_init(IB_VENUE)
        self.log.info(f"Initial margin: {margins_init}", color=LogColor.CYAN)

        margins_maint = self.portfolio.margins_maint(IB_VENUE)
        self.log.info(f"Maintenance margin: {margins_maint}", color=LogColor.CYAN)

        balances_locked = self.portfolio.balances_locked(IB_VENUE)
        self.log.info(f"Locked balance: {balances_locked}", color=LogColor.CYAN)


# %%
# Tested instrument id
instrument_id = "YMZ5.XCBT"  # "^SPX.XCBO", "ES.XCME", "AAPL.XNAS", "YMU5.XCBT"

instrument_provider_config = InteractiveBrokersInstrumentProviderConfig(
    symbology_method=SymbologyMethod.IB_SIMPLIFIED,
    convert_exchange_to_mic_venue=True,
    build_futures_chain=False,
    build_options_chain=False,
    min_expiry_days=0,
    max_expiry_days=5,
    load_ids=frozenset(
        [
            instrument_id,
        ],
    ),
)

ib_data_client_config = InteractiveBrokersDataClientConfig(
    ibg_port=7497,
    handle_revised_bars=False,
    use_regular_trading_hours=False,
    instrument_provider=instrument_provider_config,
    market_data_type=IBMarketDataTypeEnum.DELAYED_FROZEN,
)

ib_exec_client_config = InteractiveBrokersExecClientConfig(
    ibg_port=7497,
    instrument_provider=instrument_provider_config,
    routing=RoutingConfig(default=True),
    account_id=os.environ.get("TWS_ACCOUNT"),
)

database_config = DatabaseConfig(
    host="localhost",
    port=6379,
)

cache_config = CacheConfig(
    database=database_config,
    encoding="json",
)

data_engine_config = LiveDataEngineConfig(
    time_bars_timestamp_on_close=False,  # Will use opening time as `ts_event` (same as IB)
    validate_data_sequence=True,  # Will make sure DataEngine discards any Bars received out of sequence
)

logging_config = LoggingConfig(log_level="INFO")

# Configure the trading node
# IMPORTANT: you must use the imported IB variable so this client works properly
config_node = TradingNodeConfig(
    trader_id="TESTER-001",
    logging=logging_config,
    cache=cache_config,
    data_clients={IB: ib_data_client_config},
    exec_clients={IB: ib_exec_client_config},
    data_engine=data_engine_config,
    timeout_connection=90.0,
    timeout_reconciliation=5.0,
    timeout_portfolio=5.0,
    timeout_disconnection=5.0,
    timeout_post_stop=2.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Instantiate your strategy
strategy_config = DemoStrategyConfig(
    bar_type=BarType.from_str(f"{instrument_id}-1-MINUTE-LAST-EXTERNAL"),
    instrument_id=InstrumentId.from_str(instrument_id),
)
strategy = DemoStrategy(config=strategy_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(IB, InteractiveBrokersLiveDataClientFactory)
node.add_exec_client_factory(IB, InteractiveBrokersLiveExecClientFactory)
node.build()


# %%
def auto_stop_node(node, delay_seconds=15):
    """
    Automatically stop the node after a delay.
    """

    def stop_after_delay():
        time.sleep(delay_seconds)
        node.stop()

    thread = threading.Thread(target=stop_after_delay)
    thread.daemon = True
    thread.start()


# %%
node.run()

# %%
# # Start auto-stop timer
# # auto_stop_node(node, delay_seconds=60)

# try:
#     node.run()
# except KeyboardInterrupt:
#     node.stop()
# finally:
#     node.dispose()

# %%
# node.trader.strategies()[0].on_bar(2)

# %%
# # ?node.*

# %%

</document_content>
</document>
<document index="1871">
<source>examples/live/interactive_brokers/with_databento_client.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------



from nautilus_trader.adapters.databento import DATABENTO
from nautilus_trader.adapters.databento import DatabentoDataClientConfig
from nautilus_trader.adapters.databento import DatabentoLiveDataClientFactory
from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersExecClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.config import SymbologyMethod
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import RoutingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.subscribe import SubscribeStrategy
from nautilus_trader.examples.strategies.subscribe import SubscribeStrategyConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# *** THIS INTEGRATION IS STILL UNDER CONSTRUCTION. ***
# *** CONSIDER IT TO BE IN AN UNSTABLE BETA PHASE AND EXERCISE CAUTION. ***

instrument_ids = [
    InstrumentId.from_str("SPY.XNAS"),
    InstrumentId.from_str("AAPL.XNAS"),
    InstrumentId.from_str("V.XNAS"),
    InstrumentId.from_str("CLZ8.GLBX"),
    InstrumentId.from_str("ESZ8.GLBX"),
    InstrumentId.from_str("TFMG7.NDEX"),
    InstrumentId.from_str("CN5.IFEU"),
    InstrumentId.from_str("GH5.IFEU"),
]

# Configure the trading node

config_node = TradingNodeConfig(
    trader_id="TESTER-001",
    logging=LoggingConfig(log_level="INFO"),
    data_clients={
        DATABENTO: DatabentoDataClientConfig(
            api_key=None,  # 'DATABENTO_API_KEY' env var
            http_gateway=None,
            instrument_provider=InstrumentProviderConfig(load_all=True),
            instrument_ids=instrument_ids,
        ),
    },
    exec_clients={
        IB: InteractiveBrokersExecClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=1,
            account_id="DU123456",  # This must match with the IB Gateway/TWS node is connecting to
            instrument_provider=InteractiveBrokersInstrumentProviderConfig(
                symbology_method=SymbologyMethod.IB_SIMPLIFIED,
                load_ids=frozenset(instrument_ids),
            ),
            routing=RoutingConfig(
                default=True,
            ),
        ),
    },
    timeout_connection=90.0,
    timeout_reconciliation=5.0,
    timeout_portfolio=5.0,
    timeout_disconnection=5.0,
    timeout_post_stop=2.0,
)


# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strategy_config = SubscribeStrategyConfig(
    instrument_id=InstrumentId.from_str("SPY.XNAS"),
    trade_ticks=False,
    quote_ticks=True,
    bars=True,
)
# Instantiate your strategy
strategy = SubscribeStrategy(config=strategy_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(DATABENTO, DatabentoLiveDataClientFactory)
node.add_exec_client_factory(IB, InteractiveBrokersLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1872">
<source>examples/live/kraken/kraken_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.kraken import KRAKEN
from nautilus_trader.adapters.kraken import KrakenDataClientConfig
from nautilus_trader.adapters.kraken import KrakenEnvironment
from nautilus_trader.adapters.kraken import KrakenLiveDataClientFactory
from nautilus_trader.adapters.kraken import KrakenProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Configuration - Change product_type to switch between trading modes
product_type = KrakenProductType.FUTURES  # SPOT or FUTURES
token = "ETH"

# Symbol and settings based on product type
if product_type == KrakenProductType.SPOT:
    symbol = f"{token}/USD"
    environment = KrakenEnvironment.MAINNET
elif product_type == KrakenProductType.FUTURES:
    # Kraken Futures perpetual symbols use PI_ prefix (e.g., PI_XBTUSD, PI_ETHUSD)
    symbol = f"PI_{token}USD"
    environment = KrakenEnvironment.MAINNET
    # environment = KrakenEnvironment.DEMO  # Use demo-futures.kraken.com
else:
    raise ValueError(f"Unsupported product type: {product_type}")

instrument_id = InstrumentId.from_str(f"{symbol}.{KRAKEN}")
product_types = (product_type,)

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,  # Not applicable
    ),
    data_clients={
        KRAKEN: KrakenDataClientConfig(
            api_key=None,  # 'KRAKEN_API_KEY' env var
            api_secret=None,  # 'KRAKEN_API_SECRET' env var
            environment=environment,
            product_types=product_types,
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    timeout_connection=30.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure and initialize the tester
config_tester = DataTesterConfig(
    instrument_ids=[instrument_id],
    bar_types=[BarType.from_str(f"{instrument_id.value}-1-MINUTE-LAST-EXTERNAL")],
    subscribe_instrument=True,
    # subscribe_book_deltas=True,
    # subscribe_book_depth=True,
    # subscribe_book_at_interval=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    subscribe_mark_prices=product_type == KrakenProductType.FUTURES,
    subscribe_index_prices=product_type == KrakenProductType.FUTURES,
    subscribe_bars=True,
    # book_depth=10,
    # book_interval_ms=10,
    # requests_start_delta=pd.Timedelta(days=1),
    request_bars=True,
    request_trades=True,
)
tester = DataTester(config=config_tester)

node.trader.add_actor(tester)

# Register your client factories with the node
node.add_data_client_factory(KRAKEN, KrakenLiveDataClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1873">
<source>examples/live/kraken/kraken_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.kraken import KRAKEN
from nautilus_trader.adapters.kraken import KrakenDataClientConfig
from nautilus_trader.adapters.kraken import KrakenEnvironment
from nautilus_trader.adapters.kraken import KrakenExecClientConfig
from nautilus_trader.adapters.kraken import KrakenLiveDataClientFactory
from nautilus_trader.adapters.kraken import KrakenLiveExecClientFactory
from nautilus_trader.adapters.kraken import KrakenProductType
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Configuration - Change product_type to switch between trading modes
product_type = KrakenProductType.FUTURES  # SPOT or FUTURES
token = "ETH"

# Symbol and settings based on product type
if product_type == KrakenProductType.SPOT:
    symbol = f"{token}/USDT"
    order_qty = Decimal("0.001")
    enable_sells = False  # May not own base token when starting fresh
    reduce_only_on_stop = False  # Not supported on spot
    use_spot_position_reports = True
    environment = KrakenEnvironment.MAINNET
elif product_type == KrakenProductType.FUTURES:
    # Kraken Futures perpetual symbols use PI_ prefix (e.g., PI_XBTUSD, PI_ETHUSD)
    symbol = f"PF_{token}USD"
    order_qty = Decimal("0.001")
    enable_sells = True
    reduce_only_on_stop = True
    use_spot_position_reports = False  # Not applicable
    environment = KrakenEnvironment.MAINNET
    # environment = KrakenEnvironment.DEMO  # Use demo-futures.kraken.com
else:
    raise ValueError(f"Unsupported product type: {product_type}")

instrument_id = InstrumentId.from_str(f"{symbol}.{KRAKEN}")
product_types = (product_type,)

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        position_check_interval_secs=30.0,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        # purge_closed_orders_interval_mins=1,
        # purge_closed_orders_buffer_mins=0,
        # purge_closed_positions_interval_mins=1,
        # purge_closed_positions_buffer_mins=0,
        # purge_account_events_interval_mins=1,
        # purge_account_events_lookback_mins=0,
        # purge_from_database=False,
        # graceful_shutdown_on_exception=True,
    ),
    data_clients={
        KRAKEN: KrakenDataClientConfig(
            api_key=None,  # 'KRAKEN_API_KEY' env var
            api_secret=None,  # 'KRAKEN_API_SECRET' env var
            environment=environment,
            product_types=product_types,
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        KRAKEN: KrakenExecClientConfig(
            api_key=None,  # 'KRAKEN_API_KEY' env var
            api_secret=None,  # 'KRAKEN_API_SECRET' env var
            environment=environment,
            product_types=product_types,
            instrument_provider=InstrumentProviderConfig(load_all=True),
            use_spot_position_reports=use_spot_position_reports,
            spot_positions_quote_currency="USDT",
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
strat_config = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    use_uuid_client_order_ids=True,
    # subscribe_book=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    order_qty=order_qty,
    open_position_on_start_qty=order_qty,
    open_position_time_in_force=TimeInForce.IOC,
    # order_expire_time_delta_mins=1,
    enable_limit_buys=True,
    enable_limit_sells=enable_sells,
    # enable_stop_buys=True,
    # enable_stop_sells=enable_sells,
    # tob_offset_ticks=0,
    # stop_order_type=OrderType.STOP_LIMIT,
    # stop_trigger_type=TriggerType.LAST_PRICE,
    # modify_orders_to_maintain_tob_offset=True,
    # modify_stop_orders_to_maintain_offset=True,
    # use_batch_cancel_on_stop=True,
    # use_individual_cancels_on_stop=True,
    use_post_only=True,
    # cancel_orders_on_stop=False,
    # close_positions_on_stop=False,
    reduce_only_on_stop=reduce_only_on_stop,
    # test_reject_post_only=True,
    log_data=False,
)

# Instantiate your strategy
strategy = ExecTester(config=strat_config)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node
node.add_data_client_factory(KRAKEN, KrakenLiveDataClientFactory)
node.add_exec_client_factory(KRAKEN, KrakenLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1874">
<source>examples/live/okx/okx_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import pandas as pd

from nautilus_trader.adapters.okx import OKX
from nautilus_trader.adapters.okx import OKXDataClientConfig
from nautilus_trader.adapters.okx import OKXLiveDataClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.core.nautilus_pyo3 import OKXContractType
from nautilus_trader.core.nautilus_pyo3 import OKXInstrumentType
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Configuration - Change instrument_type to switch between trading modes
instrument_type = OKXInstrumentType.SWAP  # SPOT, MARGIN, SWAP, FUTURES, OPTION
token = "ETH"

# Symbol mapping based on instrument type
if instrument_type in (OKXInstrumentType.SPOT, OKXInstrumentType.MARGIN):
    symbol = f"{token}-USDT"
    contract_types: tuple[OKXContractType, ...] | None = None  # SPOT doesn't use contract types
elif instrument_type == OKXInstrumentType.SWAP:
    symbol = f"{token}-USDT-SWAP"
    contract_types = (OKXContractType.LINEAR,)
elif instrument_type == OKXInstrumentType.FUTURES:
    # Note: ETH-USD futures follow same pattern as BTC-USD
    # Format: ETH-USD-YYMMDD (e.g., ETH-USD-241227, ETH-USD-250131)
    symbol = f"{token}-USD-251226"  # ETH-USD futures expiring December 26, 2025
    contract_types = (OKXContractType.INVERSE,)  # ETH-USD futures are inverse contracts
elif instrument_type == OKXInstrumentType.OPTION:
    symbol = (
        f"{token}-USD-251226-4000-C"  # Example: ETH-USD call option, strike $4000, exp 2025-12-26
    )
    contract_types = None  # OPTIONS don't use contract types in the same way
else:
    raise ValueError(f"Unsupported instrument type: {instrument_type}")

instrument_id = InstrumentId.from_str(f"{symbol}.{OKX}")

# Additional instruments for testing (matching exec_tester setup)
spot_instrument_id = InstrumentId.from_str(f"{token}-USDT.{OKX}")
swap_instrument_id = InstrumentId.from_str(f"{token}-USDT-SWAP.{OKX}")

instrument_types = (
    OKXInstrumentType.SPOT,
    OKXInstrumentType.SWAP,
)

instrument_families = (
    # "BTC-USD",
    # "ETH-USDT",
)

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,  # Not applicable
    ),
    data_clients={
        OKX: OKXDataClientConfig(
            api_key=None,  # 'OKX_API_KEY' env var
            api_secret=None,  # 'OKX_API_SECRET' env var
            api_passphrase=None,  # 'OKX_API_PASSPHRASE' env var
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(
                load_all=True,
                # load_ids=frozenset([spot_instrument_id, swap_instrument_id]),
            ),
            instrument_types=instrument_types,
            contract_types=contract_types,
            is_demo=False,  # If client uses the demo API
            http_timeout_secs=10,  # Set to reasonable duration
        ),
    },
    timeout_connection=20.0,
    timeout_disconnection=5.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure and initialize the tester
config_tester = DataTesterConfig(
    instrument_ids=[spot_instrument_id, swap_instrument_id],
    bar_types=[
        BarType.from_str(f"{spot_instrument_id.value}-1-MINUTE-LAST-EXTERNAL"),
        BarType.from_str(f"{swap_instrument_id.value}-1-MINUTE-LAST-EXTERNAL"),
    ],
    # subscribe_book_deltas=True,
    # subscribe_book_depth=True,
    # subscribe_book_at_interval=True,  # Only legacy Cython wrapped book (not PyO3)
    subscribe_quotes=True,
    subscribe_trades=True,
    subscribe_mark_prices=True,
    subscribe_index_prices=False,  # Only for some derivatives
    subscribe_funding_rates=True,
    # subscribe_bars=True,
    # subscribe_instrument=True,
    # subscribe_instrument_status=True,
    # subscribe_instrument_close=True,
    # request_bars=True,
    # book_group_size=Decimal("1"),  # Only PyO3 wrapped book (not legacy Cython)
    # book_depth=5,
    # book_levels_to_print=50,
    # book_interval_ms=100,
    # manage_book=True,
    # use_pyo3_book=True,
    # request_instruments=True,
    request_bars=True,
    # request_trades=True,
    requests_start_delta=pd.Timedelta(minutes=60),
)
tester = DataTester(config=config_tester)

node.trader.add_actor(tester)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(OKX, OKXLiveDataClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1875">
<source>examples/live/okx/okx_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.okx import OKX
from nautilus_trader.adapters.okx import OKXDataClientConfig
from nautilus_trader.adapters.okx import OKXExecClientConfig
from nautilus_trader.adapters.okx import OKXLiveDataClientFactory
from nautilus_trader.adapters.okx import OKXLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.core.nautilus_pyo3 import OKXContractType
from nautilus_trader.core.nautilus_pyo3 import OKXInstrumentType
from nautilus_trader.core.nautilus_pyo3 import OKXMarginMode
from nautilus_trader.live.config import LiveRiskEngineConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Configuration - Change instrument_type to switch between trading modes
instrument_type = OKXInstrumentType.SWAP  # SPOT, MARGIN, SWAP, FUTURES, OPTION
token = "ETH"

# Symbol mapping based on instrument type
if instrument_type == OKXInstrumentType.SPOT:
    symbol = f"{token}-USDT"
    contract_types: tuple[OKXContractType, ...] | None = None  # SPOT doesn't use contract types
    order_qty = Decimal("10.00")  # In quote currency for buying
    # order_qty = Decimal("0.01")  # In base currency for selling
    enable_limit_sells = False
    use_spot_margin = False
    use_quote_quantity = True
elif instrument_type == OKXInstrumentType.MARGIN:
    symbol = f"{token}-USDT"
    contract_types = None  # MARGIN doesn't use contract types
    order_qty = Decimal("10.00")  # In quote currency for buying
    # order_qty = Decimal("0.01")  # In base currency for selling
    enable_limit_sells = False
    use_spot_margin = True
    use_quote_quantity = True
elif instrument_type == OKXInstrumentType.SWAP:
    symbol = f"{token}-USDT-SWAP"
    contract_types = (OKXContractType.LINEAR,)
    order_qty = Decimal("0.01")
    enable_limit_sells = True
    use_spot_margin = False
    use_quote_quantity = False
elif instrument_type == OKXInstrumentType.FUTURES:
    # Format: ETH-USD-YYMMDD (e.g., ETH-USD-241227, ETH-USD-250131)
    symbol = f"{token}-USD-251226"  # ETH-USD futures expiring 2025-12-26
    contract_types = (OKXContractType.INVERSE,)  # ETH-USD futures are inverse contracts
    order_qty = Decimal(1)
    enable_limit_sells = True
    use_spot_margin = False
    use_quote_quantity = False
elif instrument_type == OKXInstrumentType.OPTION:
    symbol = (
        f"{token}-USD-251226-4000-C"  # Example: ETH-USD call option, strike 4000, exp 2025-12-26
    )
    contract_types = None  # Options don't use contract types in the same way
    order_qty = Decimal(1)
    enable_limit_sells = True
    use_spot_margin = False
    use_quote_quantity = False
else:
    raise ValueError(f"Unsupported instrument type: {instrument_type}")

instrument_id = InstrumentId.from_str(f"{symbol}.{OKX}")

# Setup instruments and types based on instrument_type
instrument_types: tuple[OKXInstrumentType, ...]
if instrument_type in (OKXInstrumentType.SPOT, OKXInstrumentType.SWAP):
    spot_instrument_id = InstrumentId.from_str(f"{token}-USDT.{OKX}")
    swap_instrument_id = InstrumentId.from_str(f"{token}-USDT-SWAP.{OKX}")
    reconciliation_instrument_ids = [spot_instrument_id, swap_instrument_id]
    load_ids = frozenset([spot_instrument_id, swap_instrument_id])
    external_order_claims = [spot_instrument_id, swap_instrument_id]
    instrument_types = (
        OKXInstrumentType.SPOT,
        OKXInstrumentType.SWAP,
    )
else:
    # For FUTURES and OPTION, use only the primary instrument
    reconciliation_instrument_ids = [instrument_id]
    load_ids = frozenset([instrument_id])
    external_order_claims = [instrument_id]
    instrument_types = (instrument_type,)

instrument_families = (
    # "BTC-USD",
    # "ETH-USDT",
)

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        convert_quote_qty_to_base=False,
        reconciliation=True,
        reconciliation_instrument_ids=reconciliation_instrument_ids,
        # reconciliation_lookback_mins=60,
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        position_check_interval_secs=60,
        # own_books_audit_interval_secs=2.0,
        # manage_own_order_books=True,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        purge_closed_orders_interval_mins=15,  # Example of purging closed orders for HFT
        purge_closed_orders_buffer_mins=60,  # Purged orders closed for at least an hour
        purge_closed_positions_interval_mins=15,  # Example of purging closed positions for HFT
        purge_closed_positions_buffer_mins=60,  # Purge positions closed for at least an hour
        purge_account_events_interval_mins=15,  # Example of purging account events for HFT
        purge_account_events_lookback_mins=60,  # Purge account events occurring more than an hour ago
        graceful_shutdown_on_exception=True,
    ),
    risk_engine=LiveRiskEngineConfig(bypass=True),  # Must bypass for spot margin for now
    # cache=CacheConfig(
    #     database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    # ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     use_trader_prefix=False,
    #     use_trader_id=False,
    #     use_instance_id=False,
    #     stream_per_topic=False,
    #     types_filter=[QuoteTick],
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    data_clients={
        OKX: OKXDataClientConfig(
            api_key=None,  # 'OKX_API_KEY' env var
            api_secret=None,  # 'OKX_API_SECRET' env var
            api_passphrase=None,  # 'OKX_API_PASSPHRASE' env var
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(
                load_all=False,
                load_ids=load_ids,
            ),
            instrument_types=instrument_types,
            contract_types=contract_types,
            is_demo=False,  # If client uses the demo API
            http_timeout_secs=10,  # Set to reasonable duration
        ),
    },
    exec_clients={
        OKX: OKXExecClientConfig(
            api_key=None,  # 'OKX_API_KEY' env var
            api_secret=None,  # 'OKX_API_SECRET' env var
            api_passphrase=None,  # 'OKX_API_PASSPHRASE' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(
                load_all=False,
                load_ids=load_ids,
            ),
            instrument_types=instrument_types,
            contract_types=contract_types,
            margin_mode=OKXMarginMode.CROSS,
            use_spot_margin=use_spot_margin,
            # use_spot_cash_position_reports=True,  # Spot CASH position reports
            # use_mm_mass_cancel=True,
            is_demo=False,  # If client uses the demo API
            use_fills_channel=False,  # Set to True if VIP5+ to get separate fill reports
            http_timeout_secs=10,  # Set to reasonable duration
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
config_tester = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=external_order_claims,
    use_hyphens_in_client_order_ids=False,  # OKX doesn't allow hyphens in client order IDs
    # subscribe_quotes=False,
    # subscribe_trades=False,
    # subscribe_book=True,
    enable_limit_buys=True,
    enable_limit_sells=enable_limit_sells,
    open_position_on_start_qty=order_qty,
    open_position_time_in_force=TimeInForce.IOC,
    tob_offset_ticks=100,
    # stop_offset_ticks=1,
    order_qty=order_qty,
    # modify_orders_to_maintain_tob_offset=True,
    use_post_only=True,
    use_quote_quantity=use_quote_quantity,
    # enable_stop_buys=True,
    # enable_stop_sells=True,
    # stop_order_type=OrderType.STOP_MARKET,
    # stop_trigger_type=TriggerType.LAST_PRICE,
    # stop_offset_ticks=50,  # Offset from current price for stop trigger
    # stop_limit_offset_ticks=10,  # Additional offset for STOP_LIMIT orders
    # cancel_orders_on_stop=False,
    # close_positions_on_stop=False,
    # use_individual_cancels_on_stop=True,
    # use_batch_cancel_on_stop=True,
    # test_reject_post_only=True,
    log_data=False,
    dry_run=False,
)

# Instantiate your strategy
strategy = ExecTester(config=config_tester)

# Add your strategies and modules
node.trader.add_strategy(strategy)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(OKX, OKXLiveDataClientFactory)
node.add_exec_client_factory(OKX, OKXLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1876">
<source>examples/live/okx/okx_spot_swap_quoter.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.okx import OKX
from nautilus_trader.adapters.okx import OKXDataClientConfig
from nautilus_trader.adapters.okx import OKXExecClientConfig
from nautilus_trader.adapters.okx import OKXLiveDataClientFactory
from nautilus_trader.adapters.okx import OKXLiveExecClientFactory
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import StrategyConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.core.nautilus_pyo3 import OKXContractType
from nautilus_trader.core.nautilus_pyo3 import OKXInstrumentType
from nautilus_trader.core.nautilus_pyo3 import OKXMarginMode
from nautilus_trader.live.config import LiveRiskEngineConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import PositionSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.events import OrderFilled
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Quantity
from nautilus_trader.model.orders import LimitOrder
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# Configuration
token = "ETH"
symbol_spot = f"{token}-USDT"
symbol_swap = f"{token}-USDT-SWAP"
use_spot_margin = True  # True for MARGIN, False for SPOT (cash)

# Order quantities
order_qty_spot = Decimal("2.00")  # In quote currency (USDT)
order_qty_swap = Decimal("0.01")  # In base currency (ETH contracts)

# Trading parameters
tob_offset_ticks = 100


class SpotSwapQuoterConfig(StrategyConfig, frozen=True, kw_only=True):
    """
    Configuration for the spot and swap quoter strategy.
    """

    spot_instrument_id: InstrumentId
    swap_instrument_id: InstrumentId
    spot_order_qty: Decimal
    swap_order_qty: Decimal
    tob_offset_ticks: int = 100
    log_data: bool = False
    close_positions_on_stop: bool = True


class SpotSwapQuoter(Strategy):
    """
    A quoter that places orders on both spot and swap instruments.

    Opens a position on start and maintains quotes on both instruments.

    """

    def __init__(self, config: SpotSwapQuoterConfig) -> None:
        super().__init__(config)
        self.spot_instrument: Instrument | None = None
        self.swap_instrument: Instrument | None = None

        # Spot state
        self._spot_tick_size = Decimal(0)
        self._spot_price_offset = Decimal(0)
        self._spot_order_qty = None
        self._spot_bid_order: LimitOrder | None = None
        self._spot_ask_order: LimitOrder | None = None

        # Swap state
        self._swap_tick_size = Decimal(0)
        self._swap_price_offset = Decimal(0)
        self._swap_order_qty = None
        self._swap_bid_order: LimitOrder | None = None
        self._swap_ask_order: LimitOrder | None = None

        self._opened_position = False

    def on_start(self) -> None:
        self.spot_instrument = self.cache.instrument(self.config.spot_instrument_id)
        if self.spot_instrument is None:
            self.log.error(
                f"Could not find spot instrument for {self.config.spot_instrument_id}",
            )
            self.stop()
            return

        self.swap_instrument = self.cache.instrument(self.config.swap_instrument_id)
        if self.swap_instrument is None:
            self.log.error(f"Could not find swap instrument for {self.config.swap_instrument_id}")
            self.stop()
            return

        # Initialize spot parameters
        self._spot_tick_size = self.spot_instrument.price_increment.as_decimal()
        offset_ticks = max(self.config.tob_offset_ticks, 0)
        self._spot_price_offset = self._spot_tick_size * offset_ticks
        self._spot_order_qty = self.spot_instrument.make_qty(self.config.spot_order_qty)

        # Initialize swap parameters
        self._swap_tick_size = self.swap_instrument.price_increment.as_decimal()
        self._swap_price_offset = self._swap_tick_size * offset_ticks
        self._swap_order_qty = self.swap_instrument.make_qty(self.config.swap_order_qty)

        # Subscribe to quote ticks
        self.subscribe_quote_ticks(self.config.spot_instrument_id)
        self.subscribe_quote_ticks(self.config.swap_instrument_id)

        # Open initial position on spot
        self.open_position_on_start()

    def open_position_on_start(self) -> None:
        """
        Open a position on the spot instrument.
        """
        if self.spot_instrument is None:
            return

        order = self.order_factory.market(
            instrument_id=self.config.spot_instrument_id,
            order_side=OrderSide.BUY,
            quantity=self._spot_order_qty,
            time_in_force=TimeInForce.GTC,
            quote_quantity=True,  # Market BUY orders use quote quantity (USDT)
        )

        self.submit_order(order)
        self._opened_position = True
        self.log.info(
            f"Opened position on {self.config.spot_instrument_id} with order {order.client_order_id}",
            LogColor.BLUE,
        )

    def on_quote_tick(self, quote: QuoteTick) -> None:
        if self.config.log_data:
            self.log.info(repr(quote), LogColor.CYAN)

        # Handle spot quotes
        if quote.instrument_id == self.config.spot_instrument_id:
            self._maintain_spot_orders(quote)

        # Handle swap quotes
        elif quote.instrument_id == self.config.swap_instrument_id:
            self._maintain_swap_orders(quote)

    def _maintain_spot_orders(self, quote: QuoteTick) -> None:
        if self.spot_instrument is None:
            return

        if not self.is_running:
            # Don't create new orders if stopping
            return

        assert self._spot_order_qty is not None  # type checking

        # Clear order references on any terminal status
        if self._spot_bid_order and self._spot_bid_order.is_closed:
            self._spot_bid_order = None
        if self._spot_ask_order and self._spot_ask_order.is_closed:
            self._spot_ask_order = None

        # Calculate desired prices with bounds checking
        desired_bid = quote.bid_price.as_decimal() - self._spot_price_offset
        desired_ask = quote.ask_price.as_decimal() + self._spot_price_offset

        # Guard against non-positive prices
        min_price = self.spot_instrument.price_increment
        if desired_bid <= 0:
            self.log.warning(
                f"Calculated bid price {desired_bid} <= 0, using min price {min_price}",
            )
            desired_bid = min_price
        if desired_ask <= desired_bid:
            self.log.warning(f"Calculated ask price {desired_ask} <= bid {desired_bid}, skipping")
            return

        # Place BID order if none exists
        if self._spot_bid_order is None:
            price = self.spot_instrument.make_price(desired_bid)
            base_qty = self._spot_order_qty.as_decimal() / desired_bid
            quantity = self.spot_instrument.make_qty(base_qty)
            order = self.order_factory.limit(
                instrument_id=self.config.spot_instrument_id,
                order_side=OrderSide.BUY,
                price=price,
                quantity=quantity,
                post_only=True,
                quote_quantity=False,
            )
            self._spot_bid_order = order
            self.submit_order(order)

        # Place ASK order if none exists
        if self._spot_ask_order is None:
            price = self.spot_instrument.make_price(desired_ask)
            base_qty = self._spot_order_qty.as_decimal() / desired_ask
            quantity = self.spot_instrument.make_qty(base_qty)
            order = self.order_factory.limit(
                instrument_id=self.config.spot_instrument_id,
                order_side=OrderSide.SELL,
                price=price,
                quantity=quantity,
                post_only=True,
                quote_quantity=False,
            )
            self._spot_ask_order = order
            self.submit_order(order)

    def _maintain_swap_orders(self, quote: QuoteTick) -> None:
        if self.swap_instrument is None:
            return

        if not self.is_running:
            # Don't create new orders if stopping
            return

        # Clear order references on any terminal status
        if self._swap_bid_order and self._swap_bid_order.is_closed:
            self._swap_bid_order = None
        if self._swap_ask_order and self._swap_ask_order.is_closed:
            self._swap_ask_order = None

        # Calculate desired prices with bounds checking
        desired_bid = quote.bid_price.as_decimal() - self._swap_price_offset
        desired_ask = quote.ask_price.as_decimal() + self._swap_price_offset

        # Guard against non-positive prices
        min_price = self.swap_instrument.price_increment
        if desired_bid <= 0:
            self.log.warning(
                f"Calculated swap bid price {desired_bid} <= 0, using min price {min_price}",
            )
            desired_bid = min_price
        if desired_ask <= desired_bid:
            self.log.warning(
                f"Calculated swap ask price {desired_ask} <= bid {desired_bid}, skipping",
            )
            return

        # Place BID order if none exists
        if self._swap_bid_order is None:
            price = self.swap_instrument.make_price(desired_bid)
            order = self.order_factory.limit(
                instrument_id=self.config.swap_instrument_id,
                order_side=OrderSide.BUY,
                price=price,
                quantity=self._swap_order_qty,
                post_only=True,
                quote_quantity=False,
            )
            self._swap_bid_order = order
            self.submit_order(order)

        # Place ASK order if none exists
        if self._swap_ask_order is None:
            price = self.swap_instrument.make_price(desired_ask)
            order = self.order_factory.limit(
                instrument_id=self.config.swap_instrument_id,
                order_side=OrderSide.SELL,
                price=price,
                quantity=self._swap_order_qty,
                post_only=True,
                quote_quantity=False,
            )
            self._swap_ask_order = order
            self.submit_order(order)

    def on_event(self, event) -> None:
        # Handle fills and reset state
        if isinstance(event, OrderFilled):
            # Spot fills
            if (
                self._spot_bid_order
                and event.client_order_id == self._spot_bid_order.client_order_id
            ):
                self._spot_bid_order = None
            elif (
                self._spot_ask_order
                and event.client_order_id == self._spot_ask_order.client_order_id
            ):
                self._spot_ask_order = None

            # Swap fills
            if (
                self._swap_bid_order
                and event.client_order_id == self._swap_bid_order.client_order_id
            ):
                self._swap_bid_order = None
            elif (
                self._swap_ask_order
                and event.client_order_id == self._swap_ask_order.client_order_id
            ):
                self._swap_ask_order = None

    def on_stop(self) -> None:
        # Cancel all orders
        self.cancel_all_orders(self.config.spot_instrument_id)
        self.cancel_all_orders(self.config.swap_instrument_id)

        assert self.spot_instrument is not None  # type checking
        assert self.swap_instrument is not None  # type checking

        if self.config.close_positions_on_stop:
            # Close spot positions created by this strategy only
            spot_positions = self.cache.positions_open(
                instrument_id=self.config.spot_instrument_id,
                strategy_id=self.id,
            )
            for position in spot_positions:
                if position.side == PositionSide.SHORT:
                    # SHORT positions require BUY to close
                    # OKX spot margin requires quote_quantity=True for MARKET BUY
                    # Convert position quantity (ETH) to quote amount (USDT)
                    quote_tick = self.cache.quote_tick(self.config.spot_instrument_id)
                    if quote_tick is None:
                        self.log.warning(
                            f"No quote tick available for {self.config.spot_instrument_id}, cannot close SHORT position",
                        )
                        continue

                    # Use mid price to estimate quote amount needed
                    mid_price = (quote_tick.bid_price + quote_tick.ask_price) / 2
                    quote_amount = position.quantity.as_decimal() * mid_price

                    # Create quantity in quote currency (USDT) using price precision
                    quote_qty = Quantity(
                        quote_amount,
                        precision=self.spot_instrument.price_precision,
                    )

                    self.log.info(
                        f"Closing SHORT position {position.id} with quote quantity {quote_amount:.2f} USDT",
                        LogColor.YELLOW,
                    )

                    # Submit market order with quote quantity
                    order = self.order_factory.market(
                        instrument_id=position.instrument_id,
                        order_side=OrderSide.BUY,
                        quantity=quote_qty,
                        time_in_force=TimeInForce.GTC,
                        reduce_only=True,
                        quote_quantity=True,
                    )
                    self.submit_order(order, position_id=position.id)
                else:
                    # LONG positions can use normal close_position
                    self.close_position(position)

            # Close swap positions
            self.close_all_positions(self.config.swap_instrument_id)

        # Reset state
        self._spot_bid_order = None
        self._spot_ask_order = None
        self._swap_bid_order = None
        self._swap_ask_order = None


# Setup instruments
spot_instrument_id = InstrumentId.from_str(f"{symbol_spot}.{OKX}")
swap_instrument_id = InstrumentId.from_str(f"{symbol_swap}.{OKX}")

reconciliation_instrument_ids = [spot_instrument_id, swap_instrument_id]
load_ids = frozenset([spot_instrument_id, swap_instrument_id])
external_order_claims = [spot_instrument_id, swap_instrument_id]

# Determine instrument types based on use_spot_margin flag
spot_instrument_type = OKXInstrumentType.MARGIN if use_spot_margin else OKXInstrumentType.SPOT
instrument_types = (
    spot_instrument_type,
    OKXInstrumentType.SWAP,
)

contract_types = (OKXContractType.LINEAR,)

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        log_level_file="DEBUG",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        convert_quote_qty_to_base=False,
        reconciliation=True,
        reconciliation_instrument_ids=reconciliation_instrument_ids,
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        position_check_interval_secs=60,
        purge_closed_orders_interval_mins=15,
        purge_closed_orders_buffer_mins=60,
        purge_closed_positions_interval_mins=15,
        purge_closed_positions_buffer_mins=60,
        purge_account_events_interval_mins=15,
        purge_account_events_lookback_mins=60,
        graceful_shutdown_on_exception=True,
    ),
    risk_engine=LiveRiskEngineConfig(bypass=True),  # Must bypass for spot for now
    data_clients={
        OKX: OKXDataClientConfig(
            api_key=None,  # 'OKX_API_KEY' env var
            api_secret=None,  # 'OKX_API_SECRET' env var
            api_passphrase=None,  # 'OKX_API_PASSPHRASE' env var
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(
                load_all=False,
                load_ids=load_ids,
            ),
            instrument_types=instrument_types,
            contract_types=contract_types,
            is_demo=False,  # If client uses the demo API
            http_timeout_secs=10,
        ),
    },
    exec_clients={
        OKX: OKXExecClientConfig(
            api_key=None,  # 'OKX_API_KEY' env var
            api_secret=None,  # 'OKX_API_SECRET' env var
            api_passphrase=None,  # 'OKX_API_PASSPHRASE' env var
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            instrument_provider=InstrumentProviderConfig(
                load_all=False,
                load_ids=load_ids,
            ),
            instrument_types=instrument_types,
            contract_types=contract_types,
            margin_mode=OKXMarginMode.CROSS,
            use_spot_margin=use_spot_margin,
            is_demo=False,  # If client uses the demo API
            use_fills_channel=False,  # Set to True if VIP5+ to get separate fill reports
            http_timeout_secs=10,
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure strategy
config_strategy = SpotSwapQuoterConfig(
    spot_instrument_id=spot_instrument_id,
    swap_instrument_id=swap_instrument_id,
    spot_order_qty=order_qty_spot,
    swap_order_qty=order_qty_swap,
    tob_offset_ticks=tob_offset_ticks,
    log_data=False,
    use_hyphens_in_client_order_ids=False,  # OKX doesn't allow hyphens
)

# Instantiate strategy
strategy = SpotSwapQuoter(config=config_strategy)

# Add strategy
node.trader.add_strategy(strategy)

# Register client factories with the node
node.add_data_client_factory(OKX, OKXLiveDataClientFactory)
node.add_exec_client_factory(OKX, OKXLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1877">
<source>examples/live/polymarket/polymarket_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.polymarket import POLYMARKET
from nautilus_trader.adapters.polymarket import PolymarketDataClientConfig
from nautilus_trader.adapters.polymarket import PolymarketLiveDataClientFactory
from nautilus_trader.adapters.polymarket import get_polymarket_instrument_id
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# For correct subscription operation, you must specify all instruments to be immediately
# subscribed for as part of the data client configuration

# To find active markets run `python nautilus_trader/adapters/polymarket/scripts/active_markets.py`

# Slug: fed-rate-hike-in-2025
# Active: True
# Condition ID: 0x4319532e181605cb15b1bd677759a3bc7f7394b2fdf145195b700eeaedfd5221
# Token IDs: 60487116984468020978247225474488676749601001829886755968952521846780452448915,
# 81104637750588840860328515305303028259865221573278091453716127842023614249200
# Link: https://polymarket.com/event/fed-rate-hike-in-2025
condition_id = "0x4319532e181605cb15b1bd677759a3bc7f7394b2fdf145195b700eeaedfd5221"
token_id = "60487116984468020978247225474488676749601001829886755968952521846780452448915"

instrument_ids = [
    get_polymarket_instrument_id(condition_id, token_id),
]

filters = {
    # "next_cursor": "MTE3MDA=",
    "is_active": True,
}

load_ids = [str(x) for x in instrument_ids]
instrument_provider_config = InstrumentProviderConfig(load_ids=frozenset(load_ids))
# instrument_provider_config = InstrumentProviderConfig(load_all=True, filters=filters)

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,  # Not applicable
    ),
    data_clients={
        POLYMARKET: PolymarketDataClientConfig(
            private_key=None,  # 'POLYMARKET_PK' env var
            api_key=None,  # 'POLYMARKET_API_KEY' env var
            api_secret=None,  # 'POLYMARKET_API_SECRET' env var
            passphrase=None,  # 'POLYMARKET_PASSPHRASE' env var
            # signature_type=2,  # Uncomment if you're using the proxy wallet (Polymarket UI)
            instrument_provider=instrument_provider_config,
            compute_effective_deltas=True,
        ),
    },
    timeout_connection=20.0,
    timeout_disconnection=10.0,
    timeout_post_stop=1.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure and initialize the tester
config_tester = DataTesterConfig(
    instrument_ids=instrument_ids,
    subscribe_book_deltas=False,
    subscribe_book_at_interval=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    can_unsubscribe=False,  # Polymarket does not support unsubscribing from ws streams
)
tester = DataTester(config=config_tester)

node.trader.add_actor(tester)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(POLYMARKET, PolymarketLiveDataClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1878">
<source>examples/live/polymarket/polymarket_exec_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.polymarket import POLYMARKET
from nautilus_trader.adapters.polymarket import PolymarketDataClientConfig
from nautilus_trader.adapters.polymarket import PolymarketExecClientConfig
from nautilus_trader.adapters.polymarket import PolymarketLiveDataClientFactory
from nautilus_trader.adapters.polymarket import PolymarketLiveExecClientFactory
from nautilus_trader.adapters.polymarket.common.symbol import get_polymarket_instrument_id
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.portfolio.config import PortfolioConfig
from nautilus_trader.test_kit.strategies.tester_exec import ExecTester
from nautilus_trader.test_kit.strategies.tester_exec import ExecTesterConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***

# For correct subscription operation, you must specify all instruments to be immediately
# subscribed for as part of the data client configuration

# Note on pagination: The py_clob_client library handles pagination internally
# for both get_orders() and get_trades() methods. It automatically fetches all
# pages and returns the complete dataset, so no manual pagination is needed.

# To find active markets run `python nautilus_trader/adapters/polymarket/scripts/active_markets.py`

# Slug: fed-rate-hike-in-2025
# Active: True
# Condition ID: 0x4319532e181605cb15b1bd677759a3bc7f7394b2fdf145195b700eeaedfd5221
# Token IDs: 60487116984468020978247225474488676749601001829886755968952521846780452448915,
# 81104637750588840860328515305303028259865221573278091453716127842023614249200
# Link: https://polymarket.com/event/fed-rate-hike-in-2025
condition_id = "0x4319532e181605cb15b1bd677759a3bc7f7394b2fdf145195b700eeaedfd5221"
token_id = "60487116984468020978247225474488676749601001829886755968952521846780452448915"

instrument_id = get_polymarket_instrument_id(condition_id, token_id)

# Configure instrument provider to only load the specific instrument we're testing
# This avoids walking the entire Polymarket market space unnecessarily
load_ids = [str(instrument_id)]
instrument_provider_config = InstrumentProviderConfig(load_ids=frozenset(load_ids))

# Order configuration
order_qty = Decimal(10)  # Number of shares for limit orders, or notional value for market BUY

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        # log_file_max_size=1_000_000_000,
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        convert_quote_qty_to_base=False,  # Required for submitting market BUY orders
        reconciliation=True,
        reconciliation_instrument_ids=[instrument_id],  # Only reconcile these instruments
        open_check_interval_secs=5.0,
        open_check_open_only=True,
        # own_books_audit_interval_secs=2.0,
        # manage_own_order_books=True,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        purge_closed_orders_interval_mins=1,  # Example of purging closed orders for HFT
        purge_closed_orders_buffer_mins=0,  # Purged orders closed for at least an hour
        purge_closed_positions_interval_mins=1,  # Example of purging closed positions for HFT
        purge_closed_positions_buffer_mins=0,  # Purge positions closed for at least an hour
        purge_account_events_interval_mins=1,  # Example of purging account events for HFT
        purge_account_events_lookback_mins=0,  # Purge account events occurring more than an hour ago
        purge_from_database=True,  # Set True with caution
        graceful_shutdown_on_exception=True,
    ),
    # cache=CacheConfig(
    #     database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     persist_account_events=False,  # Useful for HFT ops where this can quickly accumulate
    #     buffer_interval_ms=100,
    # ),
    portfolio=PortfolioConfig(min_account_state_logging_interval_ms=1_000),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="polymarket",
    #     use_trader_prefix=False,
    #     use_trader_id=False,
    #     use_instance_id=False,
    #     stream_per_topic=False,
    #     types_filter=[QuoteTick],
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    data_clients={
        POLYMARKET: PolymarketDataClientConfig(
            api_key=None,  # 'POLYMARKET_API_KEY' env var
            api_secret=None,  # 'POLYMARKET_API_SECRET' env var
            passphrase=None,  # 'POLYMARKET_PASSPHRASE' env var
            # signature_type=2,  # Use if trading via Polymarket Proxy (enables UI verification, requires funder address)
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=instrument_provider_config,
        ),
    },
    exec_clients={
        POLYMARKET: PolymarketExecClientConfig(
            api_key=None,  # 'POLYMARKET_API_KEY' env var
            api_secret=None,  # 'POLYMARKET_API_SECRET' env var
            passphrase=None,  # 'POLYMARKET_PASSPHRASE' env var
            # signature_type=2,  # Use if trading via Polymarket Proxy (enables UI verification, requires funder address)
            base_url_http=None,  # Override with custom endpoint
            instrument_provider=instrument_provider_config,
            generate_order_history_from_trades=False,
        ),
    },
    timeout_connection=20.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure your strategy
config_tester = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    subscribe_quotes=True,
    subscribe_trades=True,
    # subscribe_book=True,
    # enable_limit_buys=False,
    enable_limit_sells=False,
    tob_offset_ticks=10,
    order_qty=order_qty,
    # open_position_on_start_qty=order_qty,
    # use_quote_quantity=True,  # Required for submitting market BUY orders
    use_post_only=False,  # Polymarket does not support post-only orders
    # test_reject_post_only=True,
    reduce_only_on_stop=False,  # Polymarket does not support reduce-only orders
    cancel_orders_on_stop=True,
    close_positions_on_stop=True,
    log_data=False,
    log_rejected_due_post_only_as_warning=False,
    can_unsubscribe=False,  # Polymarket does not support unsubscribing from ws streams
)

# Instantiate your strategy
tester = ExecTester(config=config_tester)

# Add your strategies and modules
node.trader.add_strategy(tester)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(POLYMARKET, PolymarketLiveDataClientFactory)
node.add_exec_client_factory(POLYMARKET, PolymarketLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1879">
<source>examples/live/tardis/tardis_data_tester.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.tardis import TARDIS
from nautilus_trader.adapters.tardis import TARDIS_CLIENT_ID
from nautilus_trader.adapters.tardis import TardisDataClientConfig
from nautilus_trader.adapters.tardis import TardisLiveDataClientFactory
from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.test_kit.strategies.tester_data import DataTester
from nautilus_trader.test_kit.strategies.tester_data import DataTesterConfig


# Run the following to start the tardis-machine server:
# - The TM_API_KEY environment variable should be set
# - The TARDIS_MACHINE_WS_URL environment variable should be set to ws://localhost:8001
# - docker run -p 8000:8000 -p 8001:8001 -d tardisdev/tardis-machine

instrument_ids = [
    # InstrumentId.from_str("BTCUSDT-PERP.BINANCE"),
    # InstrumentId.from_str("BTCUSD_PERP.BINANCE_DELIVERY"),
    # InstrumentId.from_str("USDTUSD.BINANCE_US"),
    # InstrumentId.from_str("BTCUSDT-SPOT.BYBIT"),
    # InstrumentId.from_str("BTCUSDT-LINEAR.BYBIT"),
    # InstrumentId.from_str("BTCUSDT.BINANCE"),
    InstrumentId.from_str("XBTUSDT.BITMEX"),
    InstrumentId.from_str("ETHUSDT.BITMEX"),
    # InstrumentId.from_str("BTC_USDT.GATE_IO"),
    # InstrumentId.from_str("BTC_USDT-PERP.GATE_IO"),
]

# See supported venues https://nautilustrader.io/docs/nightly/integrations/tardis#venues
venues = {i.venue.value for i in instrument_ids}
filters = {"venues": frozenset(venues)}
instrument_provider_config = InstrumentProviderConfig(load_all=True, filters=filters)

# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,  # Not applicable
        inflight_check_interval_ms=0,  # Not applicable
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(),
        encoding="msgpack",
        timestamps_as_iso8601=True,
        buffer_interval_ms=100,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     # types_filter=[QuoteTick],
    #     autotrim_mins=30,
    # ),
    # heartbeat_interval=1.0,
    data_clients={
        TARDIS: TardisDataClientConfig(
            api_key=None,  # 'TARDIS_API_KEY' env var
            instrument_provider=instrument_provider_config,
        ),
    },
    timeout_connection=60.0,
    timeout_reconciliation=10.0,  # Not applicable
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=1.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure and initialize the tester
config_tester = DataTesterConfig(
    client_id=TARDIS_CLIENT_ID,
    instrument_ids=instrument_ids,
    # subscribe_book_deltas=True,
    # subscribe_book_depth=True,
    # subscribe_book_at_interval=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    subscribe_funding_rates=True,
    # subscribe_bars=True,
    book_interval_ms=10,
)
tester = DataTester(config=config_tester)

node.trader.add_actor(tester)

# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(TARDIS, TardisLiveDataClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1882">
<source>examples/other/minimal_reproducible_example/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from datetime import UTC
from datetime import datetime
from decimal import Decimal

from strategy import DemoStrategy

from nautilus_trader.backtest.config import BacktestEngineConfig
from nautilus_trader.backtest.engine import BacktestEngine
from nautilus_trader.config import LoggingConfig
from nautilus_trader.core.datetime import dt_to_unix_nanos
from nautilus_trader.data.config import DataEngineConfig
from nautilus_trader.model import Bar
from nautilus_trader.model import BarType
from nautilus_trader.model import TraderId
from nautilus_trader.model.currencies import USD
from nautilus_trader.model.enums import AccountType
from nautilus_trader.model.enums import OmsType
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Money
from nautilus_trader.model.objects import Quantity
from nautilus_trader.test_kit.providers import TestInstrumentProvider


NANOSECONDS_IN_SECOND = 1_000_000_000


def generate_artificial_bars(instrument: Instrument, bar_type: BarType) -> list[Bar]:
    # Changes between generated bars
    PRICE_CHANGE = instrument.price_increment.as_double() * 10  # 10 ticks
    TIME_CHANGE_NANOS = 60 * NANOSECONDS_IN_SECOND  # 1 minute

    # --------------------------------------------
    # CREATE 1ST BAR
    # --------------------------------------------

    first_bar_time_as_unix_nanos = dt_to_unix_nanos(
        datetime(2024, 2, 1, hour=0, minute=1, second=0, tzinfo=UTC),
    )

    # Add 1st bar
    first_bar = Bar(
        bar_type=bar_type,
        open=instrument.make_price(1.10250),
        high=instrument.make_price(1.10300),
        low=instrument.make_price(1.100000),
        close=instrument.make_price(1.10050),
        volume=Quantity.from_int(999999),
        ts_event=first_bar_time_as_unix_nanos + TIME_CHANGE_NANOS,
        ts_init=first_bar_time_as_unix_nanos + TIME_CHANGE_NANOS,
    )

    generated_bars = [first_bar]
    last_bar = generated_bars[-1]

    # --------------------------------------------
    # CREATE ADDITIONAL BARS
    # --------------------------------------------

    # Add some INCREASING bars
    for _ in range(10):
        last_bar = Bar(
            bar_type=first_bar.bar_type,
            open=instrument.make_price(first_bar.open + PRICE_CHANGE),
            high=instrument.make_price(first_bar.high + PRICE_CHANGE),
            low=instrument.make_price(first_bar.low + PRICE_CHANGE),
            close=instrument.make_price(first_bar.close + PRICE_CHANGE),
            volume=first_bar.volume,
            ts_event=first_bar.ts_event + TIME_CHANGE_NANOS,
            ts_init=first_bar.ts_init + TIME_CHANGE_NANOS,
        )
        generated_bars.append(last_bar)

    # Add some DECREASING bars
    for _ in range(10):
        last_bar = Bar(
            bar_type=first_bar.bar_type,
            open=instrument.make_price(first_bar.open - PRICE_CHANGE),
            high=instrument.make_price(first_bar.high - PRICE_CHANGE),
            low=instrument.make_price(first_bar.low - PRICE_CHANGE),
            close=instrument.make_price(first_bar.close - PRICE_CHANGE),
            volume=first_bar.volume,
            ts_event=first_bar.ts_event + TIME_CHANGE_NANOS,
            ts_init=first_bar.ts_init + TIME_CHANGE_NANOS,
        )
        generated_bars.append(last_bar)

    return generated_bars


def run_backtest():
    # Step 1: Configure and create backtest engine
    engine_config = BacktestEngineConfig(
        trader_id=TraderId("BACKTEST_TRADER-001"),
        # Configure how data will be processed
        data_engine=DataEngineConfig(
            time_bars_interval_type="left-open",
            time_bars_timestamp_on_close=True,
            time_bars_skip_first_non_full_bar=False,
            time_bars_build_with_no_updates=False,  # don't emit aggregated bars, when no source data
            validate_data_sequence=True,
        ),
        # Configure logging
        logging=LoggingConfig(
            log_level="DEBUG",  # set DEBUG log level for console to see loaded bars in logs
        ),
    )
    engine = BacktestEngine(config=engine_config)

    # Step 2: Define exchange and add it to the engine
    VENUE_NAME = "XCME"
    engine.add_venue(
        venue=Venue(VENUE_NAME),
        oms_type=OmsType.NETTING,  # Order Management System type
        account_type=AccountType.MARGIN,  # Type of trading account
        starting_balances=[Money(1_000_000, USD)],  # Initial account balance
        base_currency=USD,  # Base currency for account
        default_leverage=Decimal(1),  # No leverage used for account
    )

    # Step 3: Create instrument definition and add it to the engine
    EURUSD_FUTURE = TestInstrumentProvider.eurusd_future(
        expiry_year=2024,
        expiry_month=3,
        venue_name=VENUE_NAME,
    )
    engine.add_instrument(EURUSD_FUTURE)

    # -------------------------------------------------------
    # PREPARE DATA
    # -------------------------------------------------------

    # Step 4a: Prepare BarType
    EURUSD_1MIN_BARTYPE = BarType.from_str(f"{EURUSD_FUTURE.id}-1-MINUTE-LAST-EXTERNAL")

    # Step 4b: Prepare bar data as list[Bar]
    bars: list[Bar] = generate_artificial_bars(
        instrument=EURUSD_FUTURE,
        bar_type=EURUSD_1MIN_BARTYPE,
    )

    # Step 4c: Add loaded data to the engine
    engine.add_data(bars)

    # ------------------------------------------------------------------------------------------

    # Step 5: Create strategy and add it to the engine
    strategy = DemoStrategy(input_bartype=EURUSD_1MIN_BARTYPE)
    engine.add_strategy(strategy)

    # Step 6: Run engine = Run backtest
    engine.run()

    # Step 7: Release system resources
    engine.dispose()


if __name__ == "__main__":
    run_backtest()

</document_content>
</document>
<document index="1883">
<source>examples/other/minimal_reproducible_example/strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import datetime as dt

from nautilus_trader.common.enums import LogColor
from nautilus_trader.core.datetime import unix_nanos_to_dt
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.objects import Quantity
from nautilus_trader.trading.strategy import Strategy


class DemoStrategy(Strategy):

    def __init__(self, input_bartype: BarType):
        super().__init__()

        # Input data
        self.input_bartype = input_bartype
        self.instrument_id = input_bartype.instrument_id
        self.bars_processed = 0

        # Order placed
        self.order_placed = False

        # Start/End time of strategy
        self.start_time = None
        self.end_time = None

    def on_start(self):
        # Remember and log start time of strategy
        self.start_time = dt.datetime.now()
        self.log.info(f"Strategy started at: {self.start_time}")

        # Subscribe to primary data
        self.subscribe_bars(self.input_bartype)

    def on_bar(self, bar: Bar):
        self.bars_processed += 1
        self.log.info(
            f"Bar #{self.bars_processed} | Time: {unix_nanos_to_dt(bar.ts_event):%Y-%m-%d %H:%M:%S} | Bar: {bar}",
            color=LogColor.BLUE,
        )

        # Enter: SELL MARKET order (at 3rd bar)
        if not self.order_placed and self.bars_processed == 3:
            order = self.order_factory.market(
                instrument_id=self.instrument_id,
                order_side=OrderSide.SELL,
                quantity=Quantity.from_int(1),  # 1 contract
                time_in_force=TimeInForce.GTC,
            )
            self.submit_order(order)
            self.order_placed = True
            self.log.info(f"Market order placed at {bar.close}", color=LogColor.GREEN)

        # Exit: BUY MARKET order (at 6th bar)
        if self.order_placed and self.bars_processed == 6:
            order = self.order_factory.market(
                instrument_id=self.instrument_id,
                order_side=OrderSide.BUY,
                quantity=Quantity.from_int(1),  # 1 contract
                time_in_force=TimeInForce.GTC,
            )
            self.submit_order(order)
            self.order_placed = True
            self.log.info(f"Market order placed at {bar.close}", color=LogColor.RED)

    def on_stop(self):
        # Remember and log end time of strategy
        self.end_time = dt.datetime.now()
        self.log.info(f"Strategy finished at: {self.end_time}")

        # Log count of processed bars
        self.log.info(f"Total bars processed: {self.bars_processed}")

</document_content>
</document>
<document index="1885">
<source>examples/other/state_machine/run_example.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from enum import IntEnum  # IntEnum is used to create enumerated types with integer values

from nautilus_trader.core.fsm import FiniteStateMachine
from nautilus_trader.core.fsm import InvalidStateTrigger


if __name__ == "__main__":

    # Step 1: Define all possible states of our application.
    # Each state represents a distinct condition the application can be in.
    # We use IntEnum to ensure each state has an integer value, which is required by Nautilus FSM
    # (i.e. similar StrEnum is not supported by FSM now)

    class AppState(IntEnum):

        INITIALIZED = 0  # Initial setup complete
        READY = 1  # Ready to start operations
        ACTIVE = 2  # Currently running/operating
        PAUSED = 3  # Temporarily paused
        STOPPED = 4  # Operations terminated

        @staticmethod
        def parse_from_code_to_str(code: int) -> str:
            try:
                return AppState(code).name
            except ValueError:
                raise ValueError(f"Invalid code '{code}' for AppState.")

        def __str__(self):
            return self.name

        def __repr__(self):
            return f"{self.name} ({self.value})"

    # Step 2: Define all possible triggers (actions / commands) that can cause state transitions
    # between application's states. Only IntEnum is supported (not StrEnum).

    class AppTrigger(IntEnum):

        START = 0  # Begin operations
        PAUSE = 1  # Temporarily suspend operations
        RESUME = 2  # Continue operations after being paused
        STOP = 3  # End operations

        def __str__(self):
            return self.name

        def __repr__(self):
            return f"{self.name} ({self.value})"

    # Step 3: Define the valid state transitions
    # This dictionary defines which state transitions are allowed and what their results should be
    # Format: (CURRENT_STATE, TRIGGER_ACTION): NEW_STATE
    # Any combination not listed here is considered invalid and will raise an exception

    STATE_TRANSITIONS: dict[tuple[AppState, AppTrigger], AppState] = {
        (AppState.READY, AppTrigger.START): AppState.ACTIVE,
        (AppState.ACTIVE, AppTrigger.PAUSE): AppState.PAUSED,
        (AppState.ACTIVE, AppTrigger.STOP): AppState.STOPPED,
        (AppState.PAUSED, AppTrigger.RESUME): AppState.ACTIVE,
        (AppState.PAUSED, AppTrigger.STOP): AppState.STOPPED,
    }

    # -----------------------------------------------
    # Example: Creating and Using State Machine
    # -----------------------------------------------

    # Create a new FSM instance with our defined states and transitions
    fsm = FiniteStateMachine(
        state_transition_table=STATE_TRANSITIONS,  # Our defined valid transitions
        initial_state=AppState.READY,  # Starting state of the FSM
        # Parsing function required to make work `fsm.state_string`
        state_parser=AppState.parse_from_code_to_str,
    )

    # -----------------------------------------------
    # Demo: Using the State Machine
    # The main operations are:
    # 1. Checking current state (fsm.state_string)
    # 2. Triggering state changes (fsm.trigger())
    # -----------------------------------------------

    # Print initial state
    print(f"Current (initial) state: {fsm.state_string}")

    # Demonstrate a series of valid state transitions
    print(f"Invoking trigger: {AppTrigger.START}")
    fsm.trigger(AppTrigger.START)  # READY -> ACTIVE
    print(f"Current state: {fsm.state_string}")

    print(f"Invoking trigger: {AppTrigger.PAUSE}")
    fsm.trigger(AppTrigger.PAUSE)  # ACTIVE -> PAUSED
    print(f"Current state: {fsm.state_string}")

    print(f"Invoking trigger: {AppTrigger.RESUME}")
    fsm.trigger(AppTrigger.RESUME)  # PAUSED -> ACTIVE
    print(f"Current state: {fsm.state_string}")

    print(f"Invoking trigger: {AppTrigger.STOP}")
    fsm.trigger(AppTrigger.STOP)  # ACTIVE -> STOPPED
    print(f"Current state: {fsm.state_string}")

    # Demonstrate invalid state transition
    # Once STOPPED, we cannot RESUME (this transition isn't in our STATE_TRANSITIONS table)
    try:
        print(f"Invoking trigger: {AppTrigger.RESUME}")
        fsm.trigger(AppTrigger.RESUME)  # This will fail - cannot RESUME from STOPPED state
    except InvalidStateTrigger:
        print("We got expected exception: InvalidStateTrigger")

</document_content>
</document>
<document index="1886">
<source>examples/sandbox/betfair_sandbox.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
import traceback
from decimal import Decimal

from nautilus_trader.adapters.betfair import BETFAIR
from nautilus_trader.adapters.betfair import BetfairDataClientConfig
from nautilus_trader.adapters.betfair import BetfairInstrumentProviderConfig
from nautilus_trader.adapters.betfair import BetfairLiveDataClientFactory
from nautilus_trader.adapters.betfair import get_cached_betfair_client
from nautilus_trader.adapters.betfair import get_cached_betfair_instrument_provider
from nautilus_trader.adapters.sandbox.config import SandboxExecutionClientConfig
from nautilus_trader.adapters.sandbox.factory import SandboxLiveExecClientFactory
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalance
from nautilus_trader.examples.strategies.orderbook_imbalance import OrderBookImbalanceConfig
from nautilus_trader.live.node import TradingNode


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


async def main(instrument_config: BetfairInstrumentProviderConfig) -> TradingNode:
    # Connect to Betfair client early to load instruments and account currency
    client = get_cached_betfair_client(
        username=None,  # Pass here or will source from the `BETFAIR_USERNAME` env var
        password=None,  # Pass here or will source from the `BETFAIR_PASSWORD` env var
        app_key=None,  # Pass here or will source from the `BETFAIR_APP_KEY` env var
    )
    await client.connect()

    # Find instruments for a particular market_id
    provider = get_cached_betfair_instrument_provider(
        client=client,
        config=instrument_config,
    )
    await provider.load_all_async()
    instruments = provider.list_all()
    print(f"Found instruments:\n{[ins.id for ins in instruments]}")

    # Load account currency
    account_currency = await provider.get_account_currency()

    # Configure trading node
    config = TradingNodeConfig(
        timeout_connection=30.0,
        logging=LoggingConfig(log_level="DEBUG"),
        data_clients={
            BETFAIR: BetfairDataClientConfig(
                account_currency=account_currency,
                instrument_config=instrument_config,
            ),
        },
        exec_clients={
            BETFAIR: SandboxExecutionClientConfig(
                venue=BETFAIR,
                base_currency="AUD",
                starting_balances=["10_000 AUD"],
            ),
        },
    )
    strategies = [
        OrderBookImbalance(
            config=OrderBookImbalanceConfig(
                instrument_id=instrument.id,
                max_trade_size=Decimal(10),
                order_id_tag=instrument.selection_id,
            ),
        )
        for instrument in instruments
    ]

    # Set up TradingNode
    node = TradingNode(config=config)

    # Can manually set instruments for sandbox exec client
    for instrument in instruments:
        node.cache.add_instrument(instrument)

    node.trader.add_strategies(strategies)

    # Register your client factories with the node (can take user-defined factories)
    node.add_data_client_factory(BETFAIR, BetfairLiveDataClientFactory)
    node.add_exec_client_factory(BETFAIR, SandboxLiveExecClientFactory)
    node.build()

    try:
        await node.run_async()
    except Exception as e:
        print(e)
        print(traceback.format_exc())
    finally:
        await node.stop_async()
        await asyncio.sleep(1)

    return node


if __name__ == "__main__":
    # Update the market ID with something coming up in `Next Races` from
    # https://www.betfair.com.au/exchange/plus/
    # The market ID will appear in the browser query string.
    config = BetfairInstrumentProviderConfig(
        market_ids=["1.199513161"],
        account_currency="GBP",
    )
    node = asyncio.run(main(config))
    node.dispose()

</document_content>
</document>
<document index="1887">
<source>examples/sandbox/binance_futures_testnet_sandbox.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
from decimal import Decimal

from nautilus_trader.adapters.binance import BINANCE
from nautilus_trader.adapters.binance import BINANCE_VENUE
from nautilus_trader.adapters.binance import BinanceAccountType
from nautilus_trader.adapters.binance import BinanceDataClientConfig
from nautilus_trader.adapters.binance.factories import BinanceLiveDataClientFactory
from nautilus_trader.adapters.sandbox.config import SandboxExecutionClientConfig
from nautilus_trader.adapters.sandbox.factory import SandboxLiveExecClientFactory
from nautilus_trader.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMaker
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMakerConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


async def main():
    """
    Show how to run a strategy in a sandbox for the Binance venue.
    """
    # Configure the trading node
    config_node = TradingNodeConfig(
        trader_id=TraderId("TESTER-001"),
        logging=LoggingConfig(
            log_level="INFO",
            # log_level_file="DEBUG",
            # log_file_format="json",
            log_colors=True,
            use_pyo3=True,
        ),
        exec_engine=LiveExecEngineConfig(
            reconciliation=True,
            reconciliation_lookback_mins=1440,
            filter_position_reports=True,
            # snapshot_orders=True,
            # snapshot_positions=True,
            # snapshot_positions_interval_secs=5.0,
        ),
        cache=CacheConfig(
            # database=DatabaseConfig(timeout=2),
            timestamps_as_iso8601=True,
            flush_on_start=False,
        ),
        # message_bus=MessageBusConfig(
        #     database=DatabaseConfig(timeout=2),
        #     encoding="json",
        #     timestamps_as_iso8601=True,
        #     streams_prefix="quoters",
        #     use_instance_id=False,
        #     # types_filter=[QuoteTick],
        #     autotrim_mins=30,
        #     heartbeat_interval_secs=1,
        # ),
        data_clients={
            BINANCE: BinanceDataClientConfig(
                api_key=None,  # 'BINANCE_API_KEY' env var
                api_secret=None,  # 'BINANCE_API_SECRET' env var
                account_type=BinanceAccountType.USDT_FUTURES,
                base_url_http=None,  # Override with custom endpoint
                base_url_ws=None,  # Override with custom endpoint
                us=False,  # If client is for Binance US
                testnet=True,  # If client uses the testnet
                instrument_provider=InstrumentProviderConfig(load_all=True),
            ),
        },
        exec_clients={
            BINANCE: SandboxExecutionClientConfig(
                venue=BINANCE_VENUE,
                starting_balances=["10_000 USDT", "10 ETH"],
            ),
        },
        timeout_connection=30.0,
        timeout_reconciliation=10.0,
        timeout_portfolio=10.0,
        timeout_disconnection=10.0,
        timeout_post_stop=5.0,
    )

    # Instantiate the node with a configuration
    node = TradingNode(config=config_node)

    # Configure your strategy
    strat_config = VolatilityMarketMakerConfig(
        instrument_id=InstrumentId.from_str("ETHUSDT-PERP.BINANCE"),
        external_order_claims=[InstrumentId.from_str("ETHUSDT-PERP.BINANCE")],
        bar_type=BarType.from_str("ETHUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL"),
        atr_period=20,
        atr_multiple=6.0,
        trade_size=Decimal("0.010"),
        # manage_gtd_expiry=True,
    )
    # Instantiate your strategy
    strategy = VolatilityMarketMaker(config=strat_config)

    # Add your strategies and modules
    node.trader.add_strategy(strategy)

    # Register your client factories with the node (can take user-defined factories)
    node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
    node.add_exec_client_factory(BINANCE, SandboxLiveExecClientFactory)
    node.build()

    try:
        await node.run_async()
    finally:
        await node.stop_async()
        await asyncio.sleep(1)
        node.dispose()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    asyncio.run(main())

</document_content>
</document>
<document index="1888">
<source>examples/sandbox/binance_spot_futures_sandbox.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
import json
from decimal import Decimal

from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
from nautilus_trader.adapters.binance.config import BinanceDataClientConfig
from nautilus_trader.adapters.binance.factories import BinanceLiveDataClientFactory
from nautilus_trader.adapters.binance.futures.types import BinanceFuturesMarkPriceUpdate
from nautilus_trader.adapters.sandbox.config import SandboxExecutionClientConfig
from nautilus_trader.adapters.sandbox.factory import SandboxLiveExecClientFactory
from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import CacheConfig
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.core.data import Data
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import DataType
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.identifiers import ClientId
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId
from nautilus_trader.model.identifiers import Venue
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading import Strategy
from nautilus_trader.trading.config import StrategyConfig


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class TestStrategyConfig(StrategyConfig, frozen=True):
    futures_client_id: ClientId
    futures_instrument_id: InstrumentId
    spot_instrument_id: InstrumentId


class TestStrategy(Strategy):
    def __init__(self, config: TestStrategyConfig) -> None:
        super().__init__(config)

        self.futures_instrument: Instrument | None = None  # Initialized in on_start
        self.spot_instrument: Instrument | None = None  # Initialized in on_start
        self.futures_client_id = config.futures_client_id

    def on_start(self) -> None:
        self.futures_instrument = self.cache.instrument(self.config.futures_instrument_id)
        if self.futures_instrument is None:
            self.log.error(
                f"Could not find instrument for {self.config.futures_instrument_id}"
                f"\nPossible instruments: {self.cache.instrument_ids()}",
            )
            self.stop()
            return
        self.spot_instrument = self.cache.instrument(self.config.spot_instrument_id)
        if self.spot_instrument is None:
            self.log.error(
                f"Could not find futures instrument for {self.config.spot_instrument_id}"
                f"\nPossible instruments: {self.cache.instrument_ids()}",
            )
            self.stop()
            return

        account = self.portfolio.account(venue=self.futures_instrument.venue)
        balances = {str(currency): str(balance) for currency, balance in account.balances().items()}
        self.log.info(f"Futures balances\n{json.dumps(balances, indent=4)}", LogColor.GREEN)
        account = self.portfolio.account(venue=self.spot_instrument.venue)
        balances = {str(currency): str(balance) for currency, balance in account.balances().items()}
        self.log.info(f"Spot balances\n{json.dumps(balances, indent=4)}", LogColor.GREEN)

        # Subscribe to live data
        self.subscribe_quote_ticks(self.config.futures_instrument_id)
        self.subscribe_quote_ticks(self.config.spot_instrument_id)
        self.subscribe_data(
            data_type=DataType(
                BinanceFuturesMarkPriceUpdate,
                metadata={"instrument_id": self.futures_instrument.id},
            ),
            client_id=self.futures_client_id,
        )

    def on_data(self, data: Data) -> None:
        self.log.info(repr(data), LogColor.CYAN)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        self.log.info(repr(tick), LogColor.CYAN)

    def on_trade_tick(self, tick: TradeTick) -> None:
        self.log.info(repr(tick), LogColor.CYAN)

    def on_bar(self, bar: Bar) -> None:
        self.log.info(repr(bar), LogColor.CYAN)

    def on_stop(self) -> None:
        # Unsubscribe from data
        self.unsubscribe_quote_ticks(self.config.futures_instrument_id)
        self.unsubscribe_quote_ticks(self.config.spot_instrument_id)


async def main():
    """
    Show how to run a strategy in a sandbox for the Binance venue.
    """
    # Configure the trading node
    config_node = TradingNodeConfig(
        trader_id=TraderId("TESTER-001"),
        logging=LoggingConfig(
            log_level="INFO",
            log_colors=True,
            use_pyo3=True,
        ),
        exec_engine=LiveExecEngineConfig(
            reconciliation=True,
            reconciliation_lookback_mins=1440,
            filter_position_reports=True,
        ),
        cache=CacheConfig(
            timestamps_as_iso8601=True,
            flush_on_start=False,
        ),
        data_clients={
            "BINANCE_FUTURES": BinanceDataClientConfig(
                venue=Venue("BINANCE_FUTURES"),
                api_key=None,  # 'BINANCE_API_KEY' env var
                api_secret=None,  # 'BINANCE_API_SECRET' env var
                account_type=BinanceAccountType.USDT_FUTURES,
                base_url_http=None,  # Override with custom endpoint
                base_url_ws=None,  # Override with custom endpoint
                us=False,  # If client is for Binance US
                testnet=False,  # If client uses the testnet
                instrument_provider=InstrumentProviderConfig(load_all=True),
            ),
            "BINANCE_SPOT": BinanceDataClientConfig(
                venue=Venue("BINANCE_SPOT"),
                api_key=None,  # 'BINANCE_API_KEY' env var
                api_secret=None,  # 'BINANCE_API_SECRET' env var
                account_type=BinanceAccountType.SPOT,
                base_url_http=None,  # Override with custom endpoint
                base_url_ws=None,  # Override with custom endpoint
                us=False,  # If client is for Binance US
                testnet=False,  # If client uses the testnet
                instrument_provider=InstrumentProviderConfig(load_all=True),
            ),
        },
        exec_clients={
            "BINANCE_FUTURES": SandboxExecutionClientConfig(
                venue="BINANCE_FUTURES",
                account_type="MARGIN",
                starting_balances=["10_000 USDC", "0.005 BTC"],
                default_leverage=Decimal(5),
            ),
            "BINANCE_SPOT": SandboxExecutionClientConfig(
                venue="BINANCE_SPOT",
                account_type="CASH",
                starting_balances=["1_000 USDC", "0.001 BTC"],
            ),
        },
        timeout_connection=30.0,
        timeout_reconciliation=10.0,
        timeout_portfolio=10.0,
        timeout_disconnection=10.0,
        timeout_post_stop=5.0,
    )

    # Instantiate the node with a configuration
    node = TradingNode(config=config_node)

    # Configure your strategy
    strat_config = TestStrategyConfig(
        futures_client_id=ClientId("BINANCE_FUTURES"),
        futures_instrument_id=InstrumentId.from_str("BTCUSDT-PERP.BINANCE_FUTURES"),
        spot_instrument_id=InstrumentId.from_str("BTCUSDC.BINANCE_SPOT"),
    )
    # Instantiate your strategy
    strategy = TestStrategy(config=strat_config)

    # Add your strategies and modules
    node.trader.add_strategy(strategy)

    # Register your client factories with the node (can take user-defined factories)
    node.add_data_client_factory("BINANCE_FUTURES", BinanceLiveDataClientFactory)
    node.add_data_client_factory("BINANCE_SPOT", BinanceLiveDataClientFactory)
    node.add_exec_client_factory("BINANCE_FUTURES", SandboxLiveExecClientFactory)
    node.add_exec_client_factory("BINANCE_SPOT", SandboxLiveExecClientFactory)
    node.build()

    try:
        await node.run_async()
    finally:
        await node.stop_async()
        await asyncio.sleep(1)
        node.dispose()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    asyncio.run(main())

</document_content>
</document>
<document index="1889">
<source>examples/sandbox/bybit_sandbox.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
from decimal import Decimal

from nautilus_trader.adapters.bybit import BybitDataClientConfig
from nautilus_trader.adapters.bybit import BybitLiveDataClientFactory
from nautilus_trader.adapters.bybit import BybitProductType
from nautilus_trader.adapters.sandbox.config import SandboxExecutionClientConfig
from nautilus_trader.adapters.sandbox.factory import SandboxLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMaker
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMakerConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


async def main():
    """
    Show how to run a strategy in a sandbox for the Bybit venue.
    """
    instrument_provider_config = InstrumentProviderConfig(load_all=True)

    # Set up the execution clients (required per venue)
    venues = ["BYBIT"]

    exec_clients = {}
    for venue in venues:
        exec_clients[venue] = SandboxExecutionClientConfig(
            venue=venue,
            starting_balances=["10_000 USDT", "10 ETH"],
            instrument_provider=instrument_provider_config,
            account_type="MARGIN",
            oms_type="NETTING",
        )

    # Configure the trading node
    config_node = TradingNodeConfig(
        trader_id=TraderId("TESTER-001"),
        logging=LoggingConfig(
            log_level="INFO",
            # log_level_file="DEBUG",
            # log_file_format="json",
            log_colors=True,
            use_pyo3=True,
        ),
        data_clients={
            "BYBIT": BybitDataClientConfig(
                api_key=None,  # 'BYBIT_API_KEY' env var
                api_secret=None,  # 'BYBIT_API_SECRET' env var
                instrument_provider=instrument_provider_config,
                product_types=(BybitProductType.LINEAR,),
                testnet=False,  # If client uses the testnet
            ),
        },
        exec_clients=exec_clients,
        timeout_connection=30.0,
        timeout_reconciliation=10.0,
        timeout_portfolio=10.0,
        timeout_disconnection=10.0,
        timeout_post_stop=5.0,
    )

    # Instantiate the node with a configuration
    node = TradingNode(config=config_node)

    # Configure your strategy
    strat_config = VolatilityMarketMakerConfig(
        instrument_id=InstrumentId.from_str("ETHUSDT-LINEAR.BYBIT"),
        external_order_claims=[InstrumentId.from_str("ETHUSDT-LINEAR.BYBIT")],
        bar_type=BarType.from_str("ETHUSDT-LINEAR.BYBIT-1-MINUTE-LAST-EXTERNAL"),
        atr_period=20,
        atr_multiple=6.0,
        trade_size=Decimal("0.010"),
        # manage_gtd_expiry=True,
    )
    # Instantiate your strategy
    strategy = VolatilityMarketMaker(config=strat_config)

    # Add your strategies and modules
    node.trader.add_strategy(strategy)

    # Register client factories with the node
    for data_client in config_node.data_clients:
        node.add_data_client_factory(data_client, BybitLiveDataClientFactory)

    for exec_client in config_node.exec_clients:
        node.add_exec_client_factory(exec_client, SandboxLiveExecClientFactory)

    node.build()

    try:
        await node.run_async()
    finally:
        await node.stop_async()
        await asyncio.sleep(1)
        node.dispose()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    asyncio.run(main())

</document_content>
</document>
<document index="1890">
<source>examples/sandbox/databento_cme_sandbox.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
"""
Sandbox for Databento live data and CME simulated execution.
"""

from nautilus_trader.adapters.databento import DATABENTO
from nautilus_trader.adapters.databento import DatabentoDataClientConfig
from nautilus_trader.adapters.databento import DatabentoLiveDataClientFactory
from nautilus_trader.adapters.sandbox.config import SandboxExecutionClientConfig
from nautilus_trader.adapters.sandbox.factory import SandboxLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LiveExecEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.simpler_quoter import SimpleQuoterStrategy
from nautilus_trader.examples.strategies.simpler_quoter import SimpleQuoterStrategyConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# Specify instrument to be traded
instrument_id = InstrumentId.from_str("ESZ5.XCME")

instrument_provider = InstrumentProviderConfig(load_all=True)

# Configure the trading node:
# For correct subscription operation, you must specify all instruments to be immediately
# subscribed for as part of the data client configuration.
config_data = DatabentoDataClientConfig(
    api_key=None,  # 'DATABENTO_API_KEY' env var
    http_gateway=None,
    instrument_provider=instrument_provider,
    use_exchange_as_venue=True,
    mbo_subscriptions_delay=10.0,
    instrument_ids=[instrument_id],
    parent_symbols={"GLBX.MDP3": {"ES.FUT"}},
)

config_exec = SandboxExecutionClientConfig(
    venue="XCME",
    base_currency="USD",
    starting_balances=["1_000_000 USD"],
    instrument_provider=instrument_provider,
)

config_node = TradingNodeConfig(
    trader_id=TraderId("SANDBOX-001"),
    logging=LoggingConfig(log_level="INFO", use_pyo3=True),
    exec_engine=LiveExecEngineConfig(reconciliation=False),
    data_clients={
        DATABENTO: config_data,
    },
    exec_clients={
        "XCME": config_exec,
    },
    timeout_connection=30.0,
    timeout_reconciliation=5.0,
    timeout_portfolio=5.0,
    timeout_disconnection=10.0,
    timeout_post_stop=2.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Configure and initialize the quoter strategy
config_quoter = SimpleQuoterStrategyConfig(
    instrument_id=InstrumentId.from_str("ESZ5.XCME"),
    tob_offset_ticks=0,
    log_data=False,
)
quoter = SimpleQuoterStrategy(config=config_quoter)

node.trader.add_strategy(quoter)

# Register required client factories with the node
node.add_data_client_factory(DATABENTO, DatabentoLiveDataClientFactory)
node.add_exec_client_factory("XCME", SandboxLiveExecClientFactory)
node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1891">
<source>examples/sandbox/dydx_sandbox.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
from decimal import Decimal

from nautilus_trader.adapters.dydx.config import DYDXDataClientConfig
from nautilus_trader.adapters.dydx.factories import DYDXLiveDataClientFactory
from nautilus_trader.adapters.sandbox.config import SandboxExecutionClientConfig
from nautilus_trader.adapters.sandbox.factory import SandboxLiveExecClientFactory
from nautilus_trader.config import InstrumentProviderConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMaker
from nautilus_trader.examples.strategies.volatility_market_maker import VolatilityMarketMakerConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import TraderId


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


async def main():
    """
    Show how to run a strategy in a sandbox for the dYdX venue.
    """
    instrument_provider_config = InstrumentProviderConfig(load_all=True)

    # Set up the execution clients (required per venue)
    venues = ["DYDX"]

    exec_clients = {}
    for venue in venues:
        exec_clients[venue] = SandboxExecutionClientConfig(
            venue=venue,
            starting_balances=["10_000 USDC", "10 ETH"],
            instrument_provider=instrument_provider_config,
            account_type="MARGIN",
            oms_type="NETTING",
        )

    # Configure the trading node
    config_node = TradingNodeConfig(
        trader_id=TraderId("TESTER-001"),
        logging=LoggingConfig(
            log_level="INFO",
            # log_level_file="DEBUG",
            # log_file_format="json",
            log_colors=True,
            use_pyo3=True,
        ),
        data_clients={
            "DYDX": DYDXDataClientConfig(
                wallet_address=None,  # 'DYDX_WALLET_ADDRESS' env var
                instrument_provider=instrument_provider_config,
                is_testnet=False,  # If client uses the testnet
            ),
        },
        exec_clients=exec_clients,
        timeout_connection=30.0,
        timeout_reconciliation=10.0,
        timeout_portfolio=10.0,
        timeout_disconnection=10.0,
        timeout_post_stop=5.0,
    )

    # Instantiate the node with a configuration
    node = TradingNode(config=config_node)

    # Configure your strategy
    strat_config = VolatilityMarketMakerConfig(
        instrument_id=InstrumentId.from_str("ETH-USD-PERP.DYDX"),
        external_order_claims=[InstrumentId.from_str("ETH-USD-PERP.DYDX")],
        bar_type=BarType.from_str("ETH-USD-PERP.DYDX-1-MINUTE-LAST-EXTERNAL"),
        atr_period=20,
        atr_multiple=6.0,
        trade_size=Decimal("0.010"),
        # manage_gtd_expiry=True,
    )
    # Instantiate your strategy
    strategy = VolatilityMarketMaker(config=strat_config)

    # Add your strategies and modules
    node.trader.add_strategy(strategy)

    # Register client factories with the node
    for data_client in config_node.data_clients:
        node.add_data_client_factory(data_client, DYDXLiveDataClientFactory)

    for exec_client in config_node.exec_clients:
        node.add_exec_client_factory(exec_client, SandboxLiveExecClientFactory)

    node.build()

    try:
        await node.run_async()
    finally:
        await node.stop_async()
        await asyncio.sleep(1)
        node.dispose()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    asyncio.run(main())

</document_content>
</document>
<document index="1892">
<source>examples/sandbox/hyperliquid_testnet_sandbox.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
"""
Sandbox script for testing Hyperliquid testnet order placement.

Usage:
    export HYPERLIQUID_TESTNET_PK=0x...
    python examples/sandbox/hyperliquid_testnet_sandbox.py

"""

import asyncio
import os
import sys
import uuid

from nautilus_trader.core.nautilus_pyo3 import UUID4
from nautilus_trader.core.nautilus_pyo3 import ClientOrderId
from nautilus_trader.core.nautilus_pyo3 import HyperliquidHttpClient
from nautilus_trader.core.nautilus_pyo3 import LimitOrder
from nautilus_trader.core.nautilus_pyo3 import OrderSide
from nautilus_trader.core.nautilus_pyo3 import Price
from nautilus_trader.core.nautilus_pyo3 import Quantity
from nautilus_trader.core.nautilus_pyo3 import StrategyId
from nautilus_trader.core.nautilus_pyo3 import TimeInForce
from nautilus_trader.core.nautilus_pyo3 import TraderId


async def main():
    """
    Test Hyperliquid testnet order placement.
    """
    private_key = os.getenv("HYPERLIQUID_TESTNET_PK")
    if not private_key:
        print("Error: HYPERLIQUID_TESTNET_PK not set")
        sys.exit(1)

    try:
        http_client = HyperliquidHttpClient(
            private_key=private_key,
            vault_address=None,
            is_testnet=True,
            timeout_secs=None,
        )

        # Verify the derived address
        address = http_client.get_user_address()

        instruments = await http_client.load_instrument_definitions(
            include_perp=True,
            include_spot=False,
        )
        instrument = next((i for i in instruments if "BTC-USD-PERP" in str(i.id.symbol)), None)
        if not instrument:
            raise ValueError("BTC-USD-PERP not found")

        http_client.add_instrument(instrument)
        http_client.set_account_id(f"HYPERLIQUID-{address}")

        # Get current BTC price
        import json

        book_json = await http_client.get_l2_book("BTC")
        book = json.loads(book_json)
        best_bid = float(book["levels"][0][0]["px"])

        # Place order at best bid minus $100
        limit_price = int(best_bid - 100)  # $100 below best bid for safety

        cloid_hex = "0x" + uuid.UUID(UUID4().value).hex
        order = LimitOrder(
            trader_id=TraderId("TESTER-001"),
            strategy_id=StrategyId("SANDBOX-001"),
            instrument_id=instrument.id,
            client_order_id=ClientOrderId(cloid_hex),
            order_side=OrderSide.BUY,
            quantity=Quantity.from_str("0.00100"),  # Exactly 5 decimals
            price=Price.from_str(str(limit_price)),
            time_in_force=TimeInForce.GTC,
            post_only=False,  # Try without post_only
            reduce_only=False,
            quote_quantity=False,
            init_id=UUID4(),
            ts_init=0,
        )

        report = await http_client.submit_order(order)
        print("=" * 60)
        print(" ORDER SUBMITTED SUCCESSFULLY!")
        print(f"  Client Order ID: {report.client_order_id}")
        print(f"  Venue Order ID:  {report.venue_order_id}")
        print(f"  Order Status:    {report.order_status}")
        print(f"  Filled Qty:      {report.filled_qty}")
        print("=" * 60)
    except Exception as e:
        print(f"Error: {e}")
        raise


if __name__ == "__main__":
    asyncio.run(main())

</document_content>
</document>
<document index="1893">
<source>examples/sandbox/interactive_brokers_sandbox.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.adapters.interactive_brokers.common import IB
from nautilus_trader.adapters.interactive_brokers.config import DockerizedIBGatewayConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
from nautilus_trader.adapters.interactive_brokers.factories import InteractiveBrokersLiveDataClientFactory
from nautilus_trader.adapters.sandbox.config import SandboxExecutionClientConfig
from nautilus_trader.adapters.sandbox.factory import SandboxLiveExecClientFactory
from nautilus_trader.config import LiveDataEngineConfig
from nautilus_trader.config import LoggingConfig
from nautilus_trader.config import TradingNodeConfig
from nautilus_trader.examples.strategies.ema_cross import EMACross
from nautilus_trader.examples.strategies.ema_cross import EMACrossConfig
from nautilus_trader.live.node import TradingNode
from nautilus_trader.model.data import BarType
from nautilus_trader.persistence.catalog import ParquetDataCatalog


# Load instruments from a Parquet catalog
CATALOG_PATH = "/path/to/catalog"
catalog = ParquetDataCatalog(CATALOG_PATH)
SANDBOX_INSTRUMENTS = catalog.instruments(instrument_ids=["EUR/USD.IDEALPRO"])

# Set up the Interactive Brokers gateway configuration, this is applicable only when using Docker.
dockerized_gateway = DockerizedIBGatewayConfig(
    username=None,
    password=None,
    trading_mode="paper",
    read_only_api=True,
)

instrument_provider = InteractiveBrokersInstrumentProviderConfig(
    build_futures_chain=False,
    build_options_chain=False,
    min_expiry_days=10,
    max_expiry_days=60,
    load_ids=frozenset(str(instrument.id) for instrument in SANDBOX_INSTRUMENTS),
)

# Set up the execution clients (required per venue)
SANDBOX_VENUES = {str(instrument.venue) for instrument in SANDBOX_INSTRUMENTS}
exec_clients = {}
for venue in SANDBOX_VENUES:
    exec_clients[venue] = SandboxExecutionClientConfig(
        venue=venue,
        base_currency="USD",
        starting_balances=["1_000_000 USD"],
        instrument_provider=instrument_provider,
    )


# Configure the trading node
config_node = TradingNodeConfig(
    trader_id="SANDBOX-001",
    logging=LoggingConfig(log_level="INFO"),
    data_clients={
        IB: InteractiveBrokersDataClientConfig(
            ibg_host="127.0.0.1",
            ibg_port=7497,
            ibg_client_id=1,
            use_regular_trading_hours=True,
            instrument_provider=instrument_provider,
            dockerized_gateway=dockerized_gateway,
        ),
    },
    exec_clients=exec_clients,  # type: ignore
    data_engine=LiveDataEngineConfig(
        time_bars_timestamp_on_close=False,
        validate_data_sequence=True,
    ),
    timeout_connection=90.0,
    timeout_reconciliation=5.0,
    timeout_portfolio=5.0,
    timeout_disconnection=5.0,
    timeout_post_stop=2.0,
)

# Instantiate the node with a configuration
node = TradingNode(config=config_node)

# Can manually set instruments for sandbox exec client
for instrument in SANDBOX_INSTRUMENTS:
    node.cache.add_instrument(instrument)

# Instantiate strategies
strategies = {}
for instrument in SANDBOX_INSTRUMENTS:
    # Configure your strategy
    strategy_config = EMACrossConfig(
        instrument_id=instrument.id,
        bar_type=BarType.from_str(f"{instrument.id}-30-SECOND-MID-EXTERNAL"),
        trade_size=Decimal(100_000),
        subscribe_quote_ticks=True,
    )
    # Instantiate your strategy
    strategy = EMACross(config=strategy_config)
    # Add your strategies and modules
    node.trader.add_strategy(strategy)

    strategies[str(instrument.id)] = strategy


# Register client factories with the node
for data_client in config_node.data_clients:
    node.add_data_client_factory(data_client, InteractiveBrokersLiveDataClientFactory)
for exec_client in config_node.exec_clients:
    node.add_exec_client_factory(exec_client, SandboxLiveExecClientFactory)

node.build()


# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()

</document_content>
</document>
<document index="1894">
<source>examples/utils/__init__.py</source>
<document_content>
# This module contains reusable functions used for examples.
# The point is, that examples are often similar and contain a lot of same code,
# so it is better to extract repetitive parts into a separate module.

</document_content>
</document>
<document index="1895">
<source>examples/utils/data_provider.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import pandas as pd

from nautilus_trader import TEST_DATA_DIR
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.persistence.wranglers import BarDataWrangler
from nautilus_trader.test_kit.providers import TestInstrumentProvider


def prepare_demo_data_eurusd_futures_1min():
    # Define exchange name
    VENUE_NAME = "XCME"

    # Instrument definition for EURUSD futures (March 2024)
    EURUSD_INSTRUMENT = TestInstrumentProvider.eurusd_future(
        expiry_year=2024,
        expiry_month=3,
        venue_name=VENUE_NAME,
    )

    # CSV file containing 1-minute bars instrument data above
    csv_file_path = rf"{TEST_DATA_DIR}/xcme/6EH4.{VENUE_NAME}_1min_bars_20240101_20240131.csv.gz"

    # Load raw data from CSV file and restructure them into required format for BarDataWrangler
    df = pd.read_csv(csv_file_path, header=0, index_col=False)
    df = df.reindex(columns=["timestamp_utc", "open", "high", "low", "close", "volume"])
    df["timestamp_utc"] = pd.to_datetime(df["timestamp_utc"], format="%Y-%m-%d %H:%M:%S")
    df = df.rename(columns={"timestamp_utc": "timestamp"})
    df = df.set_index("timestamp")

    # Define bar type
    EURUSD_1MIN_BARTYPE = BarType.from_str(f"{EURUSD_INSTRUMENT.id}-1-MINUTE-LAST-EXTERNAL")

    # Convert DataFrame rows into Bar objects
    wrangler = BarDataWrangler(EURUSD_1MIN_BARTYPE, EURUSD_INSTRUMENT)
    bars_list: list[Bar] = wrangler.process(df)

    # Collect and return all prepared data
    prepared_data = {
        "venue_name": VENUE_NAME,
        "instrument": EURUSD_INSTRUMENT,
        "bar_type": EURUSD_1MIN_BARTYPE,
        "bars_list": bars_list,
    }
    return prepared_data

</document_content>
</document>
<document index="2310">
<source>nautilus_trader/examples/__init__.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

</document_content>
</document>
<document index="2311">
<source>nautilus_trader/examples/algorithms/__init__.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

</document_content>
</document>
<document index="2312">
<source>nautilus_trader/examples/algorithms/blank.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.common.component import LogColor
from nautilus_trader.config import ExecAlgorithmConfig
from nautilus_trader.execution.algorithm import ExecAlgorithm
from nautilus_trader.model.identifiers import ExecAlgorithmId
from nautilus_trader.model.orders import Order
from nautilus_trader.model.orders import OrderList


class MyExecAlgorithmConfig(ExecAlgorithmConfig, frozen=True):
    """
    Configuration for ``MyExecAlgorithm`` instances.

    Parameters
    ----------
    exec_algorithm_id : str | ExecAlgorithmId, optional
        The execution algorithm ID (will override default which is the class name).

    """

    exec_algorithm_id: ExecAlgorithmId | None = None


class MyExecAlgorithm(ExecAlgorithm):
    """
    A blank template execution algorithm.

    Parameters
    ----------
    config : MyExecAlgorithmConfig
        The configuration for the instance.

    """

    def __init__(self, config: MyExecAlgorithmConfig) -> None:
        super().__init__(config)
        # Optionally implement further initialization

    def on_start(self) -> None:
        """
        Actions to be performed when the algorithm component is started.
        """
        # Optionally implement

    def on_stop(self) -> None:
        """
        Actions to be performed when the algorithm component is stopped.
        """
        # Optionally implement

    def on_reset(self) -> None:
        """
        Actions to be performed when the algorithm component is reset.
        """
        # Optionally implement

    def on_dispose(self) -> None:
        """
        Actions to be performed when the algorithm component is disposed.

        Cleanup any resources used by the strategy here.

        """
        # Optionally implement

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the algorithm component is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}  # Optionally implement

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the algorithm component is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """
        # Optionally implement

    def on_order(self, order: Order) -> None:
        """
        Actions to be performed when running and receives an order.

        Parameters
        ----------
        order : Order
            The order to be handled.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        self.log.info(repr(order), LogColor.CYAN)
        # Optionally implement

    def on_order_list(self, order_list: OrderList) -> None:
        """
        Actions to be performed when running and receives an order list.

        Parameters
        ----------
        order_list : OrderList
            The order list to be handled.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        self.log.info(repr(order_list), LogColor.CYAN)
        # Optionally implement

</document_content>
</document>
<document index="2313">
<source>nautilus_trader/examples/algorithms/twap.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import math
from datetime import timedelta
from decimal import ROUND_DOWN
from decimal import Decimal

from nautilus_trader.common.enums import LogColor
from nautilus_trader.common.events import TimeEvent
from nautilus_trader.config import ExecAlgorithmConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.execution.algorithm import ExecAlgorithm
from nautilus_trader.model.enums import OrderType
from nautilus_trader.model.identifiers import ClientOrderId
from nautilus_trader.model.identifiers import ExecAlgorithmId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Quantity
from nautilus_trader.model.orders import MarketOrder
from nautilus_trader.model.orders import Order


class TWAPExecAlgorithmConfig(ExecAlgorithmConfig, frozen=True):
    """
    Configuration for ``TWAPExecAlgorithm`` instances.

    This configuration class defines the necessary parameters for a Time-Weighted Average Price
    (TWAP) execution algorithm, which aims to execute orders evenly spread over a specified
    time horizon, at regular intervals.

    Parameters
    ----------
    exec_algorithm_id : ExecAlgorithmId
        The execution algorithm ID (will override default which is the class name).

    """

    exec_algorithm_id: ExecAlgorithmId | None = ExecAlgorithmId("TWAP")


class TWAPExecAlgorithm(ExecAlgorithm):
    """
    Provides a Time-Weighted Average Price (TWAP) execution algorithm.

    The TWAP execution algorithm aims to execute orders by evenly spreading them over a specified
    time horizon. The algorithm receives a primary order representing the total size and direction
    then splits this by spawning smaller child orders, which are then executed at regular intervals
    throughout the time horizon.

    This helps to reduce the impact of the full size of the primary order on the market, by
    minimizing the concentration of trade size at any given time.

    The algorithm will immediately submit the first order, with the final order submitted being the
    primary order at the end of the horizon period.

    Parameters
    ----------
    config : TWAPExecAlgorithmConfig, optional
        The configuration for the instance.

    """

    def __init__(self, config: TWAPExecAlgorithmConfig | None = None) -> None:
        if config is None:
            config = TWAPExecAlgorithmConfig()
        super().__init__(config)

        self._scheduled_sizes: dict[ClientOrderId, list[Quantity]] = {}

    def on_start(self) -> None:
        """
        Actions to be performed when the algorithm component is started.
        """
        # Optionally implement

    def on_stop(self) -> None:
        """
        Actions to be performed when the algorithm component is stopped.
        """
        self.clock.cancel_timers()

    def on_reset(self) -> None:
        """
        Actions to be performed when the algorithm component is reset.
        """
        self._scheduled_sizes.clear()

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the algorithm component is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}  # Optionally implement

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the algorithm component is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The algorithm component state dictionary.

        """
        # Optionally implement

    def round_decimal_down(self, amount: Decimal, precision: int) -> Decimal:
        return amount.quantize(Decimal(f"1e-{precision}"), rounding=ROUND_DOWN)

    def on_order(self, order: Order) -> None:
        """
        Actions to be performed when running and receives an order.

        Parameters
        ----------
        order : Order
            The order to be handled.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        PyCondition.not_in(
            order.client_order_id,
            self._scheduled_sizes,
            "order.client_order_id",
            "self._scheduled_sizes",
        )
        self.log.info(repr(order), LogColor.CYAN)

        if order.order_type != OrderType.MARKET:
            self.log.error(
                f"Cannot execute order: only implemented for market orders, {order.order_type=}",
            )
            return

        instrument = self.cache.instrument(order.instrument_id)
        if not instrument:
            self.log.error(
                f"Cannot execute order: instrument {order.instrument_id} not found",
            )
            return

        # Validate execution parameters
        exec_params = order.exec_algorithm_params
        if not exec_params:
            self.log.error(
                f"Cannot execute order: "
                f"`exec_algorithm_params` not found for primary order {order!r}",
            )
            return

        horizon_secs = exec_params.get("horizon_secs")
        if not horizon_secs:
            self.log.error(
                f"Cannot execute order: "
                f"`horizon_secs` not found in `exec_algorithm_params` {exec_params}",
            )
            return

        interval_secs = exec_params.get("interval_secs")
        if not interval_secs:
            self.log.error(
                f"Cannot execute order: "
                f"`interval_secs` not found in `exec_algorithm_params` {exec_params}",
            )
            return

        if horizon_secs < interval_secs:
            self.log.error(
                f"Cannot execute order: {horizon_secs=} was less than {interval_secs=}",
            )
            return

        # Calculate the number of intervals
        num_intervals: int = math.floor(horizon_secs / interval_secs)

        # Divide the order quantity evenly and determine any remainder
        quotient = order.quantity.as_decimal() / num_intervals
        floored_quotient = self.round_decimal_down(quotient, instrument.size_precision)
        qty_quotient = instrument.make_qty(floored_quotient)
        qty_per_interval = instrument.make_qty(qty_quotient)
        qty_remainder = order.quantity.as_decimal() - (floored_quotient * num_intervals)

        if (
            qty_per_interval == order.quantity
            or qty_per_interval < instrument.size_increment
            or (instrument.min_quantity and qty_per_interval < instrument.min_quantity)
        ):
            # Immediately submit first order for entire size
            self.log.warning(f"Submitting for entire size {qty_per_interval=}, {order.quantity=}")
            self.submit_order(order)
            return  # Done

        scheduled_sizes: list[Quantity] = [qty_per_interval] * num_intervals
        if qty_remainder:
            scheduled_sizes.append(instrument.make_qty(qty_remainder))

        assert sum(scheduled_sizes) == order.quantity
        self.log.info(f"Order execution size schedule: {scheduled_sizes}", LogColor.BLUE)

        self._scheduled_sizes[order.client_order_id] = scheduled_sizes
        first_qty: Quantity = scheduled_sizes.pop(0)

        spawned_order: MarketOrder = self.spawn_market(
            primary=order,
            quantity=first_qty,
            time_in_force=order.time_in_force,
            reduce_only=order.is_reduce_only,
            tags=order.tags,
        )

        self.submit_order(spawned_order)

        # Set up timer
        self.clock.set_timer(
            name=order.client_order_id.value,
            interval=timedelta(seconds=interval_secs),
            callback=self.on_time_event,
        )
        self.log.info(
            f"Started TWAP execution for {order.client_order_id}: "
            f"{horizon_secs=}, {interval_secs=}",
            LogColor.BLUE,
        )

    def on_time_event(self, event: TimeEvent) -> None:
        """
        Actions to be performed when the algorithm receives a time event.

        Parameters
        ----------
        event : TimeEvent
            The time event received.

        """
        self.log.info(repr(event), LogColor.CYAN)

        exec_spawn_id = ClientOrderId(event.name)

        primary: Order = self.cache.order(exec_spawn_id)
        if not primary:
            self.log.error(f"Cannot find primary order for {exec_spawn_id=}")
            return

        if primary.is_closed:
            self.complete_sequence(primary.client_order_id)
            return

        instrument: Instrument = self.cache.instrument(primary.instrument_id)
        if not instrument:
            self.log.error(
                f"Cannot execute order: instrument {primary.instrument_id} not found",
            )
            return

        scheduled_sizes = self._scheduled_sizes.get(exec_spawn_id)
        if scheduled_sizes is None:
            self.log.error(f"Cannot find scheduled sizes for {exec_spawn_id=}")
            return

        if not scheduled_sizes:
            self.log.warning(f"No more size to execute for {exec_spawn_id=}")
            return

        quantity: Quantity = instrument.make_qty(scheduled_sizes.pop(0))
        if not scheduled_sizes:  # Final quantity
            self.submit_order(primary)
            self.complete_sequence(primary.client_order_id)
            return

        spawned_order: MarketOrder = self.spawn_market(
            primary=primary,
            quantity=quantity,
            time_in_force=primary.time_in_force,
            reduce_only=primary.is_reduce_only,
            tags=primary.tags,
        )

        self.submit_order(spawned_order)

    def complete_sequence(self, exec_spawn_id: ClientOrderId) -> None:
        """
        Complete an execution sequence.

        Parameters
        ----------
        exec_spawn_id : ClientOrderId
            The execution spawn ID to complete.

        """
        if exec_spawn_id.value in self.clock.timer_names:
            self.clock.cancel_timer(exec_spawn_id.value)
        self._scheduled_sizes.pop(exec_spawn_id, None)
        self.log.info(f"Completed TWAP execution for {exec_spawn_id}", LogColor.BLUE)

</document_content>
</document>
<document index="2314">
<source>nautilus_trader/examples/indicators/__init__.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

</document_content>
</document>
<document index="2315">
<source>nautilus_trader/examples/indicators/ema_python.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.indicators import Indicator
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import PriceType


# It's generally recommended to code indicators in Cython as per the built-in
# indicators found in the `indicators` subpackage. This is an example
# demonstrating an equivalent EMA indicator written in Python.

# Note: The `MovingAverage` base class has not being used in this example to
# provide more clarity on how to implement custom indicators. Basically you need
# to inherit from `Indicator` and override the methods shown below.


class PyExponentialMovingAverage(Indicator):
    """
    An indicator which calculates an exponential moving average across a rolling window.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    price_type : PriceType
        The specified price type for extracting values from quotes.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).

    """

    def __init__(self, period: int, price_type: PriceType = PriceType.LAST):
        PyCondition.positive_int(period, "period")
        super().__init__(params=[period])

        self.period = period
        self.price_type = price_type
        self.alpha = 2.0 / (period + 1.0)
        self.value = 0.0  # <-- stateful value
        self.count = 0  # <-- stateful value

    def handle_quote_tick(self, tick: QuoteTick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        PyCondition.not_none(tick, "tick")

        self.update_raw(tick.extract_price(self.price_type).as_double())

    def handle_trade_tick(self, tick: TradeTick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        PyCondition.not_none(tick, "tick")

        self.update_raw(tick.price.as_double())

    def handle_bar(self, bar: Bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        PyCondition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    def update_raw(self, value: float):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        # Check if this is the initial input
        if not self.has_inputs:
            self.value = value

        self.value = self.alpha * value + ((1.0 - self.alpha) * self.value)
        self.count += 1

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self.count >= self.period:
                self._set_initialized(True)

    def _reset(self):
        # Override this method to reset stateful values introduced in the class.
        # This method will be called by the base when `.reset()` is called.
        self.value = 0.0
        self.count = 0

</document_content>
</document>
<document index="2316">
<source>nautilus_trader/examples/strategies/__init__.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

</document_content>
</document>
<document index="2317">
<source>nautilus_trader/examples/strategies/blank.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading.strategy import Strategy


class MyStrategyConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``MyStrategy`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.

    """

    instrument_id: InstrumentId


class MyStrategy(Strategy):
    """
    A blank template strategy.

    Parameters
    ----------
    config : MyStrategyConfig
        The configuration for the instance.

    """

    def __init__(self, config: MyStrategyConfig) -> None:
        super().__init__(config)

    def on_start(self) -> None:
        """
        Actions to be performed when the strategy is started.
        """
        # Optionally implement

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        # Optionally implement

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Optionally implement

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """
        # Optionally implement

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}  # Optionally implement

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """
        # Optionally implement

    def on_instrument(self, instrument: Instrument) -> None:
        """
        Actions to be performed when the strategy is running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        """
        # Optionally implement

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """
        # Optionally implement

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        """
        # Optionally implement

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        # Optionally implement

    def buy(self) -> None:
        """
        Users simple buy method (example).
        """
        # Optionally implement

    def sell(self) -> None:
        """
        Users simple sell method (example).
        """
        # Optionally implement

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """
        # Optionally implement

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """
        # Optionally implement

</document_content>
</document>
<document index="2318">
<source>nautilus_trader/examples/strategies/ema_cross.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import ExponentialMovingAverage
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Quantity
from nautilus_trader.model.orders import MarketOrder
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class EMACrossConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``EMACross`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    trade_size : Decimal
        The position size per trade.
    fast_ema_period : int, default 10
        The fast EMA period.
    slow_ema_period : int, default 20
        The slow EMA period.
    subscribe_quote_ticks : bool, default False
        If quotes should be subscribed to.
    subscribe_trade_ticks : bool, default True
        If trades should be subscribed to.
    request_bars : bool, default True
        If historical bars should be requested on strategy start.
    unsubscribe_data_on_stop : bool, default True
        If live data feeds should be unsubscribed on strategy stop.
    order_quantity_precision : int, optional
        The quantity precision for strategy market orders.
    order_time_in_force : TimeInForce, optional
        The time in force for strategy market orders.
    close_positions_on_stop : bool, default True
        If all open positions should be closed on strategy stop.
    reduce_only_on_stop : bool, default True
        If position closing market orders on stop should be reduce-only.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    trade_size: Decimal
    fast_ema_period: PositiveInt = 10
    slow_ema_period: PositiveInt = 20
    subscribe_quote_ticks: bool = False
    subscribe_trade_ticks: bool = True
    request_bars: bool = True
    unsubscribe_data_on_stop: bool = True
    order_quantity_precision: int | None = None
    order_time_in_force: TimeInForce | None = None
    close_positions_on_stop: bool = True
    reduce_only_on_stop: bool = True


class EMACross(Strategy):
    """
    A simple moving average cross example strategy.

    When the fast EMA crosses the slow EMA then enter a position at the market
    in that direction.

    Parameters
    ----------
    config : EMACrossConfig
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `config.fast_ema_period` is not less than `config.slow_ema_period`.

    """

    def __init__(self, config: EMACrossConfig) -> None:
        PyCondition.is_true(
            config.fast_ema_period < config.slow_ema_period,
            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
        )
        super().__init__(config)

        self.instrument: Instrument = None

        # Create the indicators for the strategy
        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.fast_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.slow_ema)

        # Get historical data
        if self.config.request_bars:
            self.request_bars(
                self.config.bar_type,
                start=self._clock.utc_now() - pd.Timedelta(days=1),
            )

        # self.request_quote_ticks(self.config.instrument_id)
        # self.request_trade_ticks(self.config.instrument_id)

        # Subscribe to real-time data
        self.subscribe_bars(self.config.bar_type)

        if self.config.subscribe_quote_ticks:
            self.subscribe_quote_ticks(self.config.instrument_id)
        if self.config.subscribe_trade_ticks:
            self.subscribe_trade_ticks(self.config.instrument_id)

        # self.subscribe_order_book_deltas(self.config.instrument_id, depth=20)  # For debugging
        # self.subscribe_order_book_at_interval(self.config.instrument_id, depth=20)  # For debugging

    def on_instrument(self, instrument: Instrument) -> None:
        """
        Actions to be performed when the strategy is running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(instrument), LogColor.CYAN)

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        """
        Actions to be performed when the strategy is running and receives order book
        deltas.

        Parameters
        ----------
        deltas : OrderBookDeltas
            The order book deltas received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(deltas), LogColor.CYAN)

    def on_order_book(self, order_book: OrderBook) -> None:
        """
        Actions to be performed when the strategy is running and receives an order book.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(order_book), LogColor.CYAN)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(tick), LogColor.CYAN)

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(tick), LogColor.CYAN)

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        self.log.info(repr(bar), LogColor.CYAN)

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        if bar.is_single_price():
            self._log.warning("Bar OHLC is single price; implies no market information")
            return

        # BUY LOGIC
        if self.fast_ema.value >= self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.buy()
            elif self.portfolio.is_net_short(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.buy()
        # SELL LOGIC
        elif self.fast_ema.value < self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.sell()
            elif self.portfolio.is_net_long(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.sell()

    def buy(self) -> None:
        """
        Users simple buy method (example).
        """
        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.create_order_qty(),
            time_in_force=self.config.order_time_in_force or TimeInForce.GTC,
        )

        self.submit_order(order)

    def sell(self) -> None:
        """
        Users simple sell method (example).
        """
        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.create_order_qty(),
            time_in_force=self.config.order_time_in_force or TimeInForce.GTC,
        )

        self.submit_order(order)

    def create_order_qty(self) -> Quantity:
        if self.config.order_quantity_precision is not None:
            return Quantity(self.config.trade_size, self.config.order_quantity_precision)
        else:
            return self.instrument.make_qty(self.config.trade_size)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id)
        if self.config.close_positions_on_stop:
            self.close_all_positions(
                instrument_id=self.config.instrument_id,
                reduce_only=self.config.reduce_only_on_stop,
            )

        if self.config.unsubscribe_data_on_stop:
            self.unsubscribe_bars(self.config.bar_type)

        if self.config.unsubscribe_data_on_stop and self.config.subscribe_quote_ticks:
            self.unsubscribe_quote_ticks(self.config.instrument_id)

        if self.config.unsubscribe_data_on_stop and self.config.subscribe_trade_ticks:
            self.unsubscribe_trade_ticks(self.config.instrument_id)

        # self.unsubscribe_order_book_deltas(self.config.instrument_id)
        # self.unsubscribe_order_book_at_interval(self.config.instrument_id)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.fast_ema.reset()
        self.slow_ema.reset()

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """

</document_content>
</document>
<document index="2319">
<source>nautilus_trader/examples/strategies/ema_cross_bracket.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from datetime import timedelta
from decimal import Decimal

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveFloat
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import AverageTrueRange
from nautilus_trader.indicators import ExponentialMovingAverage
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import OrderType
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.enums import TriggerType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.orders.list import OrderList
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class EMACrossBracketConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``EMACrossBracket`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    trade_size : Decimal
        The position size per trade.
    atr_period : PositiveInt, default 20
        The period for the ATR indicator.
    fast_ema_period : PositiveInt, default 10
        The fast EMA period.
    slow_ema_period : PositiveInt, default 20
        The slow EMA period.
    bracket_distance_atr : PositiveFloat, default 3.0
        The SL and TP bracket distance from entry ATR multiple.
    emulation_trigger : str, default 'NO_TRIGGER'
        The emulation trigger for submitting emulated orders.
        If ``None`` then orders will not be emulated.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    trade_size: Decimal
    atr_period: PositiveInt = 20
    fast_ema_period: PositiveInt = 10
    slow_ema_period: PositiveInt = 20
    bracket_distance_atr: PositiveFloat = 3.0
    emulation_trigger: str = "NO_TRIGGER"


class EMACrossBracket(Strategy):
    """
    A simple moving average cross example strategy.

    When the fast EMA crosses the slow EMA then enter a position at the market
    in that direction.

    Cancels all orders and closes all positions on stop.

    Parameters
    ----------
    config : EMACrossConfig
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `config.fast_ema_period` is not less than `config.slow_ema_period`.

    """

    def __init__(self, config: EMACrossBracketConfig) -> None:
        PyCondition.is_true(
            config.fast_ema_period < config.slow_ema_period,
            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
        )
        super().__init__(config)

        self.instrument: Instrument | None = None  # Initialized in on_start

        # Create the indicators for the strategy
        self.atr = AverageTrueRange(config.atr_period)
        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.atr)
        self.register_indicator_for_bars(self.config.bar_type, self.fast_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.slow_ema)

        # Get historical data
        self.request_bars(
            self.config.bar_type,
            start=self._clock.utc_now() - timedelta(days=1),
        )

        # Subscribe to live data
        self.subscribe_bars(self.config.bar_type)
        self.subscribe_quote_ticks(self.config.instrument_id)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(tick), LogColor.CYAN)

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        self.log.info(repr(bar), LogColor.CYAN)

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        if bar.is_single_price():
            # Implies no market information for this bar
            return

        # BUY LOGIC
        if self.fast_ema.value >= self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.cancel_all_orders(self.config.instrument_id)
                self.buy(bar)
            elif self.portfolio.is_net_short(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.cancel_all_orders(self.config.instrument_id)
                self.buy(bar)
        # SELL LOGIC
        elif self.fast_ema.value < self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.cancel_all_orders(self.config.instrument_id)
                self.sell(bar)
            elif self.portfolio.is_net_long(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.cancel_all_orders(self.config.instrument_id)
                self.sell(bar)

    def buy(self, last_bar: Bar) -> None:
        """
        Users bracket buy method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        bracket_distance: float = self.config.bracket_distance_atr * self.atr.value
        order_list: OrderList = self.order_factory.bracket(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.GTD,
            expire_time=self.clock.utc_now() + timedelta(seconds=30),
            entry_price=self.instrument.make_price(last_bar.close),  # TODO
            entry_trigger_price=self.instrument.make_price(last_bar.close),  # TODO
            sl_trigger_price=self.instrument.make_price(last_bar.close - bracket_distance),
            tp_price=self.instrument.make_price(last_bar.close + bracket_distance),
            entry_order_type=OrderType.LIMIT_IF_TOUCHED,
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )

        self.submit_order_list(order_list)

    def sell(self, last_bar: Bar) -> None:
        """
        Users bracket sell method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        bracket_distance: float = self.config.bracket_distance_atr * self.atr.value
        order_list: OrderList = self.order_factory.bracket(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.GTD,
            expire_time=self.clock.utc_now() + timedelta(seconds=30),
            entry_price=self.instrument.make_price(last_bar.close),  # TODO
            entry_trigger_price=self.instrument.make_price(last_bar.close),  # TODO
            sl_trigger_price=self.instrument.make_price(last_bar.close + bracket_distance),
            tp_price=self.instrument.make_price(last_bar.close - bracket_distance),
            entry_order_type=OrderType.LIMIT_IF_TOUCHED,
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )

        self.submit_order_list(order_list)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id)
        self.close_all_positions(self.config.instrument_id)

        # Unsubscribe from data
        self.unsubscribe_bars(self.config.bar_type)
        self.unsubscribe_quote_ticks(self.config.instrument_id)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.fast_ema.reset()
        self.slow_ema.reset()

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """

</document_content>
</document>
<document index="2320">
<source>nautilus_trader/examples/strategies/ema_cross_bracket_algo.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from datetime import timedelta
from decimal import Decimal
from typing import Any

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveFloat
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import AverageTrueRange
from nautilus_trader.indicators import ExponentialMovingAverage
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import OrderType
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.enums import TriggerType
from nautilus_trader.model.identifiers import ExecAlgorithmId
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Price
from nautilus_trader.model.orders import OrderList
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class EMACrossBracketAlgoConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``EMACrossBracketAlgo`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    trade_size : Decimal
        The position size per trade.
    atr_period : PositiveInt, default 20
        The period for the ATR indicator.
    fast_ema_period : PositiveInt, default 10
        The fast EMA period.
    slow_ema_period : PositiveInt, default 20
        The slow EMA period.
    bracket_distance_atr : float, default 3.0
        The SL and TP bracket distance from entry ATR multiple.
    emulation_trigger : str, default 'NO_TRIGGER'
        The emulation trigger for submitting emulated orders.
        If ``None`` then orders will not be emulated.
    entry_exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm for entry orders.
    entry_exec_algorithm_params : dict[str, Any], optional
        The execution algorithm params for entry orders.
    sl_exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm for stop-loss (SL) orders.
    sl_exec_algorithm_params : dict[str, Any], optional
        The execution algorithm params for stop-loss (SL) orders.
    tp_exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm for take-profit (TP) orders.
    tp_exec_algorithm_params : dict[str, Any], optional
        The execution algorithm params for take-profit (TP) orders.
    close_positions_on_stop : bool, default True
        If all open positions should be closed on strategy stop.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    trade_size: Decimal
    atr_period: PositiveInt = 20
    fast_ema_period: PositiveInt = 10
    slow_ema_period: PositiveInt = 20
    bracket_distance_atr: PositiveFloat = 3.0
    emulation_trigger: str = "NO_TRIGGER"
    entry_exec_algorithm_id: ExecAlgorithmId | None = None
    entry_exec_algorithm_params: dict[str, Any] | None = None
    sl_exec_algorithm_id: ExecAlgorithmId | None = None
    sl_exec_algorithm_params: dict[str, Any] | None = None
    tp_exec_algorithm_id: ExecAlgorithmId | None = None
    tp_exec_algorithm_params: dict[str, Any] | None = None
    close_positions_on_stop: bool = True


class EMACrossBracketAlgo(Strategy):
    """
    A simple moving average cross example strategy.

    When the fast EMA crosses the slow EMA then enter a position at the market
    in that direction.

    Cancels all orders and closes all positions on stop.

    Parameters
    ----------
    config : EMACrossConfig
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `config.fast_ema_period` is not less than `config.slow_ema_period`.

    """

    def __init__(self, config: EMACrossBracketAlgoConfig) -> None:
        PyCondition.is_true(
            config.fast_ema_period < config.slow_ema_period,
            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
        )
        super().__init__(config)

        self.instrument: Instrument | None = None  # Initialized in on_start

        # Create the indicators for the strategy
        self.atr = AverageTrueRange(config.atr_period)
        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.atr)
        self.register_indicator_for_bars(self.config.bar_type, self.fast_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.slow_ema)

        # Get historical data
        self.request_bars(
            self.config.bar_type,
            start=self._clock.utc_now() - timedelta(days=1),
        )

        # Subscribe to live data
        self.subscribe_bars(self.config.bar_type)
        self.subscribe_quote_ticks(self.config.instrument_id)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(tick), LogColor.CYAN)

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        self.log.info(repr(bar), LogColor.CYAN)

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        if bar.is_single_price():
            # Implies no market information for this bar
            return

        # BUY LOGIC
        if self.fast_ema.value >= self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.cancel_all_orders(self.config.instrument_id)
                self.buy(bar)
            elif self.portfolio.is_net_short(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.cancel_all_orders(self.config.instrument_id)
                self.buy(bar)
        # SELL LOGIC
        elif self.fast_ema.value < self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.cancel_all_orders(self.config.instrument_id)
                self.sell(bar)
            elif self.portfolio.is_net_long(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.cancel_all_orders(self.config.instrument_id)
                self.sell(bar)

    def buy(self, last_bar: Bar) -> None:
        """
        Users bracket buy method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        tick_size: Price = self.instrument.price_increment
        bracket_distance: float = self.config.bracket_distance_atr * self.atr.value

        order_list: OrderList = self.order_factory.bracket(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.GTD,
            expire_time=self.clock.utc_now() + timedelta(seconds=30),
            entry_trigger_price=self.instrument.make_price(last_bar.close + tick_size),
            sl_trigger_price=self.instrument.make_price(last_bar.close - bracket_distance),
            tp_price=self.instrument.make_price(last_bar.close + bracket_distance),
            entry_order_type=OrderType.MARKET_IF_TOUCHED,
            emulation_trigger=TriggerType[self.config.emulation_trigger],
            entry_exec_algorithm_id=self.config.entry_exec_algorithm_id,
            entry_exec_algorithm_params=self.config.entry_exec_algorithm_params,
            sl_exec_algorithm_id=self.config.sl_exec_algorithm_id,
            sl_exec_algorithm_params=self.config.sl_exec_algorithm_params,
            tp_exec_algorithm_id=self.config.tp_exec_algorithm_id,
            tp_exec_algorithm_params=self.config.tp_exec_algorithm_params,
        )

        self.submit_order_list(order_list)

    def sell(self, last_bar: Bar) -> None:
        """
        Users bracket sell method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        tick_size: Price = self.instrument.price_increment
        bracket_distance: float = self.config.bracket_distance_atr * self.atr.value

        order_list: OrderList = self.order_factory.bracket(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.GTD,
            expire_time=self.clock.utc_now() + timedelta(seconds=30),
            entry_trigger_price=self.instrument.make_price(last_bar.low - tick_size),
            sl_trigger_price=self.instrument.make_price(last_bar.close + bracket_distance),
            tp_price=self.instrument.make_price(last_bar.close - bracket_distance),
            entry_order_type=OrderType.MARKET_IF_TOUCHED,
            emulation_trigger=TriggerType[self.config.emulation_trigger],
            entry_exec_algorithm_id=self.config.entry_exec_algorithm_id,
            entry_exec_algorithm_params=self.config.entry_exec_algorithm_params,
            sl_exec_algorithm_id=self.config.sl_exec_algorithm_id,
            sl_exec_algorithm_params=self.config.sl_exec_algorithm_params,
            tp_exec_algorithm_id=self.config.tp_exec_algorithm_id,
            tp_exec_algorithm_params=self.config.tp_exec_algorithm_params,
        )

        self.submit_order_list(order_list)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id)
        self.close_all_positions(self.config.instrument_id)

        # Unsubscribe from data
        self.unsubscribe_bars(self.config.bar_type)
        self.unsubscribe_quote_ticks(self.config.instrument_id)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.fast_ema.reset()
        self.slow_ema.reset()

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """

</document_content>
</document>
<document index="2321">
<source>nautilus_trader/examples/strategies/ema_cross_hedge_mode.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import ExponentialMovingAverage
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.identifiers import PositionId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.orders import MarketOrder
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class EMACrossConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``EMACross`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    trade_size : Decimal
        The position size per trade.
    fast_ema_period : int, default 10
        The fast EMA period.
    slow_ema_period : int, default 20
        The slow EMA period.
    subscribe_trade_ticks : bool, default True
        If trades should be subscribed to.
    subscribe_quote_ticks : bool, default False
        If quotes should be subscribed to.
    close_positions_on_stop : bool, default True
        If all open positions should be closed on strategy stop.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    trade_size: Decimal
    fast_ema_period: PositiveInt = 10
    slow_ema_period: PositiveInt = 20
    subscribe_trade_ticks: bool = True
    subscribe_quote_ticks: bool = False
    close_positions_on_stop: bool = True


class EMACross(Strategy):
    """
    A simple moving average cross example strategy.

    When the fast EMA crosses the slow EMA then enter a position at the market
    in that direction.

    Parameters
    ----------
    config : EMACrossConfig
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `config.fast_ema_period` is not less than `config.slow_ema_period`.

    """

    def __init__(self, config: EMACrossConfig) -> None:
        PyCondition.is_true(
            config.fast_ema_period < config.slow_ema_period,
            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
        )
        super().__init__(config)

        self.instrument: Instrument = None  # Initialized in on_start

        # Create the indicators for the strategy
        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.fast_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.slow_ema)

        # Get historical data
        self.request_bars(self.config.bar_type, start=self._clock.utc_now() - pd.Timedelta(days=1))
        # self.request_quote_ticks(self.config.instrument_id)
        # self.request_trade_ticks(self.config.instrument_id)

        # Subscribe to live data
        self.subscribe_bars(self.config.bar_type)

        if self.config.subscribe_quote_ticks:
            self.subscribe_quote_ticks(self.config.instrument_id)
        if self.config.subscribe_trade_ticks:
            self.subscribe_trade_ticks(self.config.instrument_id)

        # self.subscribe_order_book_deltas(self.config.instrument_id, depth=20)  # For debugging
        # self.subscribe_order_book_at_interval(self.config.instrument_id, depth=20)  # For debugging

    def on_instrument(self, instrument: Instrument) -> None:
        """
        Actions to be performed when the strategy is running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(instrument), LogColor.CYAN)

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        """
        Actions to be performed when the strategy is running and receives order book
        deltas.

        Parameters
        ----------
        deltas : OrderBookDeltas
            The order book deltas received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(deltas), LogColor.CYAN)

    def on_order_book(self, order_book: OrderBook) -> None:
        """
        Actions to be performed when the strategy is running and receives an order book.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(order_book), LogColor.CYAN)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(tick), LogColor.CYAN)

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(tick), LogColor.CYAN)

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        self.log.info(repr(bar), LogColor.CYAN)

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        if bar.is_single_price():
            # Implies no market information for this bar
            return

        # BUY LOGIC
        if self.fast_ema.value >= self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.buy()
            elif self.portfolio.is_net_short(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.buy()
        # SELL LOGIC
        elif self.fast_ema.value < self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.sell()
            elif self.portfolio.is_net_long(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.sell()

    def buy(self) -> None:
        """
        Users simple buy method (example).
        """
        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            # time_in_force=TimeInForce.FOK,
        )

        # LONG suffix is recognized as a long position by Binance adapter.
        position_id = PositionId(f"{self.config.instrument_id}-LONG")
        self.submit_order(order, position_id)

    def sell(self) -> None:
        """
        Users simple sell method (example).
        """
        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
            # time_in_force=TimeInForce.FOK,
        )
        # SHORT suffix is recognized as a short position by Binance adapter.
        position_id = PositionId(f"{self.config.instrument_id}-SHORT")
        self.submit_order(order, position_id)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id)
        if self.config.close_positions_on_stop:
            self.close_all_positions(self.config.instrument_id)

        # Unsubscribe from data
        self.unsubscribe_bars(self.config.bar_type)
        # self.unsubscribe_quote_ticks(self.config.instrument_id)
        self.unsubscribe_trade_ticks(self.config.instrument_id)
        # self.unsubscribe_order_book_deltas(self.config.instrument_id)
        # self.unsubscribe_order_book_at_interval(self.config.instrument_id)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.fast_ema.reset()
        self.slow_ema.reset()

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """

</document_content>
</document>
<document index="2322">
<source>nautilus_trader/examples/strategies/ema_cross_long_only.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import ExponentialMovingAverage
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.orders import MarketOrder
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class EMACrossLongOnlyConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``EMACrossLongOnly`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    trade_size : Decimal
        The position size per trade.
    fast_ema_period : int, default 10
        The fast EMA period.
    slow_ema_period : int, default 20
        The slow EMA period.
    request_historical_bars : bool, default True
        If historical bars should be requested on start.
    close_positions_on_stop : bool, default True
        If all open positions should be closed on strategy stop.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    trade_size: Decimal
    fast_ema_period: PositiveInt = 10
    slow_ema_period: PositiveInt = 20
    request_historical_bars: bool = True
    close_positions_on_stop: bool = True


class EMACrossLongOnly(Strategy):
    """
    A simple moving average cross LONG ONLY example strategy.

    This strategy is suitable for trading equities on a CASH account.

    When the fast EMA crosses the slow EMA then enter either a LONG position
    at the market for BUY, or flatten any existing position for SELL.

    Parameters
    ----------
    config : EMACrossConfig
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `config.fast_ema_period` is not less than `config.slow_ema_period`.

    """

    def __init__(self, config: EMACrossLongOnlyConfig) -> None:
        PyCondition.is_true(
            config.fast_ema_period < config.slow_ema_period,
            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
        )
        super().__init__(config)

        self.instrument: Instrument = None  # Initialized in on_start

        # Create the indicators for the strategy
        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.fast_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.slow_ema)

        # Get historical data
        if self.config.request_historical_bars:
            self.request_bars(
                self.config.bar_type,
                start=self._clock.utc_now() - pd.Timedelta(days=1),
            )
        # self.request_quote_ticks(self.config.instrument_id)
        # self.request_trade_ticks(self.config.instrument_id)

        # Subscribe to live data
        self.subscribe_bars(self.config.bar_type)
        # self.subscribe_quote_ticks(self.config.instrument_id)
        self.subscribe_trade_ticks(self.config.instrument_id)
        # self.subscribe_order_book_deltas(self.config.instrument_id, depth=20)  # For debugging
        # self.subscribe_order_book_at_interval(self.config.instrument_id, depth=20)  # For debugging

    def on_instrument(self, instrument: Instrument) -> None:
        """
        Actions to be performed when the strategy is running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(instrument), LogColor.CYAN)

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        """
        Actions to be performed when the strategy is running and receives order book
        deltas.

        Parameters
        ----------
        deltas : OrderBookDeltas
            The order book deltas received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(deltas), LogColor.CYAN)

    def on_order_book(self, order_book: OrderBook) -> None:
        """
        Actions to be performed when the strategy is running and receives an order book.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(order_book), LogColor.CYAN)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(tick), LogColor.CYAN)

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(tick), LogColor.CYAN)

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        self.log.info(repr(bar), LogColor.CYAN)

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        if bar.is_single_price():
            # Implies no market information for this bar
            return

        # BUY LOGIC
        if self.fast_ema.value >= self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.buy()
        # SELL LOGIC
        elif (
            self.fast_ema.value < self.slow_ema.value
            and self.portfolio.is_net_long(self.config.instrument_id)
        ):
            self.close_all_positions(self.config.instrument_id)

    def buy(self) -> None:
        """
        Users simple buy method (example).
        """
        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.IOC,
        )

        self.submit_order(order)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id)
        if self.config.close_positions_on_stop:
            self.close_all_positions(self.config.instrument_id)

        # Unsubscribe from data
        self.unsubscribe_bars(self.config.bar_type)
        # self.unsubscribe_quote_ticks(self.config.instrument_id)
        self.unsubscribe_trade_ticks(self.config.instrument_id)
        # self.unsubscribe_order_book_deltas(self.config.instrument_id)
        # self.unsubscribe_order_book_at_interval(self.config.instrument_id)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.fast_ema.reset()
        self.slow_ema.reset()

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """

</document_content>
</document>
<document index="2323">
<source>nautilus_trader/examples/strategies/ema_cross_stop_entry.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveFloat
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import AverageTrueRange
from nautilus_trader.indicators import ExponentialMovingAverage
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.enums import TrailingOffsetType
from nautilus_trader.model.enums import TriggerType
from nautilus_trader.model.events import OrderFilled
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Price
from nautilus_trader.model.orders import MarketIfTouchedOrder
from nautilus_trader.model.orders import TrailingStopMarketOrder
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class EMACrossStopEntryConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``EMACrossStopEntry`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    atr_period : PositiveInt
        The period for the ATR indicator.
    trailing_atr_multiple : PositiveFloat
        The ATR multiple for the trailing stop.
    trailing_offset_type : str
        The trailing offset type (interpreted as `TrailingOffsetType`).
    trailing_offset : Decimal
        The trailing offset amount.
    trigger_type : str
        The trailing stop trigger type (interpreted as `TriggerType`).
    trade_size : Decimal
        The position size per trade.
    fast_ema_period : PositiveInt, default 10
        The fast EMA period.
    slow_ema_period : PositiveInt, default 20
        The slow EMA period.
    emulation_trigger : str, default 'NO_TRIGGER'
        The emulation trigger for submitting emulated orders.
        If 'NONE' then orders will not be emulated.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    atr_period: PositiveInt
    trailing_atr_multiple: PositiveFloat
    trailing_offset_type: str
    trailing_offset: Decimal
    trigger_type: str
    trade_size: Decimal
    fast_ema_period: PositiveInt = 10
    slow_ema_period: PositiveInt = 20
    emulation_trigger: str = "NO_TRIGGER"


class EMACrossStopEntry(Strategy):
    """
    A simple moving average cross example strategy with a `MARKET_IF_TOUCHED` entry and
    `TRAILING_STOP_MARKET` stop.

    When the fast EMA crosses the slow EMA then submits a `MARKET_IF_TOUCHED` order
    one tick above the current bar for BUY, or one tick below the current bar
    for SELL.

    If the entry order is filled then a `TRAILING_STOP_MARKET` at a specified
    ATR distance is submitted and managed.

    Cancels all orders and closes all positions on stop.

    Parameters
    ----------
    config : EMACrossStopEntryConfig
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `config.fast_ema_period` is not less than `config.slow_ema_period`.

    """

    def __init__(self, config: EMACrossStopEntryConfig) -> None:
        PyCondition.is_true(
            config.fast_ema_period < config.slow_ema_period,
            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
        )
        super().__init__(config)

        # Create the indicators for the strategy
        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
        self.atr = AverageTrueRange(config.atr_period)

        # Initialized in `on_start()`
        self.instrument: Instrument | None = None
        self.tick_size: Price | None = None

        # Users order management variables
        self.entry = None
        self.trailing_stop = None

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        self.tick_size = self.instrument.price_increment

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.fast_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.slow_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.atr)

        # Get historical data
        self.request_bars(
            self.config.bar_type,
            start=self._clock.utc_now() - pd.Timedelta(days=1),
        )

        # Subscribe to live data
        self.subscribe_bars(self.config.bar_type)
        self.subscribe_quote_ticks(self.config.instrument_id)
        self.subscribe_trade_ticks(self.config.instrument_id)

    def on_instrument(self, instrument: Instrument) -> None:
        """
        Actions to be performed when the strategy is running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        """

    def on_order_book(self, order_book: OrderBook) -> None:
        """
        Actions to be performed when the strategy is running and receives an order book.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        """
        # self.log.info(f"Received {order_book}")  # For debugging (must add a subscription)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        """

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        self.log.info(f"Received {bar!r}")

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        if self.portfolio.is_flat(self.config.instrument_id):
            if self.entry is not None:
                self.cancel_order(self.entry)

            # BUY LOGIC
            if self.fast_ema.value >= self.slow_ema.value:
                self.entry_buy(bar)
            # SELL LOGIC
            else:  # fast_ema.value < self.slow_ema.value
                self.entry_sell(bar)

    def entry_buy(self, last_bar: Bar) -> None:
        """
        Users simple buy entry method (example).

        Parameters
        ----------
        last_bar : Bar
            The last bar received.

        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        if not self.tick_size:
            self.log.error("No tick size loaded")
            return

        order: MarketIfTouchedOrder = self.order_factory.market_if_touched(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.IOC,
            trigger_price=self.instrument.make_price(last_bar.high + (self.tick_size * 2)),
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )
        # TODO: Uncomment below order for development
        # order: LimitIfTouchedOrder = self.order_factory.limit_if_touched(
        #     instrument_id=self.config.instrument_id,
        #     order_side=OrderSide.BUY,
        #     quantity=self.instrument.make_qty(self.config.trade_size),
        #     time_in_force=TimeInForce.IOC,
        #     price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
        #     trigger_price=self.instrument.make_price(last_bar.high + (self.tick_size * 2)),
        # )

        self.entry = order
        self.submit_order(order)

    def entry_sell(self, last_bar: Bar) -> None:
        """
        Users simple sell entry method (example).

        Parameters
        ----------
        last_bar : Bar
            The last bar received.

        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        if not self.tick_size:
            self.log.error("No tick size loaded")
            return

        order: MarketIfTouchedOrder = self.order_factory.market_if_touched(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.IOC,
            trigger_price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )
        # TODO: Uncomment below order for development
        # order: LimitIfTouchedOrder = self.order_factory.limit_if_touched(
        #     instrument_id=self.config.instrument_id,
        #     order_side=OrderSide.SELL,
        #     quantity=self.instrument.make_qty(self.config.trade_size),
        #     time_in_force=TimeInForce.IOC,
        #     price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
        #     trigger_price=self.instrument.make_price(last_bar.low - (self.tick_size * 2)),
        # )

        self.entry = order
        self.submit_order(order)

    def trailing_stop_buy(self) -> None:
        """
        Users simple trailing stop BUY for (``SHORT`` positions).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        offset = self.atr.value * self.config.trailing_atr_multiple
        order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            trailing_offset=Decimal(f"{offset:.{self.instrument.price_precision}f}"),
            trailing_offset_type=TrailingOffsetType[self.config.trailing_offset_type],
            trigger_type=TriggerType[self.config.trigger_type],
            reduce_only=True,
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )

        self.trailing_stop = order
        self.submit_order(order)

    def trailing_stop_sell(self) -> None:
        """
        Users simple trailing stop SELL for (LONG positions).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        offset = self.atr.value * self.config.trailing_atr_multiple
        order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
            trailing_offset=Decimal(f"{offset:.{self.instrument.price_precision}f}"),
            trailing_offset_type=TrailingOffsetType[self.config.trailing_offset_type],
            trigger_type=TriggerType[self.config.trigger_type],
            reduce_only=True,
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )

        self.trailing_stop = order
        self.submit_order(order)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """
        if isinstance(event, OrderFilled):
            if self.entry and event.client_order_id == self.entry.client_order_id:
                if event.order_side == OrderSide.BUY:
                    self.trailing_stop_sell()
                elif event.order_side == OrderSide.SELL:
                    self.trailing_stop_buy()
            if self.trailing_stop and event.client_order_id == self.trailing_stop.client_order_id:
                self.trailing_stop = None

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id)
        self.close_all_positions(self.config.instrument_id)

        # Unsubscribe from data
        self.unsubscribe_bars(self.config.bar_type)
        self.unsubscribe_quote_ticks(self.config.instrument_id)
        self.unsubscribe_trade_ticks(self.config.instrument_id)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.fast_ema.reset()
        self.slow_ema.reset()
        self.atr.reset()

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """

</document_content>
</document>
<document index="2324">
<source>nautilus_trader/examples/strategies/ema_cross_trailing_stop.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveFloat
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import AverageTrueRange
from nautilus_trader.indicators import ExponentialMovingAverage
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TrailingOffsetType
from nautilus_trader.model.enums import TriggerType
from nautilus_trader.model.events import OrderFilled
from nautilus_trader.model.events import PositionChanged
from nautilus_trader.model.events import PositionClosed
from nautilus_trader.model.events import PositionOpened
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.orders import MarketOrder
from nautilus_trader.model.orders import TrailingStopMarketOrder
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class EMACrossTrailingStopConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``EMACrossTrailingStop`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    atr_period : PositiveInt
        The period for the ATR indicator.
    trailing_atr_multiple : PositiveFloat
        The ATR multiple for the trailing stop.
    trailing_offset_type : str
        The trailing offset type (interpreted as `TrailingOffsetType`).
    trigger_type : str
        The trailing stop trigger type (interpreted as `TriggerType`).
    trade_size : Decimal
        The position size per trade.
    fast_ema_period : PositiveInt, default 10
        The fast EMA period.
    slow_ema_period : PositiveInt, default 20
        The slow EMA period.
    emulation_trigger : str, default 'NO_TRIGGER'
        The emulation trigger for submitting emulated orders.
        If 'NONE' then orders will not be emulated.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    atr_period: PositiveInt
    trailing_atr_multiple: PositiveFloat
    trailing_offset_type: str
    trigger_type: str
    trade_size: Decimal
    fast_ema_period: PositiveInt = 10
    slow_ema_period: PositiveInt = 20
    emulation_trigger: str = "NO_TRIGGER"


class EMACrossTrailingStop(Strategy):
    """
    A simple moving average cross example strategy with a stop-market entry and trailing
    stop.

    When the fast EMA crosses the slow EMA then submits a stop-market order one
    tick above the current bar for BUY, or one tick below the current bar
    for SELL.

    If the entry order is filled then a trailing stop at a specified ATR
    distance is submitted and managed.

    Cancels all orders and closes all positions on stop.

    Parameters
    ----------
    config : EMACrossTrailingStopConfig
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `config.fast_ema_period` is not less than `config.slow_ema_period`.

    """

    def __init__(self, config: EMACrossTrailingStopConfig) -> None:
        PyCondition.is_true(
            config.fast_ema_period < config.slow_ema_period,
            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
        )
        super().__init__(config)

        # Initialized in on_start
        self.instrument: Instrument | None = None
        self.tick_size = None

        # Create the indicators for the strategy
        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
        self.atr = AverageTrueRange(config.atr_period)

        # Users order management variables
        self.entry = None
        self.trailing_stop = None
        self.position_id = None

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        self.tick_size = self.instrument.price_increment

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.fast_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.slow_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.atr)

        # Get historical data
        self.request_bars(
            self.config.bar_type,
            start=self._clock.utc_now() - pd.Timedelta(days=1),
        )

        # Subscribe to live data
        self.subscribe_quote_ticks(self.config.instrument_id)
        self.subscribe_bars(self.config.bar_type)

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id)
        self.close_all_positions(self.config.instrument_id)

        # Unsubscribe from data
        self.unsubscribe_quote_ticks(self.config.instrument_id)
        self.unsubscribe_bars(self.config.bar_type)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.fast_ema.reset()
        self.slow_ema.reset()
        self.atr.reset()

    def on_instrument(self, instrument: Instrument) -> None:
        """
        Actions to be performed when the strategy is running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        """

    def on_order_book(self, order_book: OrderBook) -> None:
        """
        Actions to be performed when the strategy is running and receives an order book.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        """
        # self.log.info(f"Received {order_book}")  # For debugging (must add a subscription)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        """

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        # self.log.info(f"Received {bar!r}")

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        if self.portfolio.is_flat(self.config.instrument_id):
            # BUY LOGIC
            if self.fast_ema.value >= self.slow_ema.value:
                self.entry_buy()
            # SELL LOGIC
            else:  # fast_ema.value < self.slow_ema.value
                self.entry_sell()

    def entry_buy(self) -> None:
        """
        Users simple buy entry method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
        )

        self.entry = order
        self.submit_order(order)

    def entry_sell(self) -> None:
        """
        Users simple sell entry method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
        )

        self.entry = order
        self.submit_order(order)

    def trailing_stop_buy(self) -> None:
        """
        Users simple trailing stop BUY for (``SHORT`` positions).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        last_quote = self.cache.quote_tick(self.config.instrument_id)
        if not last_quote:
            self.log.warning("Cannot submit order: no quotes yet")
            return

        offset = self.atr.value * self.config.trailing_atr_multiple
        order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            # limit_offset=Decimal(f"{offset / 2:.{self.instrument.price_precision}f}"),
            # price=self.instrument.make_price(last_quote.ask_price.as_double() + offset),
            trailing_offset=Decimal(f"{offset:.{self.instrument.price_precision}f}"),
            trailing_offset_type=TrailingOffsetType[self.config.trailing_offset_type],
            trigger_type=TriggerType[self.config.trigger_type],
            reduce_only=True,
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )

        self.trailing_stop = order
        self.submit_order(order, position_id=self.position_id)

    def trailing_stop_sell(self) -> None:
        """
        Users simple trailing stop SELL for (LONG positions).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        last_quote = self.cache.quote_tick(self.config.instrument_id)
        if not last_quote:
            self.log.warning("Cannot submit order: no quotes yet")
            return

        offset = self.atr.value * self.config.trailing_atr_multiple
        order: TrailingStopMarketOrder = self.order_factory.trailing_stop_market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
            # limit_offset=Decimal(f"{offset / 2:.{self.instrument.price_precision}f}"),
            # price=self.instrument.make_price(last_quote.bid_price.as_double() - offset),
            trailing_offset=Decimal(f"{offset:.{self.instrument.price_precision}f}"),
            trailing_offset_type=TrailingOffsetType[self.config.trailing_offset_type],
            trigger_type=TriggerType[self.config.trigger_type],
            reduce_only=True,
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )

        self.trailing_stop = order
        self.submit_order(order, position_id=self.position_id)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """
        if isinstance(event, OrderFilled):
            if self.trailing_stop and event.client_order_id == self.trailing_stop.client_order_id:
                self.trailing_stop = None
        elif isinstance(event, PositionOpened | PositionChanged):
            if self.trailing_stop:
                return  # Already a trailing stop
            if self.entry and event.opening_order_id == self.entry.client_order_id:
                if event.entry == OrderSide.BUY:
                    self.position_id = event.position_id
                    self.trailing_stop_sell()
                elif event.entry == OrderSide.SELL:
                    self.position_id = event.position_id
                    self.trailing_stop_buy()
        elif isinstance(event, PositionClosed):
            self.position_id = None

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """

</document_content>
</document>
<document index="2325">
<source>nautilus_trader/examples/strategies/ema_cross_twap.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal
from typing import Any

import pandas as pd

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveFloat
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.correctness import PyCondition
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import ExponentialMovingAverage
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.identifiers import ExecAlgorithmId
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.orders import MarketOrder
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class EMACrossTWAPConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``EMACrossTWAP`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    trade_size : Decimal
        The position size per trade.
    fast_ema_period : PositiveInt, default 10
        The fast EMA period.
    slow_ema_period : PositiveInt, default 20
        The slow EMA period.
    twap_horizon_secs : PositiveFloat, default 30.0
        The TWAP horizon (seconds) over which the algorithm will execute.
    twap_interval_secs : PositiveFloat, default 3.0
        The TWAP interval (seconds) between orders.
    close_positions_on_stop : bool, default True
        If all open positions should be closed on strategy stop.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    trade_size: Decimal
    fast_ema_period: PositiveInt = 10
    slow_ema_period: PositiveInt = 20
    twap_horizon_secs: PositiveFloat = 30.0
    twap_interval_secs: PositiveFloat = 3.0
    close_positions_on_stop: bool = True


class EMACrossTWAP(Strategy):
    """
    A simple moving average cross example strategy.

    When the fast EMA crosses the slow EMA then enter a position at the market
    in that direction.

    Cancels all orders and closes all positions on stop.

    Parameters
    ----------
    config : EMACrossConfig
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `config.fast_ema_period` is not less than `config.slow_ema_period`.
    ValueError
        If `config.twap_interval_secs` is not less than or equal to `config.twap_horizon_secs`.

    """

    def __init__(self, config: EMACrossTWAPConfig) -> None:
        PyCondition.is_true(
            config.fast_ema_period < config.slow_ema_period,
            "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
        )
        PyCondition.is_true(
            config.twap_interval_secs <= config.twap_horizon_secs,
            "{config.twap_interval_secs=} must be less than or equal to {config.twap_horizon_secs=}",
        )
        super().__init__(config)

        self.instrument: Instrument = None  # Initialized in on_start

        # Create the indicators for the strategy
        self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
        self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)

        # Order management
        self.twap_exec_algorithm_id = ExecAlgorithmId("TWAP")
        self.twap_exec_algorithm_params: dict[str, Any] = {
            "horizon_secs": config.twap_horizon_secs,
            "interval_secs": config.twap_interval_secs,
        }

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.fast_ema)
        self.register_indicator_for_bars(self.config.bar_type, self.slow_ema)

        # Get historical data
        self.request_bars(
            self.config.bar_type,
            start=self._clock.utc_now() - pd.Timedelta(days=1),
        )

        # Subscribe to live data
        self.subscribe_bars(self.config.bar_type)
        self.subscribe_quote_ticks(self.config.instrument_id)

    def on_instrument(self, instrument: Instrument) -> None:
        """
        Actions to be performed when the strategy is running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(instrument), LogColor.CYAN)

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        """
        Actions to be performed when the strategy is running and receives order book
        deltas.

        Parameters
        ----------
        deltas : OrderBookDeltas
            The order book deltas received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(deltas), LogColor.CYAN)

    def on_order_book(self, order_book: OrderBook) -> None:
        """
        Actions to be performed when the strategy is running and receives an order book.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(order_book), LogColor.CYAN)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(tick), LogColor.CYAN)

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(tick), LogColor.CYAN)

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        self.log.info(repr(bar), LogColor.CYAN)

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        if bar.is_single_price():
            # Implies no market information for this bar
            return

        # BUY LOGIC
        if self.fast_ema.value >= self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.buy()
            elif self.portfolio.is_net_short(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.buy()
        # SELL LOGIC
        elif self.fast_ema.value < self.slow_ema.value:
            if self.portfolio.is_flat(self.config.instrument_id):
                self.sell()
            elif self.portfolio.is_net_long(self.config.instrument_id):
                self.close_all_positions(self.config.instrument_id)
                self.sell()

    def buy(self) -> None:
        """
        Users simple buy method (example).
        """
        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.FOK,
            exec_algorithm_id=self.twap_exec_algorithm_id,
            exec_algorithm_params=self.twap_exec_algorithm_params,
        )

        self.submit_order(order)

    def sell(self) -> None:
        """
        Users simple sell method (example).
        """
        order: MarketOrder = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
            time_in_force=TimeInForce.FOK,
            exec_algorithm_id=self.twap_exec_algorithm_id,
            exec_algorithm_params=self.twap_exec_algorithm_params,
        )

        self.submit_order(order)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id)
        if self.config.close_positions_on_stop:
            self.close_all_positions(self.config.instrument_id)

        # Unsubscribe from data
        self.unsubscribe_bars(self.config.bar_type)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.fast_ema.reset()
        self.slow_ema.reset()

    def on_save(self) -> dict[str, bytes]:
        """
        Actions to be performed when the strategy is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state dictionary.

        """
        return {}

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Actions to be performed when the strategy is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state dictionary.

        """

    def on_dispose(self) -> None:
        """
        Actions to be performed when the strategy is disposed.

        Cleanup any resources used by the strategy here.

        """

</document_content>
</document>
<document index="2326">
<source>nautilus_trader/examples/strategies/market_maker.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.core.message import Event
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import PositionSide
from nautilus_trader.model.events import PositionChanged
from nautilus_trader.model.events import PositionClosed
from nautilus_trader.model.events import PositionOpened
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Price
from nautilus_trader.trading.strategy import Strategy


class MarketMaker(Strategy):
    """
    Provides a market making strategy for testing.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    trade_size : Decimal
        The position size per trade.
    max_size : Decimal
        The maximum inventory size allowed.

    """

    def __init__(
        self,
        instrument_id: InstrumentId,
        trade_size: Decimal,
        max_size: Decimal,
    ) -> None:
        super().__init__()

        # Configuration
        self.instrument_id = instrument_id
        self.trade_size = trade_size
        self.max_size = max_size

        self.instrument: Instrument | None = None  # Initialized in on_start
        self._book: OrderBook | None = None
        self._mid: Decimal | None = None
        self._adj = Decimal(0)

    def on_start(self) -> None:
        self.instrument = self.cache.instrument(self.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.instrument_id}")
            self.stop()
            return

        # Create orderbook
        self._book = OrderBook(
            instrument_id=self.instrument.id,
            book_type=BookType.L2_MBP,
        )

        # Subscribe to live data
        self.subscribe_order_book_deltas(self.instrument_id)

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        if not self._book:
            self.log.error("No book being maintained")
            return

        self._book.apply_deltas(deltas)
        bid_price = self._book.best_bid_price()
        ask_price = self._book.best_ask_price()
        if bid_price and ask_price:
            mid = (bid_price + ask_price) / 2
            if mid != self._mid:
                self.cancel_all_orders(self.instrument_id)
                self._mid = Decimal(mid)
                val = self._mid + self._adj
                self.buy(price=val * Decimal("1.01"))
                self.sell(price=val * Decimal("0.99"))

    def on_event(self, event: Event) -> None:
        if isinstance(event, PositionOpened | PositionChanged):
            signed_qty = event.quantity.as_decimal()
            if event.side == PositionSide.SHORT:
                signed_qty = -signed_qty
            self._adj = (signed_qty / self.max_size) * Decimal("0.01")
        elif isinstance(event, PositionClosed):
            self._adj = Decimal(0)

    def buy(self, price: Decimal) -> None:
        """
        Users simple buy method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        order = self.order_factory.limit(
            instrument_id=self.instrument_id,
            order_side=OrderSide.BUY,
            price=Price(price, precision=self.instrument.price_precision),
            quantity=self.instrument.make_qty(self.trade_size),
        )

        self.submit_order(order)

    def sell(self, price: Decimal) -> None:
        """
        Users simple sell method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        order = self.order_factory.limit(
            instrument_id=self.instrument_id,
            order_side=OrderSide.SELL,
            price=Price(price, precision=self.instrument.price_precision),
            quantity=self.instrument.make_qty(self.trade_size),
        )

        self.submit_order(order)

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.instrument_id)
        self.close_all_positions(self.instrument_id)

</document_content>
</document>
<document index="2327">
<source>nautilus_trader/examples/strategies/orderbook_imbalance.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import datetime
from decimal import Decimal

from nautilus_trader.config import NonNegativeFloat
from nautilus_trader.config import PositiveFloat
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.rust.common import LogColor
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.enums import book_type_from_str
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.objects import Quantity
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class OrderBookImbalanceConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``OrderBookImbalance`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    max_trade_size : Decimal
        The max position size per trade (volume on the level can be less).
    trigger_min_size : PositiveFloat, default 100.0
        The minimum size on the larger side to trigger an order.
    trigger_imbalance_ratio : PositiveFloat, default 0.20
        The ratio of bid:ask volume required to trigger an order (smaller
        value / larger value) ie given a trigger_imbalance_ratio=0.2, and a
        bid volume of 100, we will send a buy order if the ask volume is <
        20).
    min_seconds_between_triggers : NonNegativeFloat, default 1.0
        The minimum time between triggers.
    book_type : str, default 'L2_MBP'
        The order book type for the strategy.
    use_quote_ticks : bool, default False
        If quotes should be used.
    dry_run : bool, default False
        If dry run mode is active. If True, then no new orders will be submitted.

    """

    instrument_id: InstrumentId
    max_trade_size: Decimal
    trigger_min_size: PositiveFloat = 100.0
    trigger_imbalance_ratio: PositiveFloat = 0.20
    min_seconds_between_triggers: NonNegativeFloat = 1.0
    book_type: str = "L2_MBP"
    use_quote_ticks: bool = False
    dry_run: bool = False


class OrderBookImbalance(Strategy):
    """
    A simple strategy that sends FOK limit orders when there is a bid/ask imbalance in
    the order book.

    Cancels all orders and closes all positions on stop.

    Parameters
    ----------
    config : OrderbookImbalanceConfig
        The configuration for the instance.

    """

    def __init__(self, config: OrderBookImbalanceConfig) -> None:
        assert 0 < config.trigger_imbalance_ratio < 1
        super().__init__(config)

        # Initialized in on_start
        self.instrument: Instrument | None = None
        if self.config.use_quote_ticks:
            assert self.config.book_type == "L1_MBP"
        self.book_type: BookType = book_type_from_str(self.config.book_type)
        self._last_trigger_timestamp: datetime.datetime | None = None

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        if self.config.use_quote_ticks:
            self.book_type = BookType.L1_MBP
            self.subscribe_quote_ticks(self.instrument.id)
        else:
            self.book_type = book_type_from_str(self.config.book_type)
            self.subscribe_order_book_deltas(self.instrument.id, self.book_type)

        # Initialize to None to allow immediate first execution
        self._last_trigger_timestamp = None

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        """
        Actions to be performed when order book deltas are received.
        """
        self.check_trigger()

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when a delta is received.
        """
        self.check_trigger()

    def on_order_book(self, order_book: OrderBook) -> None:
        """
        Actions to be performed when an order book update is received.
        """
        self.check_trigger()

    def check_trigger(self) -> None:  # noqa: C901 (too complex)
        """
        Check for trigger conditions.
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        # Fetch book from the cache being maintained by the `DataEngine`
        book = self.cache.order_book(self.config.instrument_id)
        if not book:
            self.log.error("No book being maintained")
            return

        if not book.spread():
            return

        bid_size: Quantity | None = book.best_bid_size()
        ask_size: Quantity | None = book.best_ask_size()
        if (bid_size is None or bid_size <= 0) or (ask_size is None or ask_size <= 0):
            self.log.warning("No market yet")
            return

        smaller = min(bid_size, ask_size)
        larger = max(bid_size, ask_size)
        ratio = smaller / larger
        self.log.info(
            f"Book: {book.best_bid_price()} @ {book.best_ask_price()} ({ratio=:0.2f})",
        )

        # Check time since last trigger only if there was a previous trigger
        if self._last_trigger_timestamp is not None:
            seconds_since_last_trigger = (
                self.clock.utc_now() - self._last_trigger_timestamp
            ).total_seconds()
        else:
            seconds_since_last_trigger = float("inf")  # Allow first trigger

        if larger > self.config.trigger_min_size and ratio < self.config.trigger_imbalance_ratio:
            self.log.info(
                "Trigger conditions met, checking for existing orders and time since last order",
            )
            if len(self.cache.orders_inflight(strategy_id=self.id)) > 0:
                self.log.info("Already have orders in flight - skipping.")
            elif seconds_since_last_trigger < self.config.min_seconds_between_triggers:
                self.log.info("Time since last order < min_seconds_between_triggers - skipping")
            elif bid_size > ask_size:
                # Clamp order size to max_trade_size
                trade_qty = min(ask_size, Quantity.from_str(str(self.config.max_trade_size)))
                order = self.order_factory.limit(
                    instrument_id=self.instrument.id,
                    price=self.instrument.make_price(book.best_ask_price()),
                    order_side=OrderSide.BUY,
                    quantity=self.instrument.make_qty(trade_qty),
                    post_only=False,
                    time_in_force=TimeInForce.FOK,
                )
                self._last_trigger_timestamp = self.clock.utc_now()
                self.log.info(f"Hitting! {order=}", color=LogColor.BLUE)
                if self.config.dry_run:
                    self.log.warning("Dry run mode is active; skipping new order submission")
                    return
                self.submit_order(order)
            else:
                # Clamp order size to max_trade_size
                trade_qty = min(bid_size, Quantity.from_str(str(self.config.max_trade_size)))
                order = self.order_factory.limit(
                    instrument_id=self.instrument.id,
                    price=self.instrument.make_price(book.best_bid_price()),
                    order_side=OrderSide.SELL,
                    quantity=self.instrument.make_qty(trade_qty),
                    post_only=False,
                    time_in_force=TimeInForce.FOK,
                )
                self._last_trigger_timestamp = self.clock.utc_now()
                self.log.info(f"Hitting! {order=}", color=LogColor.BLUE)
                if self.config.dry_run:
                    self.log.warning("Dry run mode is active; skipping new order submission")
                    return
                self.submit_order(order)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        self._last_trigger_timestamp = None

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        if self.instrument is None:
            return

        self.cancel_all_orders(self.instrument.id)
        self.close_all_positions(self.instrument.id)

</document_content>
</document>
<document index="2328">
<source>nautilus_trader/examples/strategies/orderbook_imbalance_rust.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import datetime
from decimal import Decimal

from nautilus_trader.config import NonNegativeFloat
from nautilus_trader.config import PositiveFloat
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.core.rust.common import LogColor
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.enums import book_type_from_str
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class OrderBookImbalanceConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``OrderBookImbalance`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    max_trade_size : Decimal
        The max position size per trade (size on the level can be less).
    trigger_min_size : PositiveFloat, default 100.0
        The minimum size on the larger side to trigger an order.
    trigger_imbalance_ratio : PositiveFloat, default 0.20
        The ratio of bid:ask volume required to trigger an order (smaller
        value / larger value) ie given a trigger_imbalance_ratio=0.2, and a
        bid volume of 100, we will send a buy order if the ask volume is <
        20).
    min_seconds_between_triggers : NonNegativeFloat, default 1.0
        The minimum time between triggers.
    book_type : str, default 'L2_MBP'
        The order book type for the strategy.
    use_quote_ticks : bool, default False
        If quotes should be used.

    """

    instrument_id: InstrumentId
    max_trade_size: Decimal
    trigger_min_size: PositiveFloat = 100.0
    trigger_imbalance_ratio: PositiveFloat = 0.20
    min_seconds_between_triggers: NonNegativeFloat = 1.0
    book_type: str = "L2_MBP"
    use_quote_ticks: bool = False


class OrderBookImbalance(Strategy):
    """
    A simple strategy that sends FOK limit orders when there is a bid/ask imbalance in
    the order book.

    Cancels all orders and closes all positions on stop.

    Parameters
    ----------
    config : OrderbookImbalanceConfig
        The configuration for the instance.

    """

    def __init__(self, config: OrderBookImbalanceConfig) -> None:
        assert 0 < config.trigger_imbalance_ratio < 1
        super().__init__(config)

        self.instrument: Instrument | None = None
        if self.config.use_quote_ticks:
            assert self.config.book_type == "L1_MBP"
        self.book_type: nautilus_pyo3.BookType = nautilus_pyo3.BookType(self.config.book_type)
        self._last_trigger_timestamp: datetime.datetime | None = None

        # We need to initialize the Rust pyo3 objects
        pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(self.config.instrument_id.value)
        self.book = nautilus_pyo3.OrderBook(pyo3_instrument_id, self.book_type)
        self.imbalance = nautilus_pyo3.BookImbalanceRatio()

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        if self.config.use_quote_ticks:
            self.book_type = nautilus_pyo3.BookType.L1_MBP
            self.subscribe_quote_ticks(self.instrument.id)
        else:
            self.book_type = book_type_from_str(self.config.book_type)
            self.subscribe_order_book_deltas(
                self.instrument.id,
                self.book_type,
                managed=False,  # <-- Manually applying deltas to book
                pyo3_conversion=True,  # <--- Will automatically convert to pyo3 objects
            )

        self._last_trigger_timestamp = self.clock.utc_now()

    def on_order_book_deltas(self, pyo3_deltas: nautilus_pyo3.OrderBookDeltas) -> None:
        """
        Actions to be performed when order book deltas are received.
        """
        self.book.apply_deltas(pyo3_deltas)
        self.imbalance.handle_book(self.book)
        self.check_trigger()

    def on_quote_tick(self, quote: QuoteTick) -> None:
        """
        Actions to be performed when a quote tick is received.
        """
        if self.config.use_quote_ticks:
            nautilus_pyo3.update_book_with_quote_tick(self.book, quote)
            self.imbalance.handle_book(self.book)
            self.check_trigger()

    def on_order_book(self, book: OrderBook) -> None:
        """
        Actions to be performed when an order book update is received.
        """
        self.check_trigger()

    def check_trigger(self) -> None:
        """
        Check for trigger conditions.
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        # This could be more efficient: for demonstration
        bid_price = self.book.best_bid_price()
        ask_price = self.book.best_ask_price()
        bid_size = self.book.best_bid_size()
        ask_size = self.book.best_ask_size()
        if not bid_size or not ask_size:
            self.log.warning("No market yet")
            return

        larger = max(bid_size.as_double(), ask_size.as_double())
        ratio = self.imbalance.value
        self.log.info(
            f"Book: {self.book.best_bid_price()} @ {self.book.best_ask_price()} ({ratio=:0.2f})",
        )
        seconds_since_last_trigger = (
            self.clock.utc_now() - self._last_trigger_timestamp
        ).total_seconds()

        if larger > self.config.trigger_min_size and ratio < self.config.trigger_imbalance_ratio:
            self.log.info(
                "Trigger conditions met, checking for existing orders and time since last order",
            )
            if len(self.cache.orders_inflight(strategy_id=self.id)) > 0:
                self.log.info("Already have orders in flight - skipping.")
            elif seconds_since_last_trigger < self.config.min_seconds_between_triggers:
                self.log.info("Time since last order < min_seconds_between_triggers - skipping")
            elif bid_size.as_double() > ask_size.as_double():
                order = self.order_factory.limit(
                    instrument_id=self.instrument.id,
                    price=self.instrument.make_price(ask_price),
                    order_side=OrderSide.BUY,
                    quantity=self.instrument.make_qty(ask_size),
                    post_only=False,
                    time_in_force=TimeInForce.FOK,
                )
                self._last_trigger_timestamp = self.clock.utc_now()
                self.log.info(f"Hitting! {order=}", color=LogColor.BLUE)
                self.submit_order(order)

            else:
                order = self.order_factory.limit(
                    instrument_id=self.instrument.id,
                    price=self.instrument.make_price(bid_price),
                    order_side=OrderSide.SELL,
                    quantity=self.instrument.make_qty(bid_size),
                    post_only=False,
                    time_in_force=TimeInForce.FOK,
                )
                self._last_trigger_timestamp = self.clock.utc_now()
                self.log.info(f"Hitting! {order=}", color=LogColor.BLUE)
                self.submit_order(order)

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        if self.instrument is None:
            return

        self.cancel_all_orders(self.instrument.id)
        self.close_all_positions(self.instrument.id)

</document_content>
</document>
<document index="2329">
<source>nautilus_trader/examples/strategies/signal_strategy.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------


from nautilus_trader.config import StrategyConfig
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY ***


class SignalStrategyConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``SignalStrategy`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.

    """

    instrument_id: InstrumentId


class SignalStrategy(Strategy):
    """
    A strategy that simply emits a signal counter (FOR TESTING PURPOSES ONLY).

    Parameters
    ----------
    config : OrderbookImbalanceConfig
        The configuration for the instance.

    """

    def __init__(self, config: SignalStrategyConfig) -> None:
        super().__init__(config)
        self.instrument: Instrument | None = None
        self.counter = 0

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        self.subscribe_trade_ticks(instrument_id=self.config.instrument_id)
        self.subscribe_quote_ticks(instrument_id=self.config.instrument_id)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.
        """
        self.counter += 1
        self.publish_signal(name="counter", value=self.counter, ts_event=tick.ts_event)

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.
        """
        self.counter += 1
        self.publish_signal(name="counter", value=self.counter, ts_event=tick.ts_event)

</document_content>
</document>
<document index="2330">
<source>nautilus_trader/examples/strategies/simpler_quoter.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import StrategyConfig
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.events import OrderFilled
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.trading.strategy import Strategy


class SimpleQuoterStrategyConfig(StrategyConfig, frozen=True):
    """
    Configuration for the simple quoter strategy.
    """

    instrument_id: InstrumentId
    order_qty: Decimal = Decimal(1)
    tob_offset_ticks: int = 0
    log_data: bool = False


class SimpleQuoterStrategy(Strategy):
    """
    A quoter that places a limit order on each side of the book at a top-of-book offset.
    """

    def __init__(self, config: SimpleQuoterStrategyConfig) -> None:
        super().__init__(config)
        self.instrument = None
        self._tick_size = Decimal(0)
        self._price_offset = Decimal(0)
        self._order_qty = None
        self._bid_order = None
        self._ask_order = None

    def on_start(self) -> None:
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        self._tick_size = self.instrument.price_increment.as_decimal()
        offset_ticks = max(self.config.tob_offset_ticks, 0)
        self._price_offset = self._tick_size * offset_ticks
        self._order_qty = self.instrument.make_qty(self.config.order_qty)

        self.subscribe_quote_ticks(self.config.instrument_id)

    def on_quote_tick(self, quote: QuoteTick) -> None:
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        if self.config.log_data:
            self.log.info(repr(quote), LogColor.CYAN)

        # Check if closed
        if self._bid_order and self._bid_order.is_closed:
            self._bid_order = None
        if self._ask_order and self._ask_order.is_closed:
            self._ask_order = None

        bid_price = quote.bid_price.as_decimal() - self._price_offset
        ask_price = quote.ask_price.as_decimal() + self._price_offset

        if self._bid_order is None:
            price = self.instrument.make_price(bid_price)
            order = self.order_factory.limit(
                instrument_id=self.config.instrument_id,
                order_side=OrderSide.BUY,
                price=price,
                quantity=self._order_qty,
            )
            self._bid_order = order
            self.submit_order(order)

        if self._ask_order is None:
            price = self.instrument.make_price(ask_price)
            order = self.order_factory.limit(
                instrument_id=self.config.instrument_id,
                order_side=OrderSide.SELL,
                price=price,
                quantity=self._order_qty,
            )
            self._ask_order = order
            self.submit_order(order)

    def on_event(self, event) -> None:
        # Handle fills and reset state
        if isinstance(event, OrderFilled):
            if self._bid_order and event.client_order_id == self._bid_order.client_order_id:
                self._bid_order = None
            elif self._ask_order and event.client_order_id == self._ask_order.client_order_id:
                self._ask_order = None

    def on_stop(self) -> None:
        self.cancel_all_orders(self.config.instrument_id)
        self.close_all_positions(self.config.instrument_id)
        self._bid_order = None
        self._ask_order = None

</document_content>
</document>
<document index="2331">
<source>nautilus_trader/examples/strategies/subscribe.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.config import StrategyConfig
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarSpecification
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import AggregationSource
from nautilus_trader.model.enums import BarAggregation
from nautilus_trader.model.enums import BookType
from nautilus_trader.model.enums import PriceType
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY ***


class SubscribeStrategyConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``SubscribeStrategy`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.

    """

    instrument_id: InstrumentId
    book_type: BookType | None = None
    snapshots: bool = False
    trade_ticks: bool = False
    quote_ticks: bool = False
    bars: bool = False


class SubscribeStrategy(Strategy):
    """
    A strategy that simply subscribes to data and logs it (typically for testing
    adapters)

    Parameters
    ----------
    config : OrderbookImbalanceConfig
        The configuration for the instance.

    """

    def __init__(self, config: SubscribeStrategyConfig) -> None:
        super().__init__(config)
        self.book: OrderBook | None = None

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        if self.config.book_type:
            self.book = OrderBook(
                instrument_id=self.instrument.id,
                book_type=self.config.book_type,
            )
            if self.config.snapshots:
                self.subscribe_order_book_at_interval(
                    instrument_id=self.config.instrument_id,
                    book_type=self.config.book_type,
                )
            else:
                self.subscribe_order_book_deltas(
                    instrument_id=self.config.instrument_id,
                    book_type=self.config.book_type,
                )

        if self.config.trade_ticks:
            self.subscribe_trade_ticks(instrument_id=self.config.instrument_id)
        if self.config.quote_ticks:
            self.subscribe_quote_ticks(instrument_id=self.config.instrument_id)
        if self.config.bars:
            bar_type: BarType = BarType(
                instrument_id=self.config.instrument_id,
                bar_spec=BarSpecification(
                    step=5,
                    aggregation=BarAggregation.SECOND,
                    price_type=PriceType.LAST,
                ),
                aggregation_source=AggregationSource.EXTERNAL,
            )
            self.subscribe_bars(bar_type)

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        if not self.book:
            self.log.error("No book being maintained")
            return

        self.book.apply_deltas(deltas)
        self.log.info(str(self.book))

    def on_order_book(self, order_book: OrderBook) -> None:
        self.book = order_book
        self.log.info(str(self.book))

    def on_trade_tick(self, tick: TradeTick) -> None:
        self.log.info(str(tick))

    def on_quote_tick(self, tick: QuoteTick) -> None:
        self.log.info(str(tick))

    def on_bar(self, bar: Bar) -> None:
        self.log.info(str(bar))

</document_content>
</document>
<document index="2332">
<source>nautilus_trader/examples/strategies/volatility_market_maker.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd

from nautilus_trader.common.enums import LogColor
from nautilus_trader.config import PositiveFloat
from nautilus_trader.config import PositiveInt
from nautilus_trader.config import StrategyConfig
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.indicators import AverageTrueRange
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import Bar
from nautilus_trader.model.data import BarType
from nautilus_trader.model.data import MarkPriceUpdate
from nautilus_trader.model.data import OrderBookDeltas
from nautilus_trader.model.data import QuoteTick
from nautilus_trader.model.data import TradeTick
from nautilus_trader.model.enums import OrderSide
from nautilus_trader.model.enums import TimeInForce
from nautilus_trader.model.enums import TriggerType
from nautilus_trader.model.events import OrderFilled
from nautilus_trader.model.identifiers import ClientId
from nautilus_trader.model.identifiers import InstrumentId
from nautilus_trader.model.instruments import Instrument
from nautilus_trader.model.orders import LimitOrder
from nautilus_trader.trading.strategy import Strategy


# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***


class VolatilityMarketMakerConfig(StrategyConfig, frozen=True):
    """
    Configuration for ``VolatilityMarketMaker`` instances.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the strategy.
    bar_type : BarType
        The bar type for the strategy.
    atr_period : PositiveInt
        The period for the ATR indicator.
    atr_multiple : PositiveFloat
        The ATR multiple for bracketing limit orders.
    trade_size : Decimal
        The position size per trade.
    order_id_tag : str
        The unique order ID tag for the strategy. Must be unique
        amongst all running strategies for a particular trader ID.
    emulation_trigger : str, default 'NO_TRIGGER'
        The emulation trigger for submitting emulated orders.
        If ``None`` then orders will not be emulated.
    client_id : ClientId, optional
        The custom client ID for data and execution.
        For example if you have multiple clients for Binance you might use 'BINANCE-SPOT'.
    reduce_only_on_stop : bool, default True
        If position closing market orders on stop should be reduce-only.

    """

    instrument_id: InstrumentId
    bar_type: BarType
    atr_period: PositiveInt
    atr_multiple: PositiveFloat
    trade_size: Decimal
    emulation_trigger: str = "NO_TRIGGER"
    client_id: ClientId | None = None
    reduce_only_on_stop: bool = True


class VolatilityMarketMaker(Strategy):
    """
    A very basic market maker which brackets the top of book based on volatility
    measured by an ATR indicator.

    Cancels all orders and closes all positions on stop.

    Parameters
    ----------
    config : VolatilityMarketMakerConfig
        The configuration for the instance.

    """

    def __init__(self, config: VolatilityMarketMakerConfig) -> None:
        super().__init__(config)

        self.instrument: Instrument | None = None  # Initialized in on_start
        self.client_id = config.client_id

        # Create the indicators for the strategy
        self.atr = AverageTrueRange(config.atr_period)

        # Users order management variables
        self.buy_order: LimitOrder | None = None
        self.sell_order: LimitOrder | None = None

    def on_start(self) -> None:
        """
        Actions to be performed on strategy start.
        """
        self.instrument = self.cache.instrument(self.config.instrument_id)
        if self.instrument is None:
            self.log.error(f"Could not find instrument for {self.config.instrument_id}")
            self.stop()
            return

        # Register the indicators for updating
        self.register_indicator_for_bars(self.config.bar_type, self.atr)

        # Get historical data
        self.request_bars(
            self.config.bar_type,
            client_id=self.client_id,
            start=self.clock.utc_now() - pd.Timedelta(days=1),
        )

        # Subscribe to live data
        self.subscribe_bars(self.config.bar_type, client_id=self.client_id)
        self.subscribe_quote_ticks(self.config.instrument_id, client_id=self.client_id)
        self.subscribe_trade_ticks(self.config.instrument_id, client_id=self.client_id)

    def on_data(self, data: Data) -> None:
        """
        Actions to be performed when the strategy is running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(data), LogColor.CYAN)

    def on_instrument(self, instrument: Instrument) -> None:
        """
        Actions to be performed when the strategy is running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        """
        # For debugging (must add a subscription)
        # self.log.info(repr(instrument), LogColor.CYAN)

    def on_order_book(self, order_book: OrderBook) -> None:
        """
        Actions to be performed when the strategy is running and receives an order book.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(order_book), LogColor.CYAN)

    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
        """
        Actions to be performed when the strategy is running and receives order book
        deltas.

        Parameters
        ----------
        deltas : OrderBookDeltas
            The order book deltas received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(deltas), LogColor.CYAN)

    def on_quote_tick(self, tick: QuoteTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(tick), LogColor.CYAN)

    def on_trade_tick(self, tick: TradeTick) -> None:
        """
        Actions to be performed when the strategy is running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(tick), LogColor.CYAN)

    def on_mark_price(self, update: MarkPriceUpdate) -> None:
        """
        Actions to be performed when the strategy is running and receives a mark price
        update.

        Parameters
        ----------
        update : MarkPriceUpdate
            The update received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(update), LogColor.CYAN)

    def on_index_price(self, update: MarkPriceUpdate) -> None:
        """
        Actions to be performed when the strategy is running and receives an index price
        update.

        Parameters
        ----------
        update : IndexPriceUpdate
            The update received.

        """
        # For debugging (must add a subscription)
        self.log.info(repr(update), LogColor.CYAN)

    def on_bar(self, bar: Bar) -> None:
        """
        Actions to be performed when the strategy is running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        """
        self.log.info(repr(bar), LogColor.CYAN)

        if not self.instrument:
            self.log.error("No instrument loaded.")
            return

        # Check if indicators ready
        if not self.indicators_initialized():
            self.log.info(
                f"Waiting for indicators to warm up [{self.cache.bar_count(self.config.bar_type)}]",
                color=LogColor.BLUE,
            )
            return  # Wait for indicators to warm up...

        last: QuoteTick = self.cache.quote_tick(self.config.instrument_id)
        if last is None:
            self.log.info("No quotes yet")
            return

        # Maintain buy orders
        if self.buy_order and (self.buy_order.is_emulated or self.buy_order.is_open):
            self.cancel_order(self.buy_order)
        self.create_buy_order(last)

        # Maintain sell orders
        if self.sell_order and (self.sell_order.is_emulated or self.sell_order.is_open):
            self.cancel_order(self.sell_order)
        self.create_sell_order(last)

    def create_buy_order(self, last: QuoteTick) -> None:
        """
        Market maker simple buy limit method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        price: Decimal = last.bid_price - (self.atr.value * self.config.atr_multiple)
        order: LimitOrder = self.order_factory.limit(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.BUY,
            quantity=self.instrument.make_qty(self.config.trade_size),
            price=self.instrument.make_price(price),
            time_in_force=TimeInForce.GTD,
            expire_time=self.clock.utc_now() + pd.Timedelta(minutes=10),
            post_only=True,  # default value is True
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )

        self.buy_order = order
        self.submit_order(order, client_id=self.client_id)

    def create_sell_order(self, last: QuoteTick) -> None:
        """
        Market maker simple sell limit method (example).
        """
        if not self.instrument:
            self.log.error("No instrument loaded")
            return

        price: Decimal = last.ask_price + (self.atr.value * self.config.atr_multiple)
        order: LimitOrder = self.order_factory.limit(
            instrument_id=self.config.instrument_id,
            order_side=OrderSide.SELL,
            quantity=self.instrument.make_qty(self.config.trade_size),
            price=self.instrument.make_price(price),
            time_in_force=TimeInForce.GTD,
            expire_time=self.clock.utc_now() + pd.Timedelta(minutes=10),
            post_only=True,  # default value is True
            emulation_trigger=TriggerType[self.config.emulation_trigger],
        )

        self.sell_order = order
        self.submit_order(order, client_id=self.client_id)

    def on_event(self, event: Event) -> None:
        """
        Actions to be performed when the strategy is running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        """
        last: QuoteTick = self.cache.quote_tick(self.config.instrument_id)
        if last is None:
            self.log.info("No quotes yet")
            return

        # If order filled then replace order at ATR multiple distance from the market
        if isinstance(event, OrderFilled):
            if self.buy_order and event.order_side == OrderSide.BUY:
                if self.buy_order.is_closed:
                    self.create_buy_order(last)
            elif (
                self.sell_order and event.order_side == OrderSide.SELL and self.sell_order.is_closed
            ):
                self.create_sell_order(last)

    def on_stop(self) -> None:
        """
        Actions to be performed when the strategy is stopped.
        """
        self.cancel_all_orders(self.config.instrument_id, client_id=self.client_id)

        self.close_all_positions(
            instrument_id=self.config.instrument_id,
            client_id=self.client_id,
            reduce_only=self.config.reduce_only_on_stop,
        )

        # Unsubscribe from data
        self.unsubscribe_bars(self.config.bar_type, client_id=self.client_id)
        self.unsubscribe_quote_ticks(self.config.instrument_id, client_id=self.client_id)
        self.unsubscribe_trade_ticks(self.config.instrument_id, client_id=self.client_id)

    def on_reset(self) -> None:
        """
        Actions to be performed when the strategy is reset.
        """
        # Reset indicators here
        self.atr.reset()

</document_content>
</document>
<document index="2578">
<source>python/examples/__init__.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

</document_content>
</document>
<document index="2579">
<source>python/examples/blockchain/__init__.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

</document_content>
</document>
<document index="2580">
<source>python/examples/blockchain/actors.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from dataclasses import dataclass

from nautilus_trader.common import DataActor  # type: ignore[attr-defined]
from nautilus_trader.common import DataActorConfig  # type: ignore[attr-defined]
from nautilus_trader.common import LogColor  # type: ignore[attr-defined]
from nautilus_trader.model import ActorId  # type: ignore[attr-defined]
from nautilus_trader.model import Block  # type: ignore[attr-defined]
from nautilus_trader.model import Chain  # type: ignore[attr-defined]
from nautilus_trader.model import ClientId
from nautilus_trader.model import InstrumentId
from nautilus_trader.model import PoolFeeCollect  # type: ignore[attr-defined]
from nautilus_trader.model import PoolFlash  # type: ignore[attr-defined]
from nautilus_trader.model import PoolLiquidityUpdate  # type: ignore[attr-defined]
from nautilus_trader.model import PoolSwap  # type: ignore[attr-defined]


@dataclass
class BlockchainActorConfig(DataActorConfig):
    # Inherited fields from DataActorConfig (must be included for now)
    actor_id: ActorId | None = None
    log_events: bool = True
    log_commands: bool = True

    # Blockchain-specific fields
    chain: Chain | None = None
    client_id: ClientId | None = None
    pools: list[InstrumentId] | None = None

    def __post_init__(self):
        if isinstance(self.actor_id, str):
            self.actor_id = ActorId(self.actor_id)

        if isinstance(self.client_id, str):
            self.client_id = ClientId(self.client_id)

        if isinstance(self.pools, list) and self.pools and isinstance(self.pools[0], str):
            self.pools = [InstrumentId.from_str(pool_str) for pool_str in self.pools]

        if isinstance(self.chain, str):
            self.chain = Chain.from_chain_name(self.chain)


class BlockchainActor(DataActor):

    def __init__(self, config: BlockchainActorConfig | None = None) -> None:
        if config is None:
            config = BlockchainActorConfig()
        super().__init__()

        self.chain = config.chain or Chain.ARBITRUM()
        self.client_id = config.client_id or ClientId(f"BLOCKCHAIN-{self.chain.name}")
        self.pools = config.pools or [
            InstrumentId.from_str("0xC31E54c7a869B9FcBEcc14363CF510d1c41fa443.Arbitrum:UniswapV3"),
        ]

    def on_start(self) -> None:
        """
        Actions to be performed on actor start.
        """
        self.subscribe_blocks(self.chain.name)

        for instrument_id in self.pools:
            self.subscribe_pool(instrument_id, self.client_id)
            self.subscribe_pool_swaps(instrument_id, self.client_id)
            self.subscribe_pool_liquidity_updates(instrument_id, self.client_id)
            self.subscribe_pool_fee_collects(instrument_id, self.client_id)
            self.subscribe_pool_flash_events(instrument_id, self.client_id)

        # TODO: Uncomment to demonstrate timers
        # import pandas as pd
        # self.clock.set_timer("TEST-TIMER-SECONDS-1", pd.Timedelta(seconds=1))
        # self.clock.set_timer("TEST-TIMER-SECONDS-2", pd.Timedelta(seconds=2))

    def on_stop(self) -> None:
        """
        Actions to be performed on actor stop.
        """
        self.unsubscribe_blocks(self.chain.name)

        for instrument_id in self.pools:
            self.unsubscribe_pool(instrument_id, self.client_id)
            self.unsubscribe_pool_swaps(instrument_id, self.client_id)
            self.unsubscribe_pool_liquidity_updates(instrument_id, self.client_id)
            self.unsubscribe_pool_fee_collects(instrument_id, self.client_id)
            self.unsubscribe_pool_flash_events(instrument_id, self.client_id)

    def on_time_event(self, event) -> None:
        """
        Actions to be performed on receiving a time event.
        """
        self.log.info(repr(event), LogColor.BLUE)

    def on_pool(self, pool) -> None:
        self.log.info(f"Received pool: {pool.instrument_id}", LogColor.GREEN)

    def on_block(self, block: Block) -> None:
        """
        Actions to be performed on receiving a block.
        """
        self.log.info(repr(block), LogColor.CYAN)

        for pool_id in self.pools:
            pool = self.cache.pool_profiler(pool_id)
            if pool is None:
                continue
            total_ticks = pool.get_active_tick_count()
            total_positions = pool.get_total_active_positions()
            liquidity = pool.get_active_liquidity()
            liquidity_utilization_rate = pool.liquidity_utilization_rate()
            self.log.info(
                f"Pool {pool_id} contains {total_ticks} active ticks and {total_positions} active positions with liquidity of {liquidity}",
                LogColor.BLUE,
            )
            self.log.info(
                f"Pool {pool_id} has a liquidity utilization rate of {liquidity_utilization_rate * 100:.4f}%",
                LogColor.BLUE,
            )

    def on_pool_swap(self, swap: PoolSwap) -> None:
        """
        Actions to be performed on receiving a pool swap.
        """
        self.log.info(repr(swap), LogColor.CYAN)

    def on_pool_liquidity_update(self, update: PoolLiquidityUpdate) -> None:
        """
        Actions to be performed on receiving a pool liquidity update.
        """
        self.log.info(repr(update), LogColor.CYAN)

    def on_pool_fee_collect(self, update: PoolFeeCollect) -> None:
        """
        Actions to be performed on receiving a pool fee collect event.
        """
        self.log.info(repr(update), LogColor.CYAN)

    def on_pool_flash(self, event: PoolFlash) -> None:
        """
        Actions to be performed on receiving a pool flash event.
        """
        self.log.info(repr(event), LogColor.CYAN)

</document_content>
</document>
<document index="2581">
<source>python/examples/blockchain/node_test.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
"""
Python version of the Rust node_test.rs blockchain adapter demo.

This demonstrates the complete PyO3 interface for DeFi blockchain functionality,
mirroring the capabilities shown in crates/adapters/blockchain/bin/node_test.rs

"""

# ruff: noqa: F401

import os

from dotenv import load_dotenv

from nautilus_trader.adapters.blockchain import BlockchainDataClientConfig
from nautilus_trader.adapters.blockchain import BlockchainDataClientFactory
from nautilus_trader.common import Environment
from nautilus_trader.common import ImportableActorConfig  # type: ignore[attr-defined]
from nautilus_trader.infrastructure import PostgresConnectOptions
from nautilus_trader.live import LiveNode  # type: ignore[attr-defined]
from nautilus_trader.model import Chain  # type: ignore[attr-defined]
from nautilus_trader.model import DexType  # type: ignore[attr-defined]
from nautilus_trader.model import InstrumentId
from nautilus_trader.model import TraderId


def main() -> None:
    # Load environment variables from .env file
    load_dotenv()

    # Environment setup
    environment = Environment.LIVE
    trader_id = TraderId("TESTER-001")
    node_name = "TESTER-001"

    print(f"Environment: {environment}")
    print(f"Trader ID: {trader_id}")
    print(f"Node name: {node_name}")

    # Chain setup
    chain = Chain.ARBITRUM()
    print(f"\nChain: {chain}")

    # RPC URLs (equivalent to get_env_var calls)
    http_rpc_url = os.getenv("RPC_HTTP_URL", "https://arb1.arbitrum.io/rpc")
    wss_rpc_url = os.getenv("RPC_WSS_URL", "wss://arb1.arbitrum.io/ws")
    from_block = 0

    print(f"HTTP RPC URL: {http_rpc_url}")
    print(f"WSS RPC URL: {wss_rpc_url}")
    print(f"From block: {from_block:_}")

    # PostgreSQL configuration (optional, for caching blockchain data)
    postgres_config = None
    if os.getenv("USE_POSTGRES_CACHE"):
        postgres_config = PostgresConnectOptions(
            host=os.getenv("POSTGRES_HOST", "localhost"),
            port=int(os.getenv("POSTGRES_PORT", "5432")),
            user=os.getenv("POSTGRES_USERNAME", "nautilus"),
            password=os.getenv("POSTGRES_PASSWORD", "pass"),
            database=os.getenv("POSTGRES_DATABASE", "nautilus"),
        )
        print(f"\nPostgres cache config: {postgres_config}")

    # Client factory and configuration
    client_factory = BlockchainDataClientFactory()
    client_config = BlockchainDataClientConfig(
        chain=chain,
        dex_ids=[
            DexType.UniswapV3,
        ],
        http_rpc_url=http_rpc_url,
        wss_rpc_url=wss_rpc_url,
        use_hypersync_for_live_data=True,
        from_block=from_block,
        postgres_cache_database_config=postgres_config,
    )

    builder = LiveNode.builder(node_name, trader_id, environment)
    builder.add_data_client(None, client_factory, client_config)
    node = builder.build()

    actor_config = ImportableActorConfig(
        actor_path="actors:BlockchainActor",
        config_path="actors:BlockchainActorConfig",
        config={
            "actor_id": "BLOCKCHAIN-001",
            "log_events": True,
            "log_commands": True,
            "chain": "Arbitrum",
            "client_id": "BLOCKCHAIN-Arbitrum",
            "pools": [
                "0xD491076C7316bC28fD4D35E3da9aB5286D079250.Arbitrum:UniswapV3",
            ],
        },
    )

    # Add actor using config approach
    node.add_actor_from_config(actor_config)

    node.run()


if __name__ == "__main__":
    main()

</document_content>
</document>
<document index="2582">
<source>python/examples/blockchain/node_test_factory.py</source>
<document_content>
#!/usr/bin/env python3
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import os

from nautilus_trader.common import Environment
from nautilus_trader.common import ImportableActorConfig  # type: ignore[attr-defined]
from nautilus_trader.infrastructure import PostgresConnectOptions
from nautilus_trader.live import LiveNode  # type: ignore[attr-defined]
from nautilus_trader.model import TraderId


def test_factory_approach():
    """
    Test creating and adding actors using factory approach.

    Also tests PostgresConnectOptions Python bindings.

    """
    # Test PostgresConnectOptions creation
    postgres_config = PostgresConnectOptions(
        host=os.getenv("POSTGRES_HOST", "localhost"),
        port=int(os.getenv("POSTGRES_PORT", "5432")),
        user=os.getenv("POSTGRES_USERNAME", "nautilus"),
        password=os.getenv("POSTGRES_PASSWORD", "pass"),
        database=os.getenv("POSTGRES_DATABASE", "nautilus"),
    )
    print(f"PostgresConnectOptions created: {postgres_config}")
    print(f"  host: {postgres_config.host}")
    print(f"  port: {postgres_config.port}")
    print(f"  username: {postgres_config.username}")
    print(f"  database: {postgres_config.database}")

    trader_id = TraderId("TESTER-001")
    node = LiveNode.builder("test_factory", trader_id, Environment.SANDBOX).build()

    actor_config = ImportableActorConfig(
        actor_path="actors:BlockchainActor",
        config_path="actors:BlockchainActorConfig",
        config={
            "actor_id": "BLOCKCHAIN-001",
            "log_events": True,
            "log_commands": True,
            "chain": "Arbitrum",
            "client_id": "BLOCKCHAIN-Arbitrum",
            "pools": ["0xC31E54c7a869B9FcBEcc14363CF510d1c41fa443.Arbitrum:UniswapV3"],
        },
    )

    # Add actor using factory approach
    node.add_actor_from_config(actor_config)
    print("Successfully added actor from config")

    node.start()
    print("Successfully started node with factory-created actor")

    node.stop()
    print("Successfully stopped node")


if __name__ == "__main__":
    test_factory_approach()

</document_content>
</document></documents>
