<documents><document index="1903">
<source>nautilus_trader/accounting/accounts/base.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.accounting.error import AccountBalanceNegative

from libc.stdint cimport uint64_t

from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.model.events.account cimport AccountState
from nautilus_trader.model.functions cimport account_type_to_str
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport AccountBalance


cdef class Account:
    """
    The base class for all trading accounts.
    """

    def __init__(self, AccountState event, bint calculate_account_state):
        Condition.not_none(event, "event")

        self.id = event.account_id
        self.type = event.account_type
        self.base_currency = event.base_currency
        self.is_cash_account = self.type == AccountType.CASH or self.type == AccountType.BETTING
        self.is_margin_account = self.type == AccountType.MARGIN
        self.calculate_account_state = calculate_account_state

        self._events: list[AccountState] = [event]  # `last_event_c()` guaranteed
        self._commissions: dict[Currency, Money] = {}
        self._balances: dict[Currency, AccountBalance] = {}
        self._balances_starting: dict[Currency, Money] = {b.currency: b.total for b in event.balances}

        self.update_balances(event.balances)

    def __eq__(self, Account other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __repr__(self) -> str:
        cdef str base_str = self.base_currency.code if self.base_currency is not None else None
        return (
            f"{type(self).__name__}("
            f"id={self.id.to_str()}, "
            f"type={account_type_to_str(self.type)}, "
            f"base={base_str})"
        )

# -- QUERIES --------------------------------------------------------------------------------------

    cdef AccountState last_event_c(self):
        return self._events[-1]  # Guaranteed at least one event from initialization

    cdef list events_c(self):
        return self._events.copy()

    cdef int event_count_c(self):
        return len(self._events)

    @property
    def last_event(self):
        """
        Return the accounts last state event.

        Returns
        -------
        AccountState

        """
        return self.last_event_c()

    @property
    def events(self):
        """
        Return all events received by the account.

        Returns
        -------
        list[AccountState]

        """
        return self.events_c()

    @property
    def event_count(self):
        """
        Return the count of events.

        Returns
        -------
        int

        """
        return self.event_count_c()

    cpdef list currencies(self):
        """
        Return the account currencies.

        Returns
        -------
        list[Currency]

        """
        return list(self._balances.keys())

    cpdef dict starting_balances(self):
        """
        Return the account starting balances.

        Returns
        -------
        dict[Currency, Money]

        """
        return self._balances_starting.copy()

    cpdef dict balances(self):
        """
        Return the account balances totals.

        Returns
        -------
        dict[Currency, Money]

        """
        return self._balances.copy()

    cpdef dict balances_total(self):
        """
        Return the account balances totals.

        Returns
        -------
        dict[Currency, Money]

        """
        cdef AccountBalance b
        return {c: b.total for c, b in self._balances.items()}

    cpdef dict balances_free(self):
        """
        Return the account balances free.

        Returns
        -------
        dict[Currency, Money]

        """
        cdef AccountBalance b
        return {c: b.free for c, b in self._balances.items()}

    cpdef dict balances_locked(self):
        """
        Return the account balances locked.

        Returns
        -------
        dict[Currency, Money]

        """
        cdef AccountBalance b
        return {c: b.locked for c, b in self._balances.items()}

    cpdef dict commissions(self):
        """
        Return the total commissions for the account.
        """
        return self._commissions.copy()

    cpdef AccountBalance balance(self, Currency currency = None):
        """
        Return the current account balance total.

        For multi-currency accounts, specify the currency for the query.

        Parameters
        ----------
        currency : Currency, optional
            The currency for the query. If ``None`` then will use the default
            currency (if set).

        Returns
        -------
        AccountBalance or ``None``

        Raises
        ------
        ValueError
            If `currency` is ``None`` and `base_currency` is ``None``.

        Warnings
        --------
        Returns ``None`` if there is no applicable information for the query,
        rather than `Money` of zero amount.

        """
        if currency is None:
            currency = self.base_currency
        Condition.not_none(currency, "currency")

        return self._balances.get(currency)

    cpdef Money balance_total(self, Currency currency = None):
        """
        Return the current account balance total.

        For multi-currency accounts, specify the currency for the query.

        Parameters
        ----------
        currency : Currency, optional
            The currency for the query. If ``None`` then will use the default
            currency (if set).

        Returns
        -------
        Money or ``None``

        Raises
        ------
        ValueError
            If `currency` is ``None`` and `base_currency` is ``None``.

        Warnings
        --------
        Returns ``None`` if there is no applicable information for the query,
        rather than `Money` of zero amount.

        """
        if currency is None:
            currency = self.base_currency
        Condition.not_none(currency, "currency")

        cdef AccountBalance balance = self._balances.get(currency)
        if balance is None:
            return None
        return balance.total

    cpdef Money balance_free(self, Currency currency = None):
        """
        Return the account balance free.

        For multi-currency accounts, specify the currency for the query.

        Parameters
        ----------
        currency : Currency, optional
            The currency for the query. If ``None`` then will use the default
            currency (if set).

        Returns
        -------
        Money or ``None``

        Raises
        ------
        ValueError
            If `currency` is ``None`` and `base_currency` is ``None``.

        Warnings
        --------
        Returns ``None`` if there is no applicable information for the query,
        rather than `Money` of zero amount.

        """
        if currency is None:
            currency = self.base_currency
        Condition.not_none(currency, "currency")

        cdef AccountBalance balance = self._balances.get(currency)
        if balance is None:
            return None
        return balance.free

    cpdef Money balance_locked(self, Currency currency = None):
        """
        Return the account balance locked.

        For multi-currency accounts, specify the currency for the query.

        Parameters
        ----------
        currency : Currency, optional
            The currency for the query. If ``None`` then will use the default
            currency (if set).

        Returns
        -------
        Money or ``None``

        Raises
        ------
        ValueError
            If `currency` is ``None`` and `base_currency` is ``None``.

        Warnings
        --------
        Returns ``None`` if there is no applicable information for the query,
        rather than `Money` of zero amount.

        """
        if currency is None:
            currency = self.base_currency
        Condition.not_none(currency, "currency")

        cdef AccountBalance balance = self._balances.get(currency)
        if balance is None:
            return None
        return balance.locked

    cpdef Money commission(self, Currency currency):
        """
        Return the total commissions for the given currency.

        Parameters
        ----------
        currency : Currency
            The currency for the commission.

        Returns
        -------
        Money or ``None``

        """
        Condition.not_none(currency, "currency")

        return self._commissions.get(currency)

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void apply(self, AccountState event):
        """
        Apply the given account event to the account.

        Parameters
        ----------
        event : AccountState
            The account event to apply.

        Raises
        ------
        ValueError
            If `event.account_type` is not equal to `self.type`.
        ValueError
            If `event.account_id` is not equal to `self.id`.
        ValueError
            If `event.base_currency` is not equal to `self.base_currency`.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(event, "event")
        Condition.equal(event.account_type, self.type, "event.account_type", "self.type")
        Condition.equal(event.account_id, self.id, "self.id", "event.account_id")
        Condition.equal(event.base_currency, self.base_currency, "self.base_currency", "event.base_currency")

        if self.base_currency:
            # Single-currency account
            Condition.is_true(len(event.balances) == 1, "single-currency account has multiple currency update")
            Condition.equal(event.balances[0].currency, self.base_currency, "event.balances[0].currency", "self.base_currency")

        self._events.append(event)
        self.update_balances(event.balances)

    cpdef void update_balances(self, list balances):
        """
        Update the account balances.

        There is no guarantee that every account currency is included in the
        given balances, therefore we only update included balances.

        Parameters
        ----------
        balances : list[AccountBalance]
            The balances for the update.

        Raises
        ------
        ValueError
            If `balances` is empty.
        AccountBalanceNegative
            If account type is ``CASH``, and balance is negative.

        """
        Condition.not_empty(balances, "balances")

        cdef AccountBalance balance
        for balance in balances:
            if self.type == AccountType.CASH and balance.total._mem.raw < 0:
                raise AccountBalanceNegative(balance.total.as_decimal(), balance.currency)

            self._balances[balance.currency] = balance

    cpdef void update_commissions(self, Money commission):
        """
        Update the commissions.

        Can be negative which represents credited commission.

        Parameters
        ----------
        commission : Money
            The commission to update with.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(commission, "commission")

        # Increment total commissions
        if commission._mem.raw == 0:
            return  # Nothing to update

        cdef Currency currency = commission.currency
        total_commissions = self._commissions.get(currency, Decimal(0))
        self._commissions[currency] = Money(total_commissions + commission.as_decimal(), currency)

    cpdef void purge_account_events(self, uint64_t ts_now, uint64_t lookback_secs = 0):
        """
        Purge all account state events which are outside the lookback window.

        Guaranteed to retain at least the latest event.

        Parameters
        ----------
        ts_now : uint64_t
            The current UNIX timestamp (nanoseconds).
        lookback_secs : uint64_t, default 0
            The purge lookback window (seconds) from when the account state event occurred.
            Only events which are outside the lookback window will be purged.
            A value of 0 means purge all account state events.

        """
        cdef uint64_t lookback_ns = nautilus_pyo3.secs_to_nanos(lookback_secs)

        cdef list[AccountState] retained_events = []

        cdef:
            AccountState event
        for event in self._events:
            if event.ts_event + lookback_ns > ts_now:
                retained_events.append(event)

        # Guarantee ≥ 1 event
        if not retained_events and self._events:
            retained_events.append(self._events[-1])

        self._events = retained_events

# -- CALCULATIONS ---------------------------------------------------------------------------------

    cpdef bint is_unleveraged(self, InstrumentId instrument_id):
        """
        Return whether the given instrument is leveraged for this account (leverage == 1).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID to check.

        Returns
        -------
        bool

        """
        raise NotImplementedError("method `is_unleveraged` must be implemented in the subclass")  # pragma: no cover

    cdef void _recalculate_balance(self, Currency currency):
        raise NotImplementedError("method `_recalculate_balance` must be implemented in the subclass")  # pragma: no cover

    cpdef Money calculate_commission(
        self,
        Instrument instrument,
        Quantity last_qty,
        Price last_px,
        LiquiditySide liquidity_side,
        bint use_quote_for_inverse=False,
    ):
        raise NotImplementedError("method `calculate_commission` must be implemented in the subclass")  # pragma: no cover

    cpdef list calculate_pnls(
        self,
        Instrument instrument,
        OrderFilled fill,
        Position position: Position | None = None,
    ):
        raise NotImplementedError("method `calculate_pnls` must be implemented in the subclass")  # pragma: no cover

    cpdef Money balance_impact(
        self,
        Instrument instrument,
        Quantity quantity,
        Price price,
        OrderSide order_side,
    ):
        raise NotImplementedError("method `balance_impact` must be implemented in the subclass")  # pragma: no cover

</document_content>
</document>
<document index="1905">
<source>nautilus_trader/accounting/accounts/betting.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.accounting.accounts.cash cimport CashAccount
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class BettingAccount(CashAccount):
    """
    Provides a betting account.
    """
    ACCOUNT_TYPE = AccountType.BETTING

# -- CALCULATIONS ---------------------------------------------------------------------------------

    cpdef Money calculate_balance_locked(
        self,
        Instrument instrument,
        OrderSide side,
        Quantity quantity,
        Price price,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the locked balance.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        side : OrderSide {``BUY``, ``SELL``}
            The order side.
        quantity : Quantity
            The order quantity.
        price : Price
            The order price.
        use_quote_for_inverse : bool
            Not applicable for betting accounts.

        Returns
        -------
        Money

        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")
        Condition.not_equal(use_quote_for_inverse, True, "use_quote_for_inverse", "True")

        locked: Decimal = liability(quantity, price, side)
        return Money(locked, instrument.quote_currency)

    cpdef Money balance_impact(
        self,
        Instrument instrument,
        Quantity quantity,
        Price price,
        OrderSide order_side,
    ):
        cdef Money notional
        if order_side == OrderSide.SELL:
            notional = instrument.notional_value(quantity, price)
            return Money(-notional.as_f64_c(), notional.currency)
        elif order_side == OrderSide.BUY:
            notional = instrument.notional_value(quantity, price)
            return Money(-notional.as_f64_c() * (price.as_f64_c() - 1.0), notional.currency)
        else:
            raise RuntimeError(f"invalid `OrderSide`, was {order_side}")  # pragma: no cover (design-time error)


cpdef stake(Quantity quantity, Price price):
    return quantity * (price - 1)


cpdef liability(Quantity quantity, Price price, OrderSide side):
    if side == OrderSide.SELL:
        return quantity
    elif side == OrderSide.BUY:
        return stake(quantity, price)


cpdef win_payoff(Quantity quantity, Price price, OrderSide side):
    if side == OrderSide.BUY:
        return stake(quantity, price)
    elif side == OrderSide.SELL:
        return -stake(quantity, price)


cpdef lose_payoff(Quantity quantity, OrderSide side):
    if side == OrderSide.BUY:
        return -quantity
    elif side == OrderSide.SELL:
        return quantity


cpdef exposure(Quantity quantity, Price price, OrderSide side):
    return win_payoff(quantity, price, side) - lose_payoff(quantity, side)

</document_content>
</document>
<document index="1907">
<source>nautilus_trader/accounting/accounts/cash.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.accounting.error import AccountBalanceNegative
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.model.events.account cimport AccountState
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport AccountBalance
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.position cimport Position


cdef class CashAccount(Account):
    """
    Provides a cash account.

    Parameters
    ----------
    event : AccountState
        The initial account state event.
    calculate_account_state : bool, optional
        If the account state should be calculated from order fills.
    allow_borrowing : bool, optional
        If borrowing is allowed (negative balances).

    Raises
    ------
    ValueError
        If `event.account_type` is not equal to ``CASH``.

    """
    ACCOUNT_TYPE = AccountType.CASH  # required for BettingAccount subclass

    def __init__(
        self,
        AccountState event,
        bint calculate_account_state = False,
        bint allow_borrowing = False,
    ):
        Condition.not_none(event, "event")
        Condition.equal(event.account_type, self.ACCOUNT_TYPE, "event.account_type", "account_type")

        self.allow_borrowing = allow_borrowing

        super().__init__(event, calculate_account_state)

        self._balances_locked: dict[InstrumentId, Money] = {}

    @staticmethod
    cdef dict to_dict_c(CashAccount obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "CashAccount",
            "calculate_account_state": obj.calculate_account_state,
            "allow_borrowing": obj.allow_borrowing,
            "events": [AccountState.to_dict_c(event) for event in obj.events_c()]
        }

    @staticmethod
    def to_dict(CashAccount obj):
        return CashAccount.to_dict_c(obj)


    @staticmethod
    cdef CashAccount from_dict_c(dict values):
        Condition.not_none(values, "values")
        calculate_account_state = values["calculate_account_state"]
        allow_borrowing = values.get("allow_borrowing", False)
        events = values["events"]
        if len(events) == 0:
            return None
        init_event = events[0]
        other_events = events[1:]
        account = CashAccount(
            event=AccountState.from_dict_c(init_event),
            calculate_account_state=calculate_account_state,
            allow_borrowing=allow_borrowing
        )
        for event in other_events:
            account.apply(AccountState.from_dict_c(event))
        return account

    @staticmethod
    def from_dict(dict values):
        return CashAccount.from_dict_c(values)

    cpdef void update_balances(self, list balances):
        """
        Update the account balances.

        There is no guarantee that every account currency is included in the
        given balances, therefore we only update included balances.

        Parameters
        ----------
        balances : list[AccountBalance]
            The balances for the update.

        Raises
        ------
        ValueError
            If `balances` is empty.
        AccountBalanceNegative
            If borrowing is not allowed and balance is negative.

        """
        Condition.not_empty(balances, "balances")

        cdef AccountBalance balance
        for balance in balances:
            if not self.allow_borrowing and balance.total._mem.raw < 0:
                raise AccountBalanceNegative(balance.total.as_decimal(), balance.currency)

            self._balances[balance.currency] = balance

    cpdef void update_balance_locked(self, InstrumentId instrument_id, Money locked):
        """
        Update the balance locked for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the update.
        locked : Money
            The locked balance for the instrument.

        Raises
        ------
        ValueError
            If `margin_init` is negative (< 0).

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.not_none(locked, "locked")
        Condition.is_true(locked.raw_int_c() >= 0, f"locked was negative ({locked})")

        self._balances_locked[instrument_id] = locked
        self._recalculate_balance(locked.currency)

    cpdef void clear_balance_locked(self, InstrumentId instrument_id):
        """
        Clear the balance locked for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the locked balance to clear.

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef Money locked = self._balances_locked.pop(instrument_id, None)
        if locked is not None:
            self._recalculate_balance(locked.currency)

# -- CALCULATIONS ---------------------------------------------------------------------------------

    cpdef bint is_unleveraged(self, InstrumentId instrument_id):
        return True

    cdef void _recalculate_balance(self, Currency currency):
        cdef AccountBalance current_balance = self._balances.get(currency)
        if current_balance is None:
            # TODO: Temporary pending reimplementation of accounting
            print("Cannot recalculate balance when no current balance")
            return

        total_locked = Decimal(0)

        cdef Money locked
        for locked in self._balances_locked.values():
            if locked.currency != currency:
                continue
            total_locked += locked.as_decimal()

        # Calculate the free balance ensuring that it is never negative.
        #
        # In some edge-cases (for example, when an adapter temporarily reports
        # an inflated locked amount due to latency or rounding differences)
        # the calculated ``total_locked`` can exceed the ``total`` balance. This
        # would normally propagate to the ``AccountBalance`` constructor where
        # the internal correctness checks would raise – ultimately causing the
        # entire application to terminate. That fail-fast behaviour is useful
        # during development, but in live trading we prefer to degrade
        # gracefully whilst ensuring that balances remain internally
        # consistent.
        #
        # Therefore we clamp the locked amount to the total balance whenever it
        # would otherwise exceed it. The resulting free balance is then zero –
        # indicating that no funds are currently available for trading.
        total = current_balance.total.as_decimal()
        total_free = total - total_locked

        if total_free < 0:
            # Clamp the locked balance. We intentionally do not raise as this
            # condition can occur transiently when the venue and client state
            # are out-of-sync.
            total_locked = total
            total_free = Decimal(0)

        cdef AccountBalance new_balance = AccountBalance(
            current_balance.total,
            Money(total_locked, currency),
            Money(total_free, currency),
        )

        self._balances[currency] = new_balance

    cpdef Money calculate_commission(
        self,
        Instrument instrument,
        Quantity last_qty,
        Price last_px,
        LiquiditySide liquidity_side,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the commission generated from a transaction with the given
        parameters.

        Result will be in quote currency for standard instruments, or base
        currency for inverse instruments.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        last_qty : Quantity
            The transaction quantity.
        last_px : Price
            The transaction price.
        liquidity_side : LiquiditySide {``MAKER``, ``TAKER``}
            The liquidity side for the transaction.
        use_quote_for_inverse : bool
            If inverse instrument calculations use quote currency (instead of base).

        Returns
        -------
        Money

        Raises
        ------
        ValueError
            If `liquidity_side` is ``NO_LIQUIDITY_SIDE``.

        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(last_qty, "last_qty")
        Condition.not_equal(liquidity_side, LiquiditySide.NO_LIQUIDITY_SIDE, "liquidity_side", "NO_LIQUIDITY_SIDE")

        notional = instrument.notional_value(
            quantity=last_qty,
            price=last_px,
            use_quote_for_inverse=use_quote_for_inverse,
        ).as_decimal()

        if liquidity_side == LiquiditySide.MAKER:
            commission = notional * instrument.maker_fee
        elif liquidity_side == LiquiditySide.TAKER:
            commission = notional * instrument.taker_fee
        else:
            raise ValueError(
                f"invalid LiquiditySide, was {liquidity_side_to_str(liquidity_side)}"
            )

        if instrument.is_inverse and not use_quote_for_inverse:
            return Money(commission, instrument.base_currency)
        else:
            return Money(commission, instrument.quote_currency)

    cpdef Money calculate_balance_locked(
        self,
        Instrument instrument,
        OrderSide side,
        Quantity quantity,
        Price price,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the locked balance.

        Result will be in quote currency for standard instruments, or base
        currency for inverse instruments.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        side : OrderSide {``BUY``, ``SELL``}
            The order side.
        quantity : Quantity
            The order quantity.
        price : Price
            The order price.
        use_quote_for_inverse : bool
            If inverse instrument calculations use quote currency (instead of base).

        Returns
        -------
        Money

        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")

        cdef Currency quote_currency = instrument.quote_currency
        cdef Currency base_currency = instrument.get_base_currency() or instrument.quote_currency

        # Determine notional value
        if side == OrderSide.BUY:
            notional = instrument.notional_value(
                quantity=quantity,
                price=price,
                use_quote_for_inverse=use_quote_for_inverse,
            ).as_decimal()
        elif side == OrderSide.SELL:
            if base_currency is not None:
                notional = quantity.as_decimal()
            else:
                return None  # No balance to lock
        else:  # pragma: no cover (design-time error)
            raise RuntimeError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)

        # Handle inverse
        if instrument.is_inverse and not use_quote_for_inverse:
            return Money(notional, base_currency)

        if side == OrderSide.BUY:
            return Money(notional, quote_currency)
        elif side == OrderSide.SELL:
            return Money(notional, base_currency)
        else:  # pragma: no cover (design-time error)
            raise RuntimeError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)

    cpdef list calculate_pnls(
        self,
        Instrument instrument,
        OrderFilled fill,
        Position position: Position | None = None,
    ):
        """
        Return the calculated PnL.

        The calculation does not include any commissions.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        fill : OrderFilled
            The fill for the calculation.
        position : Position, optional
            The position for the calculation (can be None).

        Returns
        -------
        list[Money]

        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(fill, "fill")

        cdef dict pnls = {}  # type: dict[Currency, Money]

        cdef Currency quote_currency = instrument.quote_currency
        cdef Currency base_currency = instrument.get_base_currency()

        fill_px = fill.last_px.as_decimal()
        fill_qty = fill.last_qty.as_decimal()
        last_qty = fill_qty

        if position is not None and position.quantity._mem.raw != 0 and position.entry != fill.order_side:
            # Only book open quantity towards realized PnL
            fill_qty = min(fill_qty, position.quantity.as_decimal())

        # Below we are using the original `last_qty` to adjust the base currency,
        # this is to avoid a desync in account balance vs filled quantities later.
        if fill.order_side == OrderSide.BUY:
            if base_currency and not self.base_currency:
                pnls[base_currency] = Money(last_qty, base_currency)
            pnls[quote_currency] = Money(-(fill_px * fill_qty), quote_currency)
        elif fill.order_side == OrderSide.SELL:
            if base_currency and not self.base_currency:
                pnls[base_currency] = Money(-last_qty, base_currency)
            pnls[quote_currency] = Money(fill_px * fill_qty, quote_currency)
        else:  # pragma: no cover (design-time error)
            raise RuntimeError(f"invalid `OrderSide`, was {fill.order_side}")  # pragma: no cover (design-time error)

        return list(pnls.values())

    cpdef Money balance_impact(
        self,
        Instrument instrument,
        Quantity quantity,
        Price price,
        OrderSide order_side,
    ):
        cdef Money notional = instrument.notional_value(quantity, price)
        if order_side == OrderSide.BUY:
            return Money.from_raw_c(-notional._mem.raw, notional.currency)
        elif order_side == OrderSide.SELL:
            return Money.from_raw_c(notional._mem.raw, notional.currency)
        else:  # pragma: no cover (design-time error)
            raise RuntimeError(f"invalid `OrderSide`, was {order_side}")  # pragma: no cover (design-time error)

</document_content>
</document>
<document index="1909">
<source>nautilus_trader/accounting/accounts/margin.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.accounting.margin_models cimport LeveragedMarginModel
from nautilus_trader.accounting.margin_models cimport MarginModel
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.model.events.account cimport AccountState
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport AccountBalance
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport MarginBalance
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.position cimport Position


cdef class MarginAccount(Account):
    """
    Provides a margin account.

    Parameters
    ----------
    event : AccountState
        The initial account state event.
    calculate_account_state : bool, optional
        If the account state should be calculated from order fills.

    Raises
    ------
    ValueError
        If `event.account_type` is not equal to ``MARGIN``.
    """

    def __init__(
        self,
        AccountState event,
        bint calculate_account_state = False,
    ):
        Condition.not_none(event, "event")
        Condition.equal(event.account_type, AccountType.MARGIN, "event.account_type", "account_type")

        super().__init__(event, calculate_account_state)

        # Default to leveraged margin model for backward compatibility
        self._margin_model = LeveragedMarginModel()
        self.default_leverage = Decimal(1)
        self._leverages: dict[InstrumentId, Decimal] = {}
        self._margins: dict[InstrumentId, MarginBalance] = {m.instrument_id: m for m in event.margins}

    @staticmethod
    cdef dict to_dict_c(MarginAccount obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "MarginAccount",
            "calculate_account_state": obj.calculate_account_state,
            "events": [AccountState.to_dict_c(event) for event in obj.events_c()]
        }

    @staticmethod
    def to_dict(MarginAccount obj):
        return MarginAccount.to_dict_c(obj)

    @staticmethod
    cdef MarginAccount from_dict_c(dict values):
        Condition.not_none(values, "values")
        calculate_account_state = values["calculate_account_state"]
        events = values["events"]

        if len(events) == 0:
            return None

        init_event = events[0]
        account = MarginAccount(
            event=AccountState.from_dict_c(init_event),
            calculate_account_state=calculate_account_state
        )

        other_events = events[1:]

        for event in other_events:
            account.apply(AccountState.from_dict_c(event))

        return account

    @staticmethod
    def from_dict(dict values):
        return MarginAccount.from_dict_c(values)


# -- QUERIES --------------------------------------------------------------------------------------

    cpdef dict margins(self):
        """
        Return the initial (order) margins for the account.

        Returns
        -------
        dict[InstrumentId, Money]

        """
        return self._margins.copy()

    cpdef dict margins_init(self):
        """
        Return the initial (order) margins for the account.

        Returns
        -------
        dict[InstrumentId, Money]

        """
        return {k: v.initial for k, v in self._margins.items()}

    cpdef dict margins_maint(self):
        """
        Return the maintenance (position) margins for the account.

        Returns
        -------
        dict[InstrumentId, Money]

        """
        return {k: v.maintenance for k, v in self._margins.items()}

    cpdef dict leverages(self):
        """
        Return the account leverages.

        Returns
        -------
        dict[InstrumentId, Decimal]

        """
        return self._leverages.copy()

    cpdef object leverage(self, InstrumentId instrument_id):
        """
        Return the leverage for the given instrument (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the leverage.

        Returns
        -------
        Decimal or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._leverages.get(instrument_id)

    cpdef Money margin_init(self, InstrumentId instrument_id):
        """
        Return the current initial (order) margin.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the query.

        Returns
        -------
        Money or ``None``

        Warnings
        --------
        Returns ``None`` if there is no applicable information for the query,
        rather than `Money` of zero amount.

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef MarginBalance margin = self._margins.get(instrument_id)
        return None if margin is None else margin.initial

    cpdef Money margin_maint(self, InstrumentId instrument_id):
        """
        Return the current maintenance (position) margin.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the query.

        Returns
        -------
        Money or ``None``

        Warnings
        --------
        Returns ``None`` if there is no applicable information for the query,
        rather than `Money` of zero amount.

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef MarginBalance margin = self._margins.get(instrument_id)
        return None if margin is None else margin.maintenance

    cpdef MarginBalance margin(self, InstrumentId instrument_id):
        """
        Return the current margin balance.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the query.

        Returns
        -------
        MarginBalance or ``None``

        Warnings
        --------
        Returns ``None`` if there is no applicable information for the query,
        rather than `MarginBalance` with zero amounts.

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._margins.get(instrument_id)

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void set_default_leverage(self, leverage: Decimal):
        """
        Set the default leverage for the account (if not specified by instrument).

        Parameters
        ----------
        leverage : Decimal
            The default leverage value

        Returns
        -------
        TypeError
            If leverage is not of type `Decimal`.
        ValueError
            If leverage is not >= 1.

        """
        Condition.type(leverage, Decimal, "leverage")
        Condition.is_true(leverage >= 1, "leverage was not >= 1")

        self.default_leverage = leverage

    cpdef void set_leverage(self, InstrumentId instrument_id, leverage: Decimal):
        """
        Set the leverage for the given instrument.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the leverage.
        leverage : Decimal
            The leverage value

        Returns
        -------
        TypeError
            If leverage is not of type `Decimal`.
        ValueError
            If leverage is not >= 1.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.type(leverage, Decimal, "leverage")
        Condition.is_true(leverage >= 1, "leverage was not >= 1")

        self._leverages[instrument_id] = leverage

    cpdef void set_margin_model(self, MarginModel margin_model):
        """
        Set the margin calculation model for the account.

        Parameters
        ----------
        margin_model : MarginModel
            The margin model to use for calculations.

        """
        Condition.not_none(margin_model, "margin_model")

        self._margin_model = margin_model

    cpdef void update_margin_init(self, InstrumentId instrument_id, Money margin_init):
        """
        Update the initial (order) margin.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the update.
        margin_init : Money
            The current initial (order) margin for the instrument.

        Raises
        ------
        ValueError
            If `margin_init` is negative (< 0).

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.not_none(margin_init, "margin_init")

        cdef MarginBalance margin = self._margins.get(instrument_id)
        if margin is None:
            self._margins[instrument_id] = MarginBalance(
                initial=margin_init,
                maintenance=Money(0, margin_init.currency),
                instrument_id=instrument_id,
            )
        else:
            margin.initial = margin_init

        self._recalculate_balance(margin_init.currency)

    cpdef void update_margin_maint(self, InstrumentId instrument_id, Money margin_maint):
        """
        Update the maintenance (position) margin.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the update.
        margin_maint : Money
            The current maintenance (position) margin for the instrument.

        Raises
        ------
        ValueError
            If `margin_maint` is negative (< 0).

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.not_none(margin_maint, "margin_maint")

        cdef MarginBalance margin = self._margins.get(instrument_id)
        if margin is None:
            self._margins[instrument_id] = MarginBalance(
                initial=Money(0, margin_maint.currency),
                maintenance=margin_maint,
                instrument_id=instrument_id,
            )
        else:
            margin.maintenance = margin_maint

        self._recalculate_balance(margin_maint.currency)

    cpdef void update_margin(self, MarginBalance margin):
        """
        Update the margin balance.

        Parameters
        ----------
        margin : MarginBalance

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(margin, "margin")

        self._margins[margin.instrument_id] = margin
        self._recalculate_balance(margin.currency)

    cpdef void clear_margin_init(self, InstrumentId instrument_id):
        """
        Clear the initial (order) margins for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the initial margin to clear.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef MarginBalance margin = self._margins.get(instrument_id)
        if margin is not None:
            if margin.maintenance._mem.raw == 0:
                self._margins.pop(instrument_id)
            else:
                margin.initial = Money(0, margin.currency)

            self._recalculate_balance(margin.currency)

    cpdef void clear_margin_maint(self, InstrumentId instrument_id):
        """
        Clear the maintenance (position) margins for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the maintenance margin to clear.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef MarginBalance margin = self._margins.get(instrument_id)
        if margin is not None:
            if margin.initial._mem.raw == 0:
                self._margins.pop(instrument_id)
            else:
                margin.maintenance = Money(0, margin.currency)

            self._recalculate_balance(margin.currency)

    cpdef void clear_margin(self, InstrumentId instrument_id):
        """
        Clear the maintenance (position) margins for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the maintenance margin to clear.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef MarginBalance margin = self._margins.pop(instrument_id, None)
        if margin is not None:
            self._recalculate_balance(margin.currency)

# -- CALCULATIONS ---------------------------------------------------------------------------------

    cpdef bint is_unleveraged(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")
        return self._leverages.get(instrument_id, self.default_leverage) == 1

    cdef void _recalculate_balance(self, Currency currency):
        cdef AccountBalance current_balance = self._balances.get(currency)
        if current_balance is None:
            raise RuntimeError("cannot recalculate balance when no current balance")

        total_margin = Decimal()

        cdef MarginBalance margin
        for margin in self._margins.values():
            if margin.currency != currency:
                continue
            total_margin += margin.initial
            total_margin += margin.maintenance

        # Calculate the free balance ensuring that it is never negative.
        #
        # In some edge-cases (for example, when an adapter temporarily reports
        # an inflated margin amount due to latency or rounding differences)
        # the calculated ``total_margin`` can exceed the ``total`` balance. This
        # would normally propagate to the ``AccountBalance`` constructor where
        # the internal correctness checks would raise – ultimately causing the
        # entire application to terminate. That fail-fast behaviour is useful
        # during development, but in live trading we prefer to degrade
        # gracefully whilst ensuring that balances remain internally
        # consistent.
        #
        # Therefore we clamp the margin amount to the total balance whenever it
        # would otherwise exceed it. The resulting free balance is then zero –
        # indicating that no funds are currently available for trading.
        total = current_balance.total.as_decimal()
        total_free = total - total_margin

        if total_free < 0:
            # Clamp the margin balance. We intentionally do not raise as this
            # condition can occur transiently when the venue and client state
            # are out-of-sync.
            total_margin = total
            total_free = Decimal(0)

        cdef AccountBalance new_balance = AccountBalance(
            current_balance.total,
            Money(total_margin, currency),
            Money(total_free, currency),
        )

        self._balances[currency] = new_balance

    cpdef Money calculate_commission(
        self,
        Instrument instrument,
        Quantity last_qty,
        Price last_px,
        LiquiditySide liquidity_side,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the commission generated from a transaction with the given
        parameters.

        Result will be in quote currency for standard instruments, or base
        currency for inverse instruments.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        last_qty : Quantity
            The transaction quantity.
        last_px : Price
            The transaction price.
        liquidity_side : LiquiditySide {``MAKER``, ``TAKER``}
            The liquidity side for the transaction.
        use_quote_for_inverse : bool
            If inverse instrument calculations use quote currency (instead of base).

        Returns
        -------
        Money

        Raises
        ------
        ValueError
            If `liquidity_side` is ``NO_LIQUIDITY_SIDE``.

        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(last_qty, "last_qty")
        Condition.type(last_px, (Decimal, Price), "last_px")
        Condition.not_equal(liquidity_side, LiquiditySide.NO_LIQUIDITY_SIDE, "liquidity_side", "NO_LIQUIDITY_SIDE")

        notional = instrument.notional_value(
            quantity=last_qty,
            price=last_px,
            use_quote_for_inverse=use_quote_for_inverse,
        ).as_decimal()

        if liquidity_side == LiquiditySide.MAKER:
            commission = notional * instrument.maker_fee
        elif liquidity_side == LiquiditySide.TAKER:
            commission = notional * instrument.taker_fee
        else:
            raise ValueError(
                f"invalid `LiquiditySide`, was {liquidity_side_to_str(liquidity_side)}"
            )

        if instrument.is_inverse and not use_quote_for_inverse:
            return Money(commission, instrument.base_currency)
        else:
            return Money(commission, instrument.quote_currency)

    cpdef Money calculate_margin_init(
        self,
        Instrument instrument,
        Quantity quantity,
        Price price,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the initial (order) margin.

        Result will be in quote currency for standard instruments, or base
        currency for inverse instruments.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        quantity : Quantity
            The order quantity.
        price : Price
            The order price.
        use_quote_for_inverse : bool
            If inverse instrument calculations use quote currency (instead of base).

        Returns
        -------
        Money

        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")

        leverage = self._leverages.get(instrument.id, Decimal(0))
        if leverage == 0:
            leverage = self.default_leverage
            self._leverages[instrument.id] = leverage

        return self._margin_model.calculate_margin_init(
            instrument=instrument,
            quantity=quantity,
            price=price,
            leverage=leverage,
            use_quote_for_inverse=use_quote_for_inverse,
        )

    cpdef Money calculate_margin_maint(
        self,
        Instrument instrument,
        PositionSide side,
        Quantity quantity,
        Price price,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the maintenance (position) margin.

        Result will be in quote currency for standard instruments, or base
        currency for inverse instruments.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        side : PositionSide {``LONG``, ``SHORT``}
            The currency position side.
        quantity : Quantity
            The currency position quantity.
        price : Price
            The positions current price.
        use_quote_for_inverse : bool
            If inverse instrument calculations use quote currency (instead of base).

        Returns
        -------
        Money

        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(quantity, "quantity")

        leverage = self._leverages.get(instrument.id, Decimal(0))
        if leverage == 0:
            leverage = self.default_leverage
            self._leverages[instrument.id] = leverage

        return self._margin_model.calculate_margin_maint(
            instrument=instrument,
            side=side,
            quantity=quantity,
            price=price,
            leverage=leverage,
            use_quote_for_inverse=use_quote_for_inverse,
        )

    cpdef list calculate_pnls(
        self,
        Instrument instrument,
        OrderFilled fill,
        Position position: Position | None = None,
    ):
        """
        Return the calculated PnL.

        The calculation does not include any commissions.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        fill : OrderFilled
            The fill for the calculation.
        position : Position, optional
            The position for the calculation.

        Returns
        -------
        list[Money]

        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(fill, "fill")

        cdef dict pnls = {}  # type: dict[Currency, Money]

        cdef:
            Money pnl
            Quantity pnl_quantity

        if position is not None and position.quantity._mem.raw != 0 and position.entry != fill.order_side:
            # Calculate and add PnL using the minimum of fill quantity and position quantity
            # to avoid double-limiting that occurs in position._calculate_pnl()
            pnl_quantity = Quantity(
                min(fill.last_qty.as_f64_c(), position.quantity.as_f64_c()),
                fill.last_qty.precision,
            )
            pnl = position.calculate_pnl(
                avg_px_open=position.avg_px_open,
                avg_px_close=fill.last_px.as_f64_c(),
                quantity=pnl_quantity,
            )
            pnls[pnl.currency] = pnl

        return list(pnls.values())

    cpdef Money balance_impact(
        self,
        Instrument instrument,
        Quantity quantity,
        Price price,
        OrderSide order_side,
    ):
        leverage = self._leverages.get(instrument.id, Decimal(0))
        if leverage == 0:
            leverage = self.default_leverage
            self._leverages[instrument.id] = leverage

        margin_impact = Decimal(1) / leverage
        cdef Money notional = instrument.notional_value(quantity, price)

        if order_side == OrderSide.BUY:
            return Money(-notional.as_decimal() * margin_impact, notional.currency)
        elif order_side == OrderSide.SELL:
            return Money(notional.as_decimal() * margin_impact, notional.currency)
        else:  # pragma: no cover (design-time error)
            raise RuntimeError(f"invalid `OrderSide`, was {order_side}")  # pragma: no cover (design-time error)

</document_content>
</document>
<document index="1911">
<source>nautilus_trader/accounting/calculators.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal
from itertools import permutations

import pandas as pd

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.model.functions cimport price_type_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.objects cimport Currency


cdef class RolloverInterestCalculator:
    """
    Provides rollover interest rate calculations.

    If rate_data_csv_path is empty then will default to the included short-term
    interest rate data csv (data since 1956).

    Parameters
    ----------
    data : str
        The short term interest rate data.
    """

    def __init__(self, data not None: pd.DataFrame):
        self._rate_data = {
            "AUD": data.loc[data["LOCATION"] == "AUS"],
            "CAD": data.loc[data["LOCATION"] == "CAN"],
            "CHF": data.loc[data["LOCATION"] == "CHE"],
            "EUR": data.loc[data["LOCATION"] == "EA19"],
            "USD": data.loc[data["LOCATION"] == "USA"],
            "JPY": data.loc[data["LOCATION"] == "JPN"],
            "NZD": data.loc[data["LOCATION"] == "NZL"],
            "GBP": data.loc[data["LOCATION"] == "GBR"],
            "RUB": data.loc[data["LOCATION"] == "RUS"],
            "NOK": data.loc[data["LOCATION"] == "NOR"],
            "CNY": data.loc[data["LOCATION"] == "CHN"],
            "CNH": data.loc[data["LOCATION"] == "CHN"],
            "MXN": data.loc[data["LOCATION"] == "MEX"],
            "ZAR": data.loc[data["LOCATION"] == "ZAF"],
        }

    cpdef object get_rate_data(self):
        """
        Return the short-term interest rate dataframe.

        Returns
        -------
        pd.DataFrame

        """
        return self._rate_data

    cpdef object calc_overnight_rate(self, InstrumentId instrument_id, date date):
        """
        Return the rollover interest rate between the given base currency and quote currency.

        Parameters
        ----------
        instrument_id : InstrumentId
            The forex instrument ID for the calculation.
        date : date
            The date for the overnight rate.

        Returns
        -------
        Decimal

        Raises
        ------
        ValueError
            If `instrument_id.symbol` length is not in range [6, 7].

        Notes
        -----
        1% = 0.01 bp

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.not_none(date, "timestamp")
        Condition.in_range_int(len(instrument_id.symbol.value), 6, 7, "len(instrument_id)")

        cdef str symbol = instrument_id.symbol.value
        cdef str base_currency = symbol[:3]
        cdef str quote_currency = symbol[-3:]
        cdef str time_monthly = f"{date.year}-{str(date.month).zfill(2)}"
        cdef str time_quarter = f"{date.year}-Q{str(int(((date.month - 1) // 3) + 1)).zfill(2)}"

        base_data = self._rate_data[base_currency].loc[self._rate_data[base_currency]['TIME'] == time_monthly]
        if base_data.empty:
            base_data = self._rate_data[base_currency].loc[self._rate_data[base_currency]['TIME'] == time_quarter]

        quote_data = self._rate_data[quote_currency].loc[self._rate_data[quote_currency]['TIME'] == time_monthly]
        if quote_data.empty:
            quote_data = self._rate_data[quote_currency].loc[self._rate_data[quote_currency]['TIME'] == time_quarter]

        if base_data.empty and quote_data.empty:
            raise RuntimeError(f"cannot find rollover interest rate for {instrument_id} on {date}")  # pragma: no cover

        # Extract scalar values to avoid FutureWarning from casting single-element Series
        cdef double base_val = <double>base_data['Value'].iloc[0]
        cdef double quote_val = <double>quote_data['Value'].iloc[0]
        cdef double rate = ((base_val - quote_val) / 365.0) / 100.0
        return Decimal(rate)

</document_content>
</document>
<document index="1914">
<source>nautilus_trader/accounting/factory.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.accounting.accounts.betting cimport BettingAccount
from nautilus_trader.accounting.accounts.cash cimport CashAccount
from nautilus_trader.accounting.accounts.margin cimport MarginAccount
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AccountType


cdef dict[str, type] _ISSUER_ACCOUNT_TYPE = {}
cdef dict[str, bint] _ISSUER_ACCOUNT_CALCULATED = {}
cdef dict[str, bint] _ISSUER_CASH_BORROWING = {}


cdef class AccountFactory:
    """
    Provides a factory for creating different account types.
    """

    @staticmethod
    def register_account_type(str issuer, type account_cls):
        """
        Register the given custom account type for the issuer.

        Parameters
        ----------
        issuer : str
            The issuer for the account.
        account_cls : type
            The custom account type.

        Raises
        ------
        KeyError
            If `issuer` has already registered a custom account type.

        """
        Condition.not_none(issuer, "issuer")
        Condition.not_none(account_cls, "account_cls")
        Condition.not_in(issuer, _ISSUER_ACCOUNT_TYPE, "issuer", "_ISSUER_ACCOUNT_TYPE")

        _ISSUER_ACCOUNT_TYPE[issuer] = account_cls

    @staticmethod
    def register_calculated_account(str issuer):
        """
        Register for account state of the given issuer to be calculated from
        order fills.

        Parameters
        ----------
        issuer : str
            The issuer for the account.

        Raises
        ------
        KeyError
            If an issuer has already been registered for the `issuer`.

        """
        Condition.not_none(issuer, "issuer")
        Condition.not_in(issuer, _ISSUER_ACCOUNT_TYPE, "issuer", "_ISSUER_ACCOUNT_TYPE")

        _ISSUER_ACCOUNT_CALCULATED[issuer] = True

    @staticmethod
    def register_cash_borrowing(str issuer):
        """
        Register for cash accounts of the given issuer to allow borrowing
        (negative balances).

        Parameters
        ----------
        issuer : str
            The issuer for the account.

        Raises
        ------
        KeyError
            If cash borrowing has already been registered for the `issuer`.

        """
        Condition.not_none(issuer, "issuer")
        Condition.not_in(issuer, _ISSUER_CASH_BORROWING, "issuer", "_ISSUER_CASH_BORROWING")

        _ISSUER_CASH_BORROWING[issuer] = True

    @staticmethod
    def deregister_cash_borrowing(str issuer):
        """
        Deregister cash borrowing for the given issuer.

        This is primarily intended for test cleanup to prevent global state leakage.

        Parameters
        ----------
        issuer : str
            The issuer to deregister.

        """
        Condition.not_none(issuer, "issuer")

        _ISSUER_CASH_BORROWING.pop(issuer, None)

    @staticmethod
    cdef Account create_c(AccountState event):
        Condition.not_none(event, "event")

        # Parse account issuer
        cdef str issuer = event.account_id.get_issuer()

        # Determine account settings
        cdef type account_cls = _ISSUER_ACCOUNT_TYPE.get(issuer)
        cdef bint calculated = _ISSUER_ACCOUNT_CALCULATED.get(issuer, False)
        cdef bint allow_borrowing = _ISSUER_CASH_BORROWING.get(issuer, False)

        # Create account
        if account_cls is not None:
            return account_cls(event, calculated)
        if event.account_type == AccountType.CASH:
            return CashAccount(event, calculated, allow_borrowing)
        elif event.account_type == AccountType.MARGIN:
            return MarginAccount(event, calculated)
        elif event.account_type == AccountType.BETTING:
            return BettingAccount(event, calculated)
        else:
            raise RuntimeError("invalid `AccountType`")  # pragma: no cover (design-time error)

    @staticmethod
    def create(AccountState event) -> Account:
        """
        Create an account based on the events account type.

        Parameters
        ----------
        event : AccountState
            The account state event for the creation.

        Returns
        -------
        Account

        """
        return AccountFactory.create_c(event)

</document_content>
</document>
<document index="1916">
<source>nautilus_trader/accounting/manager.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.accounting.accounts.cash cimport CashAccount
from nautilus_trader.accounting.accounts.margin cimport MarginAccount
from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Logger
from nautilus_trader.common.component cimport is_logging_initialized
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.account cimport AccountState
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport AccountBalance
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.position cimport Position


cdef class AccountsManager:
    """
    Provides account management functionality.

    Parameters
    ----------
    cache : CacheFacade
        The read-only cache for the manager.
    logger : Logger
        The logger for the manager.
    clock : Clock
        The clock for the manager.
    """

    def __init__(
        self,
        CacheFacade cache not None,
        Logger logger not None,
        Clock clock not None,
    ) -> None:
        self._clock = clock
        self._log = logger
        self._cache = cache

    cpdef AccountState generate_account_state(self, Account account, uint64_t ts_event):
        """
        Generate a new account state event for the given `account`.

        Parameters
        ----------
        account : Account
            The account for the state event.
        ts_event : uint64_t
            The UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        AccountState

        """
        return AccountState(
            account_id=account.id,
            account_type=account.type,
            base_currency=account.base_currency,
            reported=False,
            balances=list(account.balances().values()),
            margins=list(account.margins().values()) if account.is_margin_account else [],
            info={},
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

    cpdef void update_balances(
        self,
        Account account,
        Instrument instrument,
        OrderFilled fill,
    ):
        """
        Update the account balances based on the `fill` event.

        Parameters
        ----------
        account : Account
            The account to update.
        instrument : Instrument
            The instrument for the update.
        fill : OrderFilled
            The order filled event for the update

        Raises
        ------
        AccountBalanceNegative
            If account type is ``CASH`` and a balance becomes negative.

        """
        Condition.not_none(account, "account")
        Condition.not_none(instrument, "instrument")
        Condition.not_none(fill, "fill")

        # Determine any position
        cdef PositionId position_id = fill.position_id
        if position_id is None:
            # Check for open positions
            positions_open = self._cache.positions_open(
                venue=None,  # Faster query filtering
                instrument_id=fill.instrument_id,
            )
            if positions_open:
                position_id = positions_open[0].id

        # Determine any position
        cdef Position position = self._cache.position(position_id)
        # *** position could still be None here ***

        cdef list pnls = account.calculate_pnls(instrument, fill, position)
        if is_logging_initialized():
            self._log.debug(f"Calculated PnLs: {pnls}")

        # Calculate final PnL including commissions
        cdef Money pnl
        if account.base_currency is not None:
            self._update_balance_single_currency(
                account=account,
                fill=fill,
                pnl=Money(0, account.base_currency) if not pnls else pnls[0],
            )
        else:
            self._update_balance_multi_currency(
                account=account,
                fill=fill,
                pnls=pnls,
            )

    cpdef bint update_orders(
        self,
        Account account,
        Instrument instrument,
        list orders_open,
        uint64_t ts_event,
    ):
        """
        Update the account states based on the given orders.

        Parameters
        ----------
        account : MarginAccount
            The account to update.
        instrument : Instrument
            The instrument for the update.
        orders_open : list[Order]
            The open orders for the update.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the account event occurred.

        Returns
        -------
        bool
            The result of the account operation.

        """
        Condition.not_none(account, "account")
        Condition.not_none(instrument, "instrument")
        Condition.not_none(orders_open, "orders_open")

        if account.is_cash_account:
            return self._update_balance_locked(
                account,
                instrument,
                orders_open,
                ts_event,
            )
        elif account.is_margin_account:
            return self._update_margin_init(
                account,
                instrument,
                orders_open,
                ts_event,
            )
        else:
            raise RuntimeError("invalid `AccountType`")  # pragma: no cover (design-time error)

    cdef bint _update_balance_locked(
        self,
        CashAccount account,
        Instrument instrument,
        list orders_open,
        uint64_t ts_event,
    ):
        if not orders_open:
            account.clear_balance_locked(instrument.id)

        cdef dict[Currency, Money] total_locked = {}
        base_xrate = Decimal(0)

        cdef:
            Order order
            Currency currency = None
            Money balance_locked
            Money cumulative_locked
        for order in orders_open:
            assert order.instrument_id == instrument.id

            if not order.is_open_c() or order.is_reduce_only or (not order.has_price_c() and not order.has_trigger_price_c()):
                # Does not contribute to locked balance
                continue

            balance_locked = account.calculate_balance_locked(
                instrument,
                order.side,
                order.quantity,
                order.price if order.has_price_c() else order.trigger_price,
            )

            currency = balance_locked.currency
            locked_amount = balance_locked.as_decimal()

            if account.base_currency is not None:
                if base_xrate == 0:
                    # Cache base xrate on first pass only
                    base_xrate = self._calculate_xrate_to_base(
                        instrument=instrument,
                        account=account,
                        side=order.side,
                    )

                    if base_xrate == 0:
                        self._log.debug(
                            f"Cannot calculate balance locked: "
                            f"insufficient data for "
                            f"{instrument.get_cost_currency()}/{account.base_currency}"
                        )
                        return False

                # Always use base currency when converting
                currency = account.base_currency
                balance_locked = Money(locked_amount * base_xrate, currency)

            cumulative_locked = total_locked.get(currency)

            if cumulative_locked is not None:
                cumulative_locked.add_assign(balance_locked)
            else:
                total_locked[currency] = balance_locked

        # No contributing orders (reduce-only/unpriced): clear any existing lock
        if len(total_locked) == 0:
            account.clear_balance_locked(instrument.id)
            return True

        for currency, balance_locked in total_locked.items():
            account.update_balance_locked(instrument.id, balance_locked)
            self._log.debug(f"{instrument.id} balance_locked={balance_locked.to_formatted_str()}")

        return True

    cdef bint _update_margin_init(
        self,
        MarginAccount account,
        Instrument instrument,
        list orders_open,
        uint64_t ts_event,
    ):
        total_margin_init = Decimal(0)
        base_xrate = Decimal(0)

        cdef Currency currency = instrument.get_cost_currency()

        cdef:
            Order order
        for order in orders_open:
            assert order.instrument_id == instrument.id, f"order not for instrument {instrument}"

            if not order.is_open_c() or order.is_reduce_only or (not order.has_price_c() and not order.has_trigger_price_c()):
                # Does not contribute to initial margin
                continue

            # Calculate initial margin
            margin_init = account.calculate_margin_init(
                instrument,
                order.quantity,
                order.price if order.has_price_c() else order.trigger_price,
            ).as_decimal()

            if account.base_currency is not None:
                if base_xrate == 0:
                    # Cache base currency and xrate
                    currency = account.base_currency
                    base_xrate = self._calculate_xrate_to_base(
                        instrument=instrument,
                        account=account,
                        side=order.side,
                    )

                    if base_xrate == 0:
                        self._log.debug(
                            f"Cannot calculate initial (order) margin: "
                            f"insufficient data for "
                            f"{instrument.get_cost_currency()}/{account.base_currency}"
                        )
                        return False

                # Apply base xrate
                margin_init = round(margin_init * base_xrate, currency.get_precision())

            # Increment total initial margin
            total_margin_init += margin_init

        cdef Money margin_init_money = Money(total_margin_init, currency)
        if total_margin_init == 0:
            account.clear_margin_init(instrument.id)
        else:
            account.update_margin_init(instrument.id, margin_init_money)

        self._log.info(f"{instrument.id} margin_init={margin_init_money.to_formatted_str()}")

        return True

    cpdef bint update_positions(
        self,
        MarginAccount account,
        Instrument instrument,
        list positions_open,
        uint64_t ts_event,
    ):
        """
        Update the maintenance (position) margin.

        Will return ``None`` if operation fails.

        Parameters
        ----------
        account : Account
            The account to update.
        instrument : Instrument
            The instrument for the update.
        positions_open : list[Position]
            The open positions for the update.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the account event occurred.

        Returns
        -------
        bool
            The result of the account operation.

        """
        Condition.not_none(account, "account")
        Condition.not_none(instrument, "instrument")
        Condition.not_none(positions_open, "positions_open")

        total_margin_maint = Decimal(0)
        base_xrate = Decimal(0)

        cdef Currency currency = instrument.get_cost_currency()

        cdef Position position
        for position in positions_open:
            assert position.instrument_id == instrument.id

            if not position.is_open_c():
                # Does not contribute to maintenance margin
                continue

            # Calculate margin
            margin_maint = account.calculate_margin_maint(
                instrument,
                position.side,
                position.quantity,
                instrument.make_price(position.avg_px_open),
            ).as_decimal()

            if account.base_currency is not None:
                if base_xrate == 0:
                    # Cache base currency and xrate
                    currency = account.base_currency
                    base_xrate = self._calculate_xrate_to_base(
                        instrument=instrument,
                        account=account,
                        side=position.entry,
                    )

                    if base_xrate == 0:
                        self._log.debug(
                            f"Cannot calculate maintenance (position) margin: "
                            f"insufficient data for "
                            f"{instrument.get_cost_currency()}/{account.base_currency}"
                        )
                        return False

                # Apply base xrate
                margin_maint = round(margin_maint * base_xrate, currency.get_precision())

            # Increment total maintenance margin
            total_margin_maint += margin_maint

        cdef Money margin_maint_money = Money(total_margin_maint, currency)
        if total_margin_maint == 0:
            account.clear_margin_maint(instrument.id)
        else:
            account.update_margin_maint(instrument.id, margin_maint_money)

        self._log.info(f"{instrument.id} margin_maint={margin_maint_money.to_formatted_str()}")

        return True

    cdef bint _update_balance_single_currency(
        self,
        Account account,
        OrderFilled fill,
        Money pnl,
    ):
        cdef Money commission = fill.commission
        cdef list balances = []

        if commission.currency != account.base_currency:
            xrate = self._cache.get_xrate(
                venue=fill.instrument_id.venue,
                from_currency=fill.commission.currency,
                to_currency=account.base_currency,
                price_type=PriceType.BID if fill.order_side == OrderSide.SELL else PriceType.ASK,
            )
            if xrate is None:
                self._log.error(
                    f"Cannot calculate account state: "
                    f"insufficient data for "
                    f"{fill.commission.currency}/{account.base_currency}"
                )
                return False  # Cannot calculate

            # Convert to account base currency
            commission = Money(commission.as_f64_c() * xrate, account.base_currency)

        if pnl.currency != account.base_currency:
            xrate = self._cache.get_xrate(
                venue=fill.instrument_id.venue,
                from_currency=pnl.currency,
                to_currency=account.base_currency,
                price_type=PriceType.BID if fill.order_side == OrderSide.SELL else PriceType.ASK,
            )
            if xrate is None:
                self._log.error(
                    f"Cannot calculate account state: "
                    f"insufficient data for "
                    f"{pnl.currency}/{account.base_currency}"
                )
                return False  # Cannot calculate

            # Convert to account base currency
            pnl = Money(pnl.as_f64_c() * xrate, account.base_currency)

        pnl = pnl.sub(commission)
        if pnl._mem.raw == 0:
            return False  # Nothing to adjust

        cdef AccountBalance balance = account.balance()
        if balance is None:
            self._log.error(f"Cannot complete transaction: no balance for {pnl.currency}")
            return False

        cdef AccountBalance new_balance = AccountBalance(
            total=balance.total.add(pnl),
            locked=balance.locked,
            free=balance.free.add(pnl),
        )
        balances.append(new_balance)

        # Finally update balances and commission
        account.update_balances(balances)
        account.update_commissions(commission)

        return True

    cdef bint _update_balance_multi_currency(
        self,
        Account account,
        OrderFilled fill,
        list pnls,
    ):
        cdef list balances = []

        cdef Money commission = fill.commission
        cdef AccountBalance balance = None
        cdef AccountBalance new_balance = None
        cdef bint apply_commission = commission._mem.raw != 0

        cdef:
            Money pnl
            Money total
            Money free
        for pnl in pnls:
            if apply_commission and pnl.currency == commission.currency:
                # Deduct the commission from the realized PnL (the commission may also be negative)
                pnl = pnl.sub(commission)
                # Ensure we only apply commission once
                apply_commission = False

            if pnl._mem.raw == 0:
                continue  # No adjustment

            currency = pnl.currency
            balance = account.balance(currency)
            if balance is None:
                if pnl._mem.raw < 0:
                    self._log.error(
                        "Cannot complete transaction: "
                        f"no {pnl.currency} to deduct a {pnl.to_formatted_str()} realized PnL from"
                    )
                    return False
                new_balance = AccountBalance(
                    total=pnl,
                    locked=Money(0, pnl.currency),
                    free=pnl,
                )
            else:
                new_total = balance.total
                new_free = balance.free
                new_locked = balance.locked

                new_total = new_total.add(pnl)
                instrument = self._cache.instrument(fill._instrument_id)
                if (
                    pnl.is_positive()
                    or fill.order_type == OrderType.MARKET
                    or instrument.instrument_class in [InstrumentClass.SPORTS_BETTING]
                ):
                    new_free = new_free.add(pnl)
                else:
                    new_locked = new_locked.add(pnl)

                if apply_commission and pnl.currency == commission.currency:
                    new_total = new_total.sub(commission)
                    new_free = new_free.sub(commission)
                    # Ensure we only apply commission once
                    apply_commission = False

                # TODO: Until the platform can accurately track account equity and
                # cross-margin requirements this condition check is inaccurate and
                # causes issues in live trading with more complex margin requirements.
                # if new_free < 0:
                #     raise AccountMarginExceeded(
                #         balance=total.as_decimal(),
                #         margin=balance.locked.as_decimal(),
                #         currency=pnl.currency,
                #     )

                new_balance = AccountBalance(
                    total=new_total,
                    locked=new_locked,
                    free=new_free,
                )

            balances.append(new_balance)

        if apply_commission:
            # We still need to apply the commission
            currency = commission.currency
            balance = account.balance(commission.currency)
            if balance is None:
                if commission._mem.raw > 0:
                    self._log.error(
                        f"Cannot complete transaction: no {commission.currency} "
                        f"balance to deduct a {commission.to_formatted_str()} commission from"
                    )
                    return False
                balance = AccountBalance(
                    total=Money(0, commission.currency),
                    locked=Money(0, commission.currency),
                    free=Money(0, commission.currency),
                )
            commission_dec = commission.as_decimal()
            balance.total = Money(balance.total.as_decimal() - commission_dec, commission.currency)
            balance.free = Money(balance.free.as_decimal() - commission_dec, commission.currency)
            balances.append(balance)

        if not balances:
            return True  # No adjustment

        # Finally update balances and commissions
        account.update_balances(balances)
        account.update_commissions(commission)

        return True

    cdef object _calculate_xrate_to_base(
        self,
        Account account,
        Instrument instrument,
        OrderSide side,
    ):
        if account.base_currency is None:
            return Decimal(1)  # No conversion needed

        return Decimal(self._cache.get_xrate(
            venue=instrument.id.venue,
            from_currency=instrument.get_cost_currency(),
            to_currency=account.base_currency,
            price_type=PriceType.BID if side == OrderSide.BUY else PriceType.ASK,
        ) or 0.0)  # Retain original behavior of returning zero for now

</document_content>
</document>
<document index="1918">
<source>nautilus_trader/accounting/margin_models.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class MarginModel:
    """
    Abstract base class for margin calculation models.

    Different venues and instrument types may have varying approaches to
    calculating margin requirements. This abstraction allows for flexible
    margin calculation strategies.
    """

    cpdef Money calculate_margin_init(
        self,
        Instrument instrument,
        Quantity quantity,
        Price price,
        leverage: Decimal,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the initial (order) margin requirement.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        quantity : Quantity
            The order quantity.
        price : Price
            The order price.
        leverage : Decimal
            The account leverage for this instrument.
        use_quote_for_inverse : bool, default False
            If inverse instrument calculations use quote currency (instead of base).

        Returns
        -------
        Money
            The initial margin requirement.
        """
        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover

    cpdef Money calculate_margin_maint(
        self,
        Instrument instrument,
        PositionSide side,
        Quantity quantity,
        Price price,
        leverage: Decimal,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the maintenance (position) margin requirement.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the calculation.
        side : PositionSide
            The position side.
        quantity : Quantity
            The position quantity.
        price : Price
            The current price.
        leverage : Decimal
            The account leverage for this instrument.
        use_quote_for_inverse : bool, default False
            If inverse instrument calculations use quote currency (instead of base).

        Returns
        -------
        Money
            The maintenance margin requirement.
        """
        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover


cdef class StandardMarginModel(MarginModel):
    """
    Standard margin model that uses fixed percentages without leverage division.

    This model matches traditional broker behavior (e.g., Interactive Brokers)
    where margin requirements are fixed percentages of notional value regardless
    of account leverage. Leverage affects buying power but not margin requirements.

    Formula:
    - Initial Margin = notional_value * instrument.margin_init
    - Maintenance Margin = notional_value * instrument.margin_maint
    """

    cpdef Money calculate_margin_init(
        self,
        Instrument instrument,
        Quantity quantity,
        Price price,
        leverage: Decimal,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate initial margin using fixed percentage of notional value.
        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")

        notional = instrument.notional_value(
            quantity=quantity,
            price=price,
            use_quote_for_inverse=use_quote_for_inverse,
        ).as_decimal()

        margin = notional * instrument.margin_init

        if instrument.is_inverse and not use_quote_for_inverse:
            return Money(margin, instrument.base_currency)
        else:
            return Money(margin, instrument.quote_currency)

    cpdef Money calculate_margin_maint(
        self,
        Instrument instrument,
        PositionSide side,
        Quantity quantity,
        Price price,
        leverage: Decimal,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate maintenance margin using fixed percentage of notional value.
        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(quantity, "quantity")

        notional = instrument.notional_value(
            quantity=quantity,
            price=price,
            use_quote_for_inverse=use_quote_for_inverse,
        ).as_decimal()

        margin = notional * instrument.margin_maint

        if instrument.is_inverse and not use_quote_for_inverse:
            return Money(margin, instrument.base_currency)
        else:
            return Money(margin, instrument.quote_currency)


cdef class LeveragedMarginModel(MarginModel):
    """
    Leveraged margin model that divides margin requirements by leverage.

    This model represents the current Nautilus behavior and may be appropriate
    for certain crypto exchanges or specific trading scenarios where leverage
    directly reduces margin requirements.

    Formula:
    - Initial Margin = (notional_value / leverage) * instrument.margin_init
    - Maintenance Margin = (notional_value / leverage) * instrument.margin_maint
    """

    cpdef Money calculate_margin_init(
        self,
        Instrument instrument,
        Quantity quantity,
        Price price,
        leverage: Decimal,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate initial margin with leverage division.
        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")
        Condition.positive(leverage, "leverage")

        notional = instrument.notional_value(
            quantity=quantity,
            price=price,
            use_quote_for_inverse=use_quote_for_inverse,
        ).as_decimal()

        # Apply leverage division (current Nautilus behavior)
        adjusted_notional = notional / leverage
        margin = adjusted_notional * instrument.margin_init

        if instrument.is_inverse and not use_quote_for_inverse:
            return Money(margin, instrument.base_currency)
        else:
            return Money(margin, instrument.quote_currency)

    cpdef Money calculate_margin_maint(
        self,
        Instrument instrument,
        PositionSide side,
        Quantity quantity,
        Price price,
        leverage: Decimal,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate maintenance margin with leverage division.
        """
        Condition.not_none(instrument, "instrument")
        Condition.not_none(quantity, "quantity")
        Condition.positive(leverage, "leverage")

        notional = instrument.notional_value(
            quantity=quantity,
            price=price,
            use_quote_for_inverse=use_quote_for_inverse,
        ).as_decimal()

        # Apply leverage division (current Nautilus behavior)
        adjusted_notional = notional / leverage
        margin = adjusted_notional * instrument.margin_maint

        if instrument.is_inverse and not use_quote_for_inverse:
            return Money(margin, instrument.base_currency)
        else:
            return Money(margin, instrument.quote_currency)

</document_content>
</document>
<document index="1935">
<source>nautilus_trader/adapters/betfair/orderbook.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.adapters.betfair.common import BETFAIR_FLOAT_TO_PRICE
from nautilus_trader.adapters.betfair.constants import BETFAIR_PRICE_PRECISION
from nautilus_trader.adapters.betfair.constants import BETFAIR_QUANTITY_PRECISION
from nautilus_trader.core.rust.model import BookType

from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cpdef inline OrderBook create_betfair_order_book(InstrumentId instrument_id):
    return OrderBook(
        instrument_id,
        BookType.L2_MBP,
    )


cpdef Price betfair_float_to_price(double value):
    try:
        return BETFAIR_FLOAT_TO_PRICE[value]
    except KeyError:
        return Price(value, BETFAIR_PRICE_PRECISION)


cpdef Quantity betfair_float_to_quantity(double value):
    return Quantity(value, BETFAIR_QUANTITY_PRECISION)

</document_content>
</document>
<document index="2206">
<source>nautilus_trader/backtest/data_client.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
This module provides a data client for backtesting.
"""
from nautilus_trader.common.config import NautilusConfig
from nautilus_trader.core.uuid import UUID4

from nautilus_trader.backtest.models cimport SpreadQuoteAggregator
from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.data.client cimport DataClient
from nautilus_trader.data.client cimport MarketDataClient
from nautilus_trader.data.messages cimport RequestBars
from nautilus_trader.data.messages cimport RequestData
from nautilus_trader.data.messages cimport RequestInstrument
from nautilus_trader.data.messages cimport RequestInstruments
from nautilus_trader.data.messages cimport RequestOrderBookSnapshot
from nautilus_trader.data.messages cimport RequestQuoteTicks
from nautilus_trader.data.messages cimport RequestTradeTicks
from nautilus_trader.data.messages cimport SubscribeBars
from nautilus_trader.data.messages cimport SubscribeData
from nautilus_trader.data.messages cimport SubscribeFundingRates
from nautilus_trader.data.messages cimport SubscribeIndexPrices
from nautilus_trader.data.messages cimport SubscribeInstrument
from nautilus_trader.data.messages cimport SubscribeInstrumentClose
from nautilus_trader.data.messages cimport SubscribeInstruments
from nautilus_trader.data.messages cimport SubscribeInstrumentStatus
from nautilus_trader.data.messages cimport SubscribeMarkPrices
from nautilus_trader.data.messages cimport SubscribeOrderBook
from nautilus_trader.data.messages cimport SubscribeQuoteTicks
from nautilus_trader.data.messages cimport SubscribeTradeTicks
from nautilus_trader.data.messages cimport UnsubscribeBars
from nautilus_trader.data.messages cimport UnsubscribeData
from nautilus_trader.data.messages cimport UnsubscribeFundingRates
from nautilus_trader.data.messages cimport UnsubscribeIndexPrices
from nautilus_trader.data.messages cimport UnsubscribeInstrument
from nautilus_trader.data.messages cimport UnsubscribeInstrumentClose
from nautilus_trader.data.messages cimport UnsubscribeInstruments
from nautilus_trader.data.messages cimport UnsubscribeInstrumentStatus
from nautilus_trader.data.messages cimport UnsubscribeMarkPrices
from nautilus_trader.data.messages cimport UnsubscribeOrderBook
from nautilus_trader.data.messages cimport UnsubscribeQuoteTicks
from nautilus_trader.data.messages cimport UnsubscribeTradeTicks
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.option_spread cimport OptionSpread


cdef class BacktestDataClient(DataClient):
    """
    Provides an implementation of `DataClient` for backtesting.

    Parameters
    ----------
    client_id : ClientId
        The data client ID.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : Clock
        The clock for the client.
    config : NautilusConfig, optional
        The configuration for the instance.
    """

    def __init__(
        self,
        ClientId client_id not None,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
        config: NautilusConfig | None = None,
    ) -> None:
        super().__init__(
            client_id=client_id,
            venue=Venue(client_id.to_str()),
            msgbus=msgbus,
            cache=cache,
            clock=clock,
            config=config,
        )

        self.is_connected = False

    cpdef void _start(self):
        self._log.info(f"Connecting...")
        self.is_connected = True
        self._log.info(f"Connected")

    cpdef void _stop(self):
        self._log.info(f"Disconnecting...")
        self.is_connected = False
        self._log.info(f"Disconnected")

# -- SUBSCRIPTIONS --------------------------------------------------------------------------------

    cpdef void subscribe(self, SubscribeData command):
        Condition.not_none(command.data_type, "data_type")

        self._add_subscription(command.data_type)
        # Do nothing else for backtest

    cpdef void unsubscribe(self, UnsubscribeData command):
        Condition.not_none(command.data_type, "data_type")

        self._remove_subscription(command.data_type)
        # Do nothing else for backtest

# -- REQUESTS -------------------------------------------------------------------------------------

    cpdef void request(self, RequestData request):
        Condition.not_none(request.data_type, "data_type")
        # Do nothing else for backtest


cdef class BacktestMarketDataClient(MarketDataClient):
    """
    Provides an implementation of `MarketDataClient` for backtesting.

    Parameters
    ----------
    client_id : ClientId
        The data client ID.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : Clock
        The clock for the client.
    """

    def __init__(
        self,
        ClientId client_id not None,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
    ):
        super().__init__(
            client_id=client_id,
            venue=Venue(client_id.to_str()),
            msgbus=msgbus,
            cache=cache,
            clock=clock,
        )

        self.is_connected = False
        self._spread_quote_aggregators = {} # type: dict[InstrumentId, SpreadQuoteAggregator]

    cpdef void _start(self):
        self._log.info(f"Connecting...")
        self.is_connected = True
        self._log.info(f"Connected")

    cpdef void _stop(self):
        self._log.info(f"Disconnecting...")

        # Stop all spread quote aggregators
        if self._spread_quote_aggregators is not None:
            for aggregator in self._spread_quote_aggregators.values():
                aggregator.stop()

        self.is_connected = False
        self._log.info(f"Disconnected")

    cpdef void _reset(self):
        # Stop and clear all spread quote aggregators
        for aggregator in self._spread_quote_aggregators.values():
            aggregator.stop()

        self._spread_quote_aggregators.clear()

# -- SUBSCRIPTIONS --------------------------------------------------------------------------------

    cpdef void subscribe(self, SubscribeData command):
        Condition.not_none(command.data_type, "data_type")

        if command.instrument_id and not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for {command.data_type} data, "
                "No data has been loaded for this instrument",
            )
            return

        self._add_subscription(command.data_type)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void unsubscribe(self, UnsubscribeData command):
        Condition.not_none(command.data_type, "data_type")

        self._remove_subscription(command.data_type)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void subscribe_instruments(self, SubscribeInstruments command):
        cdef Instrument instrument

        for instrument in self._cache.instruments(Venue(self.id.value)):
            subscribe = SubscribeInstrument(
                instrument_id=instrument.id,
                client_id=command.client_id,
                venue=command.venue,
                command_id=command.id,
                ts_init=command.ts_init,
                params=command.params,
            )
            self.subscribe_instrument(subscribe)

        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void subscribe_instrument(self, SubscribeInstrument command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `Instrument` data",
            )
            return

        self._add_subscription_instrument(command.instrument_id)
        # Do nothing else for backtest

    cpdef void subscribe_order_book_deltas(self, SubscribeOrderBook command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `OrderBookDelta` data, "
                "no data has been loaded for this instrument",
            )
            return

        self._add_subscription_order_book_deltas(command.instrument_id)
        # Do nothing else for backtest

    cpdef void subscribe_order_book_snapshots(self, SubscribeOrderBook command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `OrderBook` data, "
                "no data has been loaded for this instrument.",
            )
            return

        self._add_subscription_order_book_snapshots(command.instrument_id)
        # Do nothing else for backtest

    cpdef void subscribe_order_book_depth(self, SubscribeOrderBook command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `OrderBookDepth10` data, "
                "No data has been loaded for this instrument",
            )
            return

        self._add_subscription_order_book_snapshots(command.instrument_id)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void subscribe_quote_ticks(self, SubscribeQuoteTicks command):
        Condition.not_none(command.instrument_id, "instrument_id")

        # Handle spread instruments
        if command.instrument_id.is_spread():
            self._start_spread_quote_aggregator(command)
            return

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `QuoteTick` data, "
                "No data has been loaded for this instrument",
            )
            return

        self._add_subscription_quote_ticks(command.instrument_id)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void subscribe_trade_ticks(self, SubscribeTradeTicks command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `TradeTick` data, "
                "No data has been loaded for this instrument",
            )
            return

        self._add_subscription_trade_ticks(command.instrument_id)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void subscribe_mark_prices(self, SubscribeMarkPrices command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `MarkPriceUpdate` data, "
                "No data has been loaded for this instrument",
            )
            return

        self._add_subscription_mark_prices(command.instrument_id)
        # Do nothing else for backtest

    cpdef void subscribe_index_prices(self, SubscribeIndexPrices command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `IndexPriceUpdate` data, "
                "No data has been loaded for this instrument",
            )
            return

        self._add_subscription_index_prices(command.instrument_id)
        # Do nothing else for backtest

    cpdef void subscribe_funding_rates(self, SubscribeFundingRates command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if not self._cache.instrument(command.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.instrument_id} to subscribe for `FundingRateUpdate` data, "
                "No data has been loaded for this instrument",
            )
            return

        self._add_subscription_funding_rates(command.instrument_id)
        # Do nothing else for backtest

    cpdef void subscribe_bars(self, SubscribeBars command):
        Condition.not_none(command.bar_type, "bar_type")

        if not self._cache.instrument(command.bar_type.instrument_id):
            self._log.error(
                f"Cannot find instrument {command.bar_type.instrument_id} to subscribe for `Bar` data, "
                "No data has been loaded for this instrument",
            )
            return

        self._add_subscription_bars(command.bar_type)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void subscribe_instrument_status(self, SubscribeInstrumentStatus command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._add_subscription_instrument_status(command.instrument_id)
        # Do nothing else for backtest

    cpdef void subscribe_instrument_close(self, SubscribeInstrumentClose command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._add_subscription_instrument_close(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_instruments(self, UnsubscribeInstruments command):
        self._subscriptions_instrument.clear()
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void unsubscribe_instrument(self, UnsubscribeInstrument command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_instrument(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_order_book_deltas(self, UnsubscribeOrderBook command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_order_book_deltas(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_order_book_snapshots(self, UnsubscribeOrderBook command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_order_book_snapshots(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_order_book_depth(self, UnsubscribeOrderBook command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_order_book_snapshots(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_quote_ticks(self, UnsubscribeQuoteTicks command):
        Condition.not_none(command.instrument_id, "instrument_id")

        # Handle spread instruments
        if command.instrument_id.is_spread():
            self._stop_spread_quote_aggregator(command)
            return

        self._remove_subscription_quote_ticks(command.instrument_id)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void unsubscribe_trade_ticks(self, UnsubscribeTradeTicks command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_trade_ticks(command.instrument_id)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void unsubscribe_mark_prices(self, UnsubscribeMarkPrices command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_mark_prices(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_index_prices(self, UnsubscribeIndexPrices command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_index_prices(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_funding_rates(self, UnsubscribeFundingRates command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_funding_rates(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_bars(self, UnsubscribeBars command):
        Condition.not_none(command.bar_type, "bar_type")

        self._remove_subscription_bars(command.bar_type)
        self._msgbus.send(endpoint="BacktestEngine.execute", msg=command)

    cpdef void unsubscribe_instrument_status(self, UnsubscribeInstrumentStatus command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_instrument_status(command.instrument_id)
        # Do nothing else for backtest

    cpdef void unsubscribe_instrument_close(self, UnsubscribeInstrumentClose command):
        Condition.not_none(command.instrument_id, "instrument_id")

        self._remove_subscription_instrument_close(command.instrument_id)
        # Do nothing else for backtest

# -- REQUESTS -------------------------------------------------------------------------------------

    cpdef void request_instrument(self, RequestInstrument request):
        cdef Instrument instrument = self._cache.instrument(request.instrument_id)

        if instrument is None:
            # Check if this is a spread instrument - we're already in backtest context
            if request.instrument_id.is_spread():
                # Create OptionSpread from component instruments
                instrument = self._create_option_spread_from_components(request.instrument_id)

                if instrument is not None:
                    self._cache.add_instrument(instrument)
                    self._log.info(f"Created OptionSpread instrument {request.instrument_id} from components")
                else:
                    self._log.error(f"Failed to create OptionSpread instrument {request.instrument_id} from components")
                    return
            else:
                self._log.error(f"Cannot find instrument for {request.instrument_id}")
                return

        self._handle_instrument(instrument, request.id, request.start, request.end, request.params)

    cdef Instrument _create_option_spread_from_components(self, InstrumentId spread_instrument_id):
        min_expiration_ns = 0

        try:
            # Parse component instruments from spread ID
            components = spread_instrument_id.to_list()

            if not components:
                self._log.error(f"No components found in spread instrument ID {spread_instrument_id}")
                return None

            # Get the first component instrument to use as template
            first_component_id = components[0][0]
            first_component = self._cache.instrument(first_component_id)

            if first_component is None:
                self._log.error(f"Cannot find first component instrument {first_component_id} for spread {spread_instrument_id}")
                return None

            # Validate all components exist and find minimum expiration
            for component_id, ratio in components:
                component = self._cache.instrument(component_id)

                if component is None:
                    self._log.error(f"Cannot find component instrument {component_id} for spread {spread_instrument_id}")
                    return None

                if min_expiration_ns == 0 or component.expiration_ns < min_expiration_ns:
                    min_expiration_ns = component.expiration_ns

            # Create timestamp
            ts_event = self._clock.timestamp_ns()

            # Create the OptionSpread instrument
            return OptionSpread(
                instrument_id=spread_instrument_id,
                raw_symbol=Symbol(spread_instrument_id.symbol.value),
                asset_class=first_component.asset_class,
                currency=first_component.quote_currency,
                price_precision=first_component.price_precision,
                price_increment=first_component.price_increment,
                multiplier=first_component.multiplier,
                lot_size=first_component.lot_size,
                underlying="",
                strategy_type="SPREAD",
                activation_ns=0,
                expiration_ns=min_expiration_ns,
                ts_event=ts_event,
                ts_init=ts_event,
                margin_init=first_component.margin_init,
                margin_maint=first_component.margin_maint,
                maker_fee=first_component.maker_fee,
                taker_fee=first_component.taker_fee,
                exchange=first_component.exchange,
                tick_scheme_name=first_component.tick_scheme_name,
            )
        except Exception as e:
            self._log.error(f"Failed to create OptionSpread from components: {e}")
            return

    cpdef void request_instruments(self, RequestInstruments request):
        cdef list instruments = self._cache.instruments(request.venue)

        if not instruments:
            self._log.error(f"Cannot find instruments")
            return

        self._handle_instruments(request.venue, instruments, request.id, request.start, request.end, request.params)

    cpdef void request_order_book_snapshot(self, RequestOrderBookSnapshot request):
        # Do nothing else for backtest
        pass

    cpdef void request_quote_ticks(self, RequestQuoteTicks request):
        # Do nothing else for backtest
        pass

    cpdef void request_trade_ticks(self, RequestTradeTicks request):
        # Do nothing else for backtest
        pass

    cpdef void request_bars(self, RequestBars request):
        # Do nothing else for backtest
        pass

# -- SPREAD QUOTE AGGREGATORS --------------------------------------------------------------------

    cpdef void _start_spread_quote_aggregator(self, SubscribeQuoteTicks command):
        spread_instrument_id = command.instrument_id

        # Ensure the dictionary is initialized
        if self._spread_quote_aggregators is None:
            self._spread_quote_aggregators = {}

        if spread_instrument_id in self._spread_quote_aggregators:
            return

        update_interval_seconds = command.params.get("update_interval_seconds", 60)
        aggregator = SpreadQuoteAggregator(
            spread_instrument_id=spread_instrument_id,
            handler=self._handle_spread_quote,
            msgbus=self._msgbus,
            cache=self._cache,
            clock=self._clock,
            update_interval_seconds=update_interval_seconds,
        )
        self._spread_quote_aggregators[spread_instrument_id] = aggregator

        # Subscribe to quotes for component instruments
        components = spread_instrument_id.to_list()

        for component_id, _ in components:
            subscribe = SubscribeQuoteTicks(
                instrument_id=component_id,
                client_id=command.client_id,
                venue=command.venue,
                command_id=UUID4(),
                ts_init=command.ts_init,
                params=command.params,
                correlation_id=command.id,
            )

            # Send command to message bus for normal treatment
            self._msgbus.send(endpoint="DataEngine.execute", msg=subscribe)

    cpdef void _stop_spread_quote_aggregator(self, UnsubscribeQuoteTicks command):
        spread_instrument_id = command.instrument_id

        # Ensure the dictionary is initialized
        if self._spread_quote_aggregators is None:
            self._spread_quote_aggregators = {}
            return

        aggregator = self._spread_quote_aggregators.get(spread_instrument_id)

        if aggregator is None:
            self._log.warning(
                f"Cannot stop spread quote aggregator: no aggregator found for {spread_instrument_id}",
            )
            return

        aggregator.stop()

        # Unsubscribe from component instruments
        components = spread_instrument_id.to_list()

        for component_id, _ in components:
            unsubscribe = UnsubscribeQuoteTicks(
                instrument_id=component_id,
                client_id=command.client_id,
                venue=command.venue,
                command_id=command.id,
                ts_init=command.ts_init,
                params=command.params,
            )

            # Send command to message bus for normal treatment
            self._msgbus.send(endpoint="DataEngine.execute", msg=unsubscribe)

        del self._spread_quote_aggregators[spread_instrument_id]

    cdef void _handle_spread_quote(self, quote):
        """
        Handle a spread quote generated by the aggregator.

        Parameters
        ----------
        quote : QuoteTick
            The spread quote to handle.
        """
        # Send the quote to the data engine for processing
        self._msgbus.send(endpoint="DataEngine.process", msg=quote)

</document_content>
</document>
<document index="2208">
<source>nautilus_trader/backtest/engine.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import heapq
import pickle
import uuid
from collections import deque
from decimal import Decimal
from heapq import heappush
from typing import Generator

import cython
import pandas as pd

from nautilus_trader.accounting.error import AccountError
from nautilus_trader.backtest.results import BacktestResult
from nautilus_trader.common.component import is_logging_pyo3
from nautilus_trader.common.config import InvalidConfiguration
from nautilus_trader.config import BacktestEngineConfig
from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.data.engine import TimeRangeGenerator
from nautilus_trader.data.engine import get_time_range_generator
from nautilus_trader.model import BOOK_DATA_TYPES
from nautilus_trader.model import NAUTILUS_PYO3_DATA_TYPES
from nautilus_trader.system.kernel import NautilusKernel
from nautilus_trader.trading.trader import Trader

from cpython.datetime cimport timedelta
from cpython.object cimport PyObject
from libc.stdint cimport uint32_t
from libc.stdint cimport uint64_t

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.accounting.margin_models cimport LeveragedMarginModel
from nautilus_trader.accounting.margin_models cimport MarginModel
from nautilus_trader.backtest.data_client cimport BacktestDataClient
from nautilus_trader.backtest.data_client cimport BacktestMarketDataClient
from nautilus_trader.backtest.execution_client cimport BacktestExecClient
from nautilus_trader.backtest.models cimport FeeModel
from nautilus_trader.backtest.models cimport FillModel
from nautilus_trader.backtest.models cimport LatencyModel
from nautilus_trader.backtest.models cimport MakerTakerFeeModel
from nautilus_trader.backtest.modules cimport SimulationModule
from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.common.actor cimport Actor
from nautilus_trader.common.component cimport FORCE_STOP
from nautilus_trader.common.component cimport LOGGING_PYO3
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport Logger
from nautilus_trader.common.component cimport LogGuard
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport TestClock
from nautilus_trader.common.component cimport TimeEvent
from nautilus_trader.common.component cimport flush_logger
from nautilus_trader.common.component cimport get_component_clocks
from nautilus_trader.common.component cimport is_logging_initialized
from nautilus_trader.common.component cimport log_sysinfo
from nautilus_trader.common.component cimport set_backtest_force_stop
from nautilus_trader.common.component cimport set_logging_clock_realtime_mode
from nautilus_trader.common.component cimport set_logging_clock_static_mode
from nautilus_trader.common.component cimport set_logging_clock_static_time
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.datetime cimport format_optional_iso8601
from nautilus_trader.core.datetime cimport maybe_dt_to_unix_nanos
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.rust.backtest cimport TimeEventAccumulatorAPI
from nautilus_trader.core.rust.backtest cimport time_event_accumulator_advance_clock
from nautilus_trader.core.rust.backtest cimport time_event_accumulator_drain
from nautilus_trader.core.rust.backtest cimport time_event_accumulator_drop
from nautilus_trader.core.rust.backtest cimport time_event_accumulator_new
from nautilus_trader.core.rust.common cimport TimeEventHandler_t
from nautilus_trader.core.rust.common cimport logging_is_colored
from nautilus_trader.core.rust.common cimport vec_time_event_handlers_drop
from nautilus_trader.core.rust.core cimport CVec
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.rust.model cimport AggregationSource
from nautilus_trader.core.rust.model cimport AggressorSide
from nautilus_trader.core.rust.model cimport BookType
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport InstrumentCloseType
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.core.rust.model cimport MarketStatus
from nautilus_trader.core.rust.model cimport MarketStatusAction
from nautilus_trader.core.rust.model cimport OmsType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport Price_t
from nautilus_trader.core.rust.model cimport PriceRaw
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.core.rust.model cimport QuantityRaw
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport orderbook_best_ask_price
from nautilus_trader.core.rust.model cimport orderbook_best_bid_price
from nautilus_trader.core.rust.model cimport orderbook_has_ask
from nautilus_trader.core.rust.model cimport orderbook_has_bid
from nautilus_trader.core.rust.model cimport trade_id_new
from nautilus_trader.core.string cimport pystr_to_cstr
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.data.messages cimport DataCommand
from nautilus_trader.data.messages cimport DataResponse
from nautilus_trader.data.messages cimport SubscribeData
from nautilus_trader.data.messages cimport SubscribeInstruments
from nautilus_trader.data.messages cimport UnsubscribeData
from nautilus_trader.data.messages cimport UnsubscribeInstruments
from nautilus_trader.execution.algorithm cimport ExecAlgorithm
from nautilus_trader.execution.matching_core cimport MatchingCore
from nautilus_trader.execution.messages cimport BatchCancelOrders
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.execution.messages cimport TradingCommand
from nautilus_trader.execution.trailing cimport TrailingStopCalculator
from nautilus_trader.model.book cimport OrderBook
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarAggregation
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport BookOrder
from nautilus_trader.model.data cimport CustomData
from nautilus_trader.model.data cimport InstrumentClose
from nautilus_trader.model.data cimport InstrumentStatus
from nautilus_trader.model.data cimport OrderBookDelta
from nautilus_trader.model.data cimport OrderBookDeltas
from nautilus_trader.model.data cimport OrderBookDepth10
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.events.order cimport OrderAccepted
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderCancelRejected
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderModifyRejected
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport account_type_to_str
from nautilus_trader.model.functions cimport aggressor_side_to_str
from nautilus_trader.model.functions cimport book_type_to_str
from nautilus_trader.model.functions cimport oms_type_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TradeId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.identifiers cimport VenueOrderId
from nautilus_trader.model.instruments.base cimport EXPIRING_INSTRUMENT_CLASSES
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.crypto_future cimport CryptoFuture
from nautilus_trader.model.instruments.crypto_perpetual cimport CryptoPerpetual
from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
from nautilus_trader.model.instruments.equity cimport Equity
from nautilus_trader.model.objects cimport AccountBalance
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.limit cimport LimitOrder
from nautilus_trader.model.orders.limit_if_touched cimport LimitIfTouchedOrder
from nautilus_trader.model.orders.market cimport MarketOrder
from nautilus_trader.model.orders.market_if_touched cimport MarketIfTouchedOrder
from nautilus_trader.model.orders.market_to_limit cimport MarketToLimitOrder
from nautilus_trader.model.orders.stop_limit cimport StopLimitOrder
from nautilus_trader.model.orders.stop_market cimport StopMarketOrder
from nautilus_trader.model.position cimport Position
from nautilus_trader.portfolio.base cimport PortfolioFacade
from nautilus_trader.trading.strategy cimport Strategy


cdef class BacktestEngine:
    """
    Provides a backtest engine to run a portfolio of strategies over historical
    data.

    Parameters
    ----------
    config : BacktestEngineConfig, optional
        The configuration for the instance.

    Raises
    ------
    TypeError
        If `config` is not of type `BacktestEngineConfig`.
    """

    def __init__(self, config: BacktestEngineConfig | None = None) -> None:
        if config is None:
            config = BacktestEngineConfig()

        Condition.type(config, BacktestEngineConfig, "config")

        self._config: BacktestEngineConfig  = config

        # Set up components
        self._accumulator = <TimeEventAccumulatorAPI>time_event_accumulator_new()

        # Run IDs
        self._run_config_id: str | None = None
        self._run_id: UUID4 | None = None

        # Venues and data
        self._venues: dict[Venue, SimulatedExchange] = {}
        self._has_data: set[InstrumentId] = set()
        self._has_book_data: set[InstrumentId] = set()
        self._data: list[Data] = []
        self._data_len: uint64_t = 0
        self._iteration: uint64_t = 0
        self._last_ns : uint64_t = 0
        self._end_ns : uint64_t = 0
        self._sorted: bint = True

        # Timing
        self._run_started: pd.Timestamp | None = None
        self._run_finished: pd.Timestamp | None = None
        self._backtest_start: pd.Timestamp | None = None
        self._backtest_end: pd.Timestamp | None = None

        # Build core system kernel
        self._kernel = NautilusKernel(name=type(self).__name__, config=config)
        self._instance_id = self._kernel.instance_id
        self._log = Logger(type(self).__name__)

        self._data_engine: DataEngine = self._kernel.data_engine

        # Set up data iterator
        self._data_requests: dict[str, RequestData] = {}
        self._last_subscription_ts: dict[str, uint64_t] = {}
        self._backtest_subscription_names = set()
        self._response_data = []
        self._data_iterator = BacktestDataIterator()
        self._kernel.msgbus.register(endpoint="BacktestEngine.execute", handler=self._handle_data_command)

    def __del__(self) -> None:
        if self._accumulator._0 != NULL:
            time_event_accumulator_drop(self._accumulator)

    @property
    def trader_id(self) -> TraderId:
        """
        Return the engines trader ID.

        Returns
        -------
        TraderId

        """
        return self._kernel.trader_id

    @property
    def machine_id(self) -> str:
        """
        Return the engines machine ID.

        Returns
        -------
        str

        """
        return self._kernel.machine_id

    @property
    def instance_id(self) -> UUID4:
        """
        Return the engines instance ID.

        This is a unique identifier per initialized engine.

        Returns
        -------
        UUID4

        """
        return self._kernel.instance_id

    @property
    def kernel(self) -> NautilusKernel:
        """
        Return the internal kernel for the engine.

        Returns
        -------
        NautilusKernel

        """
        return self._kernel

    @property
    def logger(self) -> Logger:
        """
        Return the internal logger for the engine.

        Returns
        -------
        Logger

        """
        return self._log

    @property
    def run_config_id(self) -> str:
        """
        Return the last backtest engine run config ID.

        Returns
        -------
        str or ``None``

        """
        return self._run_config_id

    @property
    def run_id(self) -> UUID4:
        """
        Return the last backtest engine run ID (if run).

        Returns
        -------
        UUID4 or ``None``

        """
        return self._run_id

    @property
    def iteration(self) -> int:
        """
        Return the backtest engine iteration count.

        Returns
        -------
        int

        """
        return self._iteration

    @property
    def run_started(self) -> pd.Timestamp | None:
        """
        Return when the last backtest run started (if run).

        Returns
        -------
        pd.Timestamp or ``None``

        """
        return self._run_started

    @property
    def run_finished(self) -> pd.Timestamp | None:
        """
        Return when the last backtest run finished (if run).

        Returns
        -------
        pd.Timestamp or ``None``

        """
        return self._run_finished

    @property
    def backtest_start(self) -> pd.Timestamp | None:
        """
        Return the last backtest run time range start (if run).

        Returns
        -------
        pd.Timestamp or ``None``

        """
        return self._backtest_start

    @property
    def backtest_end(self) -> pd.Timestamp | None:
        """
        Return the last backtest run time range end (if run).

        Returns
        -------
        pd.Timestamp or ``None``

        """
        return self._backtest_end

    @property
    def trader(self) -> Trader:
        """
        Return the engines internal trader.

        Returns
        -------
        Trader

        """
        return self._kernel.trader

    @property
    def cache(self) -> CacheFacade:
        """
        Return the engines internal read-only cache.

        Returns
        -------
        CacheFacade

        """
        return self._kernel.cache

    @property
    def data(self) -> list[Data]:
        """
        Return the engines internal data stream.

        Returns
        -------
        list[Data]

        """
        return self._data.copy()

    @property
    def portfolio(self) -> PortfolioFacade:
        """
        Return the engines internal read-only portfolio.

        Returns
        -------
        PortfolioFacade

        """
        return self._kernel.portfolio

    def get_log_guard(self) -> nautilus_pyo3.LogGuard | LogGuard | None:
        """
        Return the global logging subsystems log guard.

        May return ``None`` if the logging subsystem was already initialized.

        Returns
        -------
        nautilus_pyo3.LogGuard | LogGuard | None

        """
        return self._kernel.get_log_guard()

    def list_venues(self) -> list[Venue]:
        """
        Return the venues contained within the engine.

        Returns
        -------
        list[Venue]

        """
        return list(self._venues)

    def add_venue(
        self,
        venue: Venue,
        oms_type: OmsType,
        account_type: AccountType,
        starting_balances: list[Money],
        base_currency: Currency | None = None,
        default_leverage: Decimal | None = None,
        leverages: dict[InstrumentId, Decimal] | None = None,
        margin_model: MarginModel = None,
        modules: list[SimulationModule] | None = None,
        fill_model: FillModel | None = None,
        fee_model: FeeModel | None = None,
        latency_model: LatencyModel | None = None,
        book_type: BookType = BookType.L1_MBP,
        routing: bool = False,
        reject_stop_orders: bool = True,
        support_gtd_orders: bool = True,
        support_contingent_orders: bool = True,
        use_position_ids: bool = True,
        use_random_ids: bool = False,
        use_reduce_only: bool = True,
        use_message_queue: bool = True,
        bar_execution: bool = True,
        bar_adaptive_high_low_ordering: bool = False,
        trade_execution: bool = False,
        allow_cash_borrowing: bool = False,
        frozen_account: bool = False,
        price_protection_points=None,
    ) -> None:
        """
        Add a `SimulatedExchange` with the given parameters to the backtest engine.

        Parameters
        ----------
        venue : Venue
            The venue ID.
        oms_type : OmsType {``HEDGING``, ``NETTING``}
            The order management system type for the exchange. If ``HEDGING`` will
            generate new position IDs.
        account_type : AccountType
            The account type for the exchange.
        starting_balances : list[Money]
            The starting account balances (specify one for a single asset account).
        base_currency : Currency, optional
            The account base currency for the client. Use ``None`` for multi-currency accounts.
        default_leverage : Decimal, optional
            The account default leverage (for margin accounts).
        leverages : dict[InstrumentId, Decimal], optional
            The instrument specific leverage configuration (for margin accounts).
        margin_model : MarginModelConfig, optional
            The margin calculation model configuration. Default 'leveraged'.
        modules : list[SimulationModule], optional
            The simulation modules to load into the exchange.
        fill_model : FillModel, optional
            The fill model for the exchange.
        fee_model : FeeModel, optional
            The fee model for the venue.
        latency_model : LatencyModel, optional
            The latency model for the exchange.
        book_type : BookType, default ``BookType.L1_MBP``
            The default order book type.
        routing : bool, default False
            If multi-venue routing should be enabled for the execution client.
        reject_stop_orders : bool, default True
            If stop orders are rejected on submission if trigger price is in the market.
        support_gtd_orders : bool, default True
            If orders with GTD time in force will be supported by the venue.
        support_contingent_orders : bool, default True
            If contingent orders will be supported/respected by the venue.
            If False, then it's expected the strategy will be managing any contingent orders.
        use_position_ids : bool, default True
            If venue position IDs will be generated on order fills.
        use_random_ids : bool, default False
            If all venue generated identifiers will be random UUID4's.
        use_reduce_only : bool, default True
            If the `reduce_only` execution instruction on orders will be honored.
        use_message_queue : bool, default True
            If an internal message queue should be used to process trading commands in sequence after
            they have initially arrived. Setting this to False would be appropriate for real-time
            sandbox environments, where we don't want to introduce additional latency of waiting for
            the next data event before processing the trading command.
        bar_execution : bool, default True
            If bars should be processed by the matching engine(s) (and move the market).
        bar_adaptive_high_low_ordering : bool, default False
            Determines whether the processing order of bar prices is adaptive based on a heuristic.
            This setting is only relevant when `bar_execution` is True.
            If False, bar prices are always processed in the fixed order: Open, High, Low, Close.
            If True, the processing order adapts with the heuristic:
            - If High is closer to Open than Low then the processing order is Open, High, Low, Close.
            - If Low is closer to Open than High then the processing order is Open, Low, High, Close.
        trade_execution : bool, default False
            If trades should be processed by the matching engine(s) (and move the market).
        allow_cash_borrowing : bool, default False
            If cash accounts should allow borrowing (negative balances).
        frozen_account : bool, default False
            If the account for this exchange is frozen (balances will not change).
        price_protection_points : int, optional
            Defines an exchange-calculated price boundary (in points) to prevent
            marketable orders from executing at excessively aggressive prices.

        Raises
        ------
        ValueError
            If `venue` is already registered with the engine.

        """
        if modules is None:
            modules = []

        if margin_model is None:
            margin_model = LeveragedMarginModel()

        if fill_model is None:
            fill_model = FillModel()

        if fee_model is None:
            fee_model = MakerTakerFeeModel()

        Condition.not_none(venue, "venue")
        Condition.not_in(venue, self._venues, "venue", "_venues")
        Condition.not_empty(starting_balances, "starting_balances")
        Condition.list_type(modules, SimulationModule, "modules")
        Condition.type(fill_model, FillModel, "fill_model")
        Condition.type(fee_model, FeeModel, "fee_model")

        if default_leverage is None:
            if account_type == AccountType.MARGIN:
                default_leverage = Decimal(10)
            else:
                default_leverage = Decimal(1)

        # Create exchange
        normalized_price_protection = price_protection_points

        exchange = SimulatedExchange(
            venue=venue,
            oms_type=oms_type,
            account_type=account_type,
            starting_balances=starting_balances,
            base_currency=base_currency,
            default_leverage=default_leverage,
            leverages=leverages or {},
            margin_model=margin_model,
            modules=modules,
            portfolio=self._kernel.portfolio,
            msgbus=self._kernel.msgbus,
            cache=self._kernel.cache,
            fill_model=fill_model,
            fee_model=fee_model,
            latency_model=latency_model,
            book_type=book_type,
            clock=self._kernel.clock,
            frozen_account=frozen_account,
            reject_stop_orders=reject_stop_orders,
            support_gtd_orders=support_gtd_orders,
            support_contingent_orders=support_contingent_orders,
            use_position_ids=use_position_ids,
            use_random_ids=use_random_ids,
            use_reduce_only=use_reduce_only,
            use_message_queue=use_message_queue,
            bar_execution=bar_execution,
            bar_adaptive_high_low_ordering=bar_adaptive_high_low_ordering,
            trade_execution=trade_execution,
            price_protection_points=normalized_price_protection,
        )

        self._venues[venue] = exchange

        # Create execution client for exchange
        exec_client = BacktestExecClient(
            exchange=exchange,
            msgbus=self._kernel.msgbus,
            cache=self._kernel.cache,
            clock=self._kernel.clock,
            routing=routing,
            frozen_account=frozen_account,
            allow_cash_borrowing=allow_cash_borrowing,
        )

        exchange.register_client(exec_client)
        self._kernel.exec_engine.register_client(exec_client)

        self._add_market_data_client_if_not_exists(venue)

        self._log.info(f"Added {exchange}")

    def change_fill_model(self, Venue venue, FillModel model) -> None:
        """
        Change the fill model for the exchange of the given venue.

        Parameters
        ----------
        venue : Venue
            The venue of the simulated exchange.
        model : FillModel
            The fill model to change to.

        """
        Condition.not_none(venue, "venue")
        Condition.not_none(model, "model")
        Condition.is_in(venue, self._venues, "venue", "self._venues")

        self._venues[venue].set_fill_model(model)

    def add_instrument(self, Instrument instrument) -> None:
        """
        Add the instrument to the backtest engine.

        The instrument must be valid for its associated venue. For instance,
        derivative instruments which would trade on margin cannot be added to
        a venue with a ``CASH`` account.

        Parameters
        ----------
        instrument : Instrument
            The instrument to add.

        Raises
        ------
        InvalidConfiguration
            If the venue for the `instrument` has not been added to the engine.
        InvalidConfiguration
            If `instrument` is not valid for its associated venue.

        """
        Condition.not_none(instrument, "instrument")

        if instrument.id.venue not in self._venues:
            raise InvalidConfiguration(
                "Cannot add an `Instrument` object without first adding its associated venue. "
                f"Add the {instrument.id.venue} venue using the `add_venue` method."
            )

        # Validate instrument is correct for the venue
        cdef SimulatedExchange venue = self._venues[instrument.id.venue]

        if (
            isinstance(instrument, CurrencyPair)
            and venue.account_type != AccountType.MARGIN
            and venue.base_currency is not None  # Single-currency account
        ):
            raise InvalidConfiguration(
                f"Cannot add `CurrencyPair` instrument {instrument} "
                "for a venue with a single-currency CASH account.",
            )

        # Check client has been registered
        self._add_market_data_client_if_not_exists(instrument.id.venue)

        # Add data
        self._kernel.data_engine.process(instrument)  # Adds to cache
        self._venues[instrument.id.venue].add_instrument(instrument)

        self._log.info(f"Added {instrument.id} Instrument")

    def add_data(
        self,
        list data,
        ClientId client_id = None,
        bint validate = True,
        bint sort = True,
    ) -> None:
        """
        Add the given `data` to the backtest engine.

        Parameters
        ----------
        data : list[Data]
            The data to add.
        client_id : ClientId, optional
            The client ID to associate with the data.
        validate : bool, default True
            If `data` should be validated
            (recommended when adding data directly to the engine).
        sort : bool, default True
            If `data` should be sorted by `ts_init` with the rest of the stream after adding
            (recommended when adding data directly to the engine).

        Raises
        ------
        ValueError
            If `data` is empty.
        ValueError
            If `data` contains objects which are not a type of `Data`.
        ValueError
            If `instrument_id` for the data is not found in the cache.
        ValueError
            If `data` elements do not have an `instrument_id` and `client_id` is ``None``.
        TypeError
            If `data` is a Rust PyO3 data type (cannot add directly to engine yet).

        Warnings
        --------
        Assumes all data elements are of the same type. Adding lists of varying
        data types could result in incorrect backtest logic.

        Caution if adding data without `sort` being True, as this could lead to running backtests
        on a stream which does not have monotonically increasing timestamps.

        Notes
        -----
        For optimal performance when loading large datasets, consider using `sort=False` for all
        calls to `add_data()`, then calling `sort_data()` once after all data has been added:

        .. code-block:: python

            # Add multiple data streams without sorting
            engine.add_data(instrument1_bars, sort=False)
            engine.add_data(instrument2_bars, sort=False)
            engine.add_data(instrument3_bars, sort=False)

            # Sort once at the end
            engine.sort_data()

        This approach avoids repeatedly sorting the entire data stream on each call,
        significantly reducing load time for large datasets.

        **Contract invariants:**

        - When `sort=True`: Data is immediately available for backtesting via `run()`.
        - When `sort=False`: You **must** call `sort_data()` or add data with `sort=True` before `run()`.
        - The provided `data` list is always copied internally to prevent external mutations from affecting the engine state.

        """
        Condition.not_empty(data, "data")
        Condition.list_type(data, Data, "data")

        if isinstance(data[0], NAUTILUS_PYO3_DATA_TYPES):
            raise TypeError(
                f"Cannot add data of type `{type(data[0]).__name__}` from pyo3 directly to engine. "
                "This will be supported in a future release.",
            )

        cdef str data_added_str = "data"

        if validate:
            first = data[0]

            if hasattr(first, "instrument_id"):
                Condition.is_true(
                    first.instrument_id in self._kernel.cache.instrument_ids(),
                    f"`Instrument` {first.instrument_id} for the given data not found in the cache. "
                    "Add the instrument through `add_instrument()` prior to adding related data.",
                )
                # Check client has been registered
                self._add_market_data_client_if_not_exists(first.instrument_id.venue)
                self._has_data.add(first.instrument_id)
                data_added_str = f"{first.instrument_id} {type(first).__name__}"
            elif isinstance(first, Bar):
                Condition.is_true(
                    first.bar_type.instrument_id in self._kernel.cache.instrument_ids(),
                    f"`Instrument` {first.bar_type.instrument_id} for the given data not found in the cache. "
                    "Add the instrument through `add_instrument()` prior to adding related data.",
                )
                Condition.equal(
                    first.bar_type.aggregation_source,
                    AggregationSource.EXTERNAL,
                    "bar_type.aggregation_source",
                    "required source",
                )
                self._has_data.add(first.bar_type.instrument_id)
                data_added_str = f"{first.bar_type} {type(first).__name__}"
            else:
                Condition.not_none(client_id, "client_id")
                # Check client has been registered
                self._add_data_client_if_not_exists(client_id)

                if isinstance(first, CustomData):
                    data_added_str = f"{type(first.data).__name__} "

            if type(first) in BOOK_DATA_TYPES:
                self._has_book_data.add(first.instrument_id)

        # Add data
        self._data.extend(data)

        if sort:
            self._data = sorted(self._data, key=lambda x: x.ts_init)
            self._data_iterator.add_data("backtest_data", self._data, append_data=True, presorted=True)
            self._sorted = True
        else:
            self._sorted = False

        for data_point in data:
            data_type = type(data_point)

            if data_type is Bar:
                self._backtest_subscription_names.add(f"{data_point.bar_type}")
            elif data_type in (QuoteTick, TradeTick):
                self._backtest_subscription_names.add(f"{data_type.__name__}.{data_point.instrument_id}")
            elif data_type is CustomData:
                self._backtest_subscription_names.add(f"{type(data_point.data).__name__}.{getattr(data_point.data, 'instrument_id', None)}")

        self._log.info(
            f"Added {len(data):_} {data_added_str} element{'' if len(data) == 1 else 's'}",
        )

    def add_data_iterator(
        self,
        str data_name,
        generator: Generator[list[Data], None, None],
        ClientId client_id = None,
    ) -> None:
        """
        Add a single stream generator that yields ``list[Data]`` objects for the low-level streaming backtest API.

        Parameters
        ----------
        data_name : str
            The name identifier for the data stream.
        generator : Generator[list[Data], None, None]
            A Python generator that yields lists of ``Data`` objects.
        client_id : ClientId, optional
            The client ID to associate with the data.

        Notes
        -----
        This method enables streaming large datasets by loading data in chunks.
        The generator should yield ``list[Data]`` objects sorted by `ts_init` timestamp.

        """
        self._data_iterator.init_data(
            data_name,
            generator,
            append_data=True
        )

        self._log.info(f"Added {data_name} stream generator")

    cpdef void _handle_data_command(self, DataCommand command):
        if not(command.data_type.type in [Bar, QuoteTick, TradeTick, OrderBookDepth10]
               or type(command) not in [SubscribeData, UnsubscribeData, SubscribeInstruments, UnsubscribeInstruments]):
            return

        if isinstance(command, SubscribeData):
            self._handle_subscribe(<SubscribeData>command)
        elif isinstance(command, UnsubscribeData):
            self._handle_unsubscribe(<UnsubscribeData>command)

    cdef void _handle_subscribe(self, SubscribeData command):
        cdef RequestData request = command.to_request(unix_nanos_to_dt(self._last_ns), unix_nanos_to_dt(self._end_ns), self._handle_data_response)
        cdef str subscription_name = request.params["subscription_name"]

        if subscription_name in self._data_requests or subscription_name in self._backtest_subscription_names:
            return

        self._log.debug(f"Subscribing to {subscription_name}, {command.params.get('durations_seconds')=}")

        time_range_generator = get_time_range_generator(
            request.params.get("time_range_generator", "")
        )(request)
        cdef bint append_data = request.params.get("append_data", True)
        request.params.pop("time_range_generator", None) # so sub_requests don't use long data range requests as well

        self._data_requests[subscription_name] = request
        self._data_iterator.init_data(
            subscription_name,
            self._subscription_generator(
                subscription_name,
                time_range_generator,
            ),
            append_data
        )

    def _subscription_generator(
        self,
        str subscription_name,
        time_range_generator: TimeRangeGenerator,
    ):
        """
        Generator that yields a range of backtest data for a subscription using a time range generator.
        """
        def get_next_time_range(data_received):
            # Helper to get next time range with proper error handling, data_received is a signal sent to the time_range_generator
            # to indicate if data has been received in the previous call to _update_subscription_data
            try:
                return time_range_generator.send(data_received) if data_received is not None else next(time_range_generator)
            except StopIteration:
                return None, None

        # Get initial time range
        request_start_ns, request_end_ns = get_next_time_range(None)

        try:
            while request_start_ns is not None and request_start_ns <= self._end_ns:
                # Clear and update response data
                self._response_data = []
                self._update_subscription_data(subscription_name, request_start_ns, request_end_ns)

                # Determine signal based on whether we got data
                data_received = len(self._response_data) > 0

                # Yield data if we have any
                if self._response_data:
                    yield self._response_data

                # Get next time range
                request_start_ns, request_end_ns = get_next_time_range(data_received)
        finally:
            # Ensure generator is properly closed
            try:
                time_range_generator.close()
            except (StopIteration, GeneratorExit):
                pass

    cpdef void _update_subscription_data(self, str subscription_name, uint64_t request_start_ns, uint64_t request_end_ns):
        cdef RequestData request = self._data_requests[subscription_name]
        cdef RequestData new_request = request.with_dates(
            unix_nanos_to_dt(request_start_ns),
            unix_nanos_to_dt(request_end_ns),
            self._last_ns,
            self._handle_data_response
        )
        self._log.debug(f"Renewing {request.data_type.type.__name__} data from {unix_nanos_to_dt(request_start_ns)} to {unix_nanos_to_dt(request_end_ns)}")
        self._kernel._msgbus.request(endpoint="DataEngine.request", request=new_request)

    cpdef void _handle_data_response(self, DataResponse response):
        cdef list data = response.data
        cdef str subscription_name = response.params["subscription_name"]

        if not data:
            self._log.debug(f"Empty data for {subscription_name}")
        else:
            self._log.debug(f"Received subscribe {subscription_name} data from {unix_nanos_to_dt(data[0].ts_init)} to {unix_nanos_to_dt(data[-1].ts_init)}")

        self._response_data = data

    cpdef void _handle_unsubscribe(self, UnsubscribeData command):
        cdef str subscription_name = ""

        if command.data_type.type is Bar:
            subscription_name = f"{command.bar_type}"
        elif type(command) is UnsubscribeInstruments:
            subscription_name = "subscribe_instruments"
        else:
            subscription_name = f"{command.data_type.type.__name__}.{command.instrument_id}"

        self._log.debug(f"Unsubscribing {subscription_name}")
        self._data_iterator.remove_data(subscription_name, complete_remove=True)
        self._data_requests.pop(subscription_name, None)

    def dump_pickled_data(self) -> bytes:
        """
        Return the internal data stream pickled.

        Returns
        -------
        bytes

        """
        return pickle.dumps(self._data)

    def load_pickled_data(self, bytes data) -> None:
        """
        Load the given pickled data directly into the internal data stream.

        It is highly advised to only pass data to this method which was obtained
        through a call to `.dump_pickled_data()`.

        Warnings
        --------
        This low-level direct access method makes the following assumptions:
         - The data contains valid Nautilus objects only, which inherit from `Data`.
         - The data was successfully pickled from a call to `pickle.dumps()`.
         - The data was sorted prior to pickling.
         - All required instruments have been added to the engine.

        """
        Condition.not_none(data, "data")
        self._data = pickle.loads(data)
        self._data_iterator.add_data("backtest_data", self._data, append_data=True, presorted=True)
        self._sorted = True

        self._log.info(
            f"Loaded {len(self._data):_} data "
            f"element{'' if len(data) == 1 else 's'} from pickle",
        )

    def add_actor(self, actor: Actor) -> None:
        """
        Add the given actor to the backtest engine.

        Parameters
        ----------
        actor : Actor
            The actor to add.

        """
        # Checked inside trader
        self._kernel.trader.add_actor(actor)

    def add_actors(self, actors: list[Actor]) -> None:
        """
        Add the given list of actors to the backtest engine.

        Parameters
        ----------
        actors : list[Actor]
            The actors to add.

        """
        # Checked inside trader
        self._kernel.trader.add_actors(actors)

    def add_strategy(self, strategy: Strategy) -> None:
        """
        Add the given strategy to the backtest engine.

        Parameters
        ----------
        strategy : Strategy
            The strategy to add.

        """
        # Checked inside trader
        self._kernel.trader.add_strategy(strategy)

    def add_strategies(self, strategies: list[Strategy]) -> None:
        """
        Add the given list of strategies to the backtest engine.

        Parameters
        ----------
        strategies : list[Strategy]
            The strategies to add.

        """
        # Checked inside trader
        self._kernel.trader.add_strategies(strategies)

    def add_exec_algorithm(self, exec_algorithm: ExecAlgorithm) -> None:
        """
        Add the given execution algorithm to the backtest engine.

        Parameters
        ----------
        exec_algorithm : ExecAlgorithm
            The execution algorithm to add.

        """
        # Checked inside trader
        self._kernel.trader.add_exec_algorithm(exec_algorithm)

    def add_exec_algorithms(self, exec_algorithms: list[ExecAlgorithm]) -> None:
        """
        Add the given list of execution algorithms to the backtest engine.

        Parameters
        ----------
        exec_algorithms : list[ExecAlgorithm]
            The execution algorithms to add.

        """
        # Checked inside trader
        self._kernel.trader.add_exec_algorithms(exec_algorithms)

    def reset(self) -> None:
        """
        Reset the backtest engine.

        All stateful fields are reset to their initial value, except for data and instruments which persist.

        Notes
        -----
        Data and instruments are retained across resets by default to enable repeated runs
        with different strategies or parameters against the same dataset.

        See Also
        --------
        https://nautilustrader.io/docs/concepts/backtesting#repeated-runs

        """
        self._log.debug(f"Resetting")

        if self._kernel.trader.is_running:
            # End current backtest run
            self.end()

        # Reset DataEngine
        if self._kernel.data_engine.is_running:
            self._kernel.data_engine.stop()

        self._kernel.data_engine.reset()

        # Reset ExecEngine
        if self._kernel.exec_engine.is_running:
            self._kernel.exec_engine.stop()

        self._kernel.exec_engine.reset()

        # Reset RiskEngine
        if self._kernel.risk_engine.is_running:
            self._kernel.risk_engine.stop()

        self._kernel.risk_engine.reset()

        # Reset Emulator
        if self._kernel.emulator.is_running:
            self._kernel.emulator.stop()

        self._kernel.emulator.reset()

        self._kernel.trader.reset()

        for exchange in self._venues.values():
            exchange.reset()

        # Reset run IDs
        self._run_config_id = None
        self._run_id = None

        # Reset timing
        self._iteration = 0
        self._data_iterator = BacktestDataIterator()

        if self._sorted:
            self._data_iterator.add_data("backtest_data", self._data, append_data=True, presorted=True)

        self._run_started = None
        self._run_finished = None
        self._backtest_start = None
        self._backtest_end = None

        self._log.info("Reset")

    def sort_data(self) -> None:
        """
        Sort the engines internal data stream.

        """
        self._data = sorted(self._data, key=lambda x: x.ts_init)
        self._data_iterator.add_data("backtest_data", self._data, append_data=True, presorted=True)
        self._sorted = True

    def clear_data(self) -> None:
        """
        Clear the engines internal data stream.

        Does not clear added instruments.

        """
        self._has_data.clear()
        self._has_book_data.clear()
        self._data.clear()
        self._data_len = 0
        self._data_iterator = BacktestDataIterator()
        self._sorted = True

    def clear_actors(self) -> None:
        """
        Clear all actors from the engines internal trader.

        """
        self._kernel.trader.clear_actors()

    def clear_strategies(self) -> None:
        """
        Clear all trading strategies from the engines internal trader.

        """
        self._kernel.trader.clear_strategies()

    def clear_exec_algorithms(self) -> None:
        """
        Clear all execution algorithms from the engines internal trader.

        """
        self._kernel.trader.clear_exec_algorithms()

    def dispose(self) -> None:
        """
        Dispose of the backtest engine by disposing the trader and releasing system resources.

        Calling this method multiple times has the same effect as calling it once (it is idempotent).
        Once called, it cannot be reversed, and no other methods should be called on this instance.

        """
        self.clear_data()
        self._kernel.dispose()

    def run(
        self,
        start: datetime | str | int | None = None,
        end: datetime | str | int | None = None,
        run_config_id: str | None = None,
        streaming: bool = False,
    ) -> None:
        """
        Run a backtest.

        At the end of the run the trader and strategies will be stopped, then
        post-run analysis performed.

        For datasets larger than available memory, use `streaming` mode with the
        following sequence:
        - 1. Add initial data batch and strategies
        - 2. Call `run(streaming=True)`
        - 3. Call `clear_data()`
        - 4. Add next batch of data stream
        - 5. Call `run(streaming=False)` or `end()` when processing the final batch

        Parameters
        ----------
        start : datetime or str or int, optional
            The start datetime (UTC) for the backtest run.
            If ``None`` engine runs from the start of the data.
        end : datetime or str or int, optional
            The end datetime (UTC) for the backtest run.
            If ``None`` engine runs to the end of the data.
        run_config_id : str, optional
            The tokenized `BacktestRunConfig` ID.
        streaming : bool, default False
            Controls data loading and processing mode:
            - If False (default): Loads all data at once.
              This is currently the only supported mode for custom data (e.g., option Greeks).
            - If True, loads data in chunks for memory-efficient processing of large datasets.

        Raises
        ------
        ValueError
            If no data has been added to the engine.
        ValueError
            If the `start` is >= the `end` datetime.
        RuntimeError
            If data has been added with `sort=False` but `sort_data()` has not been called.

        Notes
        -----
        **Contract invariants:**

        - All data added via `add_data()` must be sorted and synced to the internal iterator before calling `run()`.
        - If any data was added with `sort=False`, you must call `sort_data()` or add data with `sort=True` before this method.
        - The engine validates this requirement and will raise `RuntimeError` if unsorted data is detected.

        """
        self._run(start, end, run_config_id, streaming)

        if not streaming:
            self.end()

    def end(self):
        """
        Manually end the backtest.

        Notes
        -----
        Only required if you have previously been running with streaming.

        """
        if self._kernel.trader.is_running:
            self._kernel.trader.stop()

        if self._kernel.data_engine.is_running:
            self._kernel.data_engine.stop()

        if self._kernel.risk_engine.is_running:
            self._kernel.risk_engine.stop()

        if self._kernel.exec_engine.is_running:
            self._kernel.exec_engine.stop()

        if self._kernel.emulator.is_running:
            self._kernel.emulator.stop()

        try:
            # Process remaining messages
            for exchange in self._venues.values():
                exchange.process(self._kernel.clock.timestamp_ns())
        except AccountError:
            pass

        self._run_finished = pd.Timestamp.utcnow()
        self._backtest_end = self._kernel.clock.utc_now()

        # Change logger clock back to real-time for consistent time stamping
        set_logging_clock_realtime_mode()

        if LOGGING_PYO3:
            nautilus_pyo3.logging_clock_set_realtime_mode()

        self._log_post_run()

        if LOGGING_PYO3:
            nautilus_pyo3.logger_flush()
        else:
            flush_logger()

    def get_result(self):
        """
        Return the backtest result from the last run.

        Returns
        -------
        BacktestResult

        """
        stats_pnls: dict[str, dict[str, float]] = {}

        for currency in self._kernel.portfolio.analyzer.currencies:
            stats_pnls[currency.code] = self._kernel.portfolio.analyzer.get_performance_stats_pnls(currency)

        if self._backtest_start is not None and self._backtest_end is not None:
            elapsed_time = (self._backtest_end - self._backtest_start).total_seconds()
        else:
            elapsed_time = 0

        return BacktestResult(
            trader_id=self._kernel.trader_id.value,
            machine_id=self._kernel.machine_id,
            run_config_id=self._run_config_id,
            instance_id=self._kernel.instance_id.value,
            run_id=self._run_id.to_str() if self._run_id is not None else None,
            run_started=maybe_dt_to_unix_nanos(self._run_started),
            run_finished=maybe_dt_to_unix_nanos(self.run_finished),
            backtest_start=maybe_dt_to_unix_nanos(self._backtest_start),
            backtest_end=maybe_dt_to_unix_nanos(self._backtest_end),
            elapsed_time=elapsed_time,
            iterations=self._iteration,
            total_events=self._kernel.exec_engine.event_count,
            total_orders=self._kernel.cache.orders_total_count(),
            total_positions=len(self._kernel.cache.positions()) + len(self._kernel.cache.position_snapshots()),
            stats_pnls=stats_pnls,
            stats_returns=self._kernel.portfolio.analyzer.get_performance_stats_returns(),
        )

    def _run(
        self,
        start: datetime | str | int | None = None,
        end: datetime | str | int | None = None,
        run_config_id: str | None = None,
        bint streaming = False,
    ):
        # Validate data has been sorted and synced to iterator
        if self._data and not self._sorted:
            raise RuntimeError(
                "Data has been added but not sorted, "
                "call `engine.sort_data()` or use `engine.add_data(..., sort=True)` before running"
            )

        # Validate data
        cdef:
            SimulatedExchange exchange
            InstrumentId instrument_id
            bint has_data
            bint missing_book_data
            bint book_type_has_depth
        for exchange in self._venues.values():
            for instrument_id in exchange.instruments:
                has_data = instrument_id in self._has_data
                missing_book_data = instrument_id not in self._has_book_data
                book_type_has_depth = exchange.book_type > BookType.L1_MBP

                if book_type_has_depth and has_data and missing_book_data:
                    raise InvalidConfiguration(
                        f"No order book data found for instrument '{instrument_id }' when `book_type` is '{book_type_to_str(exchange.book_type)}'. "
                        "Set the venue `book_type` to 'L1_MBP' (for top-of-book data like quotes, trades, and bars) or provide order book data for this instrument."
                    )

        cdef uint64_t start_ns
        cdef uint64_t end_ns

        # Time range check and set
        if start is None:
            # Set `start` to start of data
            start_ns = self._data[0].ts_init if self._data else 0
            start = unix_nanos_to_dt(start_ns)
        else:
            start = pd.to_datetime(start, utc=True)
            start_ns = start.value

        if end is None:
            # Set `end` to end of data
            end_ns = self._data[-1].ts_init if self._data else 4102444800000000000  # Year 2100-01-01 00:00:00 UTC
            end = unix_nanos_to_dt(end_ns)
        else:
            end = pd.to_datetime(end, utc=True)
            end_ns = end.value

        Condition.is_true(start_ns <= end_ns, "start was > end")
        self._end_ns = end_ns

        # Set clocks
        self._last_ns = start_ns

        cdef TestClock clock
        for clock in get_component_clocks(self._instance_id):
            clock.set_time(start_ns)

        if self._iteration == 0:
            # Initialize run
            self._run_config_id = run_config_id  # Can be None
            self._run_id = UUID4()
            self._run_started = pd.Timestamp.utcnow()
            self._backtest_start = start

            for exchange in self._venues.values():
                exchange.initialize_account()
                open_orders = self._kernel.cache.orders_open(venue=exchange.id)

                for order in open_orders:
                    if order.is_emulated:
                        # Order should be loaded in the emulator already
                        continue

                    matching_engine = exchange.get_matching_engine(order.instrument_id)

                    if matching_engine is None:
                        self._log.error(
                            f"No matching engine for {order.instrument_id} to process {order}",
                        )
                        continue

                    matching_engine.process_order(order, order.account_id)

            # Reset any previously set FORCE_STOP
            set_backtest_force_stop(False)

            # Set start time of all components including logging
            for clock in get_component_clocks(self._instance_id):
                clock.set_time(start_ns)

            set_logging_clock_static_mode()
            set_logging_clock_static_time(start_ns)

            if LOGGING_PYO3:
                nautilus_pyo3.logging_clock_set_static_mode()
                nautilus_pyo3.logging_clock_set_static_time(start_ns)

            # Common kernel start-up sequence
            self._kernel.start()

            self._log_pre_run()

        self._log_run(start, end)

        # Set starting index
        cdef uint64_t i
        self._data_len = len(self._data)

        if self._data_len > 0:
            for i in range(self._data_len):
                if start_ns <= self._data[i].ts_init:
                    self._data_iterator.set_index("backtest_data", i)
                    break

        # -- MAIN BACKTEST LOOP -----------------------------------------------#
        self._last_ns = 0
        cdef uint64_t raw_handlers_count = 0
        cdef Data data = self._data_iterator.next()
        cdef CVec raw_handlers
        try:
            while data is not None:
                if data.ts_init > end_ns:
                    # End of backtest
                    break

                if data.ts_init > self._last_ns:
                    # Advance clocks to the next data time
                    self._last_ns = data.ts_init
                    raw_handlers = self._advance_time(data.ts_init)
                    raw_handlers_count = raw_handlers.len

                # Process data through exchange
                if isinstance(data, Instrument):
                    exchange = self._venues[data.id.venue]
                    exchange.update_instrument(data)
                elif isinstance(data, OrderBookDelta):
                    exchange = self._venues[data.instrument_id.venue]
                    exchange.process_order_book_delta(data)
                elif isinstance(data, OrderBookDeltas):
                    exchange = self._venues[data.instrument_id.venue]
                    exchange.process_order_book_deltas(data)
                elif isinstance(data, OrderBookDepth10):
                    exchange = self._venues[data.instrument_id.venue]
                    exchange.process_order_book_depth10(data)
                elif isinstance(data, QuoteTick):
                    exchange = self._venues[data.instrument_id.venue]
                    exchange.process_quote_tick(data)
                elif isinstance(data, TradeTick):
                    exchange = self._venues[data.instrument_id.venue]
                    exchange.process_trade_tick(data)
                elif isinstance(data, Bar):
                    exchange = self._venues[data.bar_type.instrument_id.venue]
                    exchange.process_bar(data)
                elif isinstance(data, InstrumentClose):
                    exchange = self._venues[data.instrument_id.venue]
                    exchange.process_instrument_close(data)
                elif isinstance(data, InstrumentStatus):
                    exchange = self._venues[data.instrument_id.venue]
                    exchange.process_instrument_status(data)

                self._data_engine.process(data)

                # Process all exchange messages
                for exchange in self._venues.values():
                    exchange.process(data.ts_init)

                data = self._data_iterator.next()

                if data is None or data.ts_init > self._last_ns:
                    # Finally process the time events
                    self._process_raw_time_event_handlers(
                        raw_handlers,
                        self._last_ns,
                        only_now=True,
                    )

                    # Drop processed event handlers
                    vec_time_event_handlers_drop(raw_handlers)
                    raw_handlers_count = 0

                self._iteration += 1
        except AccountError as e:
            set_backtest_force_stop(True)
            self._log.error(f"Stopping backtest from {e}")
            if streaming:
                # Reraise exception to interrupt batch streaming
                raise

        # ---------------------------------------------------------------------#

        if FORCE_STOP:
            return

        # Process remaining messages
        for exchange in self._venues.values():
            exchange.process(self._kernel.clock.timestamp_ns())

        # Process remaining time events
        if raw_handlers_count > 0:
            self._process_raw_time_event_handlers(
                raw_handlers,
                self._last_ns,
                only_now=True,
                as_of_now=True,
            )
            vec_time_event_handlers_drop(raw_handlers)

    cdef CVec _advance_time(self, uint64_t ts_now):
        cdef list[TestClock] clocks = get_component_clocks(self._instance_id)
        cdef TestClock clock

        for clock in clocks:
            time_event_accumulator_advance_clock(
                &self._accumulator,
                &clock._mem,
                ts_now,
                False,
            )

        cdef CVec raw_handlers = time_event_accumulator_drain(&self._accumulator)

        # Handle all events prior to the `ts_now`
        self._process_raw_time_event_handlers(
            raw_handlers,
            ts_now,
            only_now=False,
        )

        # Set all clocks to now
        set_logging_clock_static_time(ts_now)

        if LOGGING_PYO3:
            nautilus_pyo3.logging_clock_set_static_time(ts_now)

        for clock in clocks:
            clock.set_time(ts_now)

        # Return all remaining events to be handled (at `ts_now`)
        return raw_handlers

    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef void _process_raw_time_event_handlers(
        self,
        CVec raw_handler_vec,
        uint64_t ts_now,
        bint only_now,
        bint as_of_now = False,
    ):
        cdef TimeEventHandler_t* raw_handlers = <TimeEventHandler_t*>raw_handler_vec.ptr
        cdef:
            uint64_t i
            uint64_t ts_event_init
            uint64_t ts_last_init = 0
            TimeEventHandler_t raw_handler
            TimeEvent event
            TestClock clock
            PyObject *raw_callback
            object callback
            SimulatedExchange exchange
        for i in range(raw_handler_vec.len):
            if FORCE_STOP:
                # The FORCE_STOP flag has already been set,
                # no further time events should be processed.
                return

            raw_handler = <TimeEventHandler_t>raw_handlers[i]
            ts_event_init = raw_handler.event.ts_init

            if should_skip_time_event(ts_event_init, ts_now, only_now, as_of_now):
                continue  # Do not process event

            # Set all clocks to event timestamp
            set_logging_clock_static_time(ts_event_init)

            if LOGGING_PYO3:
                nautilus_pyo3.logging_clock_set_static_time(ts_event_init)

            for clock in get_component_clocks(self._instance_id):
                clock.set_time(ts_event_init)

            event = TimeEvent.from_mem_c(raw_handler.event)

            # Cast raw `PyObject *` to a `PyObject`
            raw_callback = <PyObject *>raw_handler.callback_ptr
            callback = <object>raw_callback
            callback(event)

            if ts_event_init != ts_last_init:
                # Process exchange messages
                ts_last_init = ts_event_init

                for exchange in self._venues.values():
                    exchange.process(ts_event_init)

    def _get_log_color_code(self):
        return "\033[36m" if logging_is_colored() else ""

    def _log_pre_run(self):
        if is_logging_pyo3():
            nautilus_pyo3.log_sysinfo(component=type(self).__name__)
        else:
            log_sysinfo(component=type(self).__name__)

        cdef str color = self._get_log_color_code()

        for exchange in self._venues.values():
            account = exchange.exec_client.get_account()
            self._log.info(f"{color}=================================================================")
            self._log.info(f"{color} SimulatedVenue {exchange.id}")
            self._log.info(f"{color}=================================================================")
            self._log.info(f"{repr(account)}")
            self._log.info(f"{color}-----------------------------------------------------------------")
            self._log.info(f"Balances starting:")

            if exchange.is_frozen_account:
                self._log.warning(f"ACCOUNT FROZEN")
            else:
                for b in account.starting_balances().values():
                    self._log.info(b.to_formatted_str())

    def _log_run(self, start: pd.Timestamp, end: pd.Timestamp):
        cdef str color = self._get_log_color_code()

        self._log.info(f"{color}=================================================================")
        self._log.info(f"{color} BACKTEST RUN")
        self._log.info(f"{color}=================================================================")
        self._log.info(f"Run config ID:  {self._run_config_id}")
        self._log.info(f"Run ID:         {self._run_id}")
        self._log.info(f"Run started:    {format_optional_iso8601(self._run_started)}")
        self._log.info(f"Backtest start: {format_optional_iso8601(self._backtest_start)}")
        self._log.info(f"Batch start:    {format_optional_iso8601(start)}")
        self._log.info(f"Batch end:      {format_optional_iso8601(end)}")
        self._log.info(f"{color}-----------------------------------------------------------------")

    def _log_post_run(self):
        if self._run_finished and self._run_started:
            elapsed_time = self._run_finished - self._run_started
        else:
            elapsed_time = None

        if self._backtest_end and self._backtest_start:
            backtest_range = self._backtest_end - self._backtest_start
        else:
            backtest_range = None

        cdef str color = self._get_log_color_code()

        self._log.info(f"{color}=================================================================")
        self._log.info(f"{color} BACKTEST POST-RUN")
        self._log.info(f"{color}=================================================================")
        self._log.info(f"Run config ID:  {self._run_config_id}")
        self._log.info(f"Run ID:         {self._run_id}")
        self._log.info(f"Run started:    {format_optional_iso8601(self._run_started)}")
        self._log.info(f"Run finished:   {format_optional_iso8601(self._run_finished)}")
        self._log.info(f"Elapsed time:   {elapsed_time}")
        self._log.info(f"Backtest start: {format_optional_iso8601(self._backtest_start)}")
        self._log.info(f"Backtest end:   {format_optional_iso8601(self._backtest_end)}")
        self._log.info(f"Backtest range: {backtest_range}")
        self._log.info(f"Iterations: {self._iteration:_}")
        self._log.info(f"Total events: {self._kernel.exec_engine.event_count:_}")
        self._log.info(f"Total orders: {self._kernel.cache.orders_total_count():_}")

        # Get all positions for venue
        cdef list positions = []

        for position in self._kernel.cache.positions() + self._kernel.cache.position_snapshots():
            positions.append(position)

        self._log.info(f"Total positions: {len(positions):_}")

        if not self._config.run_analysis:
            return

        cdef:
            list venue_positions
            set venue_currencies
        for venue in self._venues.values():
            account = venue.exec_client.get_account()
            self._log.info(f"{color}=================================================================")
            self._log.info(f"{color} SimulatedVenue {venue.id}")
            self._log.info(f"{color}=================================================================")
            self._log.info(f"{repr(account)}")
            self._log.info(f"{color}-----------------------------------------------------------------")
            unrealized_pnls: dict[Currency, Money] | None = None

            if venue.is_frozen_account:
                self._log.warning(f"ACCOUNT FROZEN")
            else:
                if account is None:
                    continue

                self._log.info(f"Balances starting:")

                for b in account.starting_balances().values():
                    self._log.info(b.to_formatted_str())

                self._log.info(f"{color}-----------------------------------------------------------------")
                self._log.info(f"Balances ending:")

                for b in account.balances_total().values():
                    self._log.info(b.to_formatted_str())

                self._log.info(f"{color}-----------------------------------------------------------------")
                self._log.info(f"Commissions:")

                for c in account.commissions().values():
                    self._log.info(Money(-c.as_double(), c.currency).to_formatted_str())  # Display commission as negative

                self._log.info(f"{color}-----------------------------------------------------------------")
                self._log.info(f"Unrealized PnLs (included in totals):")
                unrealized_pnls = self.portfolio.unrealized_pnls(Venue(venue.id.value))

                if not unrealized_pnls:
                    self._log.info("None")
                else:
                    for b in unrealized_pnls.values():
                        self._log.info(b.to_formatted_str())

            # Log output diagnostics for all simulation modules
            for module in venue.modules:
                module.log_diagnostics(self._log)

            self._log.info(f"{color}=================================================================")
            self._log.info(f"{color} PORTFOLIO PERFORMANCE")
            self._log.info(f"{color}=================================================================")

            # Collect all positions and currencies for venue
            venue_positions = []
            venue_currencies = set()

            for position in positions:
                if position.instrument_id.venue == venue.id:
                    venue_positions.append(position)
                    venue_currencies.add(position.quote_currency)

                    if position.base_currency is not None:
                        venue_currencies.add(position.base_currency)

            # Calculate statistics
            self._kernel.portfolio.analyzer.calculate_statistics(account, venue_positions)

            # Present PnL performance stats per asset
            for currency in sorted(list(venue_currencies), key=lambda x: x.code):
                self._log.info(f" PnL Statistics ({str(currency)})")
                self._log.info(f"{color}-----------------------------------------------------------------")
                unrealized_pnl = unrealized_pnls.get(currency) if unrealized_pnls else None

                for stat in self._kernel.portfolio.analyzer.get_stats_pnls_formatted(currency, unrealized_pnl):
                    self._log.info(stat)

                self._log.info(f"{color}-----------------------------------------------------------------")

            self._log.info(" Returns Statistics")
            self._log.info(f"{color}-----------------------------------------------------------------")

            for stat in self._kernel.portfolio.analyzer.get_stats_returns_formatted():
                self._log.info(stat)

            self._log.info(f"{color}-----------------------------------------------------------------")

            self._log.info(" General Statistics")
            self._log.info(f"{color}-----------------------------------------------------------------")

            for stat in self._kernel.portfolio.analyzer.get_stats_general_formatted():
                self._log.info(stat)

            self._log.info(f"{color}-----------------------------------------------------------------")

    def _add_data_client_if_not_exists(self, ClientId client_id) -> None:
        if client_id not in self._kernel.data_engine.registered_clients:
            client = BacktestDataClient(
                client_id=client_id,
                msgbus=self._kernel.msgbus,
                cache=self._kernel.cache,
                clock=self._kernel.clock,
            )
            self._kernel.data_engine.register_client(client)

    def _add_market_data_client_if_not_exists(self, Venue venue) -> None:
        cdef ClientId client_id = ClientId(venue.value)

        if client_id not in self._kernel.data_engine.registered_clients:
            client = BacktestMarketDataClient(
                client_id=client_id,
                msgbus=self._kernel.msgbus,
                cache=self._kernel.cache,
                clock=self._kernel.clock,
            )
            self._kernel.data_engine.register_client(client)

    def set_default_market_data_client(self) -> None:
        cdef ClientId client_id = ClientId("backtest_default_client")
        client = BacktestMarketDataClient(
            client_id=client_id,
            msgbus=self._kernel.msgbus,
            cache=self._kernel.cache,
            clock=self._kernel.clock,
        )
        self._kernel.data_engine.register_client(client)


cdef class BacktestDataIterator:
    """
    Time-ordered multiplexer for historical ``Data`` streams in backtesting.

    The iterator efficiently manages multiple data streams and yields ``Data`` objects
    in strict chronological order based on their ``ts_init`` timestamps. It supports
    both static data lists and dynamic data generators for streaming large datasets.

    **Architecture:**

    - **Single-stream optimization**: When exactly one stream is loaded, uses a fast
      array walk for optimal performance.
    - **Multi-stream merging**: With two or more streams, employs a binary min-heap
      to perform efficient k-way merge sorting.
    - **Dynamic streaming**: Supports Python generators that yield data chunks on-demand,
      enabling processing of datasets larger than available memory.

    **Stream Priority:**

    Streams can be assigned different priorities using the ``append_data`` parameter:

    - ``append_data=True`` (default): Lower priority, processed after existing streams
    - ``append_data=False``: Higher priority, processed before existing streams

    When multiple data points have identical timestamps, higher priority streams
    are yielded first.

    **Performance Characteristics:**

    - **Memory efficient**: Dynamic generators load data incrementally
    - **Time complexity**: O(log n) per item for n streams (heap operations)
    - **Space complexity**: O(k) where k is the total number of active data points
      across all streams at any given time

    Notes
    -----
    When using ``add_data()`` with ``presorted=False`` (default), the data will be
    sorted internally. When using ``presorted=True`` or ``init_data()``, the data
    must be pre-sorted by ``ts_init`` in ascending order.

    See Also
    --------
    BacktestEngine.add_data : Add static data to the backtest engine
    BacktestEngine.add_data_iterator : Add streaming data generators

    """
    def __init__(self) -> None:
        self._log = Logger(type(self).__name__)

        self._data = {} # key=data_priority, value=data_list
        self._data_name = {} # key=data_priority, value=data_name
        self._data_priority = {} # key=data_name, value=data_priority
        self._data_len = {} # key=data_priority, value=len(data_list)
        self._data_index = {} # key=data_priority, value=current index of data_list
        self._data_update_function = {} # key=data_priority, value=data_update_function, Callable[[], list] | None

        self._heap = []
        # Counter for assigning priorities to data streams.
        # Incremented before use so that a priority of zero is never assigned.
        self._next_data_priority = 0
        self._reset_single_data()

    cpdef void _reset_single_data(self):
        self._single_data = []
        self._single_data_name = ""
        self._single_data_priority = 0
        self._single_data_len = 0
        self._single_data_index = 0
        self._is_single_data = False

    def add_data(
        self,
        str data_name,
        list data,
        bint append_data = True,
        bint presorted = False,
    ) -> None:
        """
        Add (or replace) a named data list for static data loading.

        If a stream with the same ``data_name`` already exists, it will be replaced
        with the new data.

        Parameters
        ----------
        data_name : str
            Unique identifier for the data stream.
        data : list[Data]
            Data instances to add. Must be pre-sorted by `ts_init` if ``presorted=True``.
        append_data : bool, default ``True``
            Controls stream priority for timestamp ties:
            ``True`` – lower priority (appended).
            ``False`` – higher priority (prepended).
        presorted : bool, default ``False``
            If ``True``, assumes the data is already sorted by `ts_init` and
            skips internal sorting for better performance. If ``False`` (default),
            the data will be sorted internally.

        Raises
        ------
        ValueError
            If `data_name` is not a valid string.

        """
        Condition.valid_string(data_name, "data_name")

        if not data:
            return

        self._add_data(data_name, data, append_data, presorted)

    def init_data(
        self,
        str data_name,
        data_generator,
        bint append_data = True,
    ) -> None:
        """
        Add (or replace) a named data generator for streaming large datasets.

        This method enables memory-efficient processing of large datasets by using
        Python generators that yield data chunks on-demand. The generator is called
        incrementally as data is consumed, allowing datasets larger than available
        memory to be processed.

        The generator should yield lists of ``Data`` objects, where each list represents
        a chunk of data. When a chunk is exhausted, the iterator automatically calls
        ``next()`` on the generator to fetch the next chunk.

        Parameters
        ----------
        data_name : str
            Unique identifier for the data stream.
        data_generator : Generator[list[Data], None, None]
            A Python generator that yields lists of ``Data`` instances sorted ascending by `ts_init`.
        append_data : bool, default ``True``
            Controls stream priority for timestamp ties:
            ``True`` – lower priority (appended).
            ``False`` – higher priority (prepended).

        Raises
        ------
        ValueError
            If `data_name` is not a valid string.

        """
        Condition.valid_string(data_name, "data_name")

        cdef list[Data] data

        try:
            data = next(data_generator)

            if data:
                self._data_update_function[data_name] = data_generator
                self._add_data(data_name, data, append_data)
                self._log.debug(f"Added {len(data):_} data elements from iterator '{data_name}'")
        except StopIteration:
            # Generator is already exhausted, nothing to add
            pass

    cdef void _add_data(
        self,
        str data_name,
        list data_list,
        bint append_data = True,
        bint presorted = False,
    ):
        if len(data_list) == 0:
            return

        cdef int data_priority

        if data_name in self._data_priority:
            data_priority = self._data_priority[data_name]
            self.remove_data(data_name)
        else:
            # heapq is a min priority queue so smaller values are popped first.
            # Increment the counter *before* applying the sign so that priority
            # zero is never produced (zero would undermine prepend/append
            # semantics when ordering streams).
            self._next_data_priority += 1
            data_priority = (1 if append_data else -1) * self._next_data_priority

        if self._is_single_data:
            self._deactivate_single_data()

        # Copy and optionally sort to avoid aliasing caller's list
        if presorted:
            self._data[data_priority] = list(data_list)
        else:
            self._data[data_priority] = sorted(data_list, key=lambda data: data.ts_init)

        self._data_name[data_priority] = data_name
        self._data_priority[data_name] = data_priority
        self._data_len[data_priority] = len(data_list)
        self._data_index[data_priority] = 0

        if len(self._data) == 1:
            self._activate_single_data()
            return

        self._push_data(data_priority, 0)

    cpdef void remove_data(self, str data_name, bint complete_remove=False):
        """
        Remove the data stream identified by ``data_name``. The operation is silently
        ignored if the specified stream does not exist.

        Parameters
        ----------
        data_name : str
            The unique identifier of the data stream to remove.
        complete_remove : bool, default False
            Controls the level of cleanup performed:
            - ``False``: Remove stream data but preserve generator function for potential
              re-initialization (useful for temporary stream removal)
            - ``True``: Complete removal including any associated generator function
              (recommended for permanent stream removal)

        Raises
        ------
        ValueError
            If `data_name` is not a valid string.

        """
        Condition.valid_string(data_name, "data_name")

        if data_name not in self._data_priority:
            return

        cdef int data_priority = self._data_priority[data_name]
        del self._data[data_priority]
        del self._data_name[data_priority]
        del self._data_priority[data_name]
        del self._data_len[data_priority]
        del self._data_index[data_priority]

        if complete_remove:
            del self._data_update_function[data_name]

        if len(self._data) == 1:
            self._activate_single_data()
            return

        if len(self._data) == 0:
            self._reset_single_data()
            return

        # rebuild heap excluding data_priority
        self._heap = [item for item in self._heap if item[1] != data_priority]
        heapq.heapify(self._heap)

    cpdef void _activate_single_data(self):
        assert len(self._data) == 1

        cdef str single_data_name = list(self._data_name.values())[0]
        self._single_data_name = single_data_name
        self._single_data_priority = self._data_priority[self._single_data_name]
        self._single_data = self._data[self._single_data_priority]
        self._single_data_len = self._data_len[self._single_data_priority]
        self._single_data_index = self._data_index[self._single_data_priority]
        self._heap = []
        self._is_single_data = True

    cpdef void _deactivate_single_data(self):
        assert len(self._heap) == 0

        if self._single_data_index < self._single_data_len:
            self._data_index[self._single_data_priority] = self._single_data_index
            self._push_data(self._single_data_priority, self._single_data_index)

        self._reset_single_data()

    @cython.boundscheck(False)
    @cython.wraparound(False)
    cpdef Data next(self):
        """
        Return the next ``Data`` object in chronological order.

        This method implements the core iteration logic, yielding data points from
        all streams in strict chronological order based on ``ts_init`` timestamps.
        When multiple data points have identical timestamps, stream priority
        determines the order.

        The method automatically handles:
        - Single-stream optimization for performance
        - Multi-stream heap-based merging
        - Dynamic data loading from generators
        - Stream exhaustion and cleanup

        Returns
        -------
        Data or None
            The next ``Data`` object in chronological order, or ``None`` when
            all streams are exhausted.

        Notes
        -----
        - Returns ``None`` when all streams are exhausted
        - Automatically triggers generator calls for streaming data
        - Performance is optimized for single-stream scenarios
        - Thread-safe only when called from a single thread

        """
        cdef:
            uint64_t ts_init
            int data_priority
            int cursor
            Data object_to_return

        if not self._is_single_data:
            if not self._heap:
                return None

            ts_init, data_priority, cursor = heapq.heappop(self._heap)
            object_to_return = self._data[data_priority][cursor]

            self._data_index[data_priority] += 1
            self._push_data(data_priority, self._data_index[data_priority])

            return object_to_return

        if self._single_data_index >= self._single_data_len:
            return None

        object_to_return = self._single_data[self._single_data_index]
        self._single_data_index += 1

        if self._single_data_index >= self._single_data_len:
            self._update_data(self._single_data_priority)

        return object_to_return

    @cython.boundscheck(False)
    @cython.wraparound(False)
    cpdef void _push_data(self, int data_priority, int data_index):
        cdef uint64_t ts_init

        if data_index < self._data_len[data_priority]:
            ts_init = self._data[data_priority][data_index].ts_init
            heapq.heappush(self._heap, (ts_init, data_priority, data_index))
        else:
            self._update_data(data_priority)

    cpdef void _update_data(self, int data_priority):
        cdef str data_name = self._data_name[data_priority]

        if data_name not in self._data_update_function:
            return

        cdef list[Data] data

        try:
            data = next(self._data_update_function[data_name])

            if data:
                # No need for append_data bool as it's an update
                self._add_data(data_name, data)
                self._log.debug(f"Adding {len(data):_} data elements from iterator '{data_name}'")
            else:
                self.remove_data(data_name, complete_remove=True)
        except StopIteration:
            # Generator is exhausted, remove the stream
            self.remove_data(data_name, complete_remove=True)

    cpdef void set_index(self, str data_name, int index):
        """
        Move the cursor of `data_name` to `index` and rebuild ordering.

        Raises
        ------
        ValueError
            If `data_name` is not a valid string.

        """
        Condition.valid_string(data_name, "data_name")

        if data_name not in self._data_priority:
            return

        cdef int data_priority = self._data_priority[data_name]
        self._data_index[data_priority] = index
        self._reset_heap()

    cpdef void _reset_heap(self):
        if len(self._data) == 1:
            self._activate_single_data()
            return

        self._heap = []

        for data_priority, index in self._data_index.items():
            self._push_data(data_priority, index)

    cpdef bint is_done(self):
        """
        Return ``True`` when every stream has been fully consumed.
        """
        if self._is_single_data:
            return self._single_data_index >= self._single_data_len
        else:
            return not self._heap

    cpdef dict all_data(self):
        """
        Return a *shallow* mapping of ``{stream_name: list[Data]}``.
        """
        # we assume dicts are ordered by order of insertion
        return {data_name:self._data[data_priority] for data_priority, data_name in self._data_name.items()}

    cpdef list[Data] data(self, str data_name):
        """
        Return the underlying data list for `data_name`.

        Returns
        -------
        list[Data]

        Raises
        ------
        ValueError
            If `data_name` is not a valid string.
        KeyError
            If the stream is unknown.

        """
        Condition.valid_string(data_name, "data_name")

        return self._data[self._data_priority[data_name]]

    def __iter__(self):
        return self

    def __next__(self):
        cdef Data element
        element = self.next()

        if element is None:
            raise StopIteration

        return element


cdef class SimulatedExchange:
    """
    Provides a simulated exchange venue.

    Parameters
    ----------
    venue : Venue
        The venue to simulate.
    oms_type : OmsType {``HEDGING``, ``NETTING``}
        The order management system type used by the exchange.
    account_type : AccountType
        The account type for the client.
    starting_balances : list[Money]
        The starting balances for the exchange.
    base_currency : Currency, optional
        The account base currency for the client. Use ``None`` for multi-currency accounts.
    default_leverage : Decimal
        The account default leverage (for margin accounts).
    leverages : dict[InstrumentId, Decimal]
        The instrument specific leverage configuration (for margin accounts).
    modules : list[SimulationModule]
        The simulation modules for the exchange.
    portfolio : PortfolioFacade
        The read-only portfolio for the exchange.
    msgbus : MessageBus
        The message bus for the exchange.
    cache : CacheFacade
        The read-only cache for the exchange.
    clock : TestClock
        The clock for the exchange.
    fill_model : FillModel
        The fill model for the exchange.
    fee_model : FeeModel
        The fee model for the exchange.
    latency_model : LatencyModel, optional
        The latency model for the exchange.
    book_type : BookType
        The order book type for the exchange.
    frozen_account : bool, default False
        If the account for this exchange is frozen (balances will not change).
    reject_stop_orders : bool, default True
        If stop orders are rejected on submission if in the market.
    support_gtd_orders : bool, default True
        If orders with GTD time in force will be supported by the exchange.
    support_contingent_orders : bool, default True
        If contingent orders will be supported/respected by the exchange.
        If False, then its expected the strategy will be managing any contingent orders.
    use_position_ids : bool, default True
        If venue position IDs will be generated on order fills.
    use_random_ids : bool, default False
        If all exchange generated identifiers will be random UUID4's.
    use_reduce_only : bool, default True
        If the `reduce_only` execution instruction on orders will be honored.
    use_message_queue : bool, default True
        If an internal message queue should be used to process trading commands in sequence after
        they have initially arrived. Setting this to False would be appropriate for real-time
        sandbox environments, where we don't want to introduce additional latency of waiting for
        the next data event before processing the trading command.
    bar_execution : bool, default True
        If bars should be processed by the matching engine(s) (and move the market).
    bar_adaptive_high_low_ordering : bool, default False
        Determines whether the processing order of bar prices is adaptive based on a heuristic.
        This setting is only relevant when `bar_execution` is True.
        If False, bar prices are always processed in the fixed order: Open, High, Low, Close.
        If True, the processing order adapts with the heuristic:
        - If High is closer to Open than Low then the processing order is Open, High, Low, Close.
        - If Low is closer to Open than High then the processing order is Open, Low, High, Close.
    price_protection_points : int, optional
        Defines an exchange-calculated price boundary (in points) to prevent
        marketable orders from executing at excessively aggressive prices.
    trade_execution : bool, default False
        If trades should be processed by the matching engine(s) (and move the market).

    Raises
    ------
    ValueError
        If `instruments` is empty.
    ValueError
        If `instruments` contains a type other than `Instrument`.
    ValueError
        If `starting_balances` is empty.
    ValueError
        If `starting_balances` contains a type other than `Money`.
    ValueError
        If `base_currency` and multiple starting balances.
    ValueError
        If `modules` contains a type other than `SimulationModule`.

    """

    def __init__(
        self,
        Venue venue not None,
        OmsType oms_type,
        AccountType account_type,
        list starting_balances not None,
        Currency base_currency: Currency | None,
        default_leverage not None: Decimal,
        leverages not None: dict[InstrumentId, Decimal],
        list modules not None,
        PortfolioFacade portfolio not None,
        MessageBus msgbus not None,
        CacheFacade cache not None,
        TestClock clock not None,
        FillModel fill_model not None,
        FeeModel fee_model not None,
        LatencyModel latency_model = None,
        MarginModel margin_model = None,
        BookType book_type = BookType.L1_MBP,
        bint frozen_account = False,
        bint reject_stop_orders = True,
        bint support_gtd_orders = True,
        bint support_contingent_orders = True,
        bint use_position_ids = True,
        bint use_random_ids = False,
        bint use_reduce_only = True,
        bint use_message_queue = True,
        bint bar_execution = True,
        bint bar_adaptive_high_low_ordering = False,
        bint trade_execution = False,
        price_protection_points=None,
    ) -> None:
        Condition.not_empty(starting_balances, "starting_balances")
        Condition.list_type(starting_balances, Money, "starting_balances")
        Condition.list_type(modules, SimulationModule, "modules", "SimulationModule")
        if base_currency:
            Condition.is_true(len(starting_balances) == 1, "single-currency account has multiple starting currencies")
        if default_leverage and default_leverage > 1 or leverages:
            Condition.is_true(account_type == AccountType.MARGIN, "leverages defined when account type is not `MARGIN`")

        self._clock = clock
        self._log = Logger(name=f"{type(self).__name__}({venue})")

        self.id = venue
        self.oms_type = oms_type
        self._log.info(f"OmsType={oms_type_to_str(oms_type)}")
        self.book_type = book_type

        self.msgbus = msgbus
        self.cache = cache
        self.exec_client = None  # Initialized when execution client registered

        # Accounting
        self.account_type = account_type
        self.base_currency = base_currency
        self.starting_balances = starting_balances
        self.default_leverage = default_leverage
        self.leverages = leverages
        self.margin_model = margin_model
        self.is_frozen_account = frozen_account

        # Execution config
        self.reject_stop_orders = reject_stop_orders
        self.support_gtd_orders = support_gtd_orders
        self.support_contingent_orders = support_contingent_orders
        self.use_position_ids = use_position_ids
        self.use_random_ids = use_random_ids
        self.use_reduce_only = use_reduce_only
        self.use_message_queue = use_message_queue
        self.bar_execution = bar_execution
        self.bar_adaptive_high_low_ordering = bar_adaptive_high_low_ordering
        self.trade_execution = trade_execution
        self.price_protection_points = price_protection_points if price_protection_points is not None else 0

        # Execution models
        self.fill_model = fill_model
        self.fee_model = fee_model
        self.latency_model = latency_model

        # Load modules
        self.modules = []
        for module in modules:
            Condition.not_in(module, self.modules, "module", "modules")
            module.register_venue(self)
            module.register_base(
                portfolio=portfolio,
                msgbus=msgbus,
                cache=cache,
                clock=clock,
            )
            self.modules.append(module)
            self._log.info(f"Loaded {module}")

        # Markets
        self.instruments: dict[InstrumentId, Instrument] = {}
        self._matching_engines: dict[InstrumentId, OrderMatchingEngine] = {}

        self._message_queue = deque()
        self._inflight_queue: list[tuple[(uint64_t, uint64_t), TradingCommand]] = []
        self._inflight_counter: dict[uint64_t, uint64_t] = {}

        # For direct communication from SpreadQuoteAggregator
        spread_quote_endpoint = f"SimulatedExchange.spread_quote.{venue}"
        if spread_quote_endpoint not in self.msgbus._endpoints:
            self.msgbus.register(endpoint=spread_quote_endpoint, handler=self.process_quote_tick)

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"id={self.id}, "
            f"oms_type={oms_type_to_str(self.oms_type)}, "
            f"account_type={account_type_to_str(self.account_type)})"
        )

# -- REGISTRATION ---------------------------------------------------------------------------------

    cpdef void register_client(self, BacktestExecClient client):
        """
        Register the given execution client with the simulated exchange.

        Parameters
        ----------
        client : BacktestExecClient
            The client to register

        """
        Condition.not_none(client, "client")

        self.exec_client = client

        self._log.info(f"Registered ExecutionClient-{client}")

    cpdef void set_fill_model(self, FillModel fill_model):
        """
        Set the fill model for all matching engines.

        Parameters
        ----------
        fill_model : FillModel
            The fill model to set.

        """
        Condition.not_none(fill_model, "fill_model")

        self.fill_model = fill_model

        cdef OrderMatchingEngine matching_engine
        for matching_engine in self._matching_engines.values():
            matching_engine.set_fill_model(fill_model)
            self._log.info(
                f"Changed `FillModel` for {matching_engine.venue} "
                f"to {self.fill_model}",
            )

    cpdef void set_latency_model(self, LatencyModel latency_model):
        """
        Change the latency model for this exchange.

        Parameters
        ----------
        latency_model : LatencyModel
            The latency model to set.

        """
        Condition.not_none(latency_model, "latency_model")

        self.latency_model = latency_model

        self._log.info("Changed latency model")

    cpdef void initialize_account(self):
        """
        Initialize the account to the starting balances.

        """
        self._generate_fresh_account_state()

    cpdef void add_instrument(self, Instrument instrument):
        """
        Add the given instrument to the exchange.

        Parameters
        ----------
        instrument : Instrument
            The instrument to add.

        Raises
        ------
        ValueError
            If `instrument.id.venue` is not equal to the venue ID.
        InvalidConfiguration
            If `instrument` is invalid for this venue.

        """
        Condition.not_none(instrument, "instrument")
        Condition.equal(instrument.id.venue, self.id, "instrument.id.venue", "self.id")

        # Validate instrument
        if isinstance(instrument, (CryptoPerpetual, CryptoFuture)):
            if self.account_type == AccountType.CASH:
                raise InvalidConfiguration(
                    f"Cannot add a `{type(instrument).__name__}` type instrument "
                    f"to a venue with a `CASH` account type. Add to a "
                    f"venue with a `MARGIN` account type.",
                )

        self.instruments[instrument.id] = instrument

        cdef OrderMatchingEngine matching_engine = OrderMatchingEngine(
            instrument=instrument,
            raw_id=len(self.instruments),
            fill_model=self.fill_model,
            fee_model=self.fee_model,
            book_type=self.book_type,
            oms_type=self.oms_type,
            account_type=self.account_type,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self._clock,
            reject_stop_orders=self.reject_stop_orders,
            support_gtd_orders=self.support_gtd_orders,
            support_contingent_orders=self.support_contingent_orders,
            use_position_ids=self.use_position_ids,
            use_random_ids=self.use_random_ids,
            use_reduce_only=self.use_reduce_only,
            bar_execution=self.bar_execution,
            bar_adaptive_high_low_ordering=self.bar_adaptive_high_low_ordering,
            trade_execution=self.trade_execution,
            price_protection_points=self.price_protection_points,
        )

        self._matching_engines[instrument.id] = matching_engine

        self._log.info(f"Added instrument {instrument.id} and created matching engine")

# -- QUERIES --------------------------------------------------------------------------------------

    cpdef Price best_bid_price(self, InstrumentId instrument_id):
        """
        Return the best bid price for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the price.

        Returns
        -------
        Price or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(instrument_id)
        if matching_engine is None:
            return None

        return matching_engine.best_bid_price()

    cpdef Price best_ask_price(self, InstrumentId instrument_id):
        """
        Return the best ask price for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the price.

        Returns
        -------
        Price or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(instrument_id)
        if matching_engine is None:
            return None

        return matching_engine.best_ask_price()

    cpdef OrderBook get_book(self, InstrumentId instrument_id):
        """
        Return the order book for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the price.

        Returns
        -------
        OrderBook or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(instrument_id)
        if matching_engine is None:
            return None

        return matching_engine.get_book()

    cpdef OrderMatchingEngine get_matching_engine(self, InstrumentId instrument_id):
        """
        Return the matching engine for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the matching engine.

        Returns
        -------
        OrderMatchingEngine or ``None``

        """
        return self._matching_engines.get(instrument_id)

    cpdef dict get_matching_engines(self):
        """
        Return all matching engines for the exchange (for every instrument).

        Returns
        -------
        dict[InstrumentId, OrderMatchingEngine]

        """
        return self._matching_engines.copy()

    cpdef dict get_books(self):
        """
        Return all order books within the exchange.

        Returns
        -------
        dict[InstrumentId, OrderBook]

        """
        cdef dict books = {}

        cdef OrderMatchingEngine matching_engine
        for matching_engine in self._matching_engines.values():
            books[matching_engine.instrument.id] = matching_engine.get_book()

        return books

    cpdef list get_open_orders(self, InstrumentId instrument_id = None):
        """
        Return the open orders at the exchange.

        Parameters
        ----------
        instrument_id : InstrumentId, optional
            The instrument_id query filter.

        Returns
        -------
        list[Order]

        """
        cdef OrderMatchingEngine matching_engine
        if instrument_id is not None:
            matching_engine = self._matching_engines.get(instrument_id)
            if matching_engine is None:
                return []
            else:
                return matching_engine.get_open_orders()

        cdef list open_orders = []
        for matching_engine in self._matching_engines.values():
            open_orders += matching_engine.get_open_orders()

        return open_orders

    cpdef list get_open_bid_orders(self, InstrumentId instrument_id = None):
        """
        Return the open bid orders at the exchange.

        Parameters
        ----------
        instrument_id : InstrumentId, optional
            The instrument_id query filter.

        Returns
        -------
        list[Order]

        """
        cdef OrderMatchingEngine matching_engine
        if instrument_id is not None:
            matching_engine = self._matching_engines.get(instrument_id)
            if matching_engine is None:
                return []
            else:
                return matching_engine.get_open_bid_orders()

        cdef list open_bid_orders = []
        for matching_engine in self._matching_engines.values():
            open_bid_orders += matching_engine.get_open_bid_orders()

        return open_bid_orders

    cpdef list get_open_ask_orders(self, InstrumentId instrument_id = None):
        """
        Return the open ask orders at the exchange.

        Parameters
        ----------
        instrument_id : InstrumentId, optional
            The instrument_id query filter.

        Returns
        -------
        list[Order]

        """
        cdef OrderMatchingEngine matching_engine
        if instrument_id is not None:
            matching_engine = self._matching_engines.get(instrument_id)
            if matching_engine is None:
                return []
            else:
                return matching_engine.get_open_ask_orders()

        cdef list open_ask_orders = []
        for matching_engine in self._matching_engines.values():
            open_ask_orders += matching_engine.get_open_ask_orders()

        return open_ask_orders

    cpdef Account get_account(self):
        """
        Return the account for the registered client (if registered).

        Returns
        -------
        Account or ``None``

        """
        Condition.not_none(self.exec_client, "self.exec_client")

        return self.exec_client.get_account()

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void adjust_account(self, Money adjustment):
        """
        Adjust the account at the exchange with the given adjustment.

        Parameters
        ----------
        adjustment : Money
            The adjustment for the account.

        """
        Condition.not_none(adjustment, "adjustment")

        if self.is_frozen_account:
            return  # Nothing to adjust

        cdef Account account = self.cache.account_for_venue(self.exec_client.venue)
        if account is None:
            self._log.error(
                f"Cannot adjust account: no account found for {self.exec_client.venue}"
            )
            return

        cdef AccountBalance balance = account.balance(adjustment.currency)
        if balance is None:
            self._log.error(
                f"Cannot adjust account: no balance found for {adjustment.currency}"
            )
            return

        balance.total = Money(balance.total + adjustment, adjustment.currency)
        balance.free = Money(balance.free + adjustment, adjustment.currency)

        cdef list margins = []
        if account.is_margin_account:
            margins = list(account.margins().values())

        # Generate and handle event
        self.exec_client.generate_account_state(
            balances=[balance],
            margins=margins,
            reported=True,
            ts_event=self._clock.timestamp_ns(),
        )

    cpdef void update_instrument(self, Instrument instrument):
        """
        Update the venues current instrument definition with the given instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument definition to update.

        """
        Condition.not_none(instrument, "instrument")

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(instrument.id)
        if matching_engine is None:
            self.add_instrument(instrument)
            return

        matching_engine.update_instrument(instrument)

    cpdef void send(self, TradingCommand command):
        """
        Send the given trading command into the exchange.

        Parameters
        ----------
        command : TradingCommand
            The command to send.

        """
        Condition.not_none(command, "command")

        if not self.use_message_queue:
            self._process_trading_command(command)
        elif self.latency_model is None:
            self._message_queue.appendleft(command)
        else:
            heappush(self._inflight_queue, self.generate_inflight_command(command))

    cdef tuple generate_inflight_command(self, TradingCommand command):
        cdef uint64_t ts
        if isinstance(command, (SubmitOrder, SubmitOrderList)):
            ts = command.ts_init + self.latency_model.insert_latency_nanos
        elif isinstance(command, ModifyOrder):
            ts = command.ts_init + self.latency_model.update_latency_nanos
        elif isinstance(command, (CancelOrder, CancelAllOrders, BatchCancelOrders)):
            ts = command.ts_init + self.latency_model.cancel_latency_nanos
        else:
            raise ValueError(f"invalid `TradingCommand`, was {command}")  # pragma: no cover (design-time error)

        if ts not in self._inflight_counter:
            self._inflight_counter[ts] = 0

        self._inflight_counter[ts] += 1
        cdef (uint64_t, uint64_t) key = (ts, self._inflight_counter[ts])

        return key, command

    cpdef void process_order_book_delta(self, OrderBookDelta delta):
        """
        Process the exchanges market for the given order book delta.

        Parameters
        ----------
        data : OrderBookDelta
            The order book delta to process.

        """
        Condition.not_none(delta, "delta")

        cdef SimulationModule module
        for module in self.modules:
            module.pre_process(delta)

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(delta.instrument_id)
        if matching_engine is None:
            instrument = self.cache.instrument(delta.instrument_id)
            if instrument is None:
                raise RuntimeError(f"No matching engine found for {delta.instrument_id}")

            self.add_instrument(instrument)
            matching_engine = self._matching_engines[delta.instrument_id]

        matching_engine.process_order_book_delta(delta)

    cpdef void process_order_book_deltas(self, OrderBookDeltas deltas):
        """
        Process the exchanges market for the given order book deltas.

        Parameters
        ----------
        data : OrderBookDeltas
            The order book deltas to process.

        """
        Condition.not_none(deltas, "deltas")

        cdef SimulationModule module
        for module in self.modules:
            module.pre_process(deltas)

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(deltas.instrument_id)
        if matching_engine is None:
            instrument = self.cache.instrument(deltas.instrument_id)
            if instrument is None:
                raise RuntimeError(f"No matching engine found for {deltas.instrument_id}")

            self.add_instrument(instrument)
            matching_engine = self._matching_engines[deltas.instrument_id]

        matching_engine.process_order_book_deltas(deltas)

    cpdef void process_order_book_depth10(self, OrderBookDepth10 depth):
        """
        Process the exchanges market for the given order book depth.

        Parameters
        ----------
        depth : OrderBookDepth10
            The order book depth to process.

        """
        Condition.not_none(depth, "depth")

        cdef SimulationModule module
        for module in self.modules:
            module.pre_process(depth)

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(depth.instrument_id)
        if matching_engine is None:
            instrument = self.cache.instrument(depth.instrument_id)
            if instrument is None:
                raise RuntimeError(f"No matching engine found for {depth.instrument_id}")

            self.add_instrument(instrument)
            matching_engine = self._matching_engines[depth.instrument_id]

        matching_engine.process_order_book_depth10(depth)

    cpdef void process_quote_tick(self, QuoteTick tick):
        """
        Process the exchanges market for the given quote tick.

        Market dynamics are simulated by auctioning open orders.

        Parameters
        ----------
        tick : QuoteTick
            The tick to process.

        """
        Condition.not_none(tick, "tick")

        cdef SimulationModule module
        for module in self.modules:
            module.pre_process(tick)

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(tick.instrument_id)
        if matching_engine is None:
            instrument = self.cache.instrument(tick.instrument_id)
            if instrument is None:
                raise RuntimeError(f"No matching engine found for {tick.instrument_id}")

            self.add_instrument(instrument)
            matching_engine = self._matching_engines[tick.instrument_id]

        matching_engine.process_quote_tick(tick)

    cpdef void process_trade_tick(self, TradeTick tick):
        """
        Process the exchanges market for the given trade tick.

        Market dynamics are simulated by auctioning open orders.

        Parameters
        ----------
        tick : TradeTick
            The tick to process.

        """
        Condition.not_none(tick, "tick")

        cdef SimulationModule module
        for module in self.modules:
            module.pre_process(tick)

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(tick.instrument_id)
        if matching_engine is None:
            instrument = self.cache.instrument(tick.instrument_id)
            if instrument is None:
                raise RuntimeError(f"No matching engine found for {tick.instrument_id}")

            self.add_instrument(instrument)
            matching_engine = self._matching_engines[tick.instrument_id]

        matching_engine.process_trade_tick(tick)

    cpdef void process_bar(self, Bar bar):
        """
        Process the exchanges market for the given bar.

        Market dynamics are simulated by auctioning open orders.

        Parameters
        ----------
        bar : Bar
            The bar to process.

        """
        Condition.not_none(bar, "bar")

        cdef SimulationModule module
        for module in self.modules:
            module.pre_process(bar)

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(bar.bar_type.instrument_id)
        if matching_engine is None:
            instrument = self.cache.instrument(bar.bar_type.instrument_id)
            if instrument is None:
                raise RuntimeError(f"No matching engine found for {bar.bar_type.instrument_id}")

            self.add_instrument(instrument)
            matching_engine = self._matching_engines[bar.bar_type.instrument_id]

        matching_engine.process_bar(bar)

    cpdef void process_instrument_status(self, InstrumentStatus data):
        """
        Process a specific instrument status.

        Parameters
        ----------
        data : InstrumentStatus
            The instrument status update to process.

        """
        Condition.not_none(data, "data")

        cdef SimulationModule module
        for module in self.modules:
            module.pre_process(data)

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(data.instrument_id)
        if matching_engine is None:
            instrument = self.cache.instrument(data.instrument_id)
            if instrument is None:
                raise RuntimeError(f"No matching engine found for {data.instrument_id}")

            self.add_instrument(instrument)
            matching_engine = self._matching_engines[data.instrument_id]

        matching_engine.process_status(data.action)

    cpdef void process_instrument_close(self, InstrumentClose close):
        """
        Process the exchanges market for the given instrument close.

        Parameters
        ----------
        close : InstrumentClose
            The instrument close to process.

        """
        Condition.not_none(close, "close")

        cdef SimulationModule module
        for module in self.modules:
            module.pre_process(close)

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(close.instrument_id)
        if matching_engine is None:
            instrument = self.cache.instrument(close.instrument_id)
            if instrument is None:
                raise RuntimeError(f"No matching engine found for {close.instrument_id}")

            self.add_instrument(instrument)
            matching_engine = self._matching_engines[close.instrument_id]

        matching_engine.process_instrument_close(close)

    cpdef void process(self, uint64_t ts_now):
        """
        Process the exchange to the given time.

        All pending commands will be processed along with all simulation modules.

        Parameters
        ----------
        ts_now : uint64_t
            The current UNIX timestamp (nanoseconds).

        """
        self._clock.set_time(ts_now)

        cdef:
            uint64_t ts
        while self._inflight_queue:
            # Peek at timestamp of next in-flight message
            ts = self._inflight_queue[0][0][0]
            if ts <= ts_now:
                # Place message on queue to be processed
                self._message_queue.appendleft(self._inflight_queue.pop(0)[1])
                self._inflight_counter.pop(ts, None)
            else:
                break

        cdef TradingCommand command
        while self._message_queue:
            command = self._message_queue.pop()
            self._process_trading_command(command)

        # Iterate over modules
        cdef SimulationModule module
        for module in self.modules:
            module.process(ts_now)

    cpdef void reset(self):
        """
        Reset the simulated exchange.

        All stateful fields are reset to their initial value.
        """
        self._log.debug(f"Resetting")

        for module in self.modules:
            module.reset()

        self._generate_fresh_account_state()

        for matching_engine in self._matching_engines.values():
            matching_engine.reset()

        self._message_queue = deque()
        self._inflight_queue.clear()
        self._inflight_counter.clear()

        self._log.info("Reset")

    cdef void _process_trading_command(self, TradingCommand command):

        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(command.instrument_id)
        if matching_engine is None:
            raise RuntimeError(f"Cannot process command: no matching engine for {command.instrument_id}")

        cdef:
            Order order
            list[Order] orders
        if isinstance(command, SubmitOrder):
            matching_engine.process_order(command.order, self.exec_client.account_id)
        elif isinstance(command, SubmitOrderList):
            for order in command.order_list.orders:
                matching_engine.process_order(order, self.exec_client.account_id)
        elif isinstance(command, ModifyOrder):
            # Check if order is in SUBMITTED status or PENDING_UPDATE with previous SUBMITTED status
            # (bracket orders not yet at matching engine)
            order = self.cache.order(command.client_order_id)
            if (order is not None and
                (order.status_c() == OrderStatus.SUBMITTED or
                 (order.status_c() == OrderStatus.PENDING_UPDATE and order._previous_status == OrderStatus.SUBMITTED))):
                # Handle modification locally for bracket orders not yet sent to matching engine
                self._process_modify_submitted_order(command)
            else:
                matching_engine.process_modify(command, self.exec_client.account_id)
        elif isinstance(command, CancelOrder):
            matching_engine.process_cancel(command, self.exec_client.account_id)
        elif isinstance(command, CancelAllOrders):
            matching_engine.process_cancel_all(command, self.exec_client.account_id)
        elif isinstance(command, BatchCancelOrders):
            matching_engine.process_batch_cancel(command, self.exec_client.account_id)

    cdef void _process_modify_submitted_order(self, ModifyOrder command):
        """
        Process modification of an order that is in SUBMITTED status.

        This handles bracket orders (TP/SL) that haven't been sent to the matching engine yet.
        """
        cdef Order order = self.cache.order(command.client_order_id)
        if order is None:
            self._generate_order_modify_rejected(
                command.trader_id,
                command.strategy_id,
                command.instrument_id,
                command.client_order_id,
                None,
                f"{command.client_order_id!r} not found",
                self.exec_client.account_id,
            )
            return

        # Apply the modification directly to the order
        cdef:
            Quantity new_quantity = command.quantity if command.quantity is not None else order.quantity
            Price new_price = command.price if command.price is not None else (order.price if hasattr(order, 'price') else None)
            Price new_trigger_price = command.trigger_price if command.trigger_price is not None else (order.trigger_price if hasattr(order, 'trigger_price') else None)

        # Generate OrderUpdated event
        self._generate_order_updated(
            order,
            new_quantity,
            new_price,
            new_trigger_price,
        )

    cdef void _generate_order_modify_rejected(
        self,
        TraderId trader_id,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        str reason,
        AccountId account_id,
    ):
        """Generate an OrderModifyRejected event."""
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderModifyRejected event = OrderModifyRejected(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=account_id,
            reason=reason,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cdef void _generate_order_updated(
        self,
        Order order,
        Quantity quantity,
        Price price,
        Price trigger_price,
    ):
        """Generate an OrderUpdated event."""
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderUpdated event = OrderUpdated(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id,
            quantity=quantity,
            price=price,
            trigger_price=trigger_price,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

# -- EVENT GENERATORS -----------------------------------------------------------------------------

    cdef void _generate_fresh_account_state(self):
        cdef list balances = [
            AccountBalance(
                total=money,
                locked=Money(0, money.currency),
                free=money,
            )
            for money in self.starting_balances
        ]

        self.exec_client.generate_account_state(
            balances=balances,
            margins=[],
            reported=True,
            ts_event=self._clock.timestamp_ns(),
        )

        # Set leverages and margin model
        cdef Account account = self.get_account()
        if account.is_margin_account:
            account.set_default_leverage(self.default_leverage)

            # Set instrument specific leverages
            for instrument_id, leverage in self.leverages.items():
                account.set_leverage(instrument_id, leverage)

            # Set margin model if provided
            if self.margin_model is not None:
                account.set_margin_model(self.margin_model)


cdef class OrderMatchingEngine:
    """
    Provides an order matching engine for a single market.

    Parameters
    ----------
    instrument : Instrument
        The market instrument for the matching engine.
    raw_id : uint32_t
        The raw integer ID for the instrument.
    fill_model : FillModel
        The fill model for the matching engine.
    fee_model : FeeModel
        The fee model for the matching engine.
    book_type : BookType
        The order book type for the engine.
    oms_type : OmsType
        The order management system type for the matching engine. Determines
        the generation and handling of venue position IDs.
    account_type : AccountType
        The account type for the matching engine. Determines allowable
        executions based on the instrument.
    msgbus : MessageBus
        The message bus for the matching engine.
    cache : CacheFacade
        The read-only cache for the matching engine.
    clock : TestClock
        The clock for the matching engine.
    logger : Logger
        The logger for the matching engine.
    bar_execution : bool, default True
        If bars should be processed by the matching engine (and move the market).
    trade_execution : bool, default False
        If trades should be processed by the matching engine (and move the market).
    reject_stop_orders : bool, default True
        If stop orders are rejected if already in the market on submitting.
    support_gtd_orders : bool, default True
        If orders with GTD time in force will be supported by the venue.
    support_contingent_orders : bool, default True
        If contingent orders will be supported/respected by the venue.
        If False, then its expected the strategy will be managing any contingent orders.
    use_position_ids : bool, default True
        If venue position IDs will be generated on order fills.
    use_random_ids : bool, default False
        If all venue generated identifiers will be random UUID4's.
    use_reduce_only : bool, default True
        If the `reduce_only` execution instruction on orders will be honored.
    bar_adaptive_high_low_ordering : bool, default False
        Determines whether the processing order of bar prices is adaptive based on a heuristic.
        This setting is only relevant when `bar_execution` is True.
        If False, bar prices are always processed in the fixed order: Open, High, Low, Close.
        If True, the processing order adapts with the heuristic:
        - If High is closer to Open than Low then the processing order is Open, High, Low, Close.
        - If Low is closer to Open than High then the processing order is Open, Low, High, Close.

    """

    def __init__(
        self,
        Instrument instrument not None,
        uint32_t raw_id,
        FillModel fill_model not None,
        FeeModel fee_model not None,
        BookType book_type,
        OmsType oms_type,
        AccountType account_type,
        MessageBus msgbus not None,
        CacheFacade cache not None,
        TestClock clock not None,
        bint reject_stop_orders = True,
        bint support_gtd_orders = True,
        bint support_contingent_orders = True,
        bint use_position_ids = True,
        bint use_random_ids = False,
        bint use_reduce_only = True,
        bint bar_execution = True,
        bint bar_adaptive_high_low_ordering = False,
        bint trade_execution = False,
        price_protection_points=None,
    ) -> None:
        self._clock = clock
        self._log = Logger(name=f"{type(self).__name__}({instrument.id.venue})")
        self.msgbus = msgbus
        self.cache = cache

        self.venue = instrument.id.venue
        self.instrument = instrument
        self.raw_id = raw_id
        self.book_type = book_type
        self.oms_type = oms_type
        self.account_type = account_type
        self.market_status = MarketStatus.OPEN

        self._instrument_has_expiration = instrument.instrument_class in EXPIRING_INSTRUMENT_CLASSES
        self._instrument_close = None
        self._reject_stop_orders = reject_stop_orders
        self._support_gtd_orders = support_gtd_orders
        self._support_contingent_orders = support_contingent_orders
        self._use_position_ids = use_position_ids
        self._use_random_ids = use_random_ids
        self._use_reduce_only = use_reduce_only
        self._bar_execution = bar_execution
        self._bar_adaptive_high_low_ordering = bar_adaptive_high_low_ordering
        self._trade_execution = trade_execution
        self._price_protection_points = price_protection_points if price_protection_points is not None else 0

        self._fill_model = fill_model
        self._fee_model = fee_model
        self._book = OrderBook(
            instrument_id=instrument.id,
            book_type=book_type,
        )

        self._account_ids: dict[TraderId, AccountId]  = {}
        self._execution_bar_types: dict[InstrumentId, BarType]  =  {}
        self._execution_bar_deltas: dict[BarType, timedelta]  =  {}
        self._cached_filled_qty: dict[ClientOrderId, Quantity] = {}

        # Market
        self._core = MatchingCore(
            instrument_id=instrument.id,
            price_increment=instrument.price_increment,
            trigger_stop_order=self.trigger_stop_order,
            fill_market_order=self.fill_market_order,
            fill_limit_order=self.fill_limit_order,
        )

        self._target_bid = 0
        self._target_ask = 0
        self._target_last = 0
        self._has_targets = False
        self._last_bid_bar: Bar | None = None
        self._last_ask_bar: Bar | None = None
        self._last_trade_size: Quantity | None = None

        self._position_count = 0
        self._order_count = 0
        self._execution_count = 0

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"venue={self.venue.value}, "
            f"instrument_id={self.instrument.id.value}, "
            f"raw_id={self.raw_id})"
        )

    cpdef void reset(self):
        self._log.debug(f"Resetting OrderMatchingEngine {self.instrument.id}")

        self._book.clear(0, 0)
        self._account_ids.clear()
        self._execution_bar_types.clear()
        self._execution_bar_deltas.clear()
        self._cached_filled_qty.clear()
        self._core.reset()
        self._target_bid = 0
        self._target_ask = 0
        self._target_last = 0
        self._has_targets = False
        self._last_bid_bar = None
        self._last_ask_bar = None
        self._last_trade_size = None

        self._position_count = 0
        self._order_count = 0
        self._execution_count = 0

        self._log.info(f"Reset OrderMatchingEngine {self.instrument.id}")

    cpdef void set_fill_model(self, FillModel fill_model):
        """
        Set the fill model to the given model.

        Parameters
        ----------
        fill_model : FillModel
            The fill model to set.

        """
        Condition.not_none(fill_model, "fill_model")

        self._fill_model = fill_model

        self._log.debug(f"Changed `FillModel` to {self._fill_model}")

    cpdef void update_instrument(self, Instrument instrument):
        """
        Update the matching engines current instrument definition with the given instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument definition to update.

        """
        Condition.not_none(instrument, "instrument")
        Condition.equal(instrument.id, self.instrument.id, "instrument.id", "self.instrument.id")

        self.instrument = instrument

        self._log.debug(f"Updated instrument definition for {instrument.id}")

# -- QUERIES --------------------------------------------------------------------------------------

    cpdef Price best_bid_price(self):
        """
        Return the best bid price for the given instrument ID (if found).

        Returns
        -------
        Price or ``None``

        """
        return self._book.best_bid_price()

    cpdef Price best_ask_price(self):
        """
        Return the best ask price for the given instrument ID (if found).

        Returns
        -------
        Price or ``None``

        """
        return self._book.best_ask_price()

    cpdef OrderBook get_book(self):
        """
        Return the internal order book.

        Returns
        -------
        OrderBook

        """
        return self._book

    cpdef list get_open_orders(self):
        """
        Return the open orders in the matching engine.

        Returns
        -------
        list[Order]

        """
        return self.get_open_bid_orders() + self.get_open_ask_orders()

    cpdef list get_open_bid_orders(self):
        """
        Return the open bid orders in the matching engine.

        Returns
        -------
        list[Order]

        """
        return self._core.get_orders_bid()

    cpdef list get_open_ask_orders(self):
        """
        Return the open ask orders at the exchange.

        Returns
        -------
        list[Order]

        """
        return self._core.get_orders_ask()

    cpdef bint order_exists(self, ClientOrderId client_order_id):
        return self._core.order_exists(client_order_id)

# -- DATA PROCESSING ------------------------------------------------------------------------------

    cpdef void process_order_book_delta(self, OrderBookDelta delta):
        """
        Process the exchanges market for the given order book delta.

        Parameters
        ----------
        delta : OrderBookDelta
            The order book delta to process.

        """
        Condition.not_none(delta, "delta")

        if is_logging_initialized():
            self._log.debug(f"Processing {delta!r}")

        self._book.apply_delta(delta)

        self.iterate(delta.ts_init)

    cpdef void process_order_book_deltas(self, OrderBookDeltas deltas):
        """
        Process the exchanges market for the given order book deltas.

        Parameters
        ----------
        delta : OrderBookDeltas
            The order book deltas to process.

        """
        Condition.not_none(deltas, "deltas")

        if is_logging_initialized():
            self._log.debug(f"Processing {deltas!r}")

        self._book.apply_deltas(deltas)

        self.iterate(deltas.ts_init)

    cpdef void process_order_book_depth10(self, OrderBookDepth10 depth):
        """
        Process the exchanges market for the given order book depth.

        Parameters
        ----------
        depth : OrderBookDepth10
            The order book depth to process.

        """
        Condition.not_none(depth, "depth")

        if is_logging_initialized():
            self._log.debug(f"Processing {depth!r}")

        self._book.apply_depth(depth)

        self.iterate(depth.ts_init)


    cpdef void process_quote_tick(self, QuoteTick tick) :
        """
        Process the exchanges market for the given quote tick.

        The internal order book will only be updated if the venue `book_type` is 'L1_MBP'.

        Parameters
        ----------
        tick : QuoteTick
            The tick to process.

        Raises
        ------
        RuntimeError
            If a price precision does not match the instrument for the matching engine.
        RuntimeError
            If a size precision does not match the instrument for the matching engine.

        """
        Condition.not_none(tick, "tick")

        if is_logging_initialized():
            self._log.debug(f"Processing {tick!r}")

        # Validate precisions
        if tick._mem.bid_price.precision != self.instrument.price_precision:
            raise RuntimeError(
                f"invalid {tick.bid_price.precision=} did not match {self.instrument.price_precision=}",
            )
        if tick._mem.ask_price.precision != self.instrument.price_precision:
            raise RuntimeError(
                f"invalid {tick.ask_price.precision=} did not match {self.instrument.price_precision=}",
            )
        if tick._mem.bid_size.precision != self.instrument.size_precision:
            raise RuntimeError(
                f"invalid {tick.bid_size.precision=} did not match {self.instrument.size_precision=}",
            )
        if tick._mem.ask_size.precision != self.instrument.size_precision:
            raise RuntimeError(
                f"invalid {tick.ask_size.precision=} did not match {self.instrument.size_precision=}",
            )

        if self.book_type == BookType.L1_MBP:
            self._book.update_quote_tick(tick)

        self.iterate(tick.ts_init)

    cpdef void process_trade_tick(self, TradeTick tick):
        """
        Process the exchanges market for the given trade tick.

        The internal order book will only be updated if the venue `book_type` is 'L1_MBP'.

        Parameters
        ----------
        tick : TradeTick
            The tick to process.

        Raises
        ------
        RuntimeError
            If the trades price precision does not match the instrument for the matching engine.
        RuntimeError
            If the trades size precision does not match the instrument for the matching engine.

        """
        Condition.not_none(tick, "tick")

        if is_logging_initialized():
            self._log.debug(f"Processing {tick!r}")

        # Validate precisions
        if tick._mem.price.precision != self.instrument.price_precision:
            raise RuntimeError(
                f"invalid {tick.price.precision=} did not match {self.instrument.price_precision=}",
            )
        if tick._mem.size.precision != self.instrument.size_precision:
            raise RuntimeError(
                f"invalid {tick.size.precision=} did not match {self.instrument.size_precision=}",
            )

        if self.book_type == BookType.L1_MBP:
            self._book.update_trade_tick(tick)

        cdef AggressorSide aggressor_side = AggressorSide.NO_AGGRESSOR
        cdef PriceRaw price_raw = tick._mem.price.raw
        cdef PriceRaw original_bid = 0
        cdef PriceRaw original_ask = 0

        self._core.set_last_raw(price_raw)

        if self._trade_execution:
            aggressor_side = tick.aggressor_side

            # Update the natural side based on trade
            if aggressor_side == AggressorSide.BUYER:
                if not self._core.is_ask_initialized or price_raw > self._core.ask_raw:
                    self._core.set_ask_raw(price_raw)
                if not self._core.is_bid_initialized or price_raw < self._core.bid_raw:
                    self._core.set_bid_raw(price_raw)
            elif aggressor_side == AggressorSide.SELLER:
                if not self._core.is_bid_initialized or price_raw < self._core.bid_raw:
                    self._core.set_bid_raw(price_raw)
                if not self._core.is_ask_initialized or price_raw > self._core.ask_raw:
                    self._core.set_ask_raw(price_raw)
            elif aggressor_side == AggressorSide.NO_AGGRESSOR:
                if not self._core.is_bid_initialized or price_raw <= self._core.bid_raw:
                    self._core.set_bid_raw(price_raw)
                if not self._core.is_ask_initialized or price_raw >= self._core.ask_raw:
                    self._core.set_ask_raw(price_raw)
            else:
                aggressor_side_str = aggressor_side_to_str(aggressor_side)
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"invalid `AggressorSide` for trade execution, was {aggressor_side_str}",  # pragma: no cover
                )

            # Transient override: temporarily drag the opposite side to the trade price
            original_bid = self._core.bid_raw
            original_ask = self._core.ask_raw

            if aggressor_side == AggressorSide.SELLER and price_raw < original_ask:
                self._core.set_ask_raw(price_raw)
            elif aggressor_side == AggressorSide.BUYER and price_raw > original_bid:
                self._core.set_bid_raw(price_raw)

            # Set last trade size for fill quantity capping
            self._last_trade_size = tick.size

        self.iterate(tick.ts_init, aggressor_side)

        if self._trade_execution:
            # Reset trade size after matching
            self._last_trade_size = None

            # Restore original state after matching
            if aggressor_side == AggressorSide.SELLER and price_raw < original_ask:
                self._core.set_ask_raw(original_ask)
            elif aggressor_side == AggressorSide.BUYER and price_raw > original_bid:
                self._core.set_bid_raw(original_bid)

    cpdef void process_bar(self, Bar bar):
        """
        Process the exchanges market for the given bar.

        Market dynamics are simulated by auctioning open orders.

        Parameters
        ----------
        bar : Bar
            The bar to process.

        Raises
        ------
        RuntimeError
            If a price precision does not match the instrument for the matching engine.
        RuntimeError
            If a size precision does not match the instrument for the matching engine.

        """
        Condition.not_none(bar, "bar")

        if not self._bar_execution:
            return

        if self.book_type != BookType.L1_MBP:
            return  # Can only process an L1 book with bars

        cdef BarType bar_type = bar.bar_type
        if bar_type.aggregation_source == AggregationSource.INTERNAL:
            return  # Do not process internally aggregated bars

        # Validate precisions
        if bar._mem.open.precision != self.instrument.price_precision:
            raise RuntimeError(
                f"invalid {bar.open.precision=} did not match {self.instrument.price_precision=}",
            )
        if bar._mem.high.precision != self.instrument.price_precision:
            raise RuntimeError(
                f"invalid {bar.high.precision=} did not match {self.instrument.price_precision=}",
            )
        if bar._mem.low.precision != self.instrument.price_precision:
            raise RuntimeError(
                f"invalid {bar.low.precision=} did not match {self.instrument.price_precision=}",
            )
        if bar._mem.close.precision != self.instrument.price_precision:
            raise RuntimeError(
                f"invalid {bar.close.precision=} did not match {self.instrument.price_precision=}",
            )
        if bar._mem.volume.precision != self.instrument.size_precision:
            raise RuntimeError(
                f"invalid {bar.volume.precision=} did not match {self.instrument.size_precision=}",
            )

        cdef InstrumentId instrument_id = bar_type.instrument_id
        cdef BarType execution_bar_type = self._execution_bar_types.get(instrument_id)

        if execution_bar_type is None:
            execution_bar_type = bar_type
            self._execution_bar_types[instrument_id] = bar_type
            self._execution_bar_deltas[bar_type] = bar_type.spec.timedelta

        if execution_bar_type != bar_type:
            bar_type_timedelta = self._execution_bar_deltas.get(bar_type)

            if bar_type_timedelta is None:
                bar_type_timedelta = bar_type.spec.timedelta
                self._execution_bar_deltas[bar_type] = bar_type_timedelta

            if self._execution_bar_deltas[execution_bar_type] >= bar_type_timedelta:
                self._execution_bar_types[instrument_id] = bar_type
            else:
                return

        if is_logging_initialized():
            self._log.debug(f"Processing {bar!r}")

        cdef PriceType price_type = bar_type.spec.price_type
        if price_type == PriceType.LAST or price_type == PriceType.MID:
            self._process_trade_ticks_from_bar(bar)
        elif price_type == PriceType.BID:
            self._last_bid_bar = bar
            self._process_quote_ticks_from_bar()
        elif price_type == PriceType.ASK:
            self._last_ask_bar = bar
            self._process_quote_ticks_from_bar()
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"invalid `PriceType`, was {price_type}",  # pragma: no cover
            )

    cpdef void process_status(self, MarketStatusAction status):
        """
        Process the exchange status.

        Parameters
        ----------
        status : MarketStatusAction
            The status action to process.

        """
        if (self.market_status, status) == (MarketStatus.CLOSED, MarketStatusAction.TRADING):
            self.market_status = MarketStatus.OPEN
        elif (self.market_status, status) == (MarketStatus.CLOSED, MarketStatusAction.PRE_OPEN):
            self.market_status = MarketStatus.OPEN

    cpdef void process_instrument_close(self, InstrumentClose close):
        """
        Process the instrument close.

        Parameters
        ----------
        close : InstrumentClose
            The close price to process.

        """
        if close.instrument_id != self.instrument.id:
            self._log.warning(f"Received instrument close for unknown instrument_id: {close.instrument_id}")
            return

        if close.close_type == InstrumentCloseType.CONTRACT_EXPIRED:
            self._instrument_close = close
            self.iterate(close.ts_init)

    cdef void _process_trade_ticks_from_bar(self, Bar bar):
        # Split bar volume into 4, adding remainder to close trade
        cdef QuantityRaw quarter_raw = bar._mem.volume.raw // 4
        cdef QuantityRaw remainder_raw = bar._mem.volume.raw % 4
        cdef QuantityRaw min_size_raw = self.instrument.size_increment._mem.raw

        # Ensure minimum size increment
        if quarter_raw < min_size_raw:
            quarter_raw = min_size_raw

        cdef Quantity size = Quantity.from_raw_c(quarter_raw, bar._mem.volume.precision)
        cdef Quantity close_size = Quantity.from_raw_c(quarter_raw + remainder_raw, bar._mem.volume.precision)

        # Create base tick template
        cdef TradeTick tick = self._create_base_trade_tick(bar, size)

        # Process each price point
        cdef bint process_high_first = (
            not self._bar_adaptive_high_low_ordering
            or abs(bar._mem.high.raw - bar._mem.open.raw) < abs(bar._mem.low.raw - bar._mem.open.raw)
        )
        self._process_trade_bar_open(bar, tick)

        if process_high_first:
            self._process_trade_bar_high(bar, tick)
            self._process_trade_bar_low(bar, tick)
        else:
            self._process_trade_bar_low(bar, tick)
            self._process_trade_bar_high(bar, tick)

        self._process_trade_bar_close(bar, tick, close_size)

    cdef TradeTick _create_base_trade_tick(self, Bar bar, Quantity size):
        return TradeTick(
            bar.bar_type.instrument_id,
            bar.open,
            size,
            AggressorSide.BUYER if not self._core.is_last_initialized or bar._mem.open.raw > self._core.last_raw else AggressorSide.SELLER,
            self._generate_trade_id(),
            bar.ts_init,
            bar.ts_init,
        )

    cdef void _process_trade_bar_open(self, Bar bar, TradeTick tick):
        if not self._core.is_last_initialized or bar._mem.open.raw != self._core.last_raw:
            if is_logging_initialized():
                self._log.debug(f"Updating with open {bar.open}")

            self._book.update_trade_tick(tick)
            self.iterate(tick.ts_init)
            self._core.set_last_raw(bar._mem.open.raw)

    cdef void _process_trade_bar_high(self, Bar bar, TradeTick tick):
        if bar._mem.high.raw > self._core.last_raw:
            if is_logging_initialized():
                self._log.debug(f"Updating with high {bar.high}")

            tick._mem.price = bar._mem.high
            tick._mem.aggressor_side = AggressorSide.BUYER
            tick._mem.trade_id = trade_id_new(pystr_to_cstr(self._generate_trade_id_str()))
            self._book.update_trade_tick(tick)
            self.iterate(tick.ts_init)
            self._core.set_last_raw(bar._mem.high.raw)

    cdef void _process_trade_bar_low(self, Bar bar, TradeTick tick):
        if bar._mem.low.raw < self._core.last_raw:
            if is_logging_initialized():
                self._log.debug(f"Updating with low {bar.low}")

            tick._mem.price = bar._mem.low
            tick._mem.aggressor_side = AggressorSide.SELLER
            tick._mem.trade_id = trade_id_new(pystr_to_cstr(self._generate_trade_id_str()))
            self._book.update_trade_tick(tick)
            self.iterate(tick.ts_init)
            self._core.set_last_raw(bar._mem.low.raw)

    cdef void _process_trade_bar_close(self, Bar bar, TradeTick tick, Quantity close_size = None):
        if bar._mem.close.raw != self._core.last_raw:
            if is_logging_initialized():
                self._log.debug(f"Updating with close {bar.close}")

            tick._mem.price = bar._mem.close
            if close_size is not None:
                tick._mem.size = close_size._mem
            tick._mem.aggressor_side = AggressorSide.BUYER if bar._mem.close.raw > self._core.last_raw else AggressorSide.SELLER
            tick._mem.trade_id = trade_id_new(pystr_to_cstr(self._generate_trade_id_str()))
            self._book.update_trade_tick(tick)
            self.iterate(tick.ts_init)
            self._core.set_last_raw(bar._mem.close.raw)

    cdef void _process_quote_ticks_from_bar(self):
        if self._last_bid_bar is None or self._last_ask_bar is None:
            return  # Wait for next bar

        if self._last_bid_bar.ts_init != self._last_ask_bar.ts_init:
            return  # Wait for next bar

        # Split bar volume into 4, adding remainder to close quote
        cdef QuantityRaw min_size_raw = self.instrument.size_increment._mem.raw
        cdef QuantityRaw bid_quarter = self._last_bid_bar._mem.volume.raw // 4
        cdef QuantityRaw bid_remainder = self._last_bid_bar._mem.volume.raw % 4
        cdef QuantityRaw ask_quarter = self._last_ask_bar._mem.volume.raw // 4
        cdef QuantityRaw ask_remainder = self._last_ask_bar._mem.volume.raw % 4

        # Ensure minimum size increment
        if bid_quarter < min_size_raw:
            bid_quarter = min_size_raw
        if ask_quarter < min_size_raw:
            ask_quarter = min_size_raw

        cdef Quantity bid_size = Quantity.from_raw_c(bid_quarter, self._last_bid_bar._mem.volume.precision)
        cdef Quantity ask_size = Quantity.from_raw_c(ask_quarter, self._last_ask_bar._mem.volume.precision)
        cdef Quantity bid_close_size = Quantity.from_raw_c(bid_quarter + bid_remainder, self._last_bid_bar._mem.volume.precision)
        cdef Quantity ask_close_size = Quantity.from_raw_c(ask_quarter + ask_remainder, self._last_ask_bar._mem.volume.precision)

        # Create base tick template
        cdef QuoteTick tick = self._create_base_quote_tick(bid_size, ask_size)

        # Process each price point
        cdef bint process_high_first = (
            not self._bar_adaptive_high_low_ordering
            or abs(self._last_bid_bar._mem.high.raw - self._last_bid_bar._mem.open.raw) < abs(self._last_bid_bar._mem.low.raw - self._last_bid_bar._mem.open.raw)
        )
        self._process_quote_bar_open(tick)

        if process_high_first:
            self._process_quote_bar_high(tick)
            self._process_quote_bar_low(tick)
        else:
            self._process_quote_bar_low(tick)
            self._process_quote_bar_high(tick)

        self._process_quote_bar_close(tick, bid_close_size, ask_close_size)

        self._last_bid_bar = None
        self._last_ask_bar = None

    cdef QuoteTick _create_base_quote_tick(self, Quantity bid_size, Quantity ask_size):
        return QuoteTick(
            self._book.instrument_id,
            self._last_bid_bar.open,
            self._last_ask_bar.open,
            bid_size,
            ask_size,
            self._last_bid_bar.ts_init,
            self._last_ask_bar.ts_init,
        )

    cdef void _process_quote_bar_open(self, QuoteTick tick):
        self._book.update_quote_tick(tick)
        self.iterate(tick.ts_init)

    cdef void _process_quote_bar_high(self, QuoteTick tick):
        tick._mem.bid_price = self._last_bid_bar._mem.high
        tick._mem.ask_price = self._last_ask_bar._mem.high
        self._book.update_quote_tick(tick)
        self.iterate(tick.ts_init)

    cdef void _process_quote_bar_low(self, QuoteTick tick):
        tick._mem.bid_price = self._last_bid_bar._mem.low
        tick._mem.ask_price = self._last_ask_bar._mem.low
        self._book.update_quote_tick(tick)
        self.iterate(tick.ts_init)

    cdef void _process_quote_bar_close(self, QuoteTick tick, Quantity bid_close_size = None, Quantity ask_close_size = None):
        tick._mem.bid_price = self._last_bid_bar._mem.close
        tick._mem.ask_price = self._last_ask_bar._mem.close
        if bid_close_size is not None:
            tick._mem.bid_size = bid_close_size._mem
        if ask_close_size is not None:
            tick._mem.ask_size = ask_close_size._mem
        self._book.update_quote_tick(tick)
        self.iterate(tick.ts_init)

    # -- TRADING COMMANDS -----------------------------------------------------------------------------

    cpdef void process_order(self, Order order, AccountId account_id):
        if self._core.order_exists(order.client_order_id):
            return  # Already processed

        # Index identifiers
        self._account_ids[order.trader_id] = account_id

        cdef uint64_t now_ns
        if self._instrument_has_expiration:
            now_ns = self._clock.timestamp_ns()

            if now_ns < self.instrument.activation_ns:
                self._generate_order_rejected(
                    order,
                    f"Contract {self.instrument.id} not yet active, "
                    f"activation {format_iso8601(unix_nanos_to_dt(self.instrument.activation_ns))}"
                )
                return
            elif now_ns > self.instrument.expiration_ns:
                self._generate_order_rejected(
                    order,
                    f"Contract {self.instrument.id} has expired, "
                    f"expiration {format_iso8601(unix_nanos_to_dt(self.instrument.expiration_ns))}"
                )
                return

        cdef:
            Order parent
            Order contingenct_order
            ClientOrderId client_order_id
        if self._support_contingent_orders and order.parent_order_id is not None:
            parent = self.cache.order(order.parent_order_id)
            assert parent is not None and parent.contingency_type == ContingencyType.OTO, "OTO parent not found"

            if parent.status_c() == OrderStatus.REJECTED and order.is_open_c():
                self._generate_order_rejected(order, f"REJECT OTO from {parent.client_order_id}")
                return  # Order rejected
            elif parent.status_c() == OrderStatus.ACCEPTED or parent.status_c() == OrderStatus.TRIGGERED:
                self._log.info(f"Pending OTO {order.client_order_id} triggers from {parent.client_order_id}")
                return  # Pending trigger

            if order.linked_order_ids is not None:
                # Check contingent orders are still open
                for client_order_id in order.linked_order_ids or []:
                    contingent_order = self.cache.order(client_order_id)

                    if contingent_order is None:
                        raise RuntimeError(f"Cannot find contingent order for {client_order_id!r}")  # pragma: no cover

                    if order.contingency_type == ContingencyType.OCO or order.contingency_type == ContingencyType.OUO:
                        if not order.is_closed_c() and contingent_order.is_closed_c():
                            self._generate_order_rejected(order, f"Contingent order {client_order_id} already closed")
                            return  # Order rejected

        # Check order quantity precision
        if order.quantity._mem.precision != self.instrument.size_precision:
            self._generate_order_rejected(
                order,
                f"Invalid size precision for order {order.client_order_id}, "
                f"was {order.quantity.precision} "
                f"when {self.instrument.id} size precision is {self.instrument.size_precision}"
            )
            return  # Invalid order

        cdef Price price
        if order.has_price_c():
            # Check order price precision
            price = order.price

            if price._mem.precision != self.instrument.price_precision:
                self._generate_order_rejected(
                    order,
                    f"Invalid price precision for order {order.client_order_id}, "
                    f"was {price.precision} "
                    f"when {self.instrument.id} price precision is {self.instrument.price_precision}"
                )
                return  # Invalid order

        cdef Price trigger_price
        if order.has_trigger_price_c():
            # Check order trigger price precision
            trigger_price = order.trigger_price

            if trigger_price._mem.precision != self.instrument.price_precision:
                self._generate_order_rejected(
                    order,
                    f"Invalid trigger price precision for order {order.client_order_id}, "
                    f"was {trigger_price.precision} "
                    f"when {self.instrument.id} price precision is {self.instrument.price_precision}"
                )
                return  # Invalid order

        cdef Price activation_price
        if order.has_activation_price_c():
            # Check order activation price precision
            activation_price = order.activation_price

            if activation_price._mem.precision != self.instrument.price_precision:
                self._generate_order_rejected(
                    order,
                    f"Invalid activation price precision for order {order.client_order_id}, "
                    f"was {activation_price.precision} "
                    f"when {self.instrument.id} price precision is {self.instrument.price_precision}"
                )
                return  # Invalid order

        cdef Position position = self.cache.position_for_order(order.client_order_id)

        cdef PositionId position_id
        if position is None and self.oms_type == OmsType.NETTING:
            position_id = PositionId(f"{order.instrument_id}-{order.strategy_id}")
            position = self.cache.position(position_id)

        # Check not shorting an equity without a MARGIN account
        if (
            order.side == OrderSide.SELL
            and self.account_type != AccountType.MARGIN
            and isinstance(self.instrument, Equity)
            and (position is None or not order.would_reduce_only(position.side, position.quantity))
        ):
            self._generate_order_rejected(
                order,
                f"SHORT SELLING not permitted on a CASH account with position {position} and order {order!r}"
            )
            return  # Cannot short sell

        # Check reduce-only instruction
        if self._use_reduce_only and order.is_reduce_only and not order.is_closed_c():
            if (
                not position
                or position.is_closed_c()
                or (order.is_buy_c() and position.is_long_c())
                or (order.is_sell_c() and position.is_short_c())
            ):
                self._generate_order_rejected(
                    order,
                    f"REDUCE_ONLY {order.type_string_c()} {order.side_string_c()} order "
                    f"would have increased position",
                )
                return  # Reduce only

        if order.order_type == OrderType.MARKET:
            self._process_market_order(order)
        elif order.order_type == OrderType.MARKET_TO_LIMIT:
            self._process_market_to_limit_order(order)
        elif order.order_type == OrderType.LIMIT:
            self._process_limit_order(order)
        elif order.order_type == OrderType.STOP_MARKET:
            self._process_stop_market_order(order)
        elif order.order_type == OrderType.STOP_LIMIT:
            self._process_stop_limit_order(order)
        elif order.order_type == OrderType.MARKET_IF_TOUCHED:
            self._process_market_if_touched_order(order)
        elif order.order_type == OrderType.LIMIT_IF_TOUCHED:
            self._process_limit_if_touched_order(order)
        elif (
            order.order_type == OrderType.TRAILING_STOP_MARKET
            or order.order_type == OrderType.TRAILING_STOP_LIMIT
        ):
            self._process_trailing_stop_order(order)
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"{order_type_to_str(order.order_type)} "  # pragma: no cover
                f"orders are not supported for backtesting in this version",  # pragma: no cover
            )

    cpdef void process_modify(self, ModifyOrder command, AccountId account_id):
        cdef Order order = self._core.get_order(command.client_order_id)
        if order is None:
            self._generate_order_modify_rejected(
                trader_id=command.trader_id,
                strategy_id=command.strategy_id,
                account_id=account_id,
                instrument_id=command.instrument_id,
                client_order_id=command.client_order_id,
                venue_order_id=command.venue_order_id,
                reason=f"{command.client_order_id!r} not found",
            )
        else:
            self.update_order(
                order,
                command.quantity,
                command.price,
                command.trigger_price,
            )

    cpdef void process_cancel(self, CancelOrder command, AccountId account_id):
        cdef Order order = self._core.get_order(command.client_order_id)
        if order is None:
            self._generate_order_cancel_rejected(
                trader_id=command.trader_id,
                strategy_id=command.strategy_id,
                account_id=account_id,
                instrument_id=command.instrument_id,
                client_order_id=command.client_order_id,
                venue_order_id=command.venue_order_id,
                reason=f"{command.client_order_id!r} not found",
            )
        else:
            if order.is_inflight_c() or order.is_open_c():
                self.cancel_order(order)

    cpdef void process_batch_cancel(self, BatchCancelOrders command, AccountId account_id):
        cdef CancelOrder cancel
        for cancel in command.cancels:
            self.process_cancel(cancel, account_id)

    cpdef void process_cancel_all(self, CancelAllOrders command, AccountId account_id):
        cdef Order order
        for order in self.cache.orders_open(venue=None, instrument_id=command.instrument_id):
            if command.order_side != OrderSide.NO_ORDER_SIDE and command.order_side != order.side:
                continue

            if order.is_inflight_c() or order.is_open_c():
                self.cancel_order(order)

    cdef void _process_market_order(self, MarketOrder order):
        # Check AT_THE_OPEN/AT_THE_CLOSE time in force
        if order.time_in_force == TimeInForce.AT_THE_OPEN or order.time_in_force == TimeInForce.AT_THE_CLOSE:
            self._generate_order_rejected(
                order,
                f"time in force {time_in_force_to_str(order.time_in_force)} "
                "is not currently supported",
            )
            return

        # Check market exists
        if order.side == OrderSide.BUY and not self._core.is_ask_initialized:
            self._generate_order_rejected(order, f"no market for {order.instrument_id}")
            return  # Cannot accept order
        elif order.side == OrderSide.SELL and not self._core.is_bid_initialized:
            self._generate_order_rejected(order, f"no market for {order.instrument_id}")
            return  # Cannot accept order

        # Immediately fill marketable order
        self.fill_market_order(order)

    cdef void _process_market_to_limit_order(self, MarketToLimitOrder order):
        # Check market exists
        if order.side == OrderSide.BUY and not self._core.is_ask_initialized:
            self._generate_order_rejected(order, f"no market for {order.instrument_id}")
            return  # Cannot accept order
        elif order.side == OrderSide.SELL and not self._core.is_bid_initialized:
            self._generate_order_rejected(order, f"no market for {order.instrument_id}")
            return  # Cannot accept order

        # Immediately fill marketable order
        self.fill_market_order(order)

        if order.is_open_c():
            self.accept_order(order)

    cdef void _process_limit_order(self, LimitOrder order):
        # Check AT_THE_OPEN/AT_THE_CLOSE time in force
        if order.time_in_force == TimeInForce.AT_THE_OPEN or order.time_in_force == TimeInForce.AT_THE_CLOSE:
            self._generate_order_rejected(
                order,
                f"time in force {time_in_force_to_str(order.time_in_force)} "
                "is not currently supported",
            )
            return

        if order.is_post_only and self._core.is_limit_matched(order.side, order.price):
            self._generate_order_rejected(
                order,
                f"POST_ONLY {order.type_string_c()} {order.side_string_c()} order "
                f"limit px of {order.price} would have been a TAKER: "
                f"bid={self._core.bid}, "
                f"ask={self._core.ask}",
                True,  # due_post_only
            )
            return  # Invalid price

        # Order is valid and accepted
        self.accept_order(order)

        # Check for immediate fill
        if self._core.is_limit_matched(order.side, order.price):
            # Filling as liquidity taker
            if order.liquidity_side == LiquiditySide.NO_LIQUIDITY_SIDE:
                order.liquidity_side = LiquiditySide.TAKER

            self.fill_limit_order(order)
        elif order.time_in_force == TimeInForce.FOK or order.time_in_force == TimeInForce.IOC:
            self.cancel_order(order)

    cdef void _process_stop_market_order(self, StopMarketOrder order):
        if self._core.is_stop_triggered(order.side, order.trigger_price):
            if self._reject_stop_orders:
                self._generate_order_rejected(
                    order,
                    f"{order.type_string_c()} {order.side_string_c()} order "
                    f"stop px of {order.trigger_price} was in the market: "
                    f"bid={self._core.bid}, "
                    f"ask={self._core.ask}",
                )
                return  # Invalid price

            self.fill_market_order(order)
            return

        # Order is valid and accepted
        self.accept_order(order)

    cdef void _process_stop_limit_order(self, StopLimitOrder order):
        if self._core.is_stop_triggered(order.side, order.trigger_price):
            if self._reject_stop_orders:
                self._generate_order_rejected(
                    order,
                    f"{order.type_string_c()} {order.side_string_c()} order "
                    f"trigger stop px of {order.trigger_price} was in the market: "
                    f"bid={self._core.bid}, "
                    f"ask={self._core.ask}",
                )
                return  # Invalid price

            self.accept_order(order)
            self._generate_order_triggered(order)

            # Check if immediately marketable
            if self._core.is_limit_matched(order.side, order.price):
                order.liquidity_side = LiquiditySide.TAKER
                self.fill_limit_order(order)

            return

        # Order is valid and accepted
        self.accept_order(order)

    cdef void _process_market_if_touched_order(self, MarketIfTouchedOrder order):
        if self._core.is_touch_triggered(order.side, order.trigger_price):
            if self._reject_stop_orders:
                self._generate_order_rejected(
                    order,
                    f"{order.type_string_c()} {order.side_string_c()} order "
                    f"stop px of {order.trigger_price} was in the market: "
                    f"bid={self._core.bid}, "
                    f"ask={self._core.ask}",
                )
                return  # Invalid price

            self.fill_market_order(order)
            return

        # Order is valid and accepted
        self.accept_order(order)

    cdef void _process_limit_if_touched_order(self, LimitIfTouchedOrder order):
        if self._core.is_touch_triggered(order.side, order.trigger_price):
            if self._reject_stop_orders:
                self._generate_order_rejected(
                    order,
                    f"{order.type_string_c()} {order.side_string_c()} order "
                    f"trigger stop px of {order.trigger_price} was in the market: "
                    f"bid={self._core.bid}, "
                    f"ask={self._core.ask}",
                )
                return  # Invalid price

            self.accept_order(order)
            self._generate_order_triggered(order)

            # Check if immediately marketable
            if self._core.is_limit_matched(order.side, order.price):
                order.liquidity_side = LiquiditySide.TAKER
                self.fill_limit_order(order)

            return

        # Order is valid and accepted
        self.accept_order(order)

    cdef void _process_trailing_stop_order(self, Order order):
        assert order.order_type == OrderType.TRAILING_STOP_MARKET \
            or order.order_type == OrderType.TRAILING_STOP_LIMIT

        cdef Price market_price = None
        if order.activation_price is None:
            # If activation price is not given,
            # set the activation price to the last price, and activate order
            market_price = self._core.ask if order.side == OrderSide.BUY else self._core.bid

            if market_price is None:
                # If there is no market price, we cannot process the order
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"cannot process trailing stop, "
                    f"no BID or ASK price for {order.instrument_id} "
                    f"(add quotes or use bars)",
                )

            order.set_activated_c(market_price)
        else:
            # If activation price is given,
            # the activation price should not be in the market, like if_touched orders.
            if self._core.is_touch_triggered(order.side, order.activation_price):
                # NOTE: need to apply 'reject_stop_orders' to activation price?
                if self._reject_stop_orders:
                    self._generate_order_rejected(
                        order,
                        f"{order.type_string_c()} {order.side_string_c()} order "
                        f"activation px of {order.activation_price} was in the market: "
                        f"bid={self._core.bid}, "
                        f"ask={self._core.ask}",
                    )
                    return  # Invalid price

                # if we cannot reject the order, we activate it
                order.set_activated_c(None)

        if order.is_activated:
            if order.has_trigger_price_c() and self._core.is_stop_triggered(order.side, order.trigger_price):
                self._generate_order_rejected(
                    order,
                    f"{order.type_string_c()} {order.side_string_c()} order "
                    f"trigger stop px of {order.trigger_price} was in the market: "
                    f"bid={self._core.bid}, "
                    f"ask={self._core.ask}",
                )
                return  # Invalid price

        # Order is valid and accepted
        self.accept_order(order)

    cdef void _update_limit_order(
        self,
        Order order,
        Quantity qty,
        Price price,
    ):
        if self._core.is_limit_matched(order.side, price):
            if order.is_post_only:
                self._generate_order_modify_rejected(
                    trader_id=order.trader_id,
                    strategy_id=order.strategy_id,
                    account_id=order.account_id,
                    instrument_id=order.instrument_id,
                    client_order_id=order.client_order_id,
                    venue_order_id=order.venue_order_id,
                    reason=f"POST_ONLY {order.type_string_c()} {order.side_string_c()} order "
                    f"new limit px of {price} would have been a TAKER: "
                    f"bid={self._core.bid}, "
                    f"ask={self._core.ask}",
                )
                return  # Cannot update order

            self._generate_order_updated(order, qty, price, None)
            order.liquidity_side = LiquiditySide.TAKER
            self.fill_limit_order(order)  # Immediate fill as TAKER
            return  # Filled

        self._generate_order_updated(order, qty, price, None)

    cdef void _update_stop_market_order(
        self,
        Order order,
        Quantity qty,
        Price trigger_price,
    ):
        if self._core.is_stop_triggered(order.side, trigger_price):
            self._generate_order_modify_rejected(
                trader_id=order.trader_id,
                strategy_id=order.strategy_id,
                account_id=order.account_id,
                instrument_id=order.instrument_id,
                client_order_id=order.client_order_id,
                venue_order_id=order.venue_order_id,
                reason=f"{order.type_string_c()} {order.side_string_c()} order "
                f"new stop px of {trigger_price} was in the market: "
                f"bid={self._core.bid}, "
                f"ask={self._core.ask}",
            )
            return  # Cannot update order

        self._generate_order_updated(order, qty, None, trigger_price)

    cdef void _update_stop_limit_order(
        self,
        Order order,
        Quantity qty,
        Price price,
        Price trigger_price,
    ):
        if not order.is_triggered:
            # Updating stop price
            if self._core.is_stop_triggered(order.side, trigger_price):
                self._generate_order_modify_rejected(
                    trader_id=order.trader_id,
                    strategy_id=order.strategy_id,
                    account_id=order.account_id,
                    instrument_id=order.instrument_id,
                    client_order_id=order.client_order_id,
                    venue_order_id=order.venue_order_id,
                    reason=f"{order.type_string_c()} {order.side_string_c()} order "
                    f"new trigger stop px of {trigger_price} was in the market: "
                    f"bid={self._core.bid}, "
                    f"ask={self._core.ask}",
                )
                return  # Cannot update order
        else:
            # Updating limit price
            if self._core.is_limit_matched(order.side, price):
                if order.is_post_only:
                    self._generate_order_modify_rejected(
                        trader_id=order.trader_id,
                        strategy_id=order.strategy_id,
                        account_id=order.account_id,
                        instrument_id=order.instrument_id,
                        client_order_id=order.client_order_id,
                        venue_order_id=order.venue_order_id,
                        reason=f"POST_ONLY {order.type_string_c()} {order.side_string_c()} order  "
                        f"new limit px of {price} would have been a TAKER: "
                        f"bid={self._core.bid}, "
                        f"ask={self._core.ask}",
                    )
                    return  # Cannot update order
                else:
                    self._generate_order_updated(order, qty, price, None)
                    order.liquidity_side = LiquiditySide.TAKER
                    self.fill_limit_order(order)  # Immediate fill as TAKER
                    return  # Filled

        self._generate_order_updated(order, qty, price, trigger_price or order.trigger_price)

    cdef void _update_market_if_touched_order(
        self,
        Order order,
        Quantity qty,
        Price trigger_price,
    ):
        if self._core.is_touch_triggered(order.side, trigger_price):
            self._generate_order_modify_rejected(
                trader_id=order.trader_id,
                strategy_id=order.strategy_id,
                account_id=order.account_id,
                instrument_id=order.instrument_id,
                client_order_id=order.client_order_id,
                venue_order_id=order.venue_order_id,
                reason=f"{order.type_string_c()} {order.side_string_c()} order "
                       f"new stop px of {trigger_price} was in the market: "
                       f"bid={self._core.bid}, "
                       f"ask={self._core.ask}",
            )
            return  # Cannot update order

        self._generate_order_updated(order, qty, None, trigger_price)

    cdef void _update_limit_if_touched_order(
        self,
        Order order,
        Quantity qty,
        Price price,
        Price trigger_price,
    ):
        if not order.is_triggered:
            # Updating stop price
            if self._core.is_touch_triggered(order.side, trigger_price):
                self._generate_order_modify_rejected(
                    trader_id=order.trader_id,
                    strategy_id=order.strategy_id,
                    account_id=order.account_id,
                    instrument_id=order.instrument_id,
                    client_order_id=order.client_order_id,
                    venue_order_id=order.venue_order_id,
                    reason=f"{order.type_string_c()} {order.side_string_c()} order "
                           f"new trigger stop px of {trigger_price} was in the market: "
                           f"bid={self._core.bid}, "
                           f"ask={self._core.ask}",
                )
                return  # Cannot update order
        else:
            # Updating limit price
            if self._core.is_limit_matched(order.side, price):
                if order.is_post_only:
                    self._generate_order_modify_rejected(
                        trader_id=order.trader_id,
                        strategy_id=order.strategy_id,
                        account_id=order.account_id,
                        instrument_id=order.instrument_id,
                        client_order_id=order.client_order_id,
                        venue_order_id=order.venue_order_id,
                        reason=f"POST_ONLY {order.type_string_c()} {order.side_string_c()} order  "
                               f"new limit px of {price} would have been a TAKER: "
                               f"bid={self._core.bid}, "
                               f"ask={self._core.ask}",
                    )
                    return  # Cannot update order
                else:
                    self._generate_order_updated(order, qty, price, None)
                    order.liquidity_side = LiquiditySide.TAKER
                    self.fill_limit_order(order)  # Immediate fill as TAKER
                    return  # Filled

        self._generate_order_updated(order, qty, price, trigger_price or order.trigger_price)

    cdef void _update_trailing_stop_market_order(
        self,
        Order order,
        Quantity qty,
        Price trigger_price,
    ):
        if order.is_activated:
            # Activated trailing-stop may not yet have a trigger_price;
            # await next market update to calculate it
            if trigger_price is None:
                return

            self._update_stop_market_order(order, qty, trigger_price)
        elif qty or trigger_price:
            self._generate_order_updated(order, qty, None, trigger_price)

    cdef void _update_trailing_stop_limit_order(
        self,
        Order order,
        Quantity qty,
        Price price,
        Price trigger_price,
    ):
        if order.is_activated:
            # Activated trailing-stop may not yet have a trigger_price;
            # await next market update to calculate it
            if trigger_price is None:
                return

            self._update_stop_limit_order(order, qty, price, trigger_price)
        elif qty or trigger_price:
            self._generate_order_updated(order, qty, price, trigger_price)

    cdef void _trail_stop_order(self, Order order):
        cdef Price market_price = None

        if not order.is_activated:
            if order.activation_price is None:
                # NOTE
                # The activation price should have been set in OrderMatchingEngine._process_trailing_stop_order()
                # However, the implementation of the emulator bypass this step, and directly call this method through match_order().
                market_price = self.ask if order.side == OrderSide.BUY else self.bid

                if market_price is None:
                    # If there is no market price, we cannot process the order
                    raise RuntimeError(  # pragma: no cover (design-time error)
                        f"cannot process trailing stop, "
                        f"no BID or ASK price for {order.instrument_id} "
                        f"(add quotes or use bars)",
                    )

                order.set_activated_c(market_price)
            elif self._core.is_touch_triggered(order.side, order.activation_price):
                order.set_activated_c(None)
            else:
                return  # Do nothing

        cdef tuple output = TrailingStopCalculator.calculate(
            price_increment=self.instrument.price_increment,
            order=order,
            bid=self._core.bid,
            ask=self._core.ask,
            last=self._core.last,
        )

        cdef Price new_trigger_price = output[0]
        cdef Price new_price = output[1]
        if new_trigger_price is None and new_price is None:
            return  # No updates

        self._generate_order_updated(
            order=order,
            quantity=order.quantity,
            price=new_price,
            trigger_price=new_trigger_price,
        )

# -- ORDER PROCESSING -----------------------------------------------------------------------------

    cpdef void iterate(self, uint64_t timestamp_ns, AggressorSide aggressor_side = AggressorSide.NO_AGGRESSOR):
        """
        Iterate the matching engine by processing the bid and ask order sides
        and advancing time up to the given UNIX `timestamp_ns`.

        Parameters
        ----------
        timestamp_ns : uint64_t
            UNIX timestamp to advance the matching engine time to.
        aggressor_side : AggressorSide, default 'NO_AGGRESSOR'
            The aggressor side for trade execution processing.

        """
        self._clock.set_time(timestamp_ns)

        cdef Price_t bid
        cdef Price_t ask

        if orderbook_has_bid(&self._book._mem) and aggressor_side == AggressorSide.NO_AGGRESSOR:
            bid = orderbook_best_bid_price(&self._book._mem)
            self._core.set_bid_raw(bid.raw)

        if orderbook_has_ask(&self._book._mem) and aggressor_side == AggressorSide.NO_AGGRESSOR:
            ask = orderbook_best_ask_price(&self._book._mem)
            self._core.set_ask_raw(ask.raw)

        self._core.iterate(timestamp_ns)

        cdef list orders = self._core.get_orders()
        cdef Order order
        for order in orders:
            if order.is_closed_c():
                self._cached_filled_qty.pop(order.client_order_id, None)
                continue

            # Check expiry
            if self._support_gtd_orders:
                if order.expire_time_ns > 0 and timestamp_ns >= order.expire_time_ns:
                    self._core.delete_order(order)
                    self._cached_filled_qty.pop(order.client_order_id, None)
                    self.expire_order(order)
                    continue

            # Manage trailing stop
            if order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
                self._trail_stop_order(order)

            # Move market back to targets
            if self._has_targets:
                self._core.set_bid_raw(self._target_bid)
                self._core.set_ask_raw(self._target_ask)
                self._core.set_last_raw(self._target_last)
                self._has_targets = False

        # Reset any targets after iteration
        self._target_bid = 0
        self._target_ask = 0
        self._target_last = 0
        self._has_targets = False

        # Instrument expiration
        if (self._instrument_has_expiration and timestamp_ns >= self.instrument.expiration_ns) or self._instrument_close is not None:
            self._log.info(f"{self.instrument.id} reached expiration")

            # Cancel all open orders
            for order in self.get_open_orders():
                self.cancel_order(order)

            # Close all open positions
            for position in self.cache.positions_open(None, self.instrument.id):
                order = MarketOrder(
                    trader_id=position.trader_id,
                    strategy_id=position.strategy_id,
                    instrument_id=position.instrument_id,
                    client_order_id=ClientOrderId(str(uuid.uuid4())),
                    order_side=Order.closing_side_c(position.side),
                    quantity=position.quantity,
                    init_id=UUID4(),
                    ts_init=self._clock.timestamp_ns(),
                    reduce_only=True,
                    tags=[f"EXPIRATION_{self.venue}_CLOSE"],
                )
                self.cache.add_order(order, position_id=position.id)
                self.fill_market_order(order)

    cpdef void fill_market_order(self, Order order):
        """
        Fill the given *marketable* order.

        Parameters
        ----------
        order : Order
            The order to fill.

        """
        cdef Quantity cached_filled_qty = self._cached_filled_qty.get(order.client_order_id)
        if cached_filled_qty is not None and cached_filled_qty._mem.raw >= order.quantity._mem.raw:
            self._log.debug(
                f"Ignoring fill as already filled pending application of events: "
                f"{cached_filled_qty=}, {order.quantity=}, {order.filled_qty=}, {order.leaves_qty=}",
            )
            return

        cdef PositionId venue_position_id = self._get_position_id(order)
        cdef Position position = None
        if venue_position_id is not None:
            position = self.cache.position(venue_position_id)

        if self._use_reduce_only and order.is_reduce_only and position is None:
            self._log.warning(
                f"Canceling REDUCE_ONLY {order.type_string_c()} "
                f"as would increase position",
            )
            self.cancel_order(order)
            return  # Order canceled

        order.liquidity_side = LiquiditySide.TAKER
        cdef list fills = self.determine_market_fills_with_simulation(order)

        self.apply_fills(
            order=order,
            fills=fills,
            liquidity_side=order.liquidity_side,
            venue_position_id=venue_position_id,
            position=position,
        )

    cdef list determine_market_fills_with_simulation(self, Order order):
        """
        Determine market order fills using FillModel simulation if available.

        This method first checks if the FillModel provides a simulated OrderBook
        for fill simulation. If so, it uses that for fill determination. Otherwise,
        it falls back to the standard market fill logic.
        """
        if self._fill_model is None:
            return self.determine_market_price_and_volume(order)

        # Get current best bid/ask for simulation
        cdef Price best_bid = self._core.bid
        cdef Price best_ask = self._core.ask

        if best_bid is None or best_ask is None:
            return []  # No market available

        # Try to get simulated OrderBook from FillModel
        cdef OrderBook simulated_book = self._fill_model.get_orderbook_for_fill_simulation(
            self.instrument, order, best_bid, best_ask
        )

        if simulated_book is not None:
            # Use simulated OrderBook for fill determination
            fills = simulated_book.simulate_fills(
                order,
                price_prec=self.instrument.price_precision,
                size_prec=self.instrument.size_precision,
                is_aggressive=True,
            )
            # If simulation produced no fills (e.g., custom model removed best levels),
            # fall back to standard market logic to preserve expected behavior.
            if not fills:
                return self.determine_market_price_and_volume(order)
            return fills
        else:
            # Fall back to standard logic
            return self.determine_market_price_and_volume(order)

    cpdef list determine_market_price_and_volume(self, Order order):
        """
        Return the projected fills for the given *marketable* order filling
        aggressively into the opposite order side.

        The list may be empty if no fills.

        Parameters
        ----------
        order : Order
            The order to determine fills for.

        Returns
        -------
        list[tuple[Price, Quantity]]

        """
        cdef list fills = self._book.simulate_fills(
            order,
            price_prec=self.instrument.price_precision,
            size_prec=self.instrument.size_precision,
            is_aggressive=True,
        )

        cdef Price price
        cdef Price triggered_price
        if self._book.book_type == BookType.L1_MBP and fills:
            triggered_price = order.get_triggered_price_c()

            if order.order_type == OrderType.MARKET or order.order_type == OrderType.MARKET_TO_LIMIT or order.order_type == OrderType.MARKET_IF_TOUCHED:
                if order.side == OrderSide.BUY:
                    if self._core.is_ask_initialized:
                        price = self._core.ask
                    else:
                        price = self.best_ask_price()

                    if triggered_price:
                        price = triggered_price

                    if price is not None:
                        self._core.set_last_raw(price._mem.raw)
                        fills[0] = (price, fills[0][1])
                    else:
                        raise RuntimeError(  # pragma: no cover (design-time error)
                            "Market best ASK price was None when filling MARKET order",  # pragma: no cover
                        )
                elif order.side == OrderSide.SELL:
                    if self._core.is_bid_initialized:
                        price = self._core.bid
                    else:
                        price = self.best_bid_price()

                    if triggered_price:
                        price = triggered_price

                    if price is not None:
                        self._core.set_last_raw(price._mem.raw)
                        fills[0] = (price, fills[0][1])
                    else:
                        raise RuntimeError(  # pragma: no cover (design-time error)
                            "Market best BID price was None when filling MARKET order",  # pragma: no cover
                        )
            else:
                price = order.price if (order.order_type == OrderType.LIMIT or order.order_type == OrderType.LIMIT_IF_TOUCHED) else order.trigger_price

                if triggered_price:
                    price = triggered_price

                if order.side == OrderSide.BUY:
                    self._core.set_ask_raw(price._mem.raw)
                elif order.side == OrderSide.SELL:
                    self._core.set_bid_raw(price._mem.raw)
                else:
                    raise RuntimeError(f"invalid `OrderSide`, was {order.side}")  # pragma: no cover (design-time error)

                self._core.set_last_raw(price._mem.raw)
                fills[0] = (price, fills[0][1])

        return fills

    cpdef void fill_limit_order(self, Order order):
        """
        Fill the given limit order.

        Parameters
        ----------
        order : Order
            The order to fill.

        Raises
        ------
        ValueError
            If the `order` does not have a LIMIT `price`.

        """
        Condition.is_true(order.has_price_c(), "order has no limit `price`")

        cdef Quantity cached_filled_qty = self._cached_filled_qty.get(order.client_order_id)
        if cached_filled_qty is not None and cached_filled_qty._mem.raw >= order.quantity._mem.raw:
            self._log.debug(
                f"Ignoring fill as already filled pending application of events: "
                f"{cached_filled_qty=}, {order.quantity=}, {order.filled_qty=}, {order.leaves_qty=}",
            )
            return

        cdef Price price = order.price
        if order.liquidity_side == LiquiditySide.MAKER and self._fill_model:
            if order.side == OrderSide.BUY and self._core.bid_raw == price._mem.raw and not self._fill_model.is_limit_filled():
                return  # Not filled
            elif order.side == OrderSide.SELL and self._core.ask_raw == price._mem.raw and not self._fill_model.is_limit_filled():
                return  # Not filled

        cdef PositionId venue_position_id = self._get_position_id(order)
        cdef Position position = None
        if venue_position_id is not None:
            position = self.cache.position(venue_position_id)

        if self._use_reduce_only and order.is_reduce_only and position is None:
            self._log.warning(
                f"Canceling REDUCE_ONLY {order.type_string_c()} "
                f"as would increase position",
            )
            self.cancel_order(order)
            return  # Order canceled

        cdef list fills = self.determine_limit_fills_with_simulation(order)

        self.apply_fills(
            order=order,
            fills=fills,
            liquidity_side=order.liquidity_side,
            venue_position_id=venue_position_id,
            position=position,
        )

    cdef list determine_limit_fills_with_simulation(self, Order order):
        """
        Determine limit order fills using FillModel simulation if available.

        This method first checks if the FillModel provides a simulated OrderBook
        for fill simulation. If so, it uses that for fill determination. Otherwise,
        it falls back to the standard limit fill logic.
        """
        if self._fill_model is None:
            return self.determine_limit_price_and_volume(order)

        # Get current best bid/ask for simulation
        cdef Price best_bid = self._core.bid
        cdef Price best_ask = self._core.ask

        if best_bid is None or best_ask is None:
            return []  # No market available

        # Try to get simulated OrderBook from FillModel
        cdef OrderBook simulated_book = self._fill_model.get_orderbook_for_fill_simulation(
            self.instrument, order, best_bid, best_ask
        )

        if simulated_book is not None:
            # Use simulated OrderBook for fill determination
            return simulated_book.simulate_fills(
                order,
                price_prec=self.instrument.price_precision,
                size_prec=self.instrument.size_precision,
                is_aggressive=False,
            )
        else:
            # Fall back to standard logic
            return self.determine_limit_price_and_volume(order)

    cdef Quantity determine_trade_fill_qty(self, Order order):
        """
        Determine the fill quantity for trade execution mode.

        When trade execution mode triggers a match via the transient price override,
        this method calculates the fill quantity as the minimum of:
        - The order's remaining quantity (leaves_qty)
        - The remaining trade tick size (if available)

        The trade size is decremented after each fill to ensure total fills
        across multiple orders do not exceed the trade tick's reported size.

        Returns None if there is no quantity available to fill.
        """
        cdef uint64_t leaves_raw = order.quantity._mem.raw - order.filled_qty._mem.raw
        if leaves_raw == 0:
            return None

        cdef uint64_t fill_raw = leaves_raw
        cdef uint64_t remaining_raw

        if self._last_trade_size is not None:
            if self._last_trade_size._mem.raw == 0:
                return None
            fill_raw = min(leaves_raw, self._last_trade_size._mem.raw)

            # Decrement remaining trade size for subsequent orders
            remaining_raw = self._last_trade_size._mem.raw - fill_raw
            self._last_trade_size = Quantity.from_raw_c(
                remaining_raw,
                self._last_trade_size._mem.precision,
            )

        return Quantity.from_raw_c(fill_raw, order.quantity._mem.precision)

    cpdef list determine_limit_price_and_volume(self, Order order):
        """
        Return the projected fills for the given *limit* order filling passively
        from its limit price.

        The list may be empty if no fills.

        Parameters
        ----------
        order : Order
            The order to determine fills for.

        Returns
        -------
        list[tuple[Price, Quantity]]

        Raises
        ------
        ValueError
            If the `order` does not have a LIMIT `price`.

        """
        Condition.is_true(order.has_price_c(), "order has no limit `price`")

        cdef list fills = self._book.simulate_fills(
            order,
            price_prec=self.instrument.price_precision,
            size_prec=self.instrument.size_precision,
            is_aggressive=False,
        )

        cdef Price triggered_price = order.get_triggered_price_c()
        cdef Price price = order.price

        if (
            not fills
            and order.liquidity_side == LiquiditySide.MAKER
            and self._core.is_limit_matched(order.side, order.price)
        ):
            fill_qty = self.determine_trade_fill_qty(order)
            if fill_qty is not None:
                fills = [(order.price, fill_qty)]

        if (
                fills
                and triggered_price is not None
                and order.liquidity_side == LiquiditySide.TAKER
        ):
            ########################################################################
            # Filling as TAKER from a trigger
            ########################################################################
            if order.side == OrderSide.BUY and price._mem.raw > triggered_price._mem.raw:
                fills[0] = (triggered_price, fills[0][1])
                self._has_targets = True
                self._target_bid = self._core.bid_raw
                self._target_ask = self._core.ask_raw
                self._target_last = self._core.last_raw
                self._core.set_ask_raw(price._mem.raw)
                self._core.set_last_raw(price._mem.raw)
            elif order.side == OrderSide.SELL and price._mem.raw < triggered_price._mem.raw:
                fills[0] = (triggered_price, fills[0][1])
                self._has_targets = True
                self._target_bid = self._core.bid_raw
                self._target_ask = self._core.ask_raw
                self._target_last = self._core.last_raw
                self._core.set_bid_raw(price._mem.raw)
                self._core.set_last_raw(price._mem.raw)

        cdef tuple[Price, Quantity] fill
        cdef Price last_px
        if (
                fills
                and order.liquidity_side == LiquiditySide.MAKER
        ):
            ########################################################################
            # Filling as MAKER
            ########################################################################
            price = order.price

            if order.side == OrderSide.BUY:
                if triggered_price and price > triggered_price:
                    price = triggered_price

                for fill in fills:
                    last_px = fill[0]

                    if last_px._mem.raw < price._mem.raw:
                        # Marketable BUY would have filled at limit
                        self._has_targets = True
                        self._target_bid = self._core.bid_raw
                        self._target_ask = self._core.ask_raw
                        self._target_last = self._core.last_raw
                        self._core.set_ask_raw(price._mem.raw)
                        self._core.set_last_raw(price._mem.raw)
                        last_px._mem.raw = price._mem.raw
            elif order.side == OrderSide.SELL:
                if triggered_price and price < triggered_price:
                    price = triggered_price
                for fill in fills:
                    last_px = fill[0]

                    if last_px._mem.raw > price._mem.raw:
                        # Marketable SELL would have filled at limit
                        self._has_targets = True
                        self._target_bid = self._core.bid_raw
                        self._target_ask = self._core.ask_raw
                        self._target_last = self._core.last_raw
                        self._core.set_bid_raw(price._mem.raw)
                        self._core.set_last_raw(price._mem.raw)
                        last_px._mem.raw = price._mem.raw
            else:
                raise RuntimeError(f"invalid `OrderSide`, was {order.side}")  # pragma: no cover (design-time error)

        return fills

    cpdef void apply_fills(
        self,
        Order order,
        list fills,
        LiquiditySide liquidity_side,
        PositionId venue_position_id: PositionId | None = None,
        Position position: Position | None = None,
    ):
        """
        Apply the given list of fills to the given order. Optionally provide
        existing position details.

        - If the `fills` list is empty, an error will be logged.
        - Market orders will be rejected if no opposing orders are available to fulfill them.

        Parameters
        ----------
        order : Order
            The order to fill.
        fills : list[tuple[Price, Quantity]]
            The fills to apply to the order.
        liquidity_side : LiquiditySide
            The liquidity side for the fill(s).
        venue_position_id :  PositionId, optional
            The current venue position ID related to the order (if assigned).
        position : Position, optional
            The current position related to the order (if any).

        Raises
        ------
        ValueError
            If `liquidity_side` is ``NO_LIQUIDITY_SIDE``.

        Warnings
        --------
        The `liquidity_side` will override anything previously set on the order.

        """
        Condition.not_none(order, "order")
        Condition.not_none(fills, "fills")
        Condition.not_equal(liquidity_side, LiquiditySide.NO_LIQUIDITY_SIDE, "liquidity_side", "NO_LIQUIDITY_SIDE")

        order.liquidity_side = liquidity_side

        cdef:
            Price fill_px
            Quantity fill_qty
            QuantityRaw total_size_raw = 0
        if order.time_in_force == TimeInForce.FOK:
            # Check FOK requirement
            for fill in fills:
                fill_px, fill_qty = fill
                total_size_raw += fill_qty._mem.raw

            if order.leaves_qty._mem.raw > total_size_raw:
                self.cancel_order(order)
                return  # Cannot fill full size - so kill/cancel

        if not fills:
            if order.status_c() == OrderStatus.SUBMITTED:
                self._generate_order_rejected(order, f"no market with no fills for {order.instrument_id}")
            else:
                self._log.error(
                    "Cannot fill order: no fills from book when fills were expected (check data)",
                )
            return  # No fills

        if self.oms_type == OmsType.NETTING:
            venue_position_id = None  # No position IDs generated by the venue

        if is_logging_initialized():
            self._log.debug(
                "Market: "
                f"bid={self._book.best_bid_size()} @ {self._book.best_bid_price()}, "
                f"ask={self._book.best_ask_size()} @ {self._book.best_ask_price()}, "
                f"last={self._core.last}",
            )
            self._log.debug(
                f"Applying fills to {order}, "
                f"venue_position_id={venue_position_id}, "
                f"position={position}, "
                f"fills={fills}",
            )

        cdef:
            bint initial_market_to_limit_fill = False
            Price last_fill_px = None
        for fill_px, fill_qty in fills:
            # Validate price precision
            if fill_px._mem.precision != self.instrument.price_precision:
                raise RuntimeError(
                    f"Invalid price precision for fill {fill_px.precision} "
                    f"when instrument price precision is {self.instrument.price_precision}. "
                    f"Check that the data price precision matches the {self.instrument.id} instrument"
                )

            # Validate size precision
            if fill_qty._mem.precision != self.instrument.size_precision:
                raise RuntimeError(
                    f"Invalid size precision for fill {fill_qty.precision} "
                    f"when instrument size precision is {self.instrument.size_precision}. "
                    f"Check that the data size precision matches the {self.instrument.id} instrument"
                )

            if order.filled_qty._mem.raw == 0:
                if order.order_type == OrderType.MARKET_TO_LIMIT:
                    self._generate_order_updated(
                        order,
                        qty=order.quantity,
                        price=fill_px,
                        trigger_price=None,
                    )
                    initial_market_to_limit_fill = True

            if self.book_type == BookType.L1_MBP and self._fill_model.is_slipped():
                if order.side == OrderSide.BUY:
                    fill_px = fill_px.add(self.instrument.price_increment)
                elif order.side == OrderSide.SELL:
                    fill_px = fill_px.sub(self.instrument.price_increment)
                else:
                    raise ValueError(  # pragma: no cover (design-time error)
                        f"invalid `OrderSide`, was {order.side}",  # pragma: no cover (design-time error)
                    )

            # Check reduce only order
            if self._use_reduce_only and order.is_reduce_only and fill_qty._mem.raw > position.quantity._mem.raw:
                if position.quantity._mem.raw == 0:
                    return  # Done

                # Adjust fill to honor reduce only execution (fill remaining position size only)
                fill_qty = Quantity.from_raw_c(position.quantity._mem.raw, fill_qty._mem.precision)

                self._generate_order_updated(
                    order=order,
                    qty=fill_qty,
                    price=None,
                    trigger_price=None,
                )

            if fill_qty._mem.raw == 0:
                if len(fills) == 1 and order.status_c() == OrderStatus.SUBMITTED:
                    self._generate_order_rejected(order, f"no market for {order.instrument_id}")

                return  # Done

            self.fill_order(
                order=order,
                last_px=fill_px,
                last_qty=fill_qty,
                liquidity_side=order.liquidity_side,
                venue_position_id=venue_position_id,
                position=position,
            )
            if order.order_type == OrderType.MARKET_TO_LIMIT and initial_market_to_limit_fill:
                return  # Filled initial level

            last_fill_px = fill_px

        if order.time_in_force == TimeInForce.IOC and order.is_open_c():
            # IOC order has filled all available size
            self.cancel_order(order)
            return

        # Check MARKET order on exhausted book volume
        if (
            order.is_open_c()
            and self.book_type == BookType.L1_MBP
            and (
            order.order_type == OrderType.MARKET
            or order.order_type == OrderType.MARKET_IF_TOUCHED
            or order.order_type == OrderType.STOP_MARKET
            or order.order_type == OrderType.TRAILING_STOP_MARKET
        )
        ):
            # Exhausted simulated book volume (continue aggressive filling into next level)
            # This is a very basic implementation of slipping by a single tick, in the future
            # we will implement more detailed fill modeling.
            if order.side == OrderSide.BUY:
                fill_px = last_fill_px.add(self.instrument.price_increment)
            elif order.side == OrderSide.SELL:
                fill_px = last_fill_px.sub(self.instrument.price_increment)
            else:
                raise ValueError(  # pragma: no cover (design-time error)
                    f"invalid `OrderSide`, was {order.side}",  # pragma: no cover (design-time error)
                )

            self.fill_order(
                order=order,
                last_px=fill_px,
                last_qty=order.leaves_qty,
                liquidity_side=order.liquidity_side,
                venue_position_id=venue_position_id,
                position=position,
            )

        # Check LIMIT order on exhausted book volume
        if (
            order.is_open_c()
            and self.book_type == BookType.L1_MBP
            and (
            order.order_type == OrderType.LIMIT
            or order.order_type == OrderType.LIMIT_IF_TOUCHED
            or order.order_type == OrderType.MARKET_TO_LIMIT
            or order.order_type == OrderType.STOP_LIMIT
            or order.order_type == OrderType.TRAILING_STOP_LIMIT
        )
        ):
            if not self._has_targets and ((order.side == OrderSide.BUY and order.price == self._core.ask) or (order.side == OrderSide.SELL and order.price == self._core.bid)):
                return  # Limit price is equal to top-of-book, no further fills

            if order.liquidity_side == LiquiditySide.MAKER:
                # Market moved through limit price, assumption is there was enough liquidity to fill entire order
                fill_px = order.price
            else:  # Marketable limit order
                # Exhausted simulated book volume (continue aggressive filling into next level)
                # This is a very basic implementation of slipping by a single tick, in the future
                # we will implement more detailed fill modeling.
                if order.side == OrderSide.BUY:
                    fill_px = last_fill_px.add(self.instrument.price_increment)
                elif order.side == OrderSide.SELL:
                    fill_px = last_fill_px.sub(self.instrument.price_increment)
                else:
                    raise ValueError(  # pragma: no cover (design-time error)
                        f"invalid `OrderSide`, was {order.side}",  # pragma: no cover (design-time error)
                    )

            self.fill_order(
                order=order,
                last_px=fill_px,
                last_qty=order.leaves_qty,
                liquidity_side=order.liquidity_side,
                venue_position_id=venue_position_id,
                position=position,
            )

        # Generate leg fills for spread orders after normal combo fill processing
        if order.instrument_id.is_spread() and order.is_closed_c():
            self._generate_spread_leg_fills(order, fills, liquidity_side)

    cdef void _generate_spread_leg_fills(
        self,
        Order order,
        list fills,
        LiquiditySide liquidity_side,
    ):
        """
        Generate individual leg fills for position tracking after spread order is filled.

        This method generates synthetic leg fills with "-LEG-" identifiers that will be
        handled by the ExecutionEngine for position tracking, following the IB pattern.
        """
        if not fills:
            return

        # Parse spread legs from instrument ID
        leg_tuples = order.instrument_id.to_list()
        spread_instrument_ids = [leg[0] for leg in leg_tuples]

        spread_fill_px = fills[0][0]
        spread_fill_qty = fills[0][1]

        # Calculate leg execution prices
        leg_prices = self._calculate_leg_execution_prices(
            leg_tuples=leg_tuples,
            spread_execution_price=spread_fill_px,
            spread_quantity=spread_fill_qty,
        )

        if not leg_prices:
            self._log.warning(f"Could not calculate leg prices for spread {order.instrument_id}")
            return

        # Generate fills for each leg
        for leg_instrument_id, ratio in leg_tuples:
            if leg_instrument_id not in leg_prices:
                continue

            leg_price = leg_prices[leg_instrument_id]

            # Calculate leg quantity: spread_quantity * abs(ratio)
            leg_quantity = Quantity(
                spread_fill_qty.as_double() * abs(ratio),
                precision=spread_fill_qty.precision,
            )

            # Get leg instrument for precision validation
            leg_instrument = self.cache.instrument(leg_instrument_id)

            if leg_instrument is None:
                self._log.warning(f"Leg instrument not found in cache: {leg_instrument_id}")
                continue

            # Generate synthetic leg fill directly
            adjusted_leg_price = leg_price

            # Use make_qty for proper size increment rounding
            adjusted_leg_quantity = leg_instrument.make_qty(
                leg_quantity.as_double(),
                round_down=True,  # Round down to ensure valid size
            )

            # Calculate commission for the leg
            commission = self._fee_model.get_commission(
                order=order,  # Use spread order for fee calculation context
                fill_qty=adjusted_leg_quantity,
                fill_px=adjusted_leg_price,
                instrument=leg_instrument,
            )

            # Generate unique IDs for the leg fill (following IB adapter pattern)
            # Get leg position in spread for unique identification
            leg_position = spread_instrument_ids.index(leg_instrument_id) if leg_instrument_id in spread_instrument_ids else 0

            # Generate unique client order ID for leg fill (avoids order state conflicts)
            leg_client_order_id = ClientOrderId(f"{order.client_order_id.value}-LEG-{leg_instrument_id.symbol.value}")

            # Generate unique venue order ID for leg fill
            leg_venue_order_id = VenueOrderId(f"{order.venue_order_id.value}-LEG-{leg_position}")

            # Generate unique trade ID for the leg fill (matching IB pattern: {execution.execId}-{leg_position})
            # Use the same base execution ID format as combo fills but append leg position
            leg_trade_id = TradeId(f"{self.venue.to_str()}-{self.raw_id}-{self._execution_count:03d}-{leg_position}")

            # Leg side mapping based on spread order direction
            # If spread BUY: positive ratio = BUY leg, negative = SELL leg
            # If spread SELL: positive ratio = SELL leg, negative = BUY leg
            order_side = order.side if ratio > 0 else (OrderSide.SELL if order.side == OrderSide.BUY else OrderSide.BUY)

            # Create OrderFilled event for the leg
            ts_now = self._clock.timestamp_ns()
            leg_fill = OrderFilled(
                trader_id=order.trader_id,
                strategy_id=order.strategy_id,
                instrument_id=leg_instrument_id,
                client_order_id=leg_client_order_id,  # Use unique leg client order ID
                venue_order_id=leg_venue_order_id,  # Use unique leg venue order ID
                account_id=order.account_id,
                trade_id=leg_trade_id,
                order_side=order_side,
                order_type=order.order_type,
                last_qty=adjusted_leg_quantity,
                last_px=adjusted_leg_price,
                currency=leg_instrument.quote_currency,
                liquidity_side=liquidity_side,
                event_id=UUID4(),
                ts_event=ts_now,
                ts_init=ts_now,
                reconciliation=False,
                position_id=None,
                commission=commission,
            )

            # Publish the leg fill event (same as regular order fills)
            self.msgbus.send(endpoint="ExecEngine.process", msg=leg_fill)

    cdef dict _calculate_leg_execution_prices(
        self,
        list leg_tuples,
        Price spread_execution_price,
        Quantity spread_quantity,
    ):
        """
        Calculate leg execution prices using mid-prices with adjustment.

        Uses mid-price for all legs except the highest-priced one, which is
        adjusted to satisfy: Σ(leg_price × ratio) = spread_execution_price
        """
        cdef dict leg_mid_prices = {}
        cdef dict leg_prices = {}
        cdef double highest_mid_price = 0.0
        cdef InstrumentId highest_price_leg_id = None

        # Get mid-prices for all legs
        for leg_instrument_id, ratio in leg_tuples:
            leg_quote = self.cache.quote_tick(leg_instrument_id)

            if leg_quote is None:
                self._log.warning(f"No quote available for leg {leg_instrument_id}")
                return {}

            mid_price = (leg_quote.bid_price.as_double() + leg_quote.ask_price.as_double()) * 0.5
            leg_mid_prices[leg_instrument_id] = mid_price

            # Track the leg with highest mid-price (this will be adjusted)
            if mid_price > highest_mid_price:
                highest_mid_price = mid_price
                highest_price_leg_id = leg_instrument_id

        if highest_price_leg_id is None:
            return {}

        # Calculate weighted sum using mid-prices for all legs except the highest
        cdef double weighted_sum = 0.0
        cdef int highest_price_ratio = 1

        for leg_instrument_id, ratio in leg_tuples:
            if leg_instrument_id != highest_price_leg_id:
                weighted_sum += leg_mid_prices[leg_instrument_id] * ratio

                # Get actual instrument to use its make_price method for proper tick rounding
                leg_instrument = self.cache.instrument(leg_instrument_id)

                if leg_instrument is not None:
                    leg_prices[leg_instrument_id] = leg_instrument.make_price(
                        leg_mid_prices[leg_instrument_id]
                    )
                else:
                    # If instrument not found, log warning and abort
                    self._log.warning(
                        f"Cannot find leg instrument {leg_instrument_id} in cache, "
                        f"aborting leg price calculation for spread"
                    )
                    return {}
            else:
                # Store the ratio for the highest-priced leg for adjustment calculation
                highest_price_ratio = ratio

        # Calculate adjusted price for the highest-priced leg
        # spread_execution_price = Σ(leg_price × ratio)
        # adjusted_price = (spread_execution_price - weighted_sum) / highest_price_ratio
        cdef double adjusted_price = (spread_execution_price.as_double() - weighted_sum) / highest_price_ratio

        # Get actual instrument for highest-priced leg to use its make_price method
        highest_leg_instrument = self.cache.instrument(highest_price_leg_id)

        if highest_leg_instrument is not None:
            leg_prices[highest_price_leg_id] = highest_leg_instrument.make_price(adjusted_price)
        else:
            # If instrument not found, log warning and abort
            self._log.warning(
                f"Cannot find highest-priced leg instrument {highest_price_leg_id} in cache, "
                f"aborting leg price calculation for spread"
            )
            return {}

        return leg_prices

    cpdef void fill_order(
        self,
        Order order,
        Price last_px,
        Quantity last_qty,
        LiquiditySide liquidity_side,
        PositionId venue_position_id: PositionId | None = None,
        Position position: Position | None = None,
    ):
        """
        Apply the given list of fills to the given order. Optionally provide
        existing position details.

        Parameters
        ----------
        order : Order
            The order to fill.
        last_px : Price
            The fill price for the order.
        last_qty : Quantity
            The fill quantity for the order.
        liquidity_side : LiquiditySide
            The liquidity side for the fill.
        venue_position_id :  PositionId, optional
            The current venue position ID related to the order (if assigned).
        position : Position, optional
            The current position related to the order (if any).

        Raises
        ------
        ValueError
            If `liquidity_side` is ``NO_LIQUIDITY_SIDE``.

        Warnings
        --------
        The `liquidity_side` will override anything previously set on the order.

        """
        Condition.not_none(order, "order")
        Condition.not_none(last_px, "last_px")
        Condition.not_none(last_qty, "last_qty")
        Condition.not_equal(liquidity_side, LiquiditySide.NO_LIQUIDITY_SIDE, "liquidity_side", "NO_LIQUIDITY_SIDE")

        order.liquidity_side = liquidity_side

        cdef Quantity cached_filled_qty = self._cached_filled_qty.get(order.client_order_id)
        cdef Quantity leaves_qty = None
        if cached_filled_qty is None:
            # Clamp the first fill to the order quantity to avoid over-filling
            last_qty = Quantity.from_raw_c(min(order.quantity._mem.raw, last_qty._mem.raw), last_qty._mem.precision)
            self._cached_filled_qty[order.client_order_id] = Quantity.from_raw_c(last_qty._mem.raw, last_qty._mem.precision)
        else:
            leaves_qty = Quantity.from_raw_c(order.quantity._mem.raw - cached_filled_qty._mem.raw, last_qty._mem.precision)
            last_qty = Quantity.from_raw_c(min(leaves_qty._mem.raw, last_qty._mem.raw), last_qty._mem.precision)
            cached_filled_qty._mem.raw += last_qty._mem.raw

        # Nothing to fill when adjusted last_qty <= 0.
        # Update _cached_filled_qty first to absorb duplicate or out-of-order fills
        # (seen in sandbox/async environments) and avoid emitting zero/negative fills.
        if last_qty <= 0:
            return

        # Calculate commission
        cdef Money commission = self._fee_model.get_commission(
            order=order,
            fill_qty=last_qty,
            fill_px=last_px,
            instrument=self.instrument,
        )

        self._generate_order_filled(
            order=order,
            venue_order_id=self._get_venue_order_id(order),
            venue_position_id=venue_position_id,
            last_qty=last_qty,
            last_px=last_px,
            quote_currency=self.instrument.quote_currency,
            commission=commission,
            liquidity_side=order.liquidity_side,
        )

        if order.is_passive_c() and order.is_closed_c():
            # Remove order from market
            self._core.delete_order(order)
            self._cached_filled_qty.pop(order.client_order_id, None)

        if not self._support_contingent_orders:
            return

        # Check contingent orders
        cdef ClientOrderId client_order_id
        cdef Order child_order
        if order.contingency_type == ContingencyType.OTO:
            for client_order_id in order.linked_order_ids or []:
                child_order = self.cache.order(client_order_id)
                assert child_order is not None, "OTO child order not found"

                if child_order.is_closed_c():
                    continue

                if child_order.is_active_local_c():
                    continue  # Order is not on the exchange yet

                if child_order.position_id is None and order.position_id is not None:
                    self.cache.add_position_id(
                        position_id=order.position_id,
                        venue=self.venue,
                        client_order_id=client_order_id,
                        strategy_id=child_order.strategy_id,
                    )
                    self._log.debug(
                        f"Indexed {order.position_id!r} "
                        f"for {child_order.client_order_id!r}",
                    )
                if not child_order.is_open_c() or (child_order.status_c() == OrderStatus.PENDING_UPDATE and child_order._previous_status == OrderStatus.SUBMITTED):
                    self.process_order(
                        order=child_order,
                        account_id=order.account_id or self._account_ids[order.trader_id],
                    )
        elif order.contingency_type == ContingencyType.OCO:
            for client_order_id in order.linked_order_ids or []:
                oco_order = self.cache.order(client_order_id)
                assert oco_order is not None, "OCO order not found"

                if oco_order.is_closed_c():
                    continue

                if oco_order.is_active_local_c():
                    continue  # Order is not on the exchange yet

                self.cancel_order(oco_order)
        elif order.contingency_type == ContingencyType.OUO:
            for client_order_id in order.linked_order_ids or []:
                ouo_order = self.cache.order(client_order_id)
                assert ouo_order is not None, "OUO order not found"

                if ouo_order.is_active_local_c():
                    continue  # Order is not on the exchange yet

                if order.is_closed_c() and ouo_order.is_open_c():
                    self.cancel_order(ouo_order)
                elif order.leaves_qty._mem.raw != 0 and order.leaves_qty._mem.raw != ouo_order.leaves_qty._mem.raw:
                    self.update_order(
                        ouo_order,
                        order.leaves_qty,
                        price=ouo_order.price if ouo_order.has_price_c() else None,
                        trigger_price=ouo_order.trigger_price if ouo_order.has_trigger_price_c() else None,
                        update_contingencies=False,
                    )

        if position is None:
            return  # Fill completed

        # Check reduce only orders for position
        # Previously all reduce-only orders were force-synced to the net position size,
        # which incorrectly merged quantities across independent bracket orders.
        # Instead, prefer syncing each reduce-only child (TP/SL) to its own parent
        # entry order's filled quantity when available; fall back to position size
        # only for standalone reduce-only orders without a parent.
        cdef:
            Order ro_order
            Order parent_order
            Quantity cached_ro_filled
            Quantity cached_parent_filled
            Quantity target_qty
        for ro_order in self.cache.orders_for_position(position.id):
            if (
                self._use_reduce_only
                and ro_order.is_reduce_only
                and ro_order.is_open_c()
                and ro_order.is_passive_c()
            ):
                # Skip the order being filled - it's already being processed
                if ro_order.client_order_id == order.client_order_id:
                    continue

                if position.quantity._mem.raw == 0:
                    self.cancel_order(ro_order)
                    continue

                # Order object may not be updated yet with fills
                cached_ro_filled = self._cached_filled_qty.get(ro_order.client_order_id, ro_order.filled_qty)

                # Use Quantity objects for comparisons to handle precision correctly
                parent_order = None
                if ro_order.parent_order_id is not None:
                    parent_order = self.cache.order(ro_order.parent_order_id)

                target_qty = position.quantity

                if parent_order is not None:
                    cached_parent_filled = self._cached_filled_qty.get(parent_order.client_order_id, parent_order.filled_qty)

                    # Use minimum of parent's filled qty and position qty
                    if cached_parent_filled < position.quantity:
                        target_qty = cached_parent_filled

                # Safety clamp: never update total below what's already filled
                if cached_ro_filled > target_qty:
                    target_qty = cached_ro_filled

                if ro_order.quantity != target_qty:
                    self.update_order(
                        ro_order,
                        target_qty,
                        price=ro_order.price if ro_order.has_price_c() else None,
                        trigger_price=ro_order.trigger_price if ro_order.has_trigger_price_c() else None,
                    )

# -- IDENTIFIER GENERATORS ------------------------------------------------------------------------

    cdef VenueOrderId _get_venue_order_id(self, Order order):
        # Check existing on order
        cdef VenueOrderId venue_order_id = order.venue_order_id
        if venue_order_id is not None:
            return venue_order_id

        # Check exiting in cache
        venue_order_id = self.cache.venue_order_id(order.client_order_id)
        if venue_order_id is not None:
            return venue_order_id

        venue_order_id = self._generate_venue_order_id()
        self.cache.add_venue_order_id(order.client_order_id, venue_order_id)

        return venue_order_id

    cdef PositionId _get_position_id(self, Order order, bint generate=True):
        cdef PositionId position_id
        if self.oms_type == OmsType.HEDGING:
            position_id = self.cache.position_id(order.client_order_id)

            if position_id is not None:
                return position_id

            if generate:
                # Generate a venue position ID
                return self._generate_venue_position_id()

        ####################################################################
        # NETTING OMS (position ID will be `{instrument_id}-{strategy_id}`)
        ####################################################################
        cdef list positions_open = self.cache.positions_open(
            venue=None,  # Faster query filtering
            instrument_id=order.instrument_id,
        )
        if positions_open:
            return positions_open[0].id
        else:
            return None

    cdef PositionId _generate_venue_position_id(self):
        if not self._use_position_ids:
            return None

        self._position_count += 1

        if self._use_random_ids:
            return PositionId(str(uuid.uuid4()))
        else:
            return PositionId(f"{self.venue.to_str()}-{self.raw_id}-{self._position_count:03d}")

    cdef VenueOrderId _generate_venue_order_id(self):
        self._order_count += 1

        if self._use_random_ids:
            return VenueOrderId(str(uuid.uuid4()))
        else:
            return VenueOrderId(f"{self.venue.to_str()}-{self.raw_id}-{self._order_count:03d}")

    cdef TradeId _generate_trade_id(self):
        self._execution_count += 1
        return TradeId(self._generate_trade_id_str())

    cdef str _generate_trade_id_str(self):
        if self._use_random_ids:
            return str(uuid.uuid4())
        else:
            return f"{self.venue.to_str()}-{self.raw_id}-{self._execution_count:03d}"

# -- EVENT HANDLING -------------------------------------------------------------------------------

    cpdef void accept_order(self, Order order):
        if order.is_closed_c():
            return  # Temporary guard to prevent invalid processing

        # Check if order already accepted (being added back into the matching engine)
        if not order.status_c() == OrderStatus.ACCEPTED:
            self._generate_order_accepted(order, venue_order_id=self._get_venue_order_id(order))

            if (
                order.order_type == OrderType.TRAILING_STOP_MARKET
                or order.order_type == OrderType.TRAILING_STOP_LIMIT
            ):
                if order.trigger_price is None:
                    self._trail_stop_order(order)

        self._core.add_order(order)

    cpdef void expire_order(self, Order order):
        if self._support_contingent_orders and order.contingency_type != ContingencyType.NO_CONTINGENCY:
            self._cancel_contingent_orders(order)

        self._generate_order_expired(order)

    cpdef void cancel_order(self, Order order, bint cancel_contingencies=True):
        if order.is_active_local_c():
            self._log.error(
                f"Cannot cancel an order with {order.status_string_c()} from the matching engine",
            )
            return

        self._core.delete_order(order)
        self._cached_filled_qty.pop(order.client_order_id, None)

        self._generate_order_canceled(order, venue_order_id=self._get_venue_order_id(order))

        if self._support_contingent_orders and order.contingency_type != ContingencyType.NO_CONTINGENCY and cancel_contingencies:
            self._cancel_contingent_orders(order)

    cpdef void update_order(
        self,
        Order order,
        Quantity qty,
        Price price = None,
        Price trigger_price = None,
        bint update_contingencies = True,
    ):
        if qty is None:
            qty = order.quantity

        # Use _cached_filled_qty since order object may not have updated filled_qty
        cdef Quantity filled_qty = self._cached_filled_qty.get(order.client_order_id, order.filled_qty)
        if qty < filled_qty:
            self._generate_order_modify_rejected(
                trader_id=order.trader_id,
                strategy_id=order.strategy_id,
                account_id=order.account_id,
                instrument_id=order.instrument_id,
                client_order_id=order.client_order_id,
                venue_order_id=order.venue_order_id,
                reason=f"Cannot reduce order quantity {qty} below filled quantity {filled_qty}",
            )
            return

        if order.order_type == OrderType.LIMIT or order.order_type == OrderType.MARKET_TO_LIMIT:
            if price is None:
                price = order.price

            self._update_limit_order(order, qty, price)
        elif order.order_type == OrderType.STOP_MARKET:
            if trigger_price is None:
                trigger_price = order.trigger_price

            self._update_stop_market_order(order, qty, trigger_price)
        elif order.order_type == OrderType.STOP_LIMIT:
            if price is None:
                price = order.price

            if trigger_price is None:
                trigger_price = order.trigger_price

            self._update_stop_limit_order(order, qty, price, trigger_price)
        elif order.order_type == OrderType.MARKET_IF_TOUCHED:
            if trigger_price is None:
                trigger_price = order.trigger_price

            self._update_market_if_touched_order(order, qty, trigger_price)
        elif order.order_type == OrderType.LIMIT_IF_TOUCHED:
            if price is None:
                price = order.price

            if trigger_price is None:
                trigger_price = order.trigger_price

            self._update_limit_if_touched_order(order, qty, price, trigger_price)
        elif order.order_type == OrderType.TRAILING_STOP_MARKET:
            if trigger_price is None:
                trigger_price = order.trigger_price

            self._update_trailing_stop_market_order(order, qty, trigger_price)
        elif order.order_type == OrderType.TRAILING_STOP_LIMIT:
            if price is None:
                price = order.price

            if trigger_price is None:
                trigger_price = order.trigger_price

            self._update_trailing_stop_limit_order(order, qty, price, trigger_price)
        else:
            raise ValueError(
                f"invalid `OrderType` was {order.order_type}")  # pragma: no cover (design-time error)

        # If order now has zero leaves after update, cancel it
        cdef uint64_t new_leaves_raw = qty._mem.raw - filled_qty._mem.raw if qty._mem.raw > filled_qty._mem.raw else 0
        if new_leaves_raw == 0:
            if self._support_contingent_orders and order.contingency_type != ContingencyType.NO_CONTINGENCY and update_contingencies:
                self._update_contingent_orders(order)
            # Pass False since we already handled contingents above
            self.cancel_order(order, cancel_contingencies=False)
            return

        if self._support_contingent_orders and order.contingency_type != ContingencyType.NO_CONTINGENCY and update_contingencies:
            self._update_contingent_orders(order)

    cpdef void trigger_stop_order(self, Order order):
        # Always STOP_LIMIT or LIMIT_IF_TOUCHED orders
        cdef Price trigger_price = order.trigger_price
        cdef Price price = order.price

        if self._fill_model:
            if order.side == OrderSide.BUY and self._core.ask_raw == trigger_price._mem.raw and not self._fill_model.is_stop_filled():
                return  # Not triggered
            elif order.side == OrderSide.SELL and self._core.bid_raw == trigger_price._mem.raw and not self._fill_model.is_stop_filled():
                return  # Not triggered

        self._generate_order_triggered(order)

        # Check for immediate fill (which would fill passively as a maker)
        if order.side == OrderSide.BUY and trigger_price._mem.raw > price._mem.raw > self._core.ask_raw:
            order.liquidity_side = LiquiditySide.MAKER
            self.fill_limit_order(order)
            return
        elif order.side == OrderSide.SELL and trigger_price._mem.raw < price._mem.raw < self._core.bid_raw:
            order.liquidity_side = LiquiditySide.MAKER
            self.fill_limit_order(order)
            return

        if self._core.is_limit_matched(order.side, price):
            if order.is_post_only:
                # Would be liquidity taker
                self._core.delete_order(order)
                self._cached_filled_qty.pop(order.client_order_id, None)
                self._generate_order_rejected(
                    order,
                    f"POST_ONLY {order.type_string_c()} {order.side_string_c()} order "
                    f"limit px of {order.price} would have been a TAKER: "
                    f"bid={self._core.bid}, "
                    f"ask={self._core.ask}",
                    True,  # due_post_only
                )
                return

            order.liquidity_side = LiquiditySide.TAKER
            self.fill_limit_order(order)

    cdef void _update_contingent_orders(self, Order order):
        self._log.debug(f"Updating OUO orders from {order.client_order_id}", LogColor.MAGENTA)

        cdef Quantity parent_filled_qty = self._cached_filled_qty.get(order.client_order_id, order.filled_qty)
        cdef uint64_t parent_leaves_raw = order.quantity._mem.raw - parent_filled_qty._mem.raw if order.quantity._mem.raw > parent_filled_qty._mem.raw else 0

        cdef ClientOrderId client_order_id
        cdef Order ouo_order
        cdef Quantity child_filled_qty
        cdef uint64_t child_leaves_raw
        for client_order_id in order.linked_order_ids or []:
            ouo_order = self.cache.order(client_order_id)
            assert ouo_order is not None, "OUO order not found"

            if ouo_order.is_active_local_c():
                continue  # Order is not on the exchange yet

            if ouo_order.order_type == OrderType.MARKET or ouo_order.is_closed_c():
                continue

            child_filled_qty = self._cached_filled_qty.get(ouo_order.client_order_id, ouo_order.filled_qty)

            if parent_leaves_raw == 0:
                self.cancel_order(ouo_order, cancel_contingencies=False)
            elif child_filled_qty._mem.raw >= parent_leaves_raw:
                # Child already filled beyond parent's remaining qty, cancel it
                self.cancel_order(ouo_order, cancel_contingencies=False)
            else:
                child_leaves_raw = ouo_order.quantity._mem.raw - child_filled_qty._mem.raw if ouo_order.quantity._mem.raw > child_filled_qty._mem.raw else 0
                if child_leaves_raw != parent_leaves_raw:
                    self.update_order(
                        ouo_order,
                        Quantity.from_raw_c(parent_leaves_raw, order.quantity._mem.precision),
                        price=ouo_order.price if ouo_order.has_price_c() else None,
                        trigger_price=ouo_order.trigger_price if ouo_order.has_trigger_price_c() else None,
                        update_contingencies=False,
                    )

    cdef void _cancel_contingent_orders(self, Order order):
        # Iterate all contingent orders and cancel if active
        cdef ClientOrderId client_order_id
        cdef Order contingent_order
        for client_order_id in order.linked_order_ids or []:
            contingent_order = self.cache.order(client_order_id)
            assert contingent_order is not None, "Contingency order not found"

            if contingent_order.is_active_local_c():
                continue  # Order is not on the exchange yet

            if not contingent_order.is_closed_c():
                self.cancel_order(contingent_order, cancel_contingencies=False)

# -- EVENT GENERATORS -----------------------------------------------------------------------------

    cdef void _generate_order_rejected(self, Order order, str reason, bint due_post_only=False):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderRejected event = OrderRejected(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            account_id=order.account_id or self._account_ids[order.trader_id],
            reason=reason,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
            due_post_only=due_post_only,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cdef void _generate_order_accepted(self, Order order, VenueOrderId venue_order_id):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderAccepted event = OrderAccepted(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=venue_order_id,
            account_id=order.account_id or self._account_ids[order.trader_id],
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cdef void _generate_order_modify_rejected(
        self,
        TraderId trader_id,
        StrategyId strategy_id,
        AccountId account_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        str reason,
    ):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderModifyRejected event = OrderModifyRejected(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=account_id,
            reason=reason,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cdef void _generate_order_cancel_rejected(
        self,
        TraderId trader_id,
        StrategyId strategy_id,
        AccountId account_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        str reason,
    ):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderCancelRejected event = OrderCancelRejected(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=account_id,
            reason=reason,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cpdef void _generate_order_updated(
        self,
        Order order,
        Quantity quantity,
        Price price,
        Price trigger_price,
    ):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderUpdated event = OrderUpdated(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id or self._account_ids[order.trader_id],
            quantity=quantity,
            price=price,
            trigger_price=trigger_price,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cdef void _generate_order_canceled(self, Order order, VenueOrderId venue_order_id):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderCanceled event = OrderCanceled(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=venue_order_id,
            account_id=order.account_id or self._account_ids[order.trader_id],
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cdef void _generate_order_triggered(self, Order order):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderTriggered event = OrderTriggered(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id or self._account_ids[order.trader_id],
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cdef void _generate_order_expired(self, Order order):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderExpired event = OrderExpired(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id or self._account_ids[order.trader_id],
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

    cdef void _generate_order_filled(
        self,
        Order order,
        VenueOrderId venue_order_id,
        PositionId venue_position_id,
        Quantity last_qty,
        Price last_px,
        Currency quote_currency,
        Money commission,
        LiquiditySide liquidity_side
    ):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderFilled event = OrderFilled(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=venue_order_id,
            account_id=order.account_id or self._account_ids[order.trader_id],
            trade_id=self._generate_trade_id(),
            position_id=venue_position_id,
            order_side=order.side,
            order_type=order.order_type,
            last_qty=last_qty,
            last_px=last_px,
            currency=quote_currency,
            commission=commission,
            liquidity_side=liquidity_side,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self.msgbus.send(endpoint="ExecEngine.process", msg=event)

</document_content>
</document>
<document index="2210">
<source>nautilus_trader/backtest/execution_client.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.accounting.factory import AccountFactory
from nautilus_trader.common.config import NautilusConfig

from nautilus_trader.backtest.engine cimport SimulatedExchange
from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport TestClock
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.execution.client cimport ExecutionClient
from nautilus_trader.execution.messages cimport BatchCancelOrders
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.orders.base cimport Order


cdef class BacktestExecClient(ExecutionClient):
    """
    Provides an execution client for the `BacktestEngine`.

    Parameters
    ----------
    exchange : SimulatedExchange
        The simulated exchange for the backtest.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : TestClock
        The clock for the client.
    routing : bool
        If multi-venue routing is enabled for the client.
    frozen_account : bool
        If the backtest run account is frozen.
    allow_cash_borrowing : bool
        If cash accounts should allow borrowing (negative balances).
    """

    def __init__(
        self,
        SimulatedExchange exchange not None,
        MessageBus msgbus not None,
        Cache cache not None,
        TestClock clock not None,
        bint routing=False,
        bint frozen_account=False,
        bint allow_cash_borrowing=False,
    ) -> None:
        super().__init__(
            client_id=ClientId(exchange.id.value),
            venue=Venue(exchange.id.value),
            oms_type=exchange.oms_type,
            account_type=exchange.account_type,
            base_currency=exchange.base_currency,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
        )

        self._set_account_id(AccountId(f"{exchange.id.value}-001"))

        if not frozen_account:
            AccountFactory.register_calculated_account(exchange.id.value)

        if exchange.account_type == AccountType.CASH and allow_cash_borrowing:
            AccountFactory.register_cash_borrowing(exchange.id.value)

        self._exchange = exchange
        self.is_connected = False

    cpdef void _start(self):
        self._log.info(f"Connecting...")
        self.is_connected = True
        self._log.info(f"Connected")

    cpdef void _stop(self):
        self._log.info(f"Disconnecting...")
        self.is_connected = False
        self._log.info(f"Disconnected")

# -- COMMAND HANDLERS -----------------------------------------------------------------------------

    cpdef void submit_order(self, SubmitOrder command):
        Condition.is_true(self.is_connected, "not connected")

        self.generate_order_submitted(
            strategy_id=command.strategy_id,
            instrument_id=command.instrument_id,
            client_order_id=command.order.client_order_id,
            ts_event=self._clock.timestamp_ns(),
        )

        self._exchange.send(command)

    cpdef void submit_order_list(self, SubmitOrderList command):
        Condition.is_true(self.is_connected, "not connected")

        cdef Order order
        for order in command.order_list.orders:
            self.generate_order_submitted(
                strategy_id=order.strategy_id,
                instrument_id=order.instrument_id,
                client_order_id=order.client_order_id,
                ts_event=self._clock.timestamp_ns(),
            )

        self._exchange.send(command)

    cpdef void modify_order(self, ModifyOrder command):
        Condition.is_true(self.is_connected, "not connected")

        self._exchange.send(command)

    cpdef void cancel_order(self, CancelOrder command):
        Condition.is_true(self.is_connected, "not connected")

        self._exchange.send(command)

    cpdef void cancel_all_orders(self, CancelAllOrders command):
        Condition.is_true(self.is_connected, "not connected")

        self._exchange.send(command)

    cpdef void batch_cancel_orders(self, BatchCancelOrders command):
        Condition.is_true(self.is_connected, "not connected")

        self._exchange.send(command)

</document_content>
</document>
<document index="2214">
<source>nautilus_trader/backtest/models/aggregator.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from typing import Callable

import numpy as np

cimport numpy as np
from cpython.datetime cimport timedelta

from datetime import timedelta

from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Component
from nautilus_trader.common.component cimport Logger
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport TimeEvent
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.greeks cimport GreeksCalculator
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.base cimport Instrument


cdef class SpreadQuoteAggregator(Component):
    """
    Provides a spread quote generator for creating synthetic quotes from component instruments.

    The generator subscribes to quotes from component instruments of a spread and generates
    averaged quotes for the spread instrument.

    Parameters
    ----------
    spread_instrument_id : InstrumentId
        The spread instrument ID to generate quotes for.
    handler : Callable[[QuoteTick], None]
        The quote handler for the generator.
    cache : CacheFacade
        The cache facade for accessing market data.
    """

    def __init__(
        self,
        InstrumentId spread_instrument_id not None,
        handler not None: Callable[[QuoteTick], None],
        MessageBus msgbus not None,
        CacheFacade cache not None,
        Clock clock not None,
        int update_interval_seconds = 60,
    ):
        Condition.is_true(spread_instrument_id.is_spread(), "instrument_id must be a spread")

        super().__init__(clock=clock, msgbus=msgbus)
        self._handler = handler
        self._cache = cache
        self._log = Logger(name=f"{type(self).__name__}")

        self._spread_instrument_id = spread_instrument_id
        self._components = spread_instrument_id.to_list()
        self._greeks_calculator = GreeksCalculator(msgbus, cache, clock)

        self._component_ids = [component[0] for component in self._components]
        self._ratios = np.array([component[1] for component in self._components])
        n_components = len(self._components)
        self._mid_prices = np.zeros(n_components)
        self._vegas = np.zeros(n_components)
        self._bid_ask_spreads = np.zeros(n_components)
        self._bid_sizes = np.zeros(n_components)
        self._ask_sizes = np.zeros(n_components)

        self._update_interval_seconds = update_interval_seconds
        self._timer_name = f"spread_quote_timer_{self._spread_instrument_id}"
        self._set_build_timer()

    cdef void _set_build_timer(self):
        self._clock.set_timer(
            name=self._timer_name,
            interval=timedelta(seconds=self._update_interval_seconds),
            callback=self._build_quote,
            start_time=None,  # Start immediately
            stop_time=None,   # Run indefinitely
            allow_past=True,  # Allow past start times
            fire_immediately=True,  # Fire immediately when timer is set
        )

    cpdef void stop(self):
        self._clock.cancel_timer(self._timer_name)

    cdef void _build_quote(self, TimeEvent event):
        # Get spread instrument to use its attributes
        cdef Instrument spread_instrument = self._cache.instrument(self._spread_instrument_id)

        if spread_instrument is None:
            self._log.error(f"Cannot find spread instrument {self._spread_instrument_id}")
            return

        # Track missing components for better error reporting
        cdef list missing_quotes = []
        cdef list missing_greeks = []

        # Calculate component values
        for i, component_id in enumerate(self._component_ids):
            component_quote = self._cache.quote_tick(component_id)

            if component_quote is None:
                missing_quotes.append(str(component_id))
                continue

            greeks_data = self._greeks_calculator.instrument_greeks(
                component_id,
                percent_greeks=True,
                use_cached_greeks=True,  # Use cached greeks for testing
                vega_time_weight_base=30, # 30-day time weight base
            )

            if greeks_data is None:
                missing_greeks.append(str(component_id))
                continue

            ask_price = component_quote.ask_price.as_double()
            bid_price = component_quote.bid_price.as_double()

            self._mid_prices[i] = (ask_price + bid_price) * 0.5
            self._bid_ask_spreads[i] = ask_price - bid_price
            self._vegas[i] = greeks_data.vega
            self._bid_sizes[i] = component_quote.bid_size.as_double()
            self._ask_sizes[i] = component_quote.ask_size.as_double()

        # Check if we have all required data (use debug for timer-driven recurring conditions)
        if missing_quotes:
            self._log.debug(
                f"Missing quotes for spread {self._spread_instrument_id} components: {', '.join(missing_quotes)}"
            )
            return

        if missing_greeks:
            self._log.debug(
                f"Missing greeks for spread {self._spread_instrument_id} components: {', '.join(missing_greeks)}"
            )
            return

        # Calculate bid ask spread of option spread
        # Use np.divide with where clause to handle zero vegas safely
        vega_multipliers = np.divide(
            self._bid_ask_spreads,
            self._vegas,
            out=np.zeros_like(self._vegas),
            where=self._vegas != 0
        )

        # Filter out zero multipliers before taking mean
        non_zero_multipliers = vega_multipliers[vega_multipliers != 0]

        if len(non_zero_multipliers) == 0:
            self._log.debug(
                f"All vegas are zero for spread {self._spread_instrument_id}, cannot generate spread quote"
            )
            return

        vega_multiplier = np.abs(non_zero_multipliers).mean()
        spread_vega = abs(np.dot(self._vegas, self._ratios))

        bid_ask_spread = spread_vega * vega_multiplier
        self._log.debug(f"{self._bid_ask_spreads=}, {self._vegas=}, {vega_multipliers=}, "
                          f"{spread_vega=}, {vega_multiplier=}, {bid_ask_spread=}")

        # Calculate raw bid/ask prices
        spread_mid_price = (self._mid_prices * self._ratios).sum()
        raw_bid_price = spread_mid_price - bid_ask_spread * 0.5
        raw_ask_price = spread_mid_price + bid_ask_spread * 0.5

        if spread_instrument._tick_scheme is not None:
            if raw_bid_price >= 0.:
                bid_price = spread_instrument._tick_scheme.next_bid_price(raw_bid_price)
            else:
                bid_price = spread_instrument.make_price(-spread_instrument._tick_scheme.next_ask_price(-raw_bid_price).as_double())

            if raw_ask_price >= 0.:
                ask_price = spread_instrument._tick_scheme.next_ask_price(raw_ask_price)
            else:
                ask_price = spread_instrument.make_price(-spread_instrument._tick_scheme.next_bid_price(-raw_ask_price).as_double())

            self._log.debug(f"Bid ask created using tick_scheme: {bid_price=}, {ask_price=}, {raw_bid_price=}, {raw_ask_price=}")
        else:
            # Fallback to simple method if no tick scheme
            bid_price = spread_instrument.make_price(raw_bid_price)
            ask_price = spread_instrument.make_price(raw_ask_price)
            self._log.debug(f"Bid ask created: {bid_price=}, {ask_price=}, {raw_bid_price=}, {raw_ask_price=}")

        # Create bid and ask sizes
        bid_size = spread_instrument.make_qty(self._bid_sizes.min())
        ask_size = spread_instrument.make_qty(self._ask_sizes.min())

        cdef QuoteTick spread_quote = QuoteTick(
            instrument_id=self._spread_instrument_id,
            bid_price=bid_price,
            ask_price=ask_price,
            bid_size=bid_size,
            ask_size=ask_size,
            ts_event=event.ts_event,
            ts_init=event.ts_event,
        )

        # Send quote to the backtest engine so it reaches a venue and a matching engine
        self._msgbus.send(endpoint=f"SimulatedExchange.spread_quote.{self._spread_instrument_id.venue}", msg=spread_quote)

        # Send the spread quote to the data engine *after* it's possibly processed by a matching engine
        # like in the main backtesting loop in the backtest engine
        self._handler(spread_quote)

</document_content>
</document>
<document index="2216">
<source>nautilus_trader/backtest/models/fee.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import random

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.core cimport NANOSECONDS_IN_MILLISECOND
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.model.book cimport OrderBook
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class FeeModel:
    """
    Provides an abstract fee model for trades.
    """

    cpdef Money get_commission(
        self,
        Order order,
        Quantity fill_qty,
        Price fill_px,
        Instrument instrument,
    ):
        """
        Return the commission for a trade.

        Parameters
        ----------
        order : Order
            The order to calculate the commission for.
        fill_qty : Quantity
            The fill quantity of the order.
        fill_px : Price
            The fill price of the order.
        instrument : Instrument
            The instrument for the order.

        Returns
        -------
        Money

        """
        raise NotImplementedError("Method 'get_commission' must be implemented in a subclass.")


cdef class MakerTakerFeeModel(FeeModel):
    """
    Provide a fee model for trades based on a maker/taker fee schedule
    and notional value of the trade.

    Parameters
    ----------
    config : MakerTakerFeeModelConfig, optional
        The configuration for the fee model.
    """

    def __init__(self, config = None) -> None:
        # No configuration needed for this model
        pass

    cpdef Money get_commission(
        self,
        Order order,
        Quantity fill_qty,
        Price fill_px,
        Instrument instrument,
    ):
        cdef Money notional = instrument.notional_value(
            quantity=fill_qty,
            price=fill_px,
            use_quote_for_inverse=False,
        )

        # Use Decimal arithmetic to avoid floating-point precision issues
        cdef object commission_value
        if order.liquidity_side == LiquiditySide.MAKER:
            commission_value = notional.as_decimal() * instrument.maker_fee
        elif order.liquidity_side == LiquiditySide.TAKER:
            commission_value = notional.as_decimal() * instrument.taker_fee
        else:
            raise ValueError(
                f"invalid `LiquiditySide`, was {liquidity_side_to_str(order.liquidity_side)}"
            )

        cdef Money commission
        if instrument.is_inverse:  # Not using quote for inverse (see above):
            commission = Money(commission_value, instrument.base_currency)
        else:
            commission = Money(commission_value, instrument.quote_currency)

        return commission


cdef class FixedFeeModel(FeeModel):
    """
    Provides a fixed fee model for trades.

    Parameters
    ----------
    commission : Money, optional
        The fixed commission amount for trades.
    charge_commission_once : bool, default True
        Whether to charge the commission once per order or per fill.
    config : FixedFeeModelConfig, optional
        The configuration for the model.

    Raises
    ------
    ValueError
        If both ``commission`` **and** ``config`` are provided, **or** if both are ``None`` (exactly one must be supplied).
    ValueError
        If `commission` is not a positive amount.
    """

    def __init__(
        self,
        Money commission = None,
        bint charge_commission_once: bool = True,
        config = None,
    ) -> None:
        Condition.is_true((commission is None) ^ (config is None), "Provide exactly one of `commission` or `config`")

        if config is not None:
            # Initialize from config
            commission = Money.from_str(config.commission)
            charge_commission_once = config.charge_commission_once

        Condition.positive(commission, "commission")

        self._commission = commission
        self._zero_commission = Money(0, commission.currency)
        self._charge_commission_once = charge_commission_once

    cpdef Money get_commission(
        self,
        Order order,
        Quantity fill_qty,
        Price fill_px,
        Instrument instrument,
    ):
        if not self._charge_commission_once or order.filled_qty == 0:
            return self._commission
        else:
            return self._zero_commission


cdef class PerContractFeeModel(FeeModel):
    """
    Provides a fee model which charges a commission per contract traded.

    Parameters
    ----------
    commission : Money, optional
        The commission amount per contract.
    config : PerContractFeeModelConfig, optional
        The configuration for the model.

    Raises
    ------
    ValueError
        If both ``commission`` **and** ``config`` are provided, **or** if both are ``None`` (exactly one must be supplied).
    ValueError
        If `commission` is negative (< 0).
    """

    def __init__(
        self,
        Money commission = None,
        config = None,
    ) -> None:
        Condition.is_true((commission is None) ^ (config is None), "Provide exactly one of `commission` or `config`")

        if config is not None:
            # Initialize from config
            commission = Money.from_str(config.commission)

        Condition.not_negative(commission, "commission")

        self._commission = commission

    cpdef Money get_commission(
        self,
        Order order,
        Quantity fill_qty,
        Price fill_px,
        Instrument instrument,
    ):
        return Money(self._commission * fill_qty, self._commission.currency)

</document_content>
</document>
<document index="2218">
<source>nautilus_trader/backtest/models/fill.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import random

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport BookType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.model.book cimport BookOrder
from nautilus_trader.model.book cimport OrderBook
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class FillModel:
    """
    Provides probabilistic modeling for order fill dynamics including probability
    of fills and slippage by order type.

    Parameters
    ----------
    prob_fill_on_limit : double
        The probability of limit order filling if the market rests on its price.
    prob_fill_on_stop : double
        The probability of stop orders filling if the market rests on its price.
    prob_slippage : double
        The probability of order fill prices slipping by one tick.
    random_seed : int, optional
        The random seed (if None then no random seed).
    config : FillModelConfig, optional
        The configuration for the model.

    Raises
    ------
    ValueError
        If any probability argument is not within range [0, 1].
    TypeError
        If `random_seed` is not None and not of type `int`.
    """

    def __init__(
        self,
        double prob_fill_on_limit = 1.0,
        double prob_fill_on_stop = 1.0,
        double prob_slippage = 0.0,
        random_seed: int | None = None,
        config = None,
    ) -> None:
        if config is not None:
            # Initialize from config
            prob_fill_on_limit = config.prob_fill_on_limit
            prob_fill_on_stop = config.prob_fill_on_stop
            prob_slippage = config.prob_slippage
            random_seed = config.random_seed

        Condition.in_range(prob_fill_on_limit, 0.0, 1.0, "prob_fill_on_limit")
        Condition.in_range(prob_fill_on_stop, 0.0, 1.0, "prob_fill_on_stop")
        Condition.in_range(prob_slippage, 0.0, 1.0, "prob_slippage")
        if random_seed is not None:
            Condition.type(random_seed, int, "random_seed")
            random.seed(random_seed)
        else:
            random.seed()

        self.prob_fill_on_limit = prob_fill_on_limit
        self.prob_fill_on_stop = prob_fill_on_stop
        self.prob_slippage = prob_slippage

    cpdef bint is_limit_filled(self):
        """
        Return a value indicating whether a ``LIMIT`` order filled.

        Returns
        -------
        bool

        """
        return self._event_success(self.prob_fill_on_limit)

    cpdef bint is_stop_filled(self):
        """
        Return a value indicating whether a ``STOP-MARKET`` order filled.

        Returns
        -------
        bool

        """
        return self._event_success(self.prob_fill_on_stop)

    cpdef bint is_slipped(self):
        """
        Return a value indicating whether an order fill slipped.

        Returns
        -------
        bool

        """
        return self._event_success(self.prob_slippage)

    cpdef OrderBook get_orderbook_for_fill_simulation(
        self,
        Instrument instrument,
        Order order,
        Price best_bid,
        Price best_ask,
    ):
        """
        Return a simulated OrderBook for fill simulation.

        This method allows custom fill models to provide their own liquidity
        simulation by returning a custom OrderBook that represents the expected
        market liquidity. The matching engine will use this simulated OrderBook
        to determine fills.

        The default implementation returns None, which means the matching engine
        will use its standard fill logic (maintaining backward compatibility).

        Parameters
        ----------
        instrument : Instrument
            The instrument being traded.
        order : Order
            The order to simulate fills for.
        best_bid : Price
            The current best bid price.
        best_ask : Price
            The current best ask price.

        Returns
        -------
        OrderBook or None
            The simulated OrderBook for fill simulation, or None to use default logic.

        """
        return None  # Default implementation - use existing fill logic

    cdef bint _event_success(self, double probability):
        # Return a result indicating whether an event occurred based on the
        # given probability of the event occurring [0, 1].
        if probability == 0:
            return False
        elif probability == 1:
            return True
        else:
            return probability >= random.random()


class BestPriceFillModel(FillModel):
    """
    Fill model that executes all orders at the best available price.

    This model simulates optimistic market conditions where every order gets filled
    immediately at the best available price. Ideal for testing basic strategy logic.

    """

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with unlimited liquidity at best prices.
        """
        UNLIMITED = 1_000_000  # Large enough to fill any order

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        # Add unlimited volume at best prices
        bid_order = BookOrder(
            side=OrderSide.BUY,
            price=best_bid,
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=1,
        )
        ask_order = BookOrder(
            side=OrderSide.SELL,
            price=best_ask,
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=2,
        )

        book.add(bid_order, 0, 0)
        book.add(ask_order, 0, 0)

        return book


class OneTickSlippageFillModel(FillModel):
    """
    Fill model that forces exactly one tick of slippage for all orders.

    This model demonstrates how to create deterministic slippage by setting zero volume
    at best prices and unlimited volume one tick away.

    """

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with no volume at best prices, unlimited volume one tick away.
        """
        tick = instrument.price_increment
        UNLIMITED = 1_000_000

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        # Only add liquidity one tick away from best price (simulates no liquidity at best)
        # By not adding any orders at best_bid/best_ask, we guarantee slippage
        bid_order = BookOrder(
            side=OrderSide.BUY,
            price=best_bid.sub(tick),
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=1,
        )
        ask_order = BookOrder(
            side=OrderSide.SELL,
            price=best_ask.add(tick),
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=2,
        )

        book.add(bid_order, 0, 0)
        book.add(ask_order, 0, 0)

        return book


class TwoTierFillModel(FillModel):
    """
    Fill model with two-tier pricing: first 10 contracts at best price, remainder one tick worse.

    This model simulates basic market depth behavior and provides realistic simulation
    of basic market impact for small to medium orders.
    """

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with two-tier liquidity structure.
        """
        tick = instrument.price_increment
        UNLIMITED = 1_000_000

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        # First tier: 10 contracts at best price
        bid_order_tier1 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid,
            size=Quantity(10, instrument.size_precision),
            order_id=1,
        )
        ask_order_tier1 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask,
            size=Quantity(10, instrument.size_precision),
            order_id=2,
        )

        # Second tier: unlimited contracts one tick worse
        bid_order_tier2 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid.sub(tick),
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=3,
        )
        ask_order_tier2 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask.add(tick),
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=4,
        )

        book.add(bid_order_tier1, 0, 0)
        book.add(ask_order_tier1, 0, 0)
        book.add(bid_order_tier2, 0, 0)
        book.add(ask_order_tier2, 0, 0)

        return book


class ProbabilisticFillModel(FillModel):
    """
    Fill model that replicates the current probabilistic behavior.

    This model demonstrates how to implement the existing FillModel's probabilistic
    behavior using the new simulation approach: 50% chance of best price fill,
    50% chance of one tick slippage.

    """

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook based on probabilistic logic.
        """
        tick = instrument.price_increment
        UNLIMITED = 1_000_000

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        if random.random() < 0.5:  # noqa: S311
            # 50% chance: fill at best price
            bid_order = BookOrder(
                side=OrderSide.BUY,
                price=best_bid,
                size=Quantity(UNLIMITED, instrument.size_precision),
                order_id=1,
            )
            ask_order = BookOrder(
                side=OrderSide.SELL,
                price=best_ask,
                size=Quantity(UNLIMITED, instrument.size_precision),
                order_id=2,
            )
        else:
            # 50% chance: one tick slippage
            bid_order = BookOrder(
                side=OrderSide.BUY,
                price=best_bid.sub(tick),
                size=Quantity(UNLIMITED, instrument.size_precision),
                order_id=1,
            )
            ask_order = BookOrder(
                side=OrderSide.SELL,
                price=best_ask.add(tick),
                size=Quantity(UNLIMITED, instrument.size_precision),
                order_id=2,
            )

        book.add(bid_order, 0, 0)
        book.add(ask_order, 0, 0)

        return book


class SizeAwareFillModel(FillModel):
    """
    Fill model that applies different execution models based on order size.

    Small orders (<=10) get good liquidity at best prices. Large orders experience price
    impact with partial fills at worse prices.

    """

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with size-dependent liquidity.
        """
        tick = instrument.price_increment

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        threshold_qty = Quantity(10, instrument.size_precision)
        if order.quantity._mem.raw <= threshold_qty._mem.raw:
            # Small orders: good liquidity at best prices
            bid_order = BookOrder(
                side=OrderSide.BUY,
                price=best_bid,
                size=Quantity(50, instrument.size_precision),
                order_id=1,
            )
            ask_order = BookOrder(
                side=OrderSide.SELL,
                price=best_ask,
                size=Quantity(50, instrument.size_precision),
                order_id=2,
            )
        else:
            # Large orders: price impact
            remaining_qty = order.quantity.sub(threshold_qty)

            # First level: 10 contracts at best price
            bid_order_tier1 = BookOrder(
                side=OrderSide.BUY,
                price=best_bid,
                size=threshold_qty,
                order_id=1,
            )
            ask_order_tier1 = BookOrder(
                side=OrderSide.SELL,
                price=best_ask,
                size=threshold_qty,
                order_id=2,
            )

            # Second level: remainder at worse price
            bid_order_tier2 = BookOrder(
                side=OrderSide.BUY,
                price=best_bid.sub(tick),
                size=remaining_qty,
                order_id=3,
            )
            ask_order_tier2 = BookOrder(
                side=OrderSide.SELL,
                price=best_ask.add(tick),
                size=remaining_qty,
                order_id=4,
            )

            book.add(bid_order_tier1, 0, 0)
            book.add(ask_order_tier1, 0, 0)
            book.add(bid_order_tier2, 0, 0)
            book.add(ask_order_tier2, 0, 0)

            return book

        book.add(bid_order, 0, 0)
        book.add(ask_order, 0, 0)

        return book


class LimitOrderPartialFillModel(FillModel):
    """
    Fill model that simulates partial fills for limit orders.

    When price touches the limit level, only fills maximum 5 contracts of the order
    quantity, modeling typical limit order queue behavior.

    """

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with limited fills at limit prices.
        """
        tick = instrument.price_increment
        UNLIMITED = 1_000_000

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        # Max 5 contracts fill if market price touches limit price
        bid_order_tier1 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid,
            size=Quantity(5, instrument.size_precision),
            order_id=1,
        )
        ask_order_tier1 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask,
            size=Quantity(5, instrument.size_precision),
            order_id=2,
        )

        # Second level acts as price buffer
        bid_order_tier2 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid.sub(tick),
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=3,
        )
        ask_order_tier2 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask.add(tick),
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=4,
        )

        book.add(bid_order_tier1, 0, 0)
        book.add(ask_order_tier1, 0, 0)
        book.add(bid_order_tier2, 0, 0)
        book.add(ask_order_tier2, 0, 0)

        return book


class ThreeTierFillModel(FillModel):
    """
    Fill model with three-tier pricing for realistic market depth simulation.

    Distributes 100-contract order fills across three price levels:
    - 50 contracts at best price
    - 30 contracts 1 tick worse
    - 20 contracts 2 ticks worse

    """

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with three-tier liquidity structure.
        """
        tick = instrument.price_increment

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        # Level 1: 50 contracts at best price
        bid_order_tier1 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid,
            size=Quantity(50, instrument.size_precision),
            order_id=1,
        )
        ask_order_tier1 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask,
            size=Quantity(50, instrument.size_precision),
            order_id=2,
        )

        # Level 2: 30 contracts 1 tick worse
        bid_order_tier2 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid.sub(tick),
            size=Quantity(30, instrument.size_precision),
            order_id=3,
        )
        ask_order_tier2 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask.add(tick),
            size=Quantity(30, instrument.size_precision),
            order_id=4,
        )

        # Level 3: 20 contracts 2 ticks worse
        two_ticks = tick.add(tick)
        bid_order_tier3 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid.sub(two_ticks),
            size=Quantity(20, instrument.size_precision),
            order_id=5,
        )
        ask_order_tier3 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask.add(two_ticks),
            size=Quantity(20, instrument.size_precision),
            order_id=6,
        )

        book.add(bid_order_tier1, 0, 0)
        book.add(ask_order_tier1, 0, 0)
        book.add(bid_order_tier2, 0, 0)
        book.add(ask_order_tier2, 0, 0)
        book.add(bid_order_tier3, 0, 0)
        book.add(ask_order_tier3, 0, 0)

        return book


class MarketHoursFillModel(FillModel):
    """
    Fill model that simulates varying market conditions based on time.

    Implements wider spreads during low liquidity periods (e.g., outside market hours).
    Essential for strategies that trade across different market sessions.

    """

    def __init__(
        self,
        prob_fill_on_limit=1.0,
        prob_fill_on_stop=1.0,
        prob_slippage=0.0,
        random_seed=None,
    ):
        super().__init__(prob_fill_on_limit, prob_fill_on_stop, prob_slippage, random_seed)
        # In a real implementation, you would track market hours
        self._is_low_liquidity = False  # Simplified for example

    def is_low_liquidity_period(self) -> bool:
        """
        Check if current time is during low liquidity period.
        """
        # In a real implementation, this would check actual market hours
        # For demo purposes, we'll use a simple flag
        return self._is_low_liquidity

    def set_low_liquidity_period(self, is_low_liquidity: bool):
        """
        Set the liquidity period for testing purposes.
        """
        self._is_low_liquidity = is_low_liquidity

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with time-dependent liquidity.
        """
        tick = instrument.price_increment
        NORMAL_VOLUME = 500

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        if self.is_low_liquidity_period():
            # During low liquidity: wider spreads (1 tick worse)
            bid_order = BookOrder(
                side=OrderSide.BUY,
                price=best_bid.sub(tick),
                size=Quantity(NORMAL_VOLUME, instrument.size_precision),
                order_id=1,
            )
            ask_order = BookOrder(
                side=OrderSide.SELL,
                price=best_ask.add(tick),
                size=Quantity(NORMAL_VOLUME, instrument.size_precision),
                order_id=2,
            )
        else:
            # Normal hours: standard liquidity
            bid_order = BookOrder(
                side=OrderSide.BUY,
                price=best_bid,
                size=Quantity(NORMAL_VOLUME, instrument.size_precision),
                order_id=1,
            )
            ask_order = BookOrder(
                side=OrderSide.SELL,
                price=best_ask,
                size=Quantity(NORMAL_VOLUME, instrument.size_precision),
                order_id=2,
            )

        book.add(bid_order, 0, 0)
        book.add(ask_order, 0, 0)

        return book


class VolumeSensitiveFillModel(FillModel):
    """
    Fill model that adjusts liquidity based on recent trading volume.

    Creates realistic market depth based on actual market activity by using recent bar
    volume data to determine available liquidity.

    """

    def __init__(
        self,
        prob_fill_on_limit=1.0,
        prob_fill_on_stop=1.0,
        prob_slippage=0.0,
        random_seed=None,
    ):
        super().__init__(prob_fill_on_limit, prob_fill_on_stop, prob_slippage, random_seed)
        self._recent_volume = 1000.0  # Default volume for demo

    def set_recent_volume(self, volume: float):
        """
        Set recent volume for testing purposes.
        """
        self._recent_volume = volume

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with volume-based liquidity.
        """
        tick = instrument.price_increment
        UNLIMITED = 1_000_000

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        # Available liquidity is 25% of recent average volume
        available_volume = int(self._recent_volume * 0.25)

        bid_order_tier1 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid,
            size=Quantity(available_volume, instrument.size_precision),
            order_id=1,
        )
        ask_order_tier1 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask,
            size=Quantity(available_volume, instrument.size_precision),
            order_id=2,
        )

        # Unlimited volume one tick worse
        bid_order_tier2 = BookOrder(
            side=OrderSide.BUY,
            price=best_bid.sub(tick),
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=3,
        )
        ask_order_tier2 = BookOrder(
            side=OrderSide.SELL,
            price=best_ask.add(tick),
            size=Quantity(UNLIMITED, instrument.size_precision),
            order_id=4,
        )

        book.add(bid_order_tier1, 0, 0)
        book.add(ask_order_tier1, 0, 0)
        book.add(bid_order_tier2, 0, 0)
        book.add(ask_order_tier2, 0, 0)

        return book


class CompetitionAwareFillModel(FillModel):
    """
    Fill model that simulates market competition effects.

    Makes only a percentage of visible liquidity actually available, reflecting
    realistic conditions where multiple traders compete for the same liquidity.

    """

    def __init__(
        self,
        prob_fill_on_limit=1.0,
        prob_fill_on_stop=1.0,
        prob_slippage=0.0,
        random_seed=None,
        liquidity_factor=0.3,
    ):
        super().__init__(prob_fill_on_limit, prob_fill_on_stop, prob_slippage, random_seed)
        self.liquidity_factor = liquidity_factor  # Can access 30% of visible liquidity by default

    def get_orderbook_for_fill_simulation(
        self,
        instrument: Instrument,
        order: Order,
        best_bid: Price,
        best_ask: Price,
    ) -> OrderBook | None:
        """
        Return OrderBook with competition-adjusted liquidity.
        """
        # In a real implementation, you would get the actual current orderbook
        # For demo purposes, we'll simulate typical market depth
        typical_bid_volume = 1000.0
        typical_ask_volume = 1000.0

        available_bid = int(typical_bid_volume * self.liquidity_factor)
        available_ask = int(typical_ask_volume * self.liquidity_factor)

        book = OrderBook(
            instrument_id=instrument.id,
            book_type=BookType.L2_MBP,
        )

        bid_order = BookOrder(
            side=OrderSide.BUY,
            price=best_bid,
            size=Quantity(available_bid, instrument.size_precision),
            order_id=1,
        )
        ask_order = BookOrder(
            side=OrderSide.SELL,
            price=best_ask,
            size=Quantity(available_ask, instrument.size_precision),
            order_id=2,
        )

        book.add(bid_order, 0, 0)
        book.add(ask_order, 0, 0)

        return book

</document_content>
</document>
<document index="2220">
<source>nautilus_trader/backtest/models/latency.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import random

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.core cimport NANOSECONDS_IN_MILLISECOND
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.model.book cimport OrderBook
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class LatencyModel:
    """
    Provides a latency model for simulated exchange message I/O.

    Parameters
    ----------
    base_latency_nanos : int, default 1_000_000_000
        The base latency (nanoseconds) for the model.
    insert_latency_nanos : int, default 0
        The order insert latency (nanoseconds) for the model.
    update_latency_nanos : int, default 0
        The order update latency (nanoseconds) for the model.
    cancel_latency_nanos : int, default 0
        The order cancel latency (nanoseconds) for the model.
    config : FillModelConfig, optional
        The configuration for the model.

    Raises
    ------
    ValueError
        If `base_latency_nanos` is negative (< 0).
    ValueError
        If `insert_latency_nanos` is negative (< 0).
    ValueError
        If `update_latency_nanos` is negative (< 0).
    ValueError
        If `cancel_latency_nanos` is negative (< 0).
    """

    def __init__(
        self,
        uint64_t base_latency_nanos = NANOSECONDS_IN_MILLISECOND,
        uint64_t insert_latency_nanos = 0,
        uint64_t update_latency_nanos = 0,
        uint64_t cancel_latency_nanos = 0,
        config = None,
    ) -> None:
        if config is not None:
            # Initialize from config
            base_latency_nanos = config.base_latency_nanos
            insert_latency_nanos = config.insert_latency_nanos
            update_latency_nanos = config.update_latency_nanos
            cancel_latency_nanos = config.cancel_latency_nanos

        Condition.not_negative_int(base_latency_nanos, "base_latency_nanos")
        Condition.not_negative_int(insert_latency_nanos, "insert_latency_nanos")
        Condition.not_negative_int(update_latency_nanos, "update_latency_nanos")
        Condition.not_negative_int(cancel_latency_nanos, "cancel_latency_nanos")

        self.base_latency_nanos = base_latency_nanos
        self.insert_latency_nanos = base_latency_nanos + insert_latency_nanos
        self.update_latency_nanos = base_latency_nanos + update_latency_nanos
        self.cancel_latency_nanos = base_latency_nanos + cancel_latency_nanos

</document_content>
</document>
<document index="2222">
<source>nautilus_trader/backtest/modules.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import msgspec
import pandas as pd
import pytz

from nautilus_trader.backtest.config import FXRolloverInterestConfig
from nautilus_trader.backtest.config import SimulationModuleConfig
from nautilus_trader.common.config import ActorConfig

from cpython.datetime cimport datetime
from libc.stdint cimport uint64_t

from nautilus_trader.accounting.calculators cimport RolloverInterestCalculator
from nautilus_trader.backtest.engine cimport SimulatedExchange
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.model.book cimport OrderBook
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.position cimport Position


cdef class SimulationModule(Actor):
    """
    The base class for all simulation modules.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(self, config: SimulationModuleConfig):
        super().__init__(config)
        self.exchange = None  # Must be registered

    def __repr__(self) -> str:
        return f"{type(self).__name__}"

    cpdef void register_venue(self, SimulatedExchange exchange):
        """
        Register the given simulated exchange with the module.

        Parameters
        ----------
        exchange : SimulatedExchange
            The exchange to register.

        """
        Condition.not_none(exchange, "exchange")

        self.exchange = exchange

    cpdef void pre_process(self, Data data):
        """Abstract method `pre_process` (implement in subclass)."""
        pass

    cpdef void process(self, uint64_t ts_now):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `process` must be implemented in the subclass")  # pragma: no cover

    cpdef void log_diagnostics(self, Logger logger):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `log_diagnostics` must be implemented in the subclass")  # pragma: no cover

    cpdef void reset(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `reset` must be implemented in the subclass")  # pragma: no cover


_TZ_US_EAST = pytz.timezone("US/Eastern")


cdef class FXRolloverInterestModule(SimulationModule):
    """
    Provides an FX rollover interest simulation module.

    Parameters
    ----------
    config  : FXRolloverInterestConfig
    """

    def __init__(self, config: FXRolloverInterestConfig):
        super().__init__(config)

        rate_data = config.rate_data
        if not isinstance(rate_data, pd.DataFrame):
            rate_data = pd.read_json(msgspec.json.decode(rate_data))

        self._calculator = RolloverInterestCalculator(data=config.rate_data)
        self._rollover_time = None  # Initialized at first rollover
        self._rollover_applied = False
        self._rollover_totals = {}
        self._day_number = 0

    cpdef void process(self, uint64_t ts_now):
        """
        Process the given tick through the module.

        Parameters
        ----------
        ts_now : uint64_t
            The current UNIX timestamp (nanoseconds) in the simulated exchange.

        """
        cdef datetime now = pd.Timestamp(ts_now, tz="UTC")
        cdef datetime rollover_local
        if self._day_number != now.day:
            # Set account statistics for new day
            self._day_number = now.day
            self._rollover_applied = False

            rollover_local = now.astimezone(_TZ_US_EAST)
            self._rollover_time = _TZ_US_EAST.localize(datetime(
                rollover_local.year,
                rollover_local.month,
                rollover_local.day,
                17),
            ).astimezone(pytz.utc)

        # Check for and apply any rollover interest
        if not self._rollover_applied and now >= self._rollover_time:
            self._apply_rollover_interest(now, self._rollover_time.isoweekday())
            self._rollover_applied = True

    cdef void _apply_rollover_interest(self, datetime timestamp, int iso_week_day):
        cdef list open_positions = self.exchange.cache.positions_open()

        cdef Position position
        cdef Instrument instrument
        cdef OrderBook book
        cdef dict mid_prices = {}  # type: dict[InstrumentId, float]
        cdef Currency currency
        cdef double mid
        cdef double rollover
        cdef double xrate
        cdef Money rollover_total
        for position in open_positions:
            instrument = self.exchange.instruments[position.instrument_id]
            if instrument.asset_class != AssetClass.FX:
                continue  # Only applicable to FX

            mid = mid_prices.get(instrument.id, 0.0)
            if mid == 0.0:
                book = self.exchange.get_book(instrument.id)
                mid = book.midpoint()
                if mid is None:
                    mid = book.best_bid_price()
                if mid is None:
                    mid = book.best_ask_price()
                if mid is None:  # pragma: no cover
                    raise RuntimeError("cannot apply rollover interest, no market prices")
                mid_prices[instrument.id] = Price(float(mid), precision=instrument.price_precision)

            interest_rate = self._calculator.calc_overnight_rate(
                position.instrument_id,
                timestamp,
            )

            rollover = position.quantity.as_f64_c() * mid_prices[instrument.id] * float(interest_rate)

            if iso_week_day == 3:  # Book triple for Wednesdays
                rollover *= 3
            elif iso_week_day == 5:  # Book triple for Fridays (holding over weekend)
                rollover *= 3

            if self.exchange.base_currency is not None:
                currency = self.exchange.base_currency
                xrate = self.exchange.cache.get_xrate(
                    venue=instrument.id.venue,
                    from_currency=instrument.quote_currency,
                    to_currency=currency,
                    price_type=PriceType.MID,
                ) or 0.0  # Retain original behavior of returning zero for now
                rollover *= xrate
            else:
                currency = instrument.quote_currency

            rollover_total = Money(self._rollover_totals.get(currency, 0.0) + rollover, currency)
            self._rollover_totals[currency] = rollover_total

            self.exchange.adjust_account(Money(-rollover, currency))

    cpdef void log_diagnostics(self, Logger logger):
        """
        Log diagnostics out to the `BacktestEngine` logger.

        Parameters
        ----------
        logger : Logger
            The logger to log to.

        """
        account_balances_starting = ', '.join([b.to_formatted_str() for b in self.exchange.starting_balances])
        account_starting_length = len(account_balances_starting)
        rollover_totals = ', '.join([b.to_formatted_str() for b in self._rollover_totals.values()])
        logger.info(f"Rollover interest (totals): {rollover_totals}")

    cpdef void reset(self):
        self._rollover_time = None  # Initialized at first rollover
        self._rollover_applied = False
        self._rollover_totals = {}
        self._day_number = 0

</document_content>
</document>
<document index="2226">
<source>nautilus_trader/backtest/option_exercise.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
"""
Option exercise simulation module for backtesting.

This module provides automatic option exercise functionality during backtesting,
handling both cash-settled and physically-settled options with unified exercise logic.

## Settlement Types

- **Cash Settlement (Index Options)**: Options are closed at intrinsic value with no underlying position created
- **Physical Settlement (Equity Options)**: Options are closed and underlying positions are created at strike price

## Exercise Logic

For both long and short positions:
1. Check if option is in-the-money (ITM) using strict price comparison
2. If ITM, exercise the option using appropriate settlement method
3. If not exercised, option expires worthless (closed at zero value)

"""


from nautilus_trader.backtest.config import SimulationModuleConfig
from nautilus_trader.common.events import TimeEvent

from libc.stdint cimport uint64_t

from nautilus_trader.backtest.engine cimport SimulatedExchange
from nautilus_trader.backtest.modules cimport SimulationModule
from nautilus_trader.common.component cimport Logger
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.core.rust.model cimport OptionKind
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.position cimport PositionClosed
from nautilus_trader.model.events.position cimport PositionOpened
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport TradeId
from nautilus_trader.model.identifiers cimport VenueOrderId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.crypto_option cimport CryptoOption
from nautilus_trader.model.instruments.index cimport IndexInstrument
from nautilus_trader.model.instruments.option_contract cimport OptionContract
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.position cimport Position


class OptionExerciseConfig(SimulationModuleConfig, frozen=True):
    auto_exercise_enabled: bool = True


cdef class OptionExerciseModule(SimulationModule):
    def __init__(self, config: OptionExerciseConfig) -> None:
        super().__init__(config)

        self.config = config
        self.cache = None
        self.expiry_timers = {}  # expiry_ns -> timer_name
        self.processed_expiries = set()  # Track processed expiry timestamps

    cpdef void reset(self):
        """Reset the module state."""
        self.expiry_timers.clear()
        self.processed_expiries.clear()

    cpdef void log_diagnostics(self, Logger logger):
        """
        Log diagnostic information about the module state.
        """
        logger.info(f"OptionExerciseModule: {len(self.expiry_timers)} expiry timers set")
        logger.info(f"OptionExerciseModule: {len(self.processed_expiries)} expiries processed")

    cpdef void register_venue(self, SimulatedExchange exchange):
        """
        Register the exchange and subscribe to position events.
        """
        SimulationModule.register_venue(self, exchange)

        # Subscribe to position events to detect new option positions
        if self._msgbus:
            # Subscribe to all position events
            self._msgbus.subscribe(
                topic="events.position.*",
                handler=self.on_position_event,
            )

    cpdef void pre_process(self, Data data):
        """
        Pre-process method - not needed for option exercise.
        """
        pass

    cpdef void process(self, uint64_t ts_now):
        """
        Process method called by backtesting engine.
        """
        pass

    def on_position_event(self, event) -> None:
        """
        Handle position events to set up exercise timers for new option positions.
        """
        if not self.config.auto_exercise_enabled or not self.exchange:
            return

        # Check if this is an option position
        instrument = self.exchange.cache.instrument(event.instrument_id)

        if not isinstance(instrument, (OptionContract, CryptoOption)):
            return

        expiry_ns = instrument.expiration_ns

        # Handle different position event types
        if isinstance(event, PositionOpened):
            # Set up timer for option expiry if not already set
            if expiry_ns not in self.expiry_timers:
                timer_name = f"option_expiry_{expiry_ns}"
                self.clock.set_time_alert_ns(
                    name=timer_name,
                    alert_time_ns=expiry_ns,
                    callback=self._on_expiry_timer,
                )
                self.expiry_timers[expiry_ns] = timer_name
                self._log.debug(f"Set expiry timer for {instrument.id} at {expiry_ns}")
        elif isinstance(event, PositionClosed):
            # Check if there are any remaining positions for this expiry
            self._cleanup_timer_if_no_positions(expiry_ns)

    def _cleanup_timer_if_no_positions(self, expiry_ns: int) -> None:
        """
        Clean up expiry timer if no option positions remain for the given expiry.
        """
        if expiry_ns not in self.expiry_timers:
            return

        # Check if any option positions exist for this expiry
        has_positions = False

        if self.exchange and self.exchange.cache:
            positions = self.exchange.cache.positions_open()

            for position in positions:
                instrument = self.exchange.cache.instrument(position.instrument_id)

                if (
                        isinstance(instrument, (OptionContract, CryptoOption))
                        and instrument.expiration_ns == expiry_ns
                ):
                    has_positions = True
                    break

        # If no positions remain for this expiry, cancel the timer
        if not has_positions:
            timer_name = self.expiry_timers[expiry_ns]

            # Cancel the timer (if the clock supports it)
            self.clock.cancel_timer(timer_name)

            # Remove from our tracking
            del self.expiry_timers[expiry_ns]
            self._log.debug(f"Cleaned up expiry timer for {expiry_ns} - no positions remaining")

    def _on_expiry_timer(self, event: TimeEvent) -> None:
        """
        Handle timer events for option expiry.
        """
        if not self.config.auto_exercise_enabled or not self.exchange:
            return

        expiry_ns = event.ts_event

        # Skip if already processed
        if expiry_ns in self.processed_expiries:
            return

        # Process all options expiring at this timestamp
        self._process_expiring_options(expiry_ns)
        self.processed_expiries.add(expiry_ns)

    def _process_expiring_options(self, ts_now: int) -> None:
        """
        Process options expiring at the current timestamp.
        """
        if not self.exchange or not self.exchange.cache:
            return

        # Find options expiring at this timestamp
        expiring_options = []

        for instrument in self.exchange.cache.instruments():
            if isinstance(instrument, (OptionContract, CryptoOption)):
                if instrument.expiration_ns == ts_now:
                    expiring_options.append(instrument)

        if not expiring_options:
            return

        # Process each expiring option
        for option in expiring_options:
            self._process_option_expiry(option, ts_now)

    def _process_option_expiry(self, option: OptionContract | CryptoOption, ts_now: int) -> None:
        """
        Process the expiry of a single option.
        """
        if not self.cache:
            return

        # Get option positions
        positions = self.cache.positions_open(venue=None, instrument_id=option.id)

        if not positions:
            return

        # Get underlying price for exercise decision
        underlying_price = self._get_underlying_price(option)

        if underlying_price is None:
            self._log.debug(f"Skipping exercise of {option.id}: no underlying price available")
            return

        # Process each position (both long and short)
        for position in positions:
            # Check if option should be exercised (applies to both long and short positions)
            if self._should_exercise(option, underlying_price):
                self._exercise(option, position, underlying_price, ts_now)
            # If not exercised, option expires worthless and position is closed at zero value
            else:
                self._log.debug(
                    f"Expiring OTM {option.id}: {position.side} {position.quantity} @ strike {option.strike_price} "
                    f"(expires worthless)",
                )
                self._generate_otm_expiry_events(option, position, ts_now)

    def _get_underlying_price(self, option: OptionContract | CryptoOption) -> Price | None:
        """
        Get the current underlying price for exercise evaluation.
        """
        # Find underlying instrument
        underlying_instrument = self._get_underlying_instrument(option)

        if underlying_instrument is None:
            return None

        return self.cache.price(underlying_instrument.id, PriceType.LAST)

    def _should_exercise(self, option: OptionContract | CryptoOption, underlying_price: Price) -> bool:
        """
        Determine if option should be exercised based on strict price comparison.

        An option is exercised if the underlying price is strictly greater than (calls)
        or strictly less than (puts) the strike price.
        """
        strike = option.strike_price.as_double()
        spot = underlying_price.as_double()

        if option.option_kind == OptionKind.CALL:
            is_itm = spot > strike
        else:  # PUT
            is_itm = strike > spot

        if not is_itm:
            self._log.debug(
                f"Skipping exercise of {option.id}: OTM "
                f"(underlying: {spot}, strike: {strike})",
            )
            return False

        return True

    def _is_option_itm(
        self,
        option: OptionContract | CryptoOption,
        underlying_price: Price,
    ) -> tuple[bool, float]:
        """
        Check if option is in-the-money and calculate intrinsic value.
        """
        strike = option.strike_price.as_double()
        spot = underlying_price.as_double()

        if option.option_kind == OptionKind.CALL:
            intrinsic_value = max(0.0, spot - strike)
            is_itm = spot > strike
        else:  # PUT
            intrinsic_value = max(0.0, strike - spot)
            is_itm = strike > spot

        return is_itm, intrinsic_value

    def _generate_otm_expiry_events(
        self,
        option: OptionContract | CryptoOption,
        position: Position,
        ts_now: int,
    ) -> None:
        """Generate OrderFilled events for OTM option expiry (expires worthless)."""
        # Close option position at zero value since it expires worthless
        option_close_fill = self._create_option_fill(
            option, position, f"OTM-EXPIRY-{ts_now}",
            f"OTM-EXPIRY-{ts_now}", ts_now, False  # use_avg_price=False for zero value
        )
        self._send_events([option_close_fill])
        self._log.debug(f"OTM expiry complete: Closed {option.id} position @ {option_close_fill.last_px} (worthless)")

    def _exercise(
        self,
        option: OptionContract | CryptoOption,
        position: Position,
        underlying_price: Price,
        ts_now: int,
    ) -> None:
        """
        Process option exercise with unified logic for both long and short positions.

        This method handles all option exercise scenarios using a single, unified approach.
        There is no distinction between "exercise" (long positions) and "assignment"
        (short positions) - both are processed identically as option exercise.

        Settlement type is automatically determined based on underlying instrument:
        - IndexInstrument: Cash settlement (close option at intrinsic value)
        - Other instruments: Physical settlement (close option + create underlying position)
        """
        underlying_instrument = self._get_underlying_instrument(option)
        is_cash_settled = isinstance(underlying_instrument, IndexInstrument)
        settlement_type = "cash" if is_cash_settled else "physical"
        self._log.debug(
            f"Exercising {option.id}: {position.side} {position.quantity} @ strike {option.strike_price} "
            f"(underlying: {underlying_price}, settlement: {settlement_type})",
        )

        if is_cash_settled:
            # Cash settlement: close option at intrinsic value
            self._generate_cash_settlement_events(option, position, underlying_price, ts_now)
        else:
            # Physical settlement: create underlying position
            underlying_quantity, underlying_side = self._calculate_underlying_position(option, position)

            if underlying_instrument is None:
                self._log.error(f"Cannot exercise {option.id}: underlying instrument not found")
                return

            self._generate_physical_settlement_events(
                option, position, underlying_instrument, underlying_quantity,
                underlying_side, underlying_price, ts_now
            )

    def _calculate_underlying_position(
        self,
        option: OptionContract | CryptoOption,
        position,
    ) -> tuple[Quantity, PositionSide]:
        """
        Calculate the underlying position quantity and side from option exercise.
        """
        # Base quantity from option multiplier and position size
        base_quantity = position.quantity.as_double() * option.multiplier.as_double()

        # Determine side based on option type and position side
        if option.option_kind == OptionKind.CALL:
            # Call exercise: long option -> long underlying, short option -> short underlying
            underlying_side = position.side
        else:  # PUT
            # Put exercise: long option -> short underlying, short option -> long underlying
            underlying_side = (
                PositionSide.SHORT if position.side == PositionSide.LONG else PositionSide.LONG
            )

        # Create quantity with appropriate precision
        underlying_quantity = Quantity.from_str(str(base_quantity))

        return underlying_quantity, underlying_side

    def _generate_cash_settlement_events(
        self,
        option: OptionContract | CryptoOption,
        position: Position,
        underlying_price: Price,
        ts_now: int,
    ) -> None:
        """
        Generate OrderFilled events for cash settlement (close option at intrinsic value).

        For cash-settled options (typically index options), the option position is closed
        at the intrinsic value with no underlying position created. The cash payment
        represents the profit/loss from the option's intrinsic value.
        """
        settlement_id = UUID4()

        # Calculate intrinsic value for cash settlement
        intrinsic_value = self._calculate_settlement_price(option, underlying_price)

        # Close option position at intrinsic value
        option_close_fill = self._create_cash_settlement_fill(
            option, position, intrinsic_value, f"CASH_SETTLE_{settlement_id}",
            f"CASH_SETTLE_{settlement_id}", ts_now
        )
        self._send_events([option_close_fill])
        self._log.debug(
            f"Cash settlement complete: exercised {option.id} position @ {intrinsic_value} "
            f"(intrinsic value from underlying: {underlying_price})"
        )

    def _create_cash_settlement_fill(self, option, position, settlement_price: Price,
                                     trade_id_suffix: str, venue_id_suffix: str, ts_now: int) -> OrderFilled:
        """Create OrderFilled event for cash settlement (closing option at intrinsic value)."""
        # Determine the order side to close the position
        close_side = OrderSide.SELL if position.side == PositionSide.LONG else OrderSide.BUY

        return OrderFilled(
            trader_id=position.trader_id,
            strategy_id=position.strategy_id,
            instrument_id=option.id,
            client_order_id=ClientOrderId(trade_id_suffix),
            venue_order_id=VenueOrderId(venue_id_suffix),
            account_id=position.account_id,
            trade_id=TradeId(trade_id_suffix),
            position_id=position.id,
            order_side=close_side,
            order_type=OrderType.MARKET,
            last_qty=position.quantity,
            last_px=settlement_price,
            currency=option.quote_currency,
            commission=Money(0, option.quote_currency),
            liquidity_side=LiquiditySide.TAKER,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

    def _generate_physical_settlement_events(
        self,
        option: OptionContract | CryptoOption,
        position: Position,
        underlying_instrument,
        underlying_quantity: Quantity,
        underlying_side: PositionSide,
        underlying_price: Price,
        ts_now: int,
    ) -> None:
        """
        Generate OrderFilled events for physical settlement (close option and open underlying).

        For physically-settled options (typically equity options), the option position is closed
        and a corresponding underlying position is created at the strike price. This simulates
        the actual delivery of the underlying asset.
        """
        settlement_id = UUID4()

        # Close option position
        option_close_fill = self._create_option_fill(
            option, position, f"EXERCISE_CLOSE_{settlement_id}",
            f"EXERCISE_{settlement_id}", ts_now, True
        )

        # Open underlying position
        settlement_price = self._calculate_settlement_price(option, underlying_price)
        underlying_open_fill = self._create_underlying_fill(
            position, underlying_instrument, underlying_quantity, underlying_side,
            settlement_price, f"EXERCISE_OPEN_{settlement_id}", f"EXERCISE_{settlement_id}", ts_now
        )
        self._send_events([option_close_fill, underlying_open_fill])
        self._log.debug(
            f"Physical settlement complete: exercised {option.id} position, "
            f"opened {underlying_instrument.id} {underlying_side} {underlying_quantity} @ {settlement_price}",
        )

    def _calculate_settlement_price(self, option, underlying_price: Price) -> Price:
        """
        Calculate settlement price based on option type (cash vs physical settlement).

        For cash-settled options (IndexInstrument underlying):
        - Returns the intrinsic value of the option
        - Call: max(0, underlying_price - strike_price)
        - Put: max(0, strike_price - underlying_price)

        For physically-settled options (other instruments):
        - Returns the strike price (price at which underlying is delivered)
        """
        underlying_instrument = self._get_underlying_instrument(option)
        is_cash_settled = isinstance(underlying_instrument, IndexInstrument)

        if is_cash_settled:
            # Cash settlement: use intrinsic value
            if option.option_kind == OptionKind.CALL:
                settlement_price = Price(max(0.0, underlying_price.as_double() - option.strike_price.as_double()), option.strike_price.precision)
            else:  # PUT
                settlement_price = Price(max(0.0, option.strike_price.as_double() - underlying_price.as_double()), option.strike_price.precision)

            self._log.debug(
                f"Cash settlement for {option.id}: intrinsic value {settlement_price} "
                f"(underlying: {underlying_price}, strike: {option.strike_price})"
            )
            return settlement_price
        else:
            # Physical settlement: use strike price
            self._log.debug(
                f"Physical settlement for {option.id}: strike price {option.strike_price} "
                f"(underlying: {underlying_price})"
            )
            return option.strike_price

    cpdef Instrument _get_underlying_instrument(self, object option):
        """Get the underlying instrument for the option."""
        underlying_instrument_id = InstrumentId.from_str(f"{option.underlying}.{option.id.venue}")

        return self._cache.instrument(underlying_instrument_id)

    def _create_option_fill(self, option, position, trade_id_suffix: str, venue_id_suffix: str, ts_now: int, use_avg_price: bool = True) -> OrderFilled:
        """Create OrderFilled event for option position closure."""
        if use_avg_price:
            # Use the average opening price to ensure unrealized PnL becomes 0
            price = Price(position.avg_px_open, option.price_precision)
        else:
            # For OTM expiry, option is worthless
            price = Price(0.0, option.price_precision)

        return OrderFilled(
            trader_id=position.trader_id,
            strategy_id=position.strategy_id,
            instrument_id=option.id,
            client_order_id=ClientOrderId(trade_id_suffix),
            venue_order_id=VenueOrderId(venue_id_suffix),
            account_id=position.account_id,
            trade_id=TradeId(trade_id_suffix),
            position_id=position.id,
            order_side=OrderSide.SELL if position.side == PositionSide.LONG else OrderSide.BUY,
            order_type=OrderType.MARKET,
            last_qty=position.quantity,
            last_px=price,
            currency=option.quote_currency,
            commission=Money(0, option.quote_currency),
            liquidity_side=LiquiditySide.TAKER,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

    def _create_underlying_fill(self, position, underlying_instrument, quantity: Quantity, side: PositionSide,
                               price: Price, trade_id_suffix: str, venue_id_suffix: str, ts_now: int) -> OrderFilled:
        """Create OrderFilled event for underlying position opening."""
        return OrderFilled(
            trader_id=position.trader_id,
            strategy_id=position.strategy_id,
            instrument_id=underlying_instrument.id,
            client_order_id=ClientOrderId(trade_id_suffix),
            venue_order_id=VenueOrderId(venue_id_suffix),
            account_id=position.account_id,
            trade_id=TradeId(trade_id_suffix),
            position_id=None,  # New underlying position will get its own ID
            order_side=OrderSide.BUY if side == PositionSide.LONG else OrderSide.SELL,
            order_type=OrderType.MARKET,
            last_qty=quantity,
            last_px=price,
            currency=underlying_instrument.quote_currency,
            commission=Money(0, underlying_instrument.quote_currency),
            liquidity_side=LiquiditySide.TAKER,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

    def _send_events(self, events: list) -> None:
        """Send events to the execution engine for processing."""
        if self.exchange:
            for event in events:
                self.exchange.msgbus.send(endpoint="ExecEngine.process", msg=event)

</document_content>
</document>
<document index="2232">
<source>nautilus_trader/cache/base.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport FundingRateUpdate
from nautilus_trader.model.data cimport IndexPriceUpdate
from nautilus_trader.model.data cimport MarkPriceUpdate
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.identifiers cimport VenueOrderId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Quantity


cdef class CacheFacade:
    """
    Provides a read-only facade for the common `Cache`.
    """

# -- GENERAL --------------------------------------------------------------------------------------

    cpdef bytes get(self, str key):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `get` must be implemented in the subclass")  # pragma: no cover

    cpdef void add(self, str key, bytes value):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add` must be implemented in the subclass")  # pragma: no cover

# -- DATA QUERIES ---------------------------------------------------------------------------------

    cpdef list quote_ticks(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `quote_ticks` must be implemented in the subclass")  # pragma: no cover

    cpdef list trade_ticks(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `trade_ticks` must be implemented in the subclass")  # pragma: no cover

    cpdef list mark_prices(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `mark_prices` must be implemented in the subclass")  # pragma: no cover

    cpdef list index_prices(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `index_prices` must be implemented in the subclass")  # pragma: no cover

    cpdef list bars(self, BarType bar_type):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `bars` must be implemented in the subclass")  # pragma: no cover

    cpdef Price price(self, InstrumentId instrument_id, PriceType price_type):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `price` must be implemented in the subclass")  # pragma: no cover

    cpdef dict[InstrumentId, Price] prices(self, PriceType price_type):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `prices` must be implemented in the subclass")  # pragma: no cover

    cpdef OrderBook order_book(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `order_book` must be implemented in the subclass")  # pragma: no cover

    cpdef object own_order_book(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `own_order_book` must be implemented in the subclass")  # pragma: no cover

    cpdef dict[Decimal, list[Order]] own_bid_orders(self, InstrumentId instrument_id, set[OrderStatus] status = None, uint64_t accepted_buffer_ns = 0, uint64_t ts_now = 0):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `own_bid_book` must be implemented in the subclass")  # pragma: no cover

    cpdef dict[Decimal, list[Order]] own_ask_orders(self, InstrumentId instrument_id, set[OrderStatus] status = None, uint64_t accepted_buffer_ns = 0, uint64_t ts_now = 0):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `own_ask_book` must be implemented in the subclass")  # pragma: no cover

    cpdef QuoteTick quote_tick(self, InstrumentId instrument_id, int index=0):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `quote_tick` must be implemented in the subclass")  # pragma: no cover

    cpdef TradeTick trade_tick(self, InstrumentId instrument_id, int index=0):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `trade_tick` must be implemented in the subclass")  # pragma: no cover

    cpdef MarkPriceUpdate mark_price(self, InstrumentId instrument_id, int index=0):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `mark_price` must be implemented in the subclass")  # pragma: no cover

    cpdef IndexPriceUpdate index_price(self, InstrumentId instrument_id, int index=0):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `index_price` must be implemented in the subclass")  # pragma: no cover

    cpdef FundingRateUpdate funding_rate(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `funding_rate` must be implemented in the subclass")  # pragma: no cover

    cpdef Bar bar(self, BarType bar_type, int index=0):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `bar` must be implemented in the subclass")  # pragma: no cover

    cpdef int book_update_count(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `book_update_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int quote_tick_count(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `quote_tick_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int trade_tick_count(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `trade_tick_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int mark_price_count(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `mark_price_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int index_price_count(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `index_price_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int bar_count(self, BarType bar_type):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `bar_count` must be implemented in the subclass")  # pragma: no cover

    cpdef bint has_order_book(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `has_order_book` must be implemented in the subclass")  # pragma: no cover

    cpdef bint has_quote_ticks(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `has_quote_ticks` must be implemented in the subclass")  # pragma: no cover

    cpdef bint has_trade_ticks(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `has_trade_ticks` must be implemented in the subclass")  # pragma: no cover

    cpdef bint has_mark_prices(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `has_mark_prices` must be implemented in the subclass")  # pragma: no cover

    cpdef bint has_index_prices(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `has_index_prices` must be implemented in the subclass")  # pragma: no cover

    cpdef bint has_bars(self, BarType bar_type):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `has_bars` must be implemented in the subclass")  # pragma: no cover

    cpdef get_xrate(
        self,
        Venue venue,
        Currency from_currency,
        Currency to_currency,
        PriceType price_type=PriceType.MID,
    ):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `get_xrate` must be implemented in the subclass")  # pragma: no cover

    cpdef get_mark_xrate(
        self,
        Currency from_currency,
        Currency to_currency,
    ):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `get_mark_xrate` must be implemented in the subclass")  # pragma: no cover

    cpdef void set_mark_xrate(
        self,
        Currency from_currency,
        Currency to_currency,
        double xrate,
    ):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `set_mark_xrate` must be implemented in the subclass")  # pragma: no cover

    cpdef void clear_mark_xrate(
        self,
        Currency from_currency,
        Currency to_currency,
    ):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `clear_mark_xrate` must be implemented in the subclass")  # pragma: no cover

    cpdef void clear_mark_xrates(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `clear_mark_xrates` must be implemented in the subclass")  # pragma: no cover

# -- INSTRUMENT QUERIES ---------------------------------------------------------------------------

    cpdef Instrument instrument(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `instrument` must be implemented in the subclass")  # pragma: no cover

    cpdef list instrument_ids(self, Venue venue = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `instrument_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef list instruments(self, Venue venue = None, str underlying = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `instruments` must be implemented in the subclass")  # pragma: no cover

# -- SYNTHETIC QUERIES ----------------------------------------------------------------------------

    cpdef SyntheticInstrument synthetic(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `synthetic` must be implemented in the subclass")  # pragma: no cover

    cpdef list synthetic_ids(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `synthetic_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef list synthetics(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `synthetics` must be implemented in the subclass")  # pragma: no cover

# -- ACCOUNT QUERIES ------------------------------------------------------------------------------

    cpdef Account account(self, AccountId account_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `account` must be implemented in the subclass")  # pragma: no cover

    cpdef void set_specific_venue(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `set_specific_venue` must be implemented in the subclass")  # p

    cpdef Account account_for_venue(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `account_for_venue` must be implemented in the subclass")  # pragma: no cover

    cpdef AccountId account_id(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `account_id` must be implemented in the subclass")  # pragma: no cover

    cpdef list accounts(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `accounts` must be implemented in the subclass")  # pragma: no cover

# -- IDENTIFIER QUERIES ---------------------------------------------------------------------------

    cpdef set client_order_ids(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `client_order_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef set client_order_ids_open(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `client_order_ids_open` must be implemented in the subclass")  # pragma: no cover

    cpdef set client_order_ids_closed(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `client_order_ids_closed` must be implemented in the subclass")  # pragma: no cover

    cpdef set client_order_ids_emulated(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `client_order_ids_emulated` must be implemented in the subclass")  # pragma: no cover

    cpdef set client_order_ids_inflight(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `client_order_ids_inflight` must be implemented in the subclass")  # pragma: no cover

    cpdef set order_list_ids(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `order_list_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef set position_ids(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef set position_open_ids(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_open_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef set position_closed_ids(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_closed_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef set actor_ids(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `actor_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef set strategy_ids(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `strategy_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef set exec_algorithm_ids(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `exec_algorithm_ids` must be implemented in the subclass")  # pragma: no cover

# -- ORDER QUERIES --------------------------------------------------------------------------------

    cpdef Order order(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `order` must be implemented in the subclass")  # pragma: no cover

    cpdef ClientOrderId client_order_id(self, VenueOrderId venue_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `client_order_id` must be implemented in the subclass")  # pragma: no cover

    cpdef VenueOrderId venue_order_id(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `venue_order_id` must be implemented in the subclass")  # pragma: no cover

    cpdef ClientId client_id(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `client_id` must be implemented in the subclass")  # pragma: no cover

    cpdef list orders(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders` must be implemented in the subclass")  # pragma: no cover

    cpdef list orders_open(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_open` must be implemented in the subclass")  # pragma: no cover

    cpdef list orders_closed(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_closed` must be implemented in the subclass")  # pragma: no cover

    cpdef list orders_emulated(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_emulated` must be implemented in the subclass")  # pragma: no cover

    cpdef list orders_inflight(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_inflight` must be implemented in the subclass")  # pragma: no cover

    cpdef list orders_for_position(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_for_position` must be implemented in the subclass")  # pragma: no cover

    cpdef bint order_exists(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `order_exists` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_order_open(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_order_open` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_order_closed(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_order_closed` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_order_emulated(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_order_emulated` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_order_inflight(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_order_inflight` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_order_pending_cancel_local(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_order_pending_cancel_local` must be implemented in the subclass")  # pragma: no cover

    cpdef int orders_open_count(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_open_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int orders_closed_count(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_closed_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int orders_emulated_count(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_emulated_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int orders_inflight_count(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_inflight_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int orders_total_count(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_total_count` must be implemented in the subclass")  # pragma: no cover

# -- ORDER_LIST_QUERIES ---------------------------------------------------------------------------

    cpdef OrderList order_list(self, OrderListId order_list_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `order_list` must be implemented in the subclass")  # pragma: no cover

    cpdef list order_lists(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `order_lists` must be implemented in the subclass")  # pragma: no cover

    cpdef bint order_list_exists(self, OrderListId order_list_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `order_list_exists` must be implemented in the subclass")  # pragma: no cover

# -- EXEC ALGORITHM QUERIES -----------------------------------------------------------------------

    cpdef list orders_for_exec_algorithm(self, ExecAlgorithmId exec_algorithm_id, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_for_exec_algorithm` must be implemented in the subclass")  # pragma: no cover

    cpdef list orders_for_exec_spawn(self, ClientOrderId exec_spawn_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `orders_for_exec_spawn` must be implemented in the subclass")  # pragma: no cover

    cpdef Quantity exec_spawn_total_quantity(self, ClientOrderId exec_spawn_id, bint active_only=False):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `exec_spawn_total_quantity` must be implemented in the subclass")  # pragma: no cover

    cpdef Quantity exec_spawn_total_filled_qty(self, ClientOrderId exec_spawn_id, bint active_only=False):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `exec_spawn_total_filled_qty` must be implemented in the subclass")  # pragma: no cover

    cpdef Quantity exec_spawn_total_leaves_qty(self, ClientOrderId exec_spawn_id, bint active_only=False):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `exec_spawn_total_leaves_qty` must be implemented in the subclass")  # pragma: no cover

# -- POSITION QUERIES -----------------------------------------------------------------------------

    cpdef Position position(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position` must be implemented in the subclass")  # pragma: no cover

    cpdef Position position_for_order(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_for_order` must be implemented in the subclass")  # pragma: no cover

    cpdef PositionId position_id(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_id` must be implemented in the subclass")  # pragma: no cover

    cpdef set[PositionId] position_snapshot_ids(self, InstrumentId instrument_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_snapshot_ids` must be implemented in the subclass")  # pragma: no cover

    cpdef list position_snapshots(self, PositionId position_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_snapshots` must be implemented in the subclass")  # pragma: no cover

    cpdef list position_snapshot_bytes(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_snapshot_bytes` must be implemented in the subclass")  # pragma: no cover

    cpdef list positions(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, PositionSide side = PositionSide.NO_POSITION_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `positions` must be implemented in the subclass")  # pragma: no cover

    cpdef bint position_exists(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `position_exists` must be implemented in the subclass")  # pragma: no cover

    cpdef list positions_open(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, PositionSide side = PositionSide.NO_POSITION_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `positions_open` must be implemented in the subclass")  # pragma: no cover

    cpdef list positions_closed(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `positions_closed` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_position_open(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_position_open` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_position_closed(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_position_closed` must be implemented in the subclass")  # pragma: no cover

    cpdef int positions_open_count(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, PositionSide side = PositionSide.NO_POSITION_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `positions_open_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int positions_closed_count(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `positions_closed_count` must be implemented in the subclass")  # pragma: no cover

    cpdef int positions_total_count(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, PositionSide side = PositionSide.NO_POSITION_SIDE):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `positions_total_count` must be implemented in the subclass")  # pragma: no cover

# -- STRATEGY QUERIES -----------------------------------------------------------------------------

    cpdef StrategyId strategy_id_for_order(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `strategy_id_for_order` must be implemented in the subclass")  # pragma: no cover

    cpdef StrategyId strategy_id_for_position(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `strategy_id_for_position` must be implemented in the subclass")  # pragma: no cover

# -- GREEKS QUERIES -----------------------------------------------------------------------------

    cpdef void add_greeks(self, object greeks):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add_greeks` must be implemented in the subclass")  # pragma: no cover

    cpdef void add_yield_curve(self, object yield_curve):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add_yield_curve` must be implemented in the subclass")  # pragma: no cover

    cpdef object greeks(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `greeks` must be implemented in the subclass")  # pragma: no cover

    cpdef object yield_curve(self, str curve_name):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `yield_curve` must be implemented in the subclass")  # pragma: no cover

</document_content>
</document>
<document index="2234">
<source>nautilus_trader/cache/cache.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import pickle
import time
import uuid
from collections import deque
from decimal import Decimal

from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.core.rust.model import PriceType as PriceType_py

from cpython.datetime cimport datetime
from cpython.datetime cimport timedelta
from libc.stdint cimport uint8_t
from libc.stdint cimport uint64_t

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.cache.facade cimport CacheDatabaseFacade
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport Logger
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AggregationSource
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OmsType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.model.book cimport should_handle_own_book_order
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarAggregation
from nautilus_trader.model.data cimport BarSpecification
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport FundingRateUpdate
from nautilus_trader.model.data cimport IndexPriceUpdate
from nautilus_trader.model.data cimport MarkPriceUpdate
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport order_status_to_pyo3
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ComponentId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.identifiers cimport VenueOrderId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.crypto_perpetual cimport CryptoPerpetual
from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.list cimport OrderList
from nautilus_trader.trading.strategy cimport Strategy


cdef class Cache(CacheFacade):
    """
    Provides a common object cache for market and execution related data.

    Parameters
    ----------
    database : CacheDatabaseFacade, optional
        The database adapter for the cache. If ``None`` then will bypass persistence.
    config : CacheConfig, optional
        The cache configuration.

    Raises
    ------
    TypeError
        If `config` is not of type `CacheConfig`.
    """

    def __init__(
        self,
        CacheDatabaseFacade database: CacheDatabaseFacade | None = None,
        config: CacheConfig | None = None,
    ) -> None:
        if config is None:
            config = CacheConfig()

        Condition.type(config, CacheConfig, "config")

        self._database = database
        self._log = Logger(name=type(self).__name__)

        # Configuration
        self._drop_instruments_on_reset = config.drop_instruments_on_reset
        self.has_backing = database is not None
        self.persist_account_events = config.persist_account_events
        self.tick_capacity = config.tick_capacity
        self.bar_capacity = config.bar_capacity
        self._specific_venue = None

        # Caches
        self._general: dict[str, bytes] = {}
        self._currencies: dict[str, Currency] = {}
        self._instruments: dict[InstrumentId, Instrument] = {}
        self._synthetics: dict[InstrumentId, SyntheticInstrument] = {}
        self._order_books: dict[InstrumentId, OrderBook] = {}
        self._own_order_books: dict[InstrumentId, nautilus_pyo3.OwnOrderBook] = {}
        self._quote_ticks: dict[InstrumentId, deque[QuoteTick]] = {}
        self._trade_ticks: dict[InstrumentId, deque[TradeTick]] = {}
        self._xrate_symbols: dict[InstrumentId, str] = {}
        self._mark_xrates: dict[tuple[Currency, Currency], double] = {}
        self._mark_prices: dict[InstrumentId, deque[MarkPriceUpdate]] = {}
        self._index_prices: dict[InstrumentId, deque[IndexPriceUpdate]] = {}
        self._funding_rates: dict[InstrumentId, FundingRateUpdate] = {}
        self._bars: dict[BarType, deque[Bar]] = {}
        self._bars_bid: dict[InstrumentId, Bar] = {}
        self._bars_ask: dict[InstrumentId, Bar] = {}
        self._accounts: dict[AccountId, Account] = {}
        self._orders: dict[ClientOrderId, Order] = {}
        self._order_lists: dict[OrderListId, OrderList] = {}
        self._positions: dict[PositionId, Position] = {}
        self._position_snapshots: dict[PositionId, list[bytes]] = {}
        self._greeks: dict[InstrumentId, object] = {}
        self._yield_curves: dict[str, object] = {}

        # Cache index
        self._index_venue_account: dict[Venue, AccountId] = {}
        self._index_venue_orders: dict[Venue, set[ClientOrderId]] = {}
        self._index_venue_positions: dict[Venue, set[PositionId]] = {}
        self._index_venue_order_ids: dict[VenueOrderId, ClientOrderId] = {}
        self._index_client_order_ids: dict[ClientOrderId, VenueOrderId] = {}
        self._index_order_position: dict[ClientOrderId, PositionId] = {}
        self._index_order_strategy: dict[ClientOrderId, StrategyId] = {}
        self._index_order_client: dict[ClientOrderId, ClientId] = {}
        self._index_position_strategy: dict[PositionId, StrategyId] = {}
        self._index_position_orders: dict[PositionId, set[ClientOrderId]] = {}
        self._index_instrument_orders: dict[InstrumentId, set[ClientOrderId]] = {}
        self._index_instrument_positions: dict[InstrumentId, set[PositionId]] = {}
        self._index_instrument_position_snapshots: dict[InstrumentId, set[PositionId]] = {}
        self._index_strategy_orders: dict[StrategyId, set[ClientOrderId]] = {}
        self._index_strategy_positions: dict[StrategyId, set[PositionId]] = {}
        self._index_exec_algorithm_orders: dict[ExecAlgorithmId, set[ClientOrderId]] = {}
        self._index_exec_spawn_orders: dict[ClientOrderId: set[ClientOrderId]] = {}
        self._index_orders: set[ClientOrderId] = set()
        self._index_orders_open: set[ClientOrderId] = set()
        self._index_orders_open_pyo3: set[nautilus_pyo3.ClientOrderId] = set()
        self._index_orders_closed: set[ClientOrderId] = set()
        self._index_orders_emulated: set[ClientOrderId] = set()
        self._index_orders_inflight: set[ClientOrderId] = set()
        self._index_orders_pending_cancel: set[ClientOrderId] = set()
        self._index_positions: set[PositionId] = set()
        self._index_positions_open: set[PositionId] = set()
        self._index_positions_closed: set[PositionId] = set()
        self._index_actors: set[ComponentId] = set()
        self._index_strategies: set[StrategyId] = set()
        self._index_exec_algorithms: set[ExecAlgorithmId] = set()

        self._log.info("READY")

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void set_specific_venue(self, Venue venue):
        """
        Set a specific venue that the cache will use for subsequent `account_for_venue` calls.

        Primarily for Interactive Brokers, a multi-venue brokerage where account updates
        are not tied to a single venue.

        Parameters
        ----------
        venue : Venue
            The specific venue to set.

        """
        Condition.not_none(venue, "venue")

        self._specific_venue = venue

    cpdef void cache_all(self):
        """
        Clears and loads the currencies, instruments, synthetics, accounts, orders, and positions.
        from the cache database.
        """
        self._log.debug(f"Loading currencies, instruments, synthetics, accounts, orders, and positions cache from database")

        if self._database is not None:
            result = self._database.load_all()
            self._currencies = result.get("currencies", {})
            self._instruments = result.get("instruments", {})
            self._synthetics = result.get("synthetics", {})
            self._accounts = result.get("accounts", {})
            self._orders = result.get("orders", {})
            self._positions = result.get("positions", {})
        else:
            self._currencies = {}
            self._instruments = {}
            self._synthetics = {}
            self._accounts = {}
            self._orders = {}
            self._positions = {}

        # Register currencies with internal `CURRENCY_MAP`
        cdef Currency currency

        for currency in self._currencies.values():
            Currency.register_c(currency, overwrite=False)

        # Assign position IDs to contingent orders
        cdef Order order

        for order in self._orders.values():
            if order.contingency_type == ContingencyType.OTO and order.position_id is not None:
                self._assign_position_id_to_contingencies(order)

        cdef int currencies_count = len(self._currencies)
        self._log.info(
            f"Cached {currencies_count} currenc{'y' if currencies_count == 1 else 'ies'} from database",
            color=LogColor.BLUE if self._currencies else LogColor.NORMAL,
        )

        cdef int instruments_count = len(self._instruments)
        self._log.info(
            f"Cached {instruments_count} instrument{'' if instruments_count == 1 else 's'} from database",
            color=LogColor.BLUE if self._instruments else LogColor.NORMAL,
        )

        cdef int synthetics_count = len(self._synthetics)
        self._log.info(
            f"Cached {synthetics_count} synthetic instrument{'' if synthetics_count == 1 else 's'} from database",
            color=LogColor.BLUE if self._synthetics else LogColor.NORMAL,
        )

        cdef int accounts_count = len(self._accounts)
        self._log.info(
            f"Cached {accounts_count} account{'' if accounts_count == 1 else 's'} from database",
            color=LogColor.BLUE if self._accounts else LogColor.NORMAL,
        )

        cdef int orders_count = len(self._orders)
        self._log.info(
            f"Cached {orders_count} order{'' if orders_count == 1 else 's'} from database",
            color=LogColor.BLUE if self._orders else LogColor.NORMAL,
        )

        cdef int positions_count = len(self._positions)
        self._log.info(
            f"Cached {positions_count} position{'' if positions_count == 1 else 's'} from database",
            color=LogColor.BLUE if self._positions else LogColor.NORMAL
        )

    cpdef void cache_general(self):
        """
        Clear the current general cache and load the general objects from the
        cache database.
        """
        cdef double ts_start = time.time()
        cdef double ts_end

        self._log.debug(f"Loading general cache from database")

        if self._database is not None:
            ts_end = time.time()
            self._log.debug(f"cache_general: Before database.load() took {(ts_end - ts_start) * 1000:.2f}ms")

            ts_start = time.time()
            self._general = self._database.load()
            ts_end = time.time()
            self._log.debug(f"cache_general: database.load() took {(ts_end - ts_start) * 1000:.2f}ms")
        else:
            self._general = {}

        cdef int count = len(self._general)
        self._log.info(
            f"Cached {count} general object{'' if count == 1 else 's'} from database",
            color=LogColor.BLUE if self._general else LogColor.NORMAL,
        )

    cpdef void cache_currencies(self):
        """
        Clear the current currencies cache and load currencies from the cache
        database.
        """
        self._log.debug(f"Loading currencies from database")

        if self._database is not None:
            self._currencies = self._database.load_currencies()
        else:
            self._currencies = {}

        # Register currencies with internal `CURRENCY_MAP`
        cdef Currency currency

        for currency in self._currencies.values():
            Currency.register_c(currency, overwrite=False)

        cdef int count = len(self._currencies)
        self._log.info(
            f"Cached {count} currenc{'y' if count == 1 else 'ies'} from database",
            color=LogColor.BLUE if self._currencies else LogColor.NORMAL,
        )

    cpdef void cache_instruments(self):
        """
        Clear the current instruments cache and load instruments from the cache
        database.
        """
        self._log.debug(f"Loading instruments from database")

        if self._database is not None:
            self._instruments = self._database.load_instruments()
        else:
            self._instruments = {}

        cdef int count = len(self._instruments)
        self._log.info(
            f"Cached {count} instrument{'' if count == 1 else 's'} from database",
            color=LogColor.BLUE if self._instruments else LogColor.NORMAL,
        )

    cpdef void cache_synthetics(self):
        """
        Clear the current synthetic instruments cache and load synthetic instruments from the cache
        database.
        """
        self._log.debug(f"Loading synthetic instruments from database")

        if self._database is not None:
            self._synthetics = self._database.load_synthetics()
        else:
            self._synthetics = {}

        cdef int count = len(self._synthetics)
        self._log.info(
            f"Cached {count} synthetic instrument{'' if count == 1 else 's'} from database",
            color=LogColor.BLUE if self._synthetics else LogColor.NORMAL,
        )

    cpdef void cache_accounts(self):
        """
        Clear the current accounts cache and load accounts from the cache
        database.
        """
        self._log.debug(f"Loading accounts from database")

        if self._database is not None:
            self._accounts = self._database.load_accounts()
        else:
            self._accounts = {}

        cdef int count = len(self._accounts)
        self._log.info(
            f"Cached {count} account{'' if count == 1 else 's'} from database",
            color=LogColor.BLUE if self._accounts else LogColor.NORMAL,
        )

    cpdef void cache_orders(self):
        """
        Clear the current orders cache and load orders from the cache database.
        """
        self._log.debug(f"Loading orders from database")

        if self._database is not None:
            self._orders = self._database.load_orders()
            self._index_order_position = self._database.load_index_order_position()
            self._index_order_client = self._database.load_index_order_client()
        else:
            self._orders = {}

        # Assign position IDs to contingent orders
        cdef Order order

        for order in self._orders.values():
            if order.contingency_type == ContingencyType.OTO and order.position_id is not None:
                self._assign_position_id_to_contingencies(order)

        cdef int count = len(self._orders)
        self._log.info(
            f"Cached {count} order{'' if count == 1 else 's'} from database",
            color=LogColor.BLUE if self._orders else LogColor.NORMAL,
        )

    cpdef void cache_order_lists(self):
        """
        Clear the current order lists cache and load order lists using cached orders.
        """
        self._log.debug(f"Loading order lists")
        cdef dict order_list_index = {}  # type: dict[OrderListId, list[Order]]

        # Collect all orders common to an OrderListId
        cdef:
            Order order
            list orders
        for order in self._orders.values():
            if order.order_list_id is not None:
                orders = order_list_index.get(order.order_list_id)

                if orders is None:
                    orders = []
                    order_list_index[order.order_list_id] = orders

                orders.append(order)

        # Rebuild and cache order lists
        cdef:
            OrderListId order_list_id
            OrderList order_list
        for order_list_id, orders in order_list_index.items():
            order_list = OrderList(
                order_list_id=order_list_id,
                orders=orders,
            )
            self._order_lists[order_list_id] = order_list

        cdef int count = len(self._order_lists)
        self._log.info(
            f"Cached {count} order list{'' if count == 1 else 's'} from database",
            color=LogColor.BLUE if self._order_lists else LogColor.NORMAL,
        )

    cpdef void cache_positions(self):
        """
        Clear the current positions cache and load positions from the cache
        database.
        """
        self._log.debug(f"Loading positions from database")

        if self._database is not None:
            self._positions = self._database.load_positions()
        else:
            self._positions = {}

        cdef int count = len(self._positions)
        self._log.info(
            f"Cached {count} position{'' if count == 1 else 's'} from database",
            color=LogColor.BLUE if self._positions else LogColor.NORMAL
        )

    cpdef void build_index(self):
        """
        Build the cache index from objects currently held in memory.
        """
        self._log.debug(f"Building index")
        cdef double ts = time.time()

        self._build_index_venue_account()
        self._build_indexes_from_orders()
        self._build_indexes_from_positions()

        self._log.debug(f"Index built in {time.time() - ts:.3f}s")

    cpdef bint check_integrity(self):
        """
        Check integrity of data within the cache.

        All data should be loaded from the database prior to this call. If an
        error is found then a log error message will also be produced.

        Returns
        -------
        bool
            True if checks pass, else False.

        """
        cdef int error_count = 0
        cdef str failure = "Integrity failure"

        # As there should be a bi-directional one-to-one relationship between
        # caches and indexes, each cache and index must be checked individually

        cdef uint64_t timestamp_us = time.time_ns() // 1000
        self._log.info("Checking data integrity")

        cdef:
            AccountId account_id
            Order order
            Position position
        for account_id in self._accounts:
            if Venue(account_id.get_issuer()) not in self._index_venue_account:
                self._log.error(
                    f"{failure} in _cached_accounts: "
                    f"{repr(account_id)} not found in self._index_venue_account"
                )
                error_count += 1

        for client_order_id, order in self._orders.items():
            if client_order_id not in self._index_order_strategy:
                self._log.error(
                    f"{failure} in _cached_orders: "
                    f"{repr(client_order_id)} not found in self._index_order_strategy"
                )
                error_count += 1
            if client_order_id not in self._index_orders:
                self._log.error(
                    f"{failure} in _cached_orders: "
                    f"{repr(client_order_id)} not found in self._index_orders"
                )
                error_count += 1
            if order.is_inflight_c() and client_order_id not in self._index_orders_inflight:
                self._log.error(
                    f"{failure} in _cached_orders: "
                    f"{repr(client_order_id)} not found in self._index_orders_inflight"
                )
                error_count += 1
            if order.is_open_c() and client_order_id not in self._index_orders_open:
                self._log.error(
                    f"{failure} in _cached_orders: "
                    f"{repr(client_order_id)} not found in self._index_orders_open"
                )
                error_count += 1
            if order.is_closed_c() and client_order_id not in self._index_orders_closed:
                self._log.error(
                    f"{failure} in _cached_orders "
                    f"{repr(client_order_id)} not found in self._index_orders_closed"
                )
                error_count += 1
            if order.exec_algorithm_id is not None and order.exec_algorithm_id not in self._index_exec_algorithm_orders:
                self._log.error(
                    f"{failure} in _cached_orders "
                    f"{repr(order.exec_algorithm_id)} not found in self._index_exec_algorithm_orders"
                )
                error_count += 1
            if order.exec_algorithm_id is not None and order.exec_spawn_id is None and order.client_order_id not in self._index_exec_spawn_orders:
                self._log.error(
                    f"{failure} in _cached_orders "
                    f"{repr(order.exec_algorithm_id)} not found in self._index_exec_spawn_orders"
                )
                error_count += 1

        for position_id, position in self._positions.items():
            if position_id not in self._index_position_strategy:
                self._log.error(
                    f"{failure} in _cached_positions: "
                    f"{repr(position_id)} not found in self._index_position_strategy"
                )
                error_count += 1
            if position_id not in self._index_position_orders:
                self._log.error(
                    f"{failure} in _cached_positions: "
                    f"{repr(position_id)} not found in self._index_position_orders"
                )
                error_count += 1
            if position_id not in self._index_positions:
                self._log.error(
                    f"{failure} in _cached_positions: "
                    f"{repr(position_id)} not found in self._index_positions"
                )
                error_count += 1
            if position.is_open_c() and position_id not in self._index_positions_open:
                self._log.error(
                    f"{failure} in _cached_positions: "
                    f"{repr(position_id)} not found in self._index_positions_open"
                )
                error_count += 1
            if position.is_closed_c() and position_id not in self._index_positions_closed:
                self._log.error(
                    f"{failure} in _cached_positions: "
                    f"{repr(position_id)} not found in self._index_positions_closed"
                )
                error_count += 1

        # Check indexes
        # -------------
        for account_id in self._index_venue_account.values():
            if account_id not in self._accounts:
                self._log.error(
                    f"{failure} in _index_venue_account: "
                    f"{repr(account_id)} not found in self._cached_accounts"
                )
                error_count += 1

        for client_order_id in self._index_venue_order_ids.values():
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_venue_order_ids: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for client_order_id in self._index_client_order_ids:
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_client_order_ids: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for client_order_id in self._index_order_position:
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_order_position: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for client_order_id in self._index_order_strategy:
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_order_strategy: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for position_id in self._index_position_strategy:
            if position_id not in self._positions:
                self._log.error(
                    f"{failure} in _index_position_strategy: "
                    f"{repr(position_id)} not found in self._cached_positions"
                )
                error_count += 1

        for position_id in self._index_position_orders:
            if position_id not in self._positions:
                self._log.error(
                    f"{failure} in _index_position_orders: "
                    f"{repr(position_id)} not found in self._cached_positions"
                )
                error_count += 1

        for instrument_id, client_order_ids in self._index_instrument_orders.items():
            for client_order_id in client_order_ids:
                if client_order_id not in self._orders:
                    self._log.error(
                        f"{failure} in _index_instrument_orders: "
                        f"{repr(instrument_id)} not found in self._cached_orders"
                    )
                    error_count += 1

        for instrument_id in self._index_instrument_positions:
            if instrument_id not in self._index_instrument_orders:
                self._log.error(
                    f"{failure} in _index_instrument_positions: "
                    f"{repr(instrument_id)} not found in self._index_instrument_orders"
                )
                error_count += 1

        for client_order_ids in self._index_strategy_orders.values():
            for client_order_id in client_order_ids:
                if client_order_id not in self._orders:
                    self._log.error(
                        f"{failure} in _index_strategy_orders: "
                        f"{repr(client_order_id)} not found in self._cached_orders"
                    )
                    error_count += 1

        for position_ids in self._index_strategy_positions.values():
            for position_id in position_ids:
                if position_id not in self._positions:
                    self._log.error(
                        f"{failure} in _index_strategy_positions: "
                        f"{repr(position_id)} not found in self._caches_positions"
                    )
                    error_count += 1

        for client_order_id in self._index_orders:
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_orders: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for client_order_id in self._index_orders_emulated:
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_orders_emulated: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for client_order_id in self._index_orders_inflight:
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_orders_inflight: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for client_order_id in self._index_orders_open:
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_orders_open: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for client_order_id in self._index_orders_closed:
            if client_order_id not in self._orders:
                self._log.error(
                    f"{failure} in _index_orders_closed: "
                    f"{repr(client_order_id)} not found in self._cached_orders"
                )
                error_count += 1

        for position_id in self._index_positions:
            if position_id not in self._positions:
                self._log.error(
                    f"{failure} in _index_positions: "
                    f"{repr(position_id)} not found in self._cached_positions"
                )
                error_count += 1

        for position_id in self._index_positions_open:
            if position_id not in self._positions:
                self._log.error(
                    f"{failure} in _index_positions_open: "
                    f"{repr(position_id)} not found in self._cached_positions"
                )
                error_count += 1

        for position_id in self._index_positions_closed:
            if position_id not in self._positions:
                self._log.error(
                    f"{failure} in _index_positions_closed: "
                    f"{repr(position_id)} not found in self._cached_positions"
                )
                error_count += 1

        for strategy_id in self._index_strategies:
            if strategy_id not in self._index_strategy_orders:
                self._log.error(
                    f"{failure} in _index_strategies: "
                    f"{repr(strategy_id)} not found in self._index_strategy_orders"
                )
                error_count += 1

        for exec_algorithm_id in self._index_exec_algorithms:
            if exec_algorithm_id not in self._index_exec_algorithm_orders:
                self._log.error(
                    f"{failure} in _index_exec_algorithms: "
                    f"{repr(exec_algorithm_id)} not found in self._index_exec_algorithm_orders"
                )
                error_count += 1

        # Finally
        cdef uint64_t total_us = round((time.time_ns() // 1000) - timestamp_us)
        if error_count == 0:
            self._log.info(
                f"Integrity check passed in {total_us}μs",
                color=LogColor.GREEN
            )
            return True
        else:
            self._log.error(
                f"Integrity check failed with "
                f"{error_count} error{'' if error_count == 1 else 's'} "
                f"in {total_us}μs"
            )
            return False

    cpdef bint check_residuals(self):
        """
        Check for any residual open state and log warnings if any are found.

        'Open state' is considered to be open orders and open positions.

        Returns
        -------
        bool
            True if residuals exist, else False.

        """
        self._log.debug("Checking residuals")

        cdef bint residuals = False

        # Check for any residual active orders and log warnings if any are found
        for order in self.orders_open():
            residuals = True
            self._log.warning(f"Residual {order}")

        for position in self.positions_open():
            residuals = True
            self._log.warning(f"Residual {position}")

        return residuals


    cpdef void purge_closed_orders(
        self,
        uint64_t ts_now,
        uint64_t buffer_secs = 0,
        bint purge_from_database = False,
    ):
        """
        Purge all closed orders from the cache.

        Parameters
        ----------
        ts_now : uint64_t
            The current UNIX timestamp (nanoseconds).
        buffer_secs : uint64_t, default 0
            The purge buffer (seconds) from when the order was closed.
            Only orders that have been closed for at least this amount of time will be purged.
            A value of 0 means purge all closed orders regardless of when they were closed.
        purge_from_database : bool, default False
            If purging operations will also delete from the backing database, in addition to the cache.

        """
        cdef str buffer_secs_str = f" with {buffer_secs=:_}" if buffer_secs else ""
        self._log.debug(f"Purging closed orders{buffer_secs_str}", LogColor.MAGENTA)

        cdef uint64_t buffer_ns = nautilus_pyo3.secs_to_nanos(buffer_secs)

        cdef:
            ClientOrderId client_order_id
            ClientOrderId linked_order_id
            Order order
            Order linked_order
        for client_order_id in self._index_orders_closed.copy():
            order = self._orders.get(client_order_id)

            if order is not None and order.is_closed_c() and order.ts_closed + buffer_ns <= ts_now:
                # Check any linked orders (contingency orders)
                if order.linked_order_ids is not None:
                    for linked_order_id in order.linked_order_ids:
                        linked_order = self._orders.get(linked_order_id)
                        if linked_order is not None and linked_order.is_open_c():
                            break  # Do not purge if linked order still open
                    else:
                        self.purge_order(client_order_id, purge_from_database)
                else:
                    self.purge_order(client_order_id, purge_from_database)

    cpdef void purge_closed_positions(
        self,
        uint64_t ts_now,
        uint64_t buffer_secs = 0,
        bint purge_from_database = False,
    ):
        """
        Purge all closed positions from the cache.

        Parameters
        ----------
        ts_now : uint64_t
            The current UNIX timestamp (nanoseconds).
        buffer_secs : uint64_t, default 0
            The purge buffer (seconds) from when the position was closed.
            Only positions that have been closed for at least this amount of time will be purged.
            A value of 0 means purge all closed positions regardless of when they were closed.
        purge_from_database : bool, default False
            If purging operations will also delete from the backing database, in addition to the cache.

        """
        cdef str buffer_secs_str = f" with {buffer_secs=:_}" if buffer_secs else ""
        self._log.debug(f"Purging closed positions{buffer_secs_str}", LogColor.MAGENTA)
        cdef uint64_t buffer_ns = nautilus_pyo3.secs_to_nanos(buffer_secs)

        cdef:
            PositionId position_id
            Position position
        for position_id in self._index_positions_closed.copy():
            position = self._positions.get(position_id)

            if position is not None and position.is_closed_c() and position.ts_closed + buffer_ns <= ts_now:
                self.purge_position(position_id, purge_from_database)

    cpdef void purge_order(self, ClientOrderId client_order_id, bint purge_from_database = False):
        """
        Purge the order for the given client order ID from the cache (if found).

        For safety, an order is prevented from being purged if it's open.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to purge.
        purge_from_database : bool, default False
            If purging operations will also delete from the backing database, in addition to the cache.

        """
        Condition.not_none(client_order_id, "client_order_id")

        # Check if order exists and is safe to purge before popping
        cdef Order order = self._orders.get(client_order_id)

        if order is not None and order.is_open_c():
            self._log.warning(f"Order {client_order_id} found open when purging, skipping purge")
            return

        if order is None:
            self._log.warning(f"Order {client_order_id} not found when purging")
        else:
            # Safe to purge
            self._orders.pop(client_order_id, None)
            self._index_venue_orders[order.instrument_id.venue].discard(client_order_id)
            self._index_venue_order_ids.pop(order.venue_order_id, None)
            self._index_instrument_orders[order.instrument_id].discard(client_order_id)

            if order.position_id is not None:
                self._index_position_orders[order.position_id].discard(client_order_id)

            if order.exec_algorithm_id is not None:
                self._index_exec_algorithm_orders[order.exec_algorithm_id].discard(client_order_id)

            # Clean up strategy orders reverse index
            strategy_orders = self._index_strategy_orders.get(order.strategy_id)
            if strategy_orders is not None:
                strategy_orders.discard(client_order_id)
                if not strategy_orders:
                    self._index_strategy_orders.pop(order.strategy_id, None)

            # Clean up exec spawn reverse index (if this order is a spawned child)
            if order.exec_spawn_id is not None:
                spawn_orders = self._index_exec_spawn_orders.get(order.exec_spawn_id)
                if spawn_orders is not None:
                    spawn_orders.discard(client_order_id)
                    if not spawn_orders:
                        self._index_exec_spawn_orders.pop(order.exec_spawn_id, None)

            self._log.info(f"Purged order {client_order_id}", LogColor.BLUE)

        # Always clean up order indices (even if order was not in cache)
        self._index_order_position.pop(client_order_id, None)
        self._index_order_client.pop(client_order_id, None)
        self._index_client_order_ids.pop(client_order_id, None)
        strategy_id = self._index_order_strategy.pop(client_order_id, None)

        # Clean up reverse index when order not in cache (using forward index)
        if strategy_id is not None:
            strategy_orders = self._index_strategy_orders.get(strategy_id)
            if strategy_orders is not None:
                strategy_orders.discard(client_order_id)
                if not strategy_orders:
                    self._index_strategy_orders.pop(strategy_id, None)

        # Remove spawn parent entry if this order was a spawn root
        self._index_exec_spawn_orders.pop(client_order_id, None)

        self._index_orders.discard(client_order_id)
        self._index_orders_closed.discard(client_order_id)
        self._index_orders_emulated.discard(client_order_id)
        self._index_orders_inflight.discard(client_order_id)
        self._index_orders_pending_cancel.discard(client_order_id)

        # Delete from database if requested
        if purge_from_database and self._database is not None:
            self._database.delete_order(client_order_id)

    cpdef void purge_position(self, PositionId position_id, bint purge_from_database = False):
        """
        Purge the position for the given position ID from the cache (if found).

        For safety, a position is prevented from being purged if it's open.

        Parameters
        ----------
        position_id : PositionId
            The position ID to purge.
        purge_from_database : bool, default False
            If purging operations will also delete from the backing database, in addition to the cache.

        """
        Condition.not_none(position_id, "position_id")

        # Check if position exists and is safe to purge before popping
        cdef Position position = self._positions.get(position_id)

        if position is not None and position.is_open_c():
            self._log.warning(f"Position {position_id} found open when purging, skipping purge")
            return

        if position is None:
            self._log.warning(f"Position {position_id} not found when purging")
        else:
            # Safe to purge
            self._positions.pop(position_id, None)
            self._index_venue_positions[position.instrument_id.venue].discard(position_id)
            self._index_instrument_positions[position.instrument_id].discard(position_id)
            self._index_strategy_positions[position.strategy_id].discard(position_id)

            for client_order_id in position.client_order_ids_c():
                self._index_order_position.pop(client_order_id, None)

            self._log.info(f"Purged position {position_id}", LogColor.BLUE)

        # Always clean up position indices (even if position not in cache)
        self._index_position_strategy.pop(position_id, None)
        self._index_position_orders.pop(position_id, None)
        self._index_positions.discard(position_id)
        self._index_positions_open.discard(position_id)
        self._index_positions_closed.discard(position_id)

        # Remove position snapshots and clean up index
        cdef set[PositionId] snapshot_position_ids
        cdef list[bytes] snapshots = self._position_snapshots.pop(position_id, None)

        if snapshots is not None and position is not None:
            snapshot_position_ids = self._index_instrument_position_snapshots.get(position.instrument_id)
            if snapshot_position_ids:
                snapshot_position_ids.discard(position_id)

                # Clean up
                if not snapshot_position_ids:
                    self._index_instrument_position_snapshots.pop(position.instrument_id, None)

        # Delete from database if requested
        if purge_from_database and self._database is not None:
            self._database.delete_position(position_id)

    cpdef void purge_account_events(
        self,
        uint64_t ts_now,
        uint64_t lookback_secs = 0,
        bint purge_from_database = False,
    ):
        """
        Purge all account state events which are outside the lookback window.

        Parameters
        ----------
        ts_now : uint64_t
            The current UNIX timestamp (nanoseconds).
        lookback_secs : uint64_t, default 0
            The purge lookback window (seconds) from when the account state event occurred.
            Only events which are outside the lookback window will be purged.
            A value of 0 means purge all account state events.
        purge_from_database : bool, default False
            If purging operations will also delete from the backing database, in addition to the cache.

        """
        cdef str lookback_secs_str = f" with {lookback_secs=:_}" if lookback_secs else ""
        self._log.debug(f"Purging account events{lookback_secs_str}", LogColor.MAGENTA)

        cdef Account account
        for account in self._accounts.values():
            event_count = account.event_count_c()

            # Track events before purging if database deletion is enabled
            events_before = None
            if purge_from_database and self._database is not None:
                events_before = account.events.copy()  # Copy, not alias

            account.purge_account_events(ts_now, lookback_secs)
            count_diff = event_count - account.event_count_c()

            if count_diff > 0:
                self._log.info(f"Purged {count_diff} event(s) from account {account.id}", LogColor.BLUE)

                # Delete from database if enabled
                if purge_from_database and self._database is not None and events_before is not None:
                    events_after = account.events
                    event_ids_before = {event.id for event in events_before}
                    event_ids_after = {event.id for event in events_after}
                    removed_event_ids = event_ids_before - event_ids_after

                    for event_id in removed_event_ids:
                        self._database.delete_account_event(account.id, event_id.value)

    cpdef void clear_index(self):
        self._log.debug(f"Clearing index")

        self._index_venue_account.clear()
        self._index_venue_orders.clear()
        self._index_venue_positions.clear()
        self._index_venue_order_ids.clear()
        self._index_client_order_ids.clear()
        self._index_order_position.clear()
        self._index_order_strategy.clear()
        self._index_order_client.clear()
        self._index_position_strategy.clear()
        self._index_position_orders.clear()
        self._index_instrument_orders.clear()
        self._index_instrument_positions.clear()
        self._index_instrument_position_snapshots.clear()
        self._index_strategy_orders.clear()
        self._index_strategy_positions.clear()
        self._index_exec_algorithm_orders.clear()
        self._index_exec_spawn_orders.clear()
        self._index_orders.clear()
        self._index_orders_open.clear()
        self._index_orders_open_pyo3.clear()
        self._index_orders_closed.clear()
        self._index_orders_emulated.clear()
        self._index_orders_inflight.clear()
        self._index_orders_pending_cancel.clear()
        self._index_positions.clear()
        self._index_positions_open.clear()
        self._index_positions_closed.clear()
        self._index_actors.clear()
        self._index_strategies.clear()
        self._index_exec_algorithms.clear()

        self._log.debug(f"Cleared index")

    cpdef void reset(self):
        """
        Reset the cache.

        All stateful fields are reset to their initial value.
        """
        self._log.debug("Resetting cache")

        self._general.clear()
        self._currencies.clear()
        self._synthetics.clear()
        self._order_books.clear()
        self._own_order_books.clear()
        self._quote_ticks.clear()
        self._trade_ticks.clear()
        self._xrate_symbols.clear()
        self._mark_xrates.clear()
        self._mark_prices.clear()
        self._index_prices.clear()
        self._funding_rates.clear()
        self._bars.clear()
        self._bars_bid.clear()
        self._bars_ask.clear()
        self._accounts.clear()
        self._orders.clear()
        self._order_lists.clear()
        self._positions.clear()
        self._position_snapshots.clear()
        self.clear_index()

        if self._drop_instruments_on_reset:
            self._instruments.clear()

        self._log.info(f"Reset")

    cpdef void dispose(self):
        """
        Dispose of the cache which will close any underlying database adapter.

        """
        if self._database is not None:
            self._database.close()

    cpdef void flush_db(self):
        """
        Flush the caches database which permanently removes all persisted data.

        Warnings
        --------
        Permanent data loss.

        """
        self._log.debug("Flushing cache database")

        if self._database is not None:
            self._database.flush()

        self._log.info("Cache database flushed")

    cdef void _build_index_venue_account(self):
        cdef AccountId account_id

        for account_id in self._accounts.keys():
            self._cache_venue_account_id(account_id)

    cdef void _cache_venue_account_id(self, AccountId account_id):
        self._index_venue_account[Venue(account_id.get_issuer())] = account_id

    cdef void _build_indexes_from_orders(self):
        cdef ClientOrderId client_order_id
        cdef Order order

        for client_order_id, order in self._orders.items():
            # 1: Build _index_venue_orders -> {Venue, {ClientOrderId}}
            if order.instrument_id.venue not in self._index_venue_orders:
                self._index_venue_orders[order.instrument_id.venue] = set()

            self._index_venue_orders[order.instrument_id.venue].add(client_order_id)

            # 2: Build _index_venue_order_ids -> {VenueOrderId, ClientOrderId}
            if order.venue_order_id is not None:
                self._index_venue_order_ids[order.venue_order_id] = order.client_order_id
                self._index_client_order_ids[order.client_order_id] = order.venue_order_id

            # 3: Build _index_order_position -> {ClientOrderId, PositionId}
            if order.position_id is not None:
                self._index_order_position[client_order_id] = order.position_id

            # 4: Build _index_order_strategy -> {ClientOrderId, StrategyId}
            self._index_order_strategy[client_order_id] = order.strategy_id

            # 5: Build _index_instrument_orders -> {InstrumentId, {ClientOrderId}}
            if order.instrument_id not in self._index_instrument_orders:
                self._index_instrument_orders[order.instrument_id] = set()

            self._index_instrument_orders[order.instrument_id].add(client_order_id)

            # 6: Build _index_strategy_orders -> {StrategyId, {ClientOrderId}}
            if order.strategy_id not in self._index_strategy_orders:
                self._index_strategy_orders[order.strategy_id] = set()

            self._index_strategy_orders[order.strategy_id].add(client_order_id)

            # 7: Build _index_exec_algorithm_orders -> {ExecAlgorithmId, {ClientOrderId}}
            if order.exec_algorithm_id is not None:
                if order.exec_algorithm_id not in self._index_exec_algorithm_orders:
                    self._index_exec_algorithm_orders[order.exec_algorithm_id] = set()

                self._index_exec_algorithm_orders[order.exec_algorithm_id].add(order.client_order_id)

            # 8: Build _index_exec_spawn_orders -> {ClientOrderId, {ClientOrderId}}
            if order.exec_algorithm_id is not None:
                if order.exec_spawn_id not in self._index_exec_spawn_orders:
                    self._index_exec_spawn_orders[order.exec_spawn_id] = set()

                self._index_exec_spawn_orders[order.exec_spawn_id].add(order.client_order_id)

            # 9: Build _index_orders -> {ClientOrderId}
            self._index_orders.add(client_order_id)

            # 10: Build _index_orders_open -> {ClientOrderId}
            if order.is_open_c():
                self._index_orders_open.add(client_order_id)

                if self._own_order_books:
                    self._index_orders_open_pyo3.add(nautilus_pyo3.ClientOrderId(client_order_id.value))

            # 11: Build _index_orders_closed -> {ClientOrderId}
            if order.is_closed_c():
                self._index_orders_closed.add(client_order_id)

            # 12: Build _index_orders_emulated -> {ClientOrderId}
            if order.emulation_trigger != TriggerType.NO_TRIGGER and not order.is_closed_c():
                self._index_orders_emulated.add(client_order_id)

            # 13: Build _index_orders_inflight -> {ClientOrderId}
            if order.is_inflight_c():
                self._index_orders_inflight.add(client_order_id)

            # 14: Build _index_strategies -> {StrategyId}
            self._index_strategies.add(order.strategy_id)

            # 15: Build _index_strategies -> {ExecAlgorithmId}
            if order.exec_algorithm_id is not None:
                self._index_exec_algorithms.add(order.exec_algorithm_id)

    cdef void _build_indexes_from_positions(self):
        cdef ClientOrderId client_order_id
        cdef PositionId position_id
        cdef Position position
        for position_id, position in self._positions.items():
            # 1: Build _index_venue_positions -> {Venue, {PositionId}}
            if position.instrument_id.venue not in self._index_venue_positions:
                self._index_venue_positions[position.instrument_id.venue] = set()

            self._index_venue_positions[position.instrument_id.venue].add(position_id)

            # 2: Build _index_position_strategy -> {PositionId, StrategyId}
            if position.strategy_id is not None:
                self._index_position_strategy[position_id] = position.strategy_id

            # 3: Build _index_position_orders -> {PositionId, {ClientOrderId}}
            if position_id not in self._index_position_orders:
                self._index_position_orders[position_id] = set()

            index_position_orders = self._index_position_orders[position_id]

            for client_order_id in position.client_order_ids_c():
                index_position_orders.add(client_order_id)

            # 4: Build _index_instrument_positions -> {InstrumentId, {PositionId}}
            if position.instrument_id not in self._index_instrument_positions:
                self._index_instrument_positions[position.instrument_id] = set()

            self._index_instrument_positions[position.instrument_id].add(position_id)

            # 5: Build _index_strategy_positions -> {StrategyId, {PositionId}}
            if position.strategy_id is not None and position.strategy_id not in self._index_strategy_positions:
                self._index_strategy_positions[position.strategy_id] = set()

            self._index_strategy_positions[position.strategy_id].add(position.id)

            # 6: Build _index_positions -> {PositionId}
            self._index_positions.add(position_id)

            # 7: Build _index_positions_open -> {PositionId}
            if position.is_open_c():
                self._index_positions_open.add(position_id)
            # 8: Build _index_positions_closed -> {PositionId}
            elif position.is_closed_c():
                self._index_positions_closed.add(position_id)

            # 9: Build _index_strategies -> {StrategyId}
            self._index_strategies.add(position.strategy_id)

    cdef void _assign_position_id_to_contingencies(self, Order order):
        cdef:
            ClientOrderId client_order_id
            Order contingent_order
        for client_order_id in order.linked_order_ids or []:
            contingent_order = self._orders.get(client_order_id)

            if contingent_order is None:
                self._log.error(f"Contingency order {client_order_id!r} not found")
                continue

            if contingent_order.position_id is None:
                # Assign the parents position ID
                contingent_order.position_id = order.position_id

                self.add_position_id(
                    order.position_id,
                    order.instrument_id.venue,
                    contingent_order.client_order_id,
                    order.strategy_id,
                )
                self._log.info(f"Assigned {order.position_id!r} to {client_order_id!r}")

    cpdef Money calculate_unrealized_pnl(self, Position position):
        cdef QuoteTick quote = self.quote_tick(position.instrument_id)

        if quote is None:
            self._log.warning(
                f"Cannot calculate unrealized PnL for {position.id!r}, "
                f"no quotes for {position.instrument_id}",
            )
            return None

        cdef Price last

        if position.side == PositionSide.FLAT:
            return Money(0.0, position.settlement_currency)
        elif position.side == PositionSide.LONG:
            last = quote.ask_price
        else:
            last = quote.bid_price

        return position.unrealized_pnl(last)

    cpdef void load_actor(self, Actor actor):
        """
        Load the state dictionary into the given actor.

        Parameters
        ----------
        actor : Actor
            The actor to load.

        """
        Condition.not_none(actor, "actor")

        cdef dict state = None

        if self._database is not None:
            state = self._database.load_actor(actor.id)

        if state:
            for key, value in state.items():
                self._log.debug(f"Loading {actor.id}) state {{ {key}: {value} }}")

            actor.load(state)
        else:
            self._log.info(f"No previous state found for {repr(actor.id)}")

    cpdef void load_strategy(self, Strategy strategy):
        """
        Load the state dictionary into the given strategy.

        Parameters
        ----------
        strategy : Strategy
            The strategy to load.

        """
        Condition.not_none(strategy, "strategy")

        cdef dict state = None

        if self._database is not None:
            state = self._database.load_strategy(strategy.id)

        if state:
            for key, value in state.items():
                self._log.debug(f"Loading {strategy.id}) state {{ {key}: {value} }}")

            strategy.load(state)
        else:
            self._log.info(f"No previous state found for {repr(strategy.id)}")

    cpdef Instrument load_instrument(self, InstrumentId instrument_id):
        """
        Load the instrument associated with the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID to load.

        Returns
        -------
        Instrument or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef Instrument instrument = self._instruments.get(instrument_id)

        if instrument is None and self._database is not None:
            instrument = self._database.load_instrument(instrument_id)

            if instrument is not None:
                self._instruments[instrument.id] = instrument

        return instrument

    cpdef SyntheticInstrument load_synthetic(self, InstrumentId instrument_id):
        """
        Load the synthetic instrument associated with the given `instrument_id` (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The synthetic instrument ID to load.

        Returns
        -------
        SyntheticInstrument or ``None``

        Raises
        ------
        ValueError
            If `instrument_id` is not a synthetic instrument ID.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(instrument_id.is_synthetic(), "instrument_id was not a synthetic")

        cdef SyntheticInstrument synthetic = self._synthetics.get(instrument_id)

        if synthetic is None and self._database is not None:
            synthetic = self._database.load_synthetic(instrument_id)

            if synthetic is not None:
                self._synthetics[synthetic.id] = synthetic

        return synthetic

    cpdef Account load_account(self, AccountId account_id):
        """
        Load the account associated with the given account_id (if found).

        Parameters
        ----------
        account_id : AccountId
            The account ID to load.

        Returns
        -------
        Account or ``None``

        """
        Condition.not_none(account_id, "account_id")

        return self._accounts.get(account_id)

    cpdef Order load_order(self, ClientOrderId client_order_id):
        """
        Load the order associated with the given ID (if found).

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to load.

        Returns
        -------
        Order or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        return self._orders.get(client_order_id)

    cpdef Position load_position(self, PositionId position_id):
        """
        Load the position associated with the given ID (if found).

        Parameters
        ----------
        position_id : PositionId
            The position ID to load.

        Returns
        -------
        Position or ``None``

        """
        Condition.not_none(position_id, "position_id")

        return self._positions.get(position_id)

    cpdef void add(self, str key, bytes value):
        """
        Add the given general object `value` to the cache.

        The cache is agnostic to what the object actually is (and how it may
        be serialized), offering maximum flexibility.

        Parameters
        ----------
        key : str
            The cache key for the object.
        value : bytes
            The object value to write.

        """
        Condition.not_none(key, "key")
        Condition.not_none(value, "value")

        self._general[key] = value

        # Update database
        if self._database is not None:
            self._database.add(key, value)

    cpdef void add_order_book(self, OrderBook order_book):
        """
        Add the given order book to the cache.

        Parameters
        ----------
        order_book : OrderBook
            The order book to add.

        """
        Condition.not_none(order_book, "order_book")

        self._order_books[order_book.instrument_id] = order_book

    cpdef void add_own_order_book(self, own_order_book):
        """
        Add the given own order book to the cache.

        Parameters
        ----------
        own_order_book : nautilus_pyo3.OwnOrderBook
            The own order book to add.

        """
        Condition.not_none(own_order_book, "own_order_book")

        cdef InstrumentId instrument_id = InstrumentId.from_str(own_order_book.instrument_id.value)
        self._own_order_books[instrument_id] = own_order_book

    cpdef void add_quote_tick(self, QuoteTick tick):
        """
        Add the given quote tick to the cache.

        Parameters
        ----------
        tick : QuoteTick
            The tick to add.

        """
        Condition.not_none(tick, "tick")

        cdef InstrumentId instrument_id = tick.instrument_id
        ticks = self._quote_ticks.get(instrument_id)

        if not ticks:
            # The instrument_id was not registered
            ticks = deque(maxlen=self.tick_capacity)
            self._quote_ticks[instrument_id] = ticks

        ticks.appendleft(tick)

    cpdef void add_trade_tick(self, TradeTick tick):
        """
        Add the given trade tick to the cache.

        Parameters
        ----------
        tick : TradeTick
            The tick to add.

        """
        Condition.not_none(tick, "tick")

        cdef InstrumentId instrument_id = tick.instrument_id
        ticks = self._trade_ticks.get(instrument_id)

        if not ticks:
            # The instrument_id was not registered
            ticks = deque(maxlen=self.tick_capacity)
            self._trade_ticks[instrument_id] = ticks

        ticks.appendleft(tick)

    cpdef void add_mark_price(self, MarkPriceUpdate mark_price):
        """
        Add the given mark price update to the cache.

        Parameters
        ----------
        mark_price : MarkPriceUpdate
            The mark price update to add.

        """
        Condition.not_none(mark_price, "mark_price")

        mark_prices = self._mark_prices.get(mark_price.instrument_id)

        if not mark_prices:
            # The instrument_id was not registered
            mark_prices = deque(maxlen=self.tick_capacity)
            self._mark_prices[mark_price.instrument_id] = mark_prices

        mark_prices.appendleft(mark_price)

    cpdef void add_index_price(self, IndexPriceUpdate index_price):
        """
        Add the given index price update to the cache.

        Parameters
        ----------
        index_price : IndexPriceUpdate
            The index price update to add.

        """
        Condition.not_none(index_price, "index_price")

        index_prices = self._index_prices.get(index_price.instrument_id)

        if not index_prices:
            # The instrument_id was not registered
            index_prices = deque(maxlen=self.tick_capacity)
            self._index_prices[index_price.instrument_id] = index_prices

        index_prices.appendleft(index_price)

    cpdef void add_funding_rate(self, FundingRateUpdate funding_rate):
        """
        Add the given funding rate update to the cache.

        Parameters
        ----------
        funding_rate : FundingRateUpdate
            The funding rate update to add.

        """
        Condition.not_none(funding_rate, "funding_rate")

        self._funding_rates[funding_rate.instrument_id] = funding_rate

    cpdef void add_bar(self, Bar bar):
        """
        Add the given bar to the cache.

        Parameters
        ----------
        bar : Bar
            The bar to add.

        """
        Condition.not_none(bar, "bar")

        bars = self._bars.get(bar.bar_type)

        if not bars:
            # The bar type was not registered
            bars = deque(maxlen=self.bar_capacity)
            self._bars[bar.bar_type] = bars

        bars.appendleft(bar)
        cdef PriceType price_type = bar.bar_type.spec.price_type

        if price_type == PriceType.BID:
            self._bars_bid[bar.bar_type.instrument_id] = bar
        elif price_type == PriceType.ASK:
            self._bars_ask[bar.bar_type.instrument_id] = bar

    cpdef void add_quote_ticks(self, list ticks):
        """
        Add the given quotes to the cache.

        Parameters
        ----------
        ticks : list[QuoteTick]
            The ticks to add.

        """
        Condition.not_none(ticks, "ticks")

        cdef int length = len(ticks)
        cdef InstrumentId instrument_id

        if length > 0:
            instrument_id = ticks[0].instrument_id
            self._log.debug(f"Received <QuoteTick[{length}]> data for {instrument_id}")
        else:
            self._log.debug("Received <QuoteTick[]> data with no ticks")
            return

        cached_ticks = self._quote_ticks.get(instrument_id)

        if not cached_ticks:
            # The instrument_id was not registered
            cached_ticks = deque(maxlen=self.tick_capacity)
            self._quote_ticks[instrument_id] = cached_ticks

        cdef uint64_t ts_latest = cached_ticks[0].ts_event if cached_ticks else 0

        cdef:
            QuoteTick tick
        for tick in ticks:
            if tick.ts_event < ts_latest:
                # Only add more recent data to cache
                continue

            cached_ticks.appendleft(tick)
            ts_latest = tick.ts_event

    cpdef void add_trade_ticks(self, list ticks):
        """
        Add the given trades to the cache.

        Parameters
        ----------
        ticks : list[TradeTick]
            The ticks to add.

        """
        Condition.not_none(ticks, "ticks")

        cdef int length = len(ticks)
        cdef InstrumentId instrument_id

        if length > 0:
            instrument_id = ticks[0].instrument_id
            self._log.debug(f"Received <TradeTick[{length}]> data for {instrument_id}")
        else:
            self._log.debug("Received <TradeTick[]> data with no ticks")
            return

        cached_ticks = self._trade_ticks.get(instrument_id)

        if not cached_ticks:
            cached_ticks = deque(maxlen=self.tick_capacity)
            self._trade_ticks[instrument_id] = cached_ticks

        cdef uint64_t ts_latest = cached_ticks[0].ts_event if cached_ticks else 0

        cdef:
            TradeTick tick
        for tick in ticks:
            if tick.ts_event < ts_latest:
                # Only add more recent data to cache
                continue

            cached_ticks.appendleft(tick)
            ts_latest = tick.ts_event

    cpdef void add_bars(self, list bars):
        """
        Add the given bars to the cache.

        Parameters
        ----------
        bars : list[Bar]
            The bars to add.

        """
        Condition.not_none(bars, "bars")

        cdef int length = len(bars)
        cdef BarType bar_type

        if length > 0:
            bar_type = bars[0].bar_type
            self._log.debug(f"Received <Bar[{length}]> data for {bar_type}")
        else:
            self._log.debug("Received <Bar[]> data with no ticks")
            return

        cached_bars = self._bars.get(bar_type)

        if not cached_bars:
            cached_bars = deque(maxlen=self.bar_capacity)
            self._bars[bar_type] = cached_bars

        cdef uint64_t ts_latest = cached_bars[0].ts_event if cached_bars else 0

        cdef:
            Bar bar
        for bar in bars:
            if bar.ts_event < ts_latest:
                # Only add more recent data to cache
                continue

            cached_bars.appendleft(bar)
            ts_latest = bar.ts_event

        bar = bars[-1]
        cdef PriceType price_type = bar.bar_type.spec.price_type

        if price_type == PriceType.BID:
            self._bars_bid[bar.bar_type.instrument_id] = bar
        elif price_type == PriceType.ASK:
            self._bars_ask[bar.bar_type.instrument_id] = bar

    cpdef void add_currency(self, Currency currency):
        """
        Add the given currency to the cache.

        Parameters
        ----------
        currency : Currency
            The currency to add.

        """
        Condition.not_none(currency, "currency")

        self._currencies[currency.code] = currency
        Currency.register_c(currency, overwrite=False)

        self._log.debug(f"Added currency {currency.code}")

        # Update database
        if self._database is not None:
            self._database.add_currency(currency)

    cpdef void add_instrument(self, Instrument instrument):
        """
        Add the given instrument to the cache.

        Parameters
        ----------
        instrument : Instrument
            The instrument to add.

        """
        self._instruments[instrument.id] = instrument

        if isinstance(instrument, (CurrencyPair, CryptoPerpetual)):
            self._xrate_symbols[instrument.id] = (
                f"{instrument.base_currency}/{instrument.quote_currency}"
            )

        self._log.debug(f"Added instrument {instrument.id}")

        # Update database
        if self._database is not None:
            self._database.add_instrument(instrument)

    cpdef void add_synthetic(self, SyntheticInstrument synthetic):
        """
        Add the given synthetic instrument to the cache.

        Parameters
        ----------
        synthetic : SyntheticInstrument
            The synthetic instrument to add.

        """
        self._synthetics[synthetic.id] = synthetic

        self._log.debug(f"Added synthetic instrument {synthetic.id}")

        # Update database
        if self._database is not None:
            self._database.add_synthetic(synthetic)

    cpdef void add_account(self, Account account):
        """
        Add the given account to the cache.

        Parameters
        ----------
        account : Account
            The account to add.

        Raises
        ------
        ValueError
            If `account_id` is already contained in the cache.

        """
        Condition.not_none(account, "account")
        Condition.not_in(account.id, self._accounts, "account.id", "cached_accounts")

        self._accounts[account.id] = account
        self._cache_venue_account_id(account.id)

        self._log.debug(f"Added Account(id={account.id.to_str()})")
        self._log.debug(f"Indexed {repr(account.id)}")

        # Update database
        if self._database is not None and self.persist_account_events:
            self._database.add_account(account)

    cpdef void add_venue_order_id(
        self,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        bint overwrite=False,
    ):
        """
        Index the given client order ID with the given venue order ID.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to index.
        venue_order_id : VenueOrderId
            The venue order ID to index.
        overwrite : bool, default False
            If the venue order ID will 'overwrite' any existing indexing and replace
            it in the cache. This is currently used for updated orders where the venue
            order ID may change.

        Raises
        ------
        ValueError
            If `overwrite` is False and the `client_order_id` is already indexed with a different `venue_order_id`.

        """
        Condition.not_none(client_order_id, "client_order_id")
        Condition.not_none(venue_order_id, "venue_order_id")

        cdef VenueOrderId existing_venue_order_id = self._index_client_order_ids.get(client_order_id)

        if not overwrite and existing_venue_order_id is not None and venue_order_id != existing_venue_order_id:
            raise ValueError(
                f"Existing {existing_venue_order_id!r} for {client_order_id!r} "
                f"did not match the given {venue_order_id!r}. "
                "If you are writing a test then try a different `venue_order_id`, "
                "otherwise this is probably a bug."
            )

        self._index_client_order_ids[client_order_id] = venue_order_id
        self._index_venue_order_ids[venue_order_id] = client_order_id

        self._log.debug(
            f"Indexed {client_order_id!r} with {venue_order_id!r}",
        )

    cpdef void add_order(
        self,
        Order order,
        PositionId position_id = None,
        ClientId client_id = None,
        bint overwrite = False,
    ):
        """
        Add the given order to the cache indexed with the given position
        ID.

        Parameters
        ----------
        order : Order
            The order to add.
        position_id : PositionId, optional
            The position ID to index for the order.
        client_id : ClientId, optional
            The execution client ID for order routing.
        overwrite : bool, default False
            If the added order should 'overwrite' any existing order and replace
            it in the cache. This is currently used for emulated orders which are
            being released and transformed into another type.

        Raises
        ------
        ValueError
            If `order.client_order_id` is already contained in the cache.

        """
        Condition.not_none(order, "order")

        if not overwrite:
            Condition.not_in(order.client_order_id, self._orders, "order.client_order_id", "_orders")
            Condition.not_in(order.client_order_id, self._index_orders, "order.client_order_id", "_index_orders")
            Condition.not_in(order.client_order_id, self._index_order_position, "order.client_order_id", "_index_order_position")
            Condition.not_in(order.client_order_id, self._index_order_strategy, "order.client_order_id", "_index_order_strategy")

        self._orders[order.client_order_id] = order
        self._index_orders.add(order.client_order_id)
        self._index_order_strategy[order.client_order_id] = order.strategy_id
        self._index_strategies.add(order.strategy_id)

        # Index: Venue -> set[ClientOrderId]
        cdef set venue_orders = self._index_venue_orders.get(order.instrument_id.venue)

        if not venue_orders:
            self._index_venue_orders[order.instrument_id.venue] = {order.client_order_id}
        else:
            venue_orders.add(order.client_order_id)

        # Index: InstrumentId -> set[ClientOrderId]
        cdef set instrument_orders = self._index_instrument_orders.get(order.instrument_id)

        if not instrument_orders:
            self._index_instrument_orders[order.instrument_id] = {order.client_order_id}
        else:
            instrument_orders.add(order.client_order_id)

        # Index: StrategyId -> set[ClientOrderId]
        cdef set strategy_orders = self._index_strategy_orders.get(order.strategy_id)

        if not strategy_orders:
            self._index_strategy_orders[order.strategy_id] = {order.client_order_id}
        else:
            strategy_orders.add(order.client_order_id)

        # Index: ExecAlgorithmId -> set[ClientOrderId]
        # Index: ClientOrderId -> set[ClientOrderId]
        cdef set exec_algorithm_orders
        cdef set exec_spawn_orders

        if order.exec_algorithm_id is not None:
            self._index_exec_algorithms.add(order.exec_algorithm_id)

            # Set exec_algorithm_orders index
            exec_algorithm_orders = self._index_exec_algorithm_orders.get(order.exec_algorithm_id)

            if not exec_algorithm_orders:
                self._index_exec_algorithm_orders[order.exec_algorithm_id] = {order.client_order_id}
            else:
                exec_algorithm_orders.add(order.client_order_id)

            # Set exec_spawn_id index
            exec_spawn_orders = self._index_exec_spawn_orders.get(order.exec_spawn_id)

            if not exec_spawn_orders:
                self._index_exec_spawn_orders[order.exec_spawn_id] = {order.client_order_id}
            else:
                self._index_exec_spawn_orders[order.exec_spawn_id].add(order.client_order_id)

        # Update emulation
        if order.emulation_trigger == TriggerType.NO_TRIGGER:
            self._index_orders_emulated.discard(order.client_order_id)
        else:
            self._index_orders_emulated.add(order.client_order_id)

        self._log.debug(f"Added {order}")

        if position_id is not None:
            # Index position ID
            self.add_position_id(
                position_id,
                order.instrument_id.venue,
                order.client_order_id,
                order.strategy_id,
            )

        # Index: ClientOrderId -> ClientId (execution client routing)
        if client_id is not None:
            self._index_order_client[order.client_order_id] = client_id
            self._log.debug(f"Indexed {client_id!r}")

        # Update database
        if self._database is not None:
            self._database.add_order(order, position_id, client_id)

    cpdef void add_order_list(self, OrderList order_list):
        """
        Add the given order list to the cache.

        Parameters
        ----------
        order_list : OrderList
            The order_list to add.

        Raises
        ------
        ValueError
            If `order_list.id` is already contained in the cache.

        """
        Condition.not_none(order_list, "order_list")
        Condition.not_in(order_list.id, self._order_lists, "order_list.id", "_order_lists")

        self._order_lists[order_list.id] = order_list
        self._log.debug(f"Added {order_list}")

    cpdef void add_position_id(
        self,
        PositionId position_id,
        Venue venue,
        ClientOrderId client_order_id,
        StrategyId strategy_id,
    ):
        """
        Index the given position ID with the other given IDs.

        Parameters
        ----------
        position_id : PositionId
            The position ID to index.
        venue : Venue
            The venue ID to index with the position ID.
        client_order_id : ClientOrderId
            The client order ID to index with the position ID.
        strategy_id : StrategyId
            The strategy ID to index with the position ID.

        """
        Condition.not_none(position_id, "position_id")
        Condition.not_none(venue, "venue")
        Condition.not_none(client_order_id, "client_order_id")
        Condition.not_none(strategy_id, "strategy_id")

        # Index: ClientOrderId -> PositionId
        self._index_order_position[client_order_id] = position_id

        if self._database is not None:
            self._database.index_order_position(client_order_id, position_id)

        # Index: PositionId -> StrategyId
        self._index_position_strategy[position_id] = strategy_id

        # Index: PositionId -> set[ClientOrderId]
        cdef set position_orders = self._index_position_orders.get(position_id)

        if not position_orders:
            self._index_position_orders[position_id] = {client_order_id}
        else:
            position_orders.add(client_order_id)

        # Index: StrategyId -> set[PositionId]
        cdef set strategy_positions = self._index_strategy_positions.get(strategy_id)

        if not strategy_positions:
            self._index_strategy_positions[strategy_id] = {position_id}
        else:
            strategy_positions.add(position_id)

        self._log.debug(
            f"Indexed {position_id!r}, "
            f"client_order_id={client_order_id}, "
            f"strategy_id={strategy_id})",
        )

    cpdef void add_position(self, Position position, OmsType oms_type):
        """
        Add the given position to the cache.

        Parameters
        ----------
        position : Position
            The position to add.
        oms_type : OmsType
            The order management system type for the position.

        Raises
        ------
        ValueError
            If `oms_type` is ``HEDGING`` and a virtual `position.id` is already contained in the cache.

        """
        Condition.not_none(position, "position")

        if oms_type == OmsType.HEDGING and position.id.is_virtual_c():
            Condition.not_in(position.id, self._positions, "position.id", "_positions")
            Condition.not_in(position.id, self._index_positions, "position.id", "_index_positions")
            Condition.not_in(position.id, self._index_positions_open, "position.id", "_index_positions_open")

        self._positions[position.id] = position
        self._index_positions.add(position.id)
        self._index_positions_open.add(position.id)
        self._index_positions_closed.discard(position.id)  # Cleanup for NETTING reopen

        self.add_position_id(
            position.id,
            position.instrument_id.venue,
            position.opening_order_id,
            position.strategy_id,
        )

        # Index: Venue -> set[PositionId]
        cdef Venue venue = position.instrument_id.venue
        cdef set venue_positions = self._index_venue_positions.get(venue)

        if not venue_positions:
            self._index_venue_positions[venue] = {position.id}
        else:
            venue_positions.add(position.id)

        # Index: InstrumentId -> set[PositionId]
        cdef InstrumentId instrument_id = position.instrument_id
        cdef set instrument_positions = self._index_instrument_positions.get(instrument_id)

        if not instrument_positions:
            self._index_instrument_positions[instrument_id] = {position.id}
        else:
            instrument_positions.add(position.id)

        self._log.debug(f"Added Position(id={position.id.to_str()}, strategy_id={position.strategy_id.to_str()})")

        # Update database
        if self._database is not None:
            self._database.add_position(position)

    cpdef void add_greeks(self, object greeks):
        """
        Add greeks to the cache.

        Parameters
        ----------
        greeks : GreeksData
            The greeks to add.

        """
        self._greeks[greeks.instrument_id] = greeks

    cpdef void add_yield_curve(self, object yield_curve):
        """
        Add a yield curve to the cache.

        Parameters
        ----------
        yield_curve : YieldCurveData
            The yield curve to add.

        """
        self._yield_curves[yield_curve.curve_name] = yield_curve

    cpdef object greeks(self, InstrumentId instrument_id):
        """
        Return the latest cached greeks for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID to get the greeks for.

        Returns
        -------
        GreeksData
            The greeks for the given instrument ID.

        """
        return self._greeks.get(instrument_id)

    cpdef object yield_curve(self, str curve_name):
        """
        Return the latest cached yield curve for the given curve name.

        Parameters
        ----------
        curve_name : str
            The name of the yield curve to get.

        Returns
        -------
        YieldCurveData
            The interest rate curve for the given currency.

        """
        return self._yield_curves.get(curve_name)

    cpdef void snapshot_position(self, Position position):
        """
        Snapshot the given position in its current state.

        The position ID will be appended with a UUID v4 string.

        Parameters
        ----------
        position : Position
            The position to snapshot.

        """
        cdef PositionId position_id = position.id
        cdef list[bytes] snapshots = self._position_snapshots.get(position_id)

        # Create snapshot with modified position ID
        cdef Position copied_position = pickle.loads(pickle.dumps(position))
        copied_position.id = PositionId(f"{position_id.to_str()}-{uuid.uuid4()}")
        cdef bytes position_pickled = pickle.dumps(copied_position)

        if snapshots is not None:
            snapshots.append(position_pickled)
        else:
            self._position_snapshots[position_id] = [position_pickled]

        # Update snapshot index
        cdef InstrumentId instrument_id = position.instrument_id
        cdef set position_ids = self._index_instrument_position_snapshots.get(instrument_id)
        if position_ids is not None:
            position_ids.add(position_id)
        else:
            self._index_instrument_position_snapshots[instrument_id] = {position_id}

        self._log.debug(f"Snapshot {repr(copied_position)}")

    cpdef void snapshot_position_state(
        self,
        Position position,
        uint64_t ts_snapshot,
        Money unrealized_pnl=None,
        bint open_only=True,
    ):
        """
        Snapshot the state dictionary for the given `position`.

        This method will persist to the backing cache database.

        Parameters
        ----------
        position : Position
            The position to snapshot the state for.
        ts_snapshot : uint64_t
            UNIX timestamp (nanoseconds) when the snapshot was taken.
        unrealized_pnl : Money, optional
            The current unrealized PnL for the position.
        open_only : bool, default True
            If only open positions should be snapshot, this flag helps to avoid race conditions
            where a position is snapshot when no longer open.

        """
        Condition.not_none(position, "position")

        if open_only and not position.is_open_c():
            return  # Only snapshot open positions

        if self._database is None:
            self._log.warning(
                "Cannot snapshot position state for {position.id:r!} (no database configured)",
            )
            return

        self._database.snapshot_position_state(
            position,
            ts_snapshot,
            unrealized_pnl,
        )

    cpdef void snapshot_order_state(self, Order order):
        """
        Snapshot the state dictionary for the given `order`.

        This method will persist to the backing cache database.

        Parameters
        ----------
        order : Order
            The order to snapshot the state for.

        """
        Condition.not_none(order, "order")

        if self._database is None:
            self._log.warning(
                "Cannot snapshot order state for {order.client_order_id:r!} (no database configured)",
            )
            return

        self._database.snapshot_order_state(order)

    cpdef void update_account(self, Account account):
        """
        Update the given account in the cache.

        Parameters
        ----------
        account : The account to update (from last event).

        """
        Condition.not_none(account, "account")

        # Update database
        if self._database is not None and self.persist_account_events:
            self._database.update_account(account)

    cpdef void update_order(self, Order order):
        """
        Update the given order in the cache.

        Parameters
        ----------
        order : Order
            The order to update (from last event).

        """
        Condition.not_none(order, "order")

        # Update venue order ID
        if order.venue_order_id is not None and order.venue_order_id not in self._index_venue_order_ids:
            # If the order is being modified then we allow a changing `VenueOrderId` to accommodate
            # venues which use a cancel+replace update strategy.
            self.add_venue_order_id(
                order.client_order_id,
                order.venue_order_id,
                overwrite=isinstance(order._events[-1], OrderUpdated),
            )

        # Update in-flight state
        if order.is_inflight_c():
            self._index_orders_inflight.add(order.client_order_id)
        else:
            self._index_orders_inflight.discard(order.client_order_id)

        # Update open/closed state
        if order.is_open_c():
            self._index_orders_closed.discard(order.client_order_id)
            self._index_orders_open.add(order.client_order_id)

            if self._own_order_books:
                self._index_orders_open_pyo3.add(nautilus_pyo3.ClientOrderId(order.client_order_id.value))
        elif order.is_closed_c():
            self._index_orders_open.discard(order.client_order_id)
            self._index_orders_pending_cancel.discard(order.client_order_id)
            self._index_orders_closed.add(order.client_order_id)

            if self._own_order_books:
                self._index_orders_open_pyo3.discard(nautilus_pyo3.ClientOrderId(order.client_order_id.value))

        # Update emulation
        if order.is_closed_c() or order.emulation_trigger == TriggerType.NO_TRIGGER:
            self._index_orders_emulated.discard(order.client_order_id)
        else:
            self._index_orders_emulated.add(order.client_order_id)

        # Update own book
        if self._own_order_books:
            own_book = self._own_order_books.get(order.instrument_id)
            # Only bypass should_handle check for closed orders (to ensure cleanup)
            if (own_book is not None and order.is_closed_c()) or should_handle_own_book_order(order):
                self.update_own_order_book(order)

        # Update database
        if self._database is not None:
            self._database.update_order(order)

    cpdef void update_order_pending_cancel_local(self, Order order):
        """
        Update the given `order` as pending cancel locally.

        Parameters
        ----------
        order : Order
            The order to update.

        """
        Condition.not_none(order, "order")

        self._index_orders_pending_cancel.add(order.client_order_id)

    cpdef void update_own_order_book(self, Order order):
        """
        Update the own order book for the given order.

        Orders without prices (MARKET, etc.) are skipped as they cannot be
        represented in own books.

        Parameters
        ----------
        order : Order
            The order to update.

        """
        Condition.not_none(order, "order")

        if not order.has_price_c():
            return

        own_book = self._own_order_books.get(order.instrument_id)

        if own_book is None:
            if order.is_closed_c():
                # Don't create own book for closed orders
                return
            pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(order.instrument_id.value)
            own_book = nautilus_pyo3.OwnOrderBook(pyo3_instrument_id)
            self._own_order_books[order.instrument_id] = own_book
            self._log.debug(f"Initialized {own_book!r}", LogColor.MAGENTA)

        own_book_order = order.to_own_book_order()

        if order.is_closed_c():
            try:
                own_book.delete(own_book_order)
                self._log.debug(f"Deleted order {order.client_order_id} from own book")
            except RuntimeError as e:
                self._log.debug(f"Failed to delete order {order.client_order_id} from own book: {e}")
        else:
            try:
                own_book.update(own_book_order)
            except RuntimeError as e:
                self._log.debug(f"Failed to update order {order.client_order_id} in own book: {e}; inserting instead")
                own_book.add(own_book_order)
            self._log.debug(f"Updated order {order.client_order_id} in own book")

    cpdef void update_position(self, Position position):
        """
        Update the given position in the cache.

        Parameters
        ----------
        position : Position
            The position to update (from last event).

        """
        Condition.not_none(position, "position")

        if position.is_open_c():
            self._index_positions_open.add(position.id)
            self._index_positions_closed.discard(position.id)
        elif position.is_closed_c():
            self._index_positions_closed.add(position.id)
            self._index_positions_open.discard(position.id)

        # Update database
        if self._database is not None:
            self._database.update_position(position)

    cpdef void update_actor(self, Actor actor):
        """
        Update the given actor state in the cache.

        Parameters
        ----------
        actor : Actor
            The actor to update.
        """
        Condition.not_none(actor, "actor")

        self._index_actors.add(actor.id)

        # Update database
        if self._database is not None:
            self._database.update_actor(actor)

    cpdef void update_strategy(self, Strategy strategy):
        """
        Update the given strategy state in the cache.

        Parameters
        ----------
        strategy : Strategy
            The strategy to update.
        """
        Condition.not_none(strategy, "strategy")

        self._index_strategies.add(strategy.id)

        # Update database
        if self._database is not None:
            self._database.update_strategy(strategy)

    cpdef void delete_actor(self, Actor actor):
        """
        Delete the given actor from the cache.

        Parameters
        ----------
        actor : Actor
            The actor to deregister.

        Raises
        ------
        ValueError
            If `actor` is not contained in the actors index.

        """
        Condition.not_none(actor, "actor")
        Condition.is_in(actor.id, self._index_actors, "actor.id", "actors")

        self._index_actors.discard(actor.id)

        # Update database
        if self._database is not None:
            self._database.delete_actor(actor.id)
            self._log.debug(f"Deleted Actor(id={actor.id.value})")

    cpdef void delete_strategy(self, Strategy strategy):
        """
        Delete the given strategy from the cache.

        Parameters
        ----------
        strategy : Strategy
            The strategy to deregister.

        Raises
        ------
        ValueError
            If `strategy` is not contained in the strategies index.

        """
        Condition.not_none(strategy, "strategy")
        Condition.is_in(strategy.id, self._index_strategies, "strategy.id", "strategies")

        self._index_strategies.discard(strategy.id)

        if strategy.id in self._index_strategy_orders:
            del self._index_strategy_orders[strategy.id]

        if strategy.id in self._index_strategy_positions:
            del self._index_strategy_positions[strategy.id]

        # Update database
        if self._database is not None:
            self._database.delete_strategy(strategy.id)
            self._log.debug(f"Deleted Strategy(id={strategy.id.value})")

# -- DATA QUERIES ---------------------------------------------------------------------------------

    cpdef bytes get(self, str key):
        """
        Return the general object for the given `key`.

        The cache is agnostic to what the object actually is (and how it may
        be serialized), offering maximum flexibility.

        Parameters
        ----------
        key : str
            The cache key for the object.

        Returns
        -------
        bytes or ``None``

        """
        Condition.not_none(key, "key")

        return self._general.get(key)

    cpdef list quote_ticks(self, InstrumentId instrument_id):
        """
        Return the quotes for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the ticks to get.

        Returns
        -------
        list[QuoteTick]

        """
        Condition.not_none(instrument_id, "instrument_id")

        return list(self._quote_ticks.get(instrument_id, []))

    cpdef list trade_ticks(self, InstrumentId instrument_id):
        """
        Return trades for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the ticks to get.

        Returns
        -------
        list[TradeTick]

        """
        Condition.not_none(instrument_id, "instrument_id")

        return list(self._trade_ticks.get(instrument_id, []))

    cpdef list mark_prices(self, InstrumentId instrument_id):
        """
        Return mark prices for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the mark prices to get.

        Returns
        -------
        list[MarkPriceUpdate]

        """
        Condition.not_none(instrument_id, "instrument_id")

        return list(self._mark_prices.get(instrument_id, []))

    cpdef list index_prices(self, InstrumentId instrument_id):
        """
        Return index prices for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the mark prices to get.

        Returns
        -------
        list[IndexPriceUpdate]

        """
        Condition.not_none(instrument_id, "instrument_id")

        return list(self._index_prices.get(instrument_id, []))

    cpdef list bars(self, BarType bar_type):
        """
        Return bars for the given bar type.

        Parameters
        ----------
        bar_type : BarType
            The bar type for bars to get.

        Returns
        -------
        list[Bar]

        """
        Condition.not_none(bar_type, "bar_type")

        return list(self._bars.get(bar_type, []))

    cpdef Price price(self, InstrumentId instrument_id, PriceType price_type):
        """
        Return the price for the given instrument ID and price type.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the price.
        price_type : PriceType
            The price type for the query.

        Returns
        -------
        Price or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef TradeTick trade_tick
        cdef QuoteTick quote_tick

        if price_type == PriceType.LAST:
            trade_tick = self.trade_tick(instrument_id)

            if trade_tick is not None:
                return trade_tick.price
        elif price_type == PriceType.BID or price_type == PriceType.ASK or price_type == PriceType.MID:
            quote_tick = self.quote_tick(instrument_id)

            if quote_tick is not None:
                return quote_tick.extract_price(price_type)
        elif price_type == PriceType.MARK:
            mark_price = self.mark_price(instrument_id)

            if mark_price is not None:
                return mark_price.value

        # Fall back to bar pricing for bid, ask and last
        cdef Bar bar
        cdef list bar_types = self.bar_types(instrument_id, price_type, AggregationSource.EXTERNAL)

        if bar_types:
            bar = self.bar(bar_types[0])  # Bar with smallest timedelta

            if bar is not None:
                return bar.close

    cpdef dict[InstrumentId, Price] prices(self, PriceType price_type):
        """
        Return a map of latest prices per instrument ID for the given price type.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the price.
        price_type : PriceType
            The price type for the query.

        Returns
        -------
        dict[InstrumentId, Price]
            Includes key value pairs for prices which exist.

        """
        cdef set[InstrumentId] instrument_ids = {b.instrument_id for b in self._bars.keys()}

        if price_type == PriceType.LAST:
            instrument_ids.update(self._trade_ticks.keys())
        elif price_type == PriceType.BID or price_type == PriceType.ASK or price_type == PriceType.MID:
            instrument_ids.update(self._quote_ticks.keys())
        elif price_type == PriceType.MARK:
            instrument_ids.update(self._mark_prices.keys())
        else:
            # Unreachable unless code changes
            raise ValueError(f"Invalid `PriceType`, was {price_type}")

        cdef dict[InstrumentId, Price] prices_map = {}

        cdef:
            InstrumentId instrument_id
            Price price
        for instrument_id in sorted(instrument_ids):
            price = self.price(instrument_id, price_type)

            if price is not None:
                prices_map[instrument_id] = price

        return prices_map

    cpdef OrderBook order_book(self, InstrumentId instrument_id):
        """
        Return the order book for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the order book to get.

        Returns
        -------
        OrderBook or ``None``
            If book not found for the instrument ID then returns ``None``.

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._order_books.get(instrument_id)

    cpdef object own_order_book(self, InstrumentId instrument_id):
        """
        Return the own order book for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the own order book to get.
            Note this is the standard Cython `InstrumentId`.

        Returns
        -------
        nautilus_pyo3.OwnOrderBook or ``None``
            If own book not found for the instrument ID then returns ``None``.

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._own_order_books.get(instrument_id)

    cpdef dict[Decimal, list[Order]] own_bid_orders(
        self,
        InstrumentId instrument_id,
        set[OrderStatus] status = None,
        uint64_t accepted_buffer_ns = 0,
        uint64_t ts_now = 0,
    ):
        """
        Return own bid orders for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the own orders to get.
            Note this is the standard Cython `InstrumentId`.
        status : set[OrderStatus], optional
            The order status to filter for. Empty price levels after filtering are excluded from the result.
        accepted_buffer_ns : uint64_t, optional
            The minimum time in nanoseconds that must have elapsed since the order was accepted.
            Orders accepted less than this time ago will be filtered out.
        ts_now : uint64_t, optional
            The current time in nanoseconds. Required if accepted_buffer_ns > 0.

        Returns
        -------
        dict[Decimal, list[Order]] or ``None``
            If own book not found for the instrument ID then returns ``None``.

        Raises
        ------
        ValueError
            If `accepted_buffer_ns` > 0 and `ts_now` == 0.

        """
        Condition.not_none(instrument_id, "instrument_id")

        if accepted_buffer_ns > 0 and ts_now == 0:
            raise ValueError("ts_now must be provided when accepted_buffer_ns > 0")

        own_order_book = self._own_order_books.get(instrument_id)
        if own_order_book is None:
            return None

        return process_own_order_map(
            own_order_book.bids_to_dict(
                {order_status_to_pyo3(s) for s in status} if status is not None else None,
                accepted_buffer_ns if accepted_buffer_ns > 0 else None,
                ts_now if ts_now > 0 else None,
            ),
            self._orders,
        )

    cpdef dict[Decimal, list[Order]] own_ask_orders(
        self,
        InstrumentId instrument_id,
        set[OrderStatus] status = None,
        uint64_t accepted_buffer_ns = 0,
        uint64_t ts_now = 0,
    ):
        """
        Return own ask orders for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the own orders to get.
            Note this is the standard Cython `InstrumentId`.
        status : set[OrderStatus], optional
            The order status to filter for. Empty price levels after filtering are excluded from the result.
        accepted_buffer_ns : uint64_t, optional
            The minimum time in nanoseconds that must have elapsed since the order was accepted.
            Orders accepted less than this time ago will be filtered out.
        ts_now : uint64_t, optional
            The current time in nanoseconds. Required if accepted_buffer_ns > 0.

        Returns
        -------
        dict[Decimal, list[Order]] or ``None``
            If own book not found for the instrument ID then returns ``None``.

        Raises
        ------
        ValueError
            If `accepted_buffer_ns` > 0 and `ts_now` == 0.

        """
        Condition.not_none(instrument_id, "instrument_id")

        if accepted_buffer_ns > 0 and ts_now == 0:
            raise ValueError("ts_now must be provided when accepted_buffer_ns > 0")

        own_order_book = self._own_order_books.get(instrument_id)
        if own_order_book is None:
            return None

        return process_own_order_map(
            own_order_book.asks_to_dict(
                {order_status_to_pyo3(s) for s in status} if status is not None else None,
                accepted_buffer_ns if accepted_buffer_ns > 0 else None,
                ts_now if ts_now > 0 else None,
            ),
            self._orders,
        )

    cpdef QuoteTick quote_tick(self, InstrumentId instrument_id, int index = 0):
        """
        Return the quote tick for the given instrument ID at the given index (if found).

        Last quote tick if no index specified.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the tick to get.
        index : int, optional
            The index for the tick to get.

        Returns
        -------
        QuoteTick or ``None``
            If no ticks or no tick at index then returns ``None``.

        Notes
        -----
        Reverse indexed (most recent tick at index 0).

        """
        Condition.not_none(instrument_id, "instrument_id")

        ticks = self._quote_ticks.get(instrument_id)

        if not ticks:
            return None

        try:
            return ticks[index]
        except IndexError:
            return None

    cpdef TradeTick trade_tick(self, InstrumentId instrument_id, int index = 0):
        """
        Return the trade tick for the given instrument ID at the given index (if found).

        Last trade tick if no index specified.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the tick to get.
        index : int, optional
            The index for the tick to get.

        Returns
        -------
        TradeTick or ``None``
            If no ticks or no tick at index then returns ``None``.

        Notes
        -----
        Reverse indexed (most recent tick at index 0).

        """
        Condition.not_none(instrument_id, "instrument_id")

        ticks = self._trade_ticks.get(instrument_id)

        if not ticks:
            return None

        try:
            return ticks[index]
        except IndexError:
            return None

    cpdef MarkPriceUpdate mark_price(self, InstrumentId instrument_id, int index = 0):
        """
        Return the mark price for the given instrument ID at the given index (if found).

        Last mark price if no index specified.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the mark price to get.
        index : int, optional
            The index for the mark price to get.

        Returns
        -------
        MarkPriceUpdate or ``None``
            If no mark prices or no mark price at index then returns ``None``.

        Notes
        -----
        Reverse indexed (most recent mark price at index 0).

        """
        Condition.not_none(instrument_id, "instrument_id")

        mark_prices = self._mark_prices.get(instrument_id)

        if not mark_prices:
            return None

        try:
            return mark_prices[index]
        except IndexError:
            return None

    cpdef IndexPriceUpdate index_price(self, InstrumentId instrument_id, int index = 0):
        """
        Return the index price for the given instrument ID at the given index (if found).

        Last index price if no index specified.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the index price to get.
        index : int, optional
            The index for the index price to get.

        Returns
        -------
        IndexPriceUpdate or ``None``
            If no index prices or no index price at index then returns ``None``.

        Notes
        -----
        Reverse indexed (most recent index price at index 0).

        """
        Condition.not_none(instrument_id, "instrument_id")

        index_prices = self._index_prices.get(instrument_id)

        if not index_prices:
            return None

        try:
            return index_prices[index]
        except IndexError:
            return None

    cpdef FundingRateUpdate funding_rate(self, InstrumentId instrument_id):
        """
        Return the funding rate for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the funding rate to get.

        Returns
        -------
        FundingRateUpdate or ``None``
            If no funding rate then returns ``None``.

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._funding_rates.get(instrument_id)

    cpdef Bar bar(self, BarType bar_type, int index = 0):
        """
        Return the bar for the given bar type at the given index (if found).

        Last bar if no index specified.

        Parameters
        ----------
        bar_type : BarType
            The bar type to get.
        index : int, optional
            The index for the bar to get.

        Returns
        -------
        Bar or ``None``
            If no bars or no bar at index then returns ``None``.

        Notes
        -----
        Reverse indexed (most recent bar at index 0).

        """
        Condition.not_none(bar_type, "bar_type")

        bars = self._bars.get(bar_type)

        if not bars:
            return None

        try:
            return bars[index]
        except IndexError:
            return None

    cpdef int book_update_count(self, InstrumentId instrument_id):
        """
        The count of order book updates for the given instrument ID.

        Will return zero if there is no book for the instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the book.

        Returns
        -------
        int

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef OrderBook book = self._order_books.get(instrument_id)

        if book is None:
            return 0
        else:
            return book.update_count

    cpdef int quote_tick_count(self, InstrumentId instrument_id):
        """
        The count of quotes for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the ticks.

        Returns
        -------
        int

        """
        Condition.not_none(instrument_id, "instrument_id")

        return len(self._quote_ticks.get(instrument_id, []))

    cpdef int trade_tick_count(self, InstrumentId instrument_id):
        """
        The count of trades for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the ticks.

        Returns
        -------
        int

        """
        Condition.not_none(instrument_id, "instrument_id")

        return len(self._trade_ticks.get(instrument_id, []))

    cpdef int mark_price_count(self, InstrumentId instrument_id):
        """
        The count of mark prices for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the mark prices.

        Returns
        -------
        int

        """
        Condition.not_none(instrument_id, "instrument_id")

        return len(self._mark_prices.get(instrument_id, []))

    cpdef int index_price_count(self, InstrumentId instrument_id):
        """
        The count of index prices for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the index prices.

        Returns
        -------
        int

        """
        Condition.not_none(instrument_id, "instrument_id")

        return len(self._index_prices.get(instrument_id, []))

    cpdef int bar_count(self, BarType bar_type):
        """
        The count of bars for the given bar type.

        Parameters
        ----------
        bar_type : BarType
            The bar type to count.

        Returns
        -------
        int

        """
        Condition.not_none(bar_type, "bar_type")

        return len(self._bars.get(bar_type, []))

    cpdef bint has_order_book(self, InstrumentId instrument_id):
        """
        Return a value indicating whether the cache has an order book snapshot
        for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the order book snapshot.

        Returns
        -------
        bool

        """
        return instrument_id in self._order_books

    cpdef bint has_quote_ticks(self, InstrumentId instrument_id):
        """
        Return a value indicating whether the cache has quotes for the
        given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the ticks.

        Returns
        -------
        bool

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self.quote_tick_count(instrument_id) > 0

    cpdef bint has_trade_ticks(self, InstrumentId instrument_id):
        """
        Return a value indicating whether the cache has trades for the
        given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the ticks.

        Returns
        -------
        bool

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self.trade_tick_count(instrument_id) > 0

    cpdef bint has_mark_prices(self, InstrumentId instrument_id):
        """
        Return a value indicating whether the cache has mark prices for the
        given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the mark prices.

        Returns
        -------
        bool

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self.mark_price_count(instrument_id) > 0

    cpdef bint has_index_prices(self, InstrumentId instrument_id):
        """
        Return a value indicating whether the cache has index prices for the
        given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the index prices.

        Returns
        -------
        bool

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self.index_price_count(instrument_id) > 0

    cpdef bint has_bars(self, BarType bar_type):
        """
        Return a value indicating whether the cache has bars for the given bar
        type.

        Parameters
        ----------
        bar_type : BarType
            The bar type for the bars.

        Returns
        -------
        bool

        """
        Condition.not_none(bar_type, "bar_type")

        return self.bar_count(bar_type) > 0

    cpdef get_xrate(
        self,
        Venue venue,
        Currency from_currency,
        Currency to_currency,
        PriceType price_type=PriceType.MID,
    ):
        """
        Return the calculated exchange rate.

        If the exchange rate cannot be calculated then returns ``None``.

        Parameters
        ----------
        venue : Venue
            The venue for the exchange rate.
        from_currency : Currency
            The currency to convert from.
        to_currency : Currency
            The currency to convert to.
        price_type : PriceType
            The price type for the exchange rate.

        Returns
        -------
        float or ``None``

        Raises
        ------
        ValueError
            If `price_type` is ``LAST`` or ``MARK``.

        """
        Condition.not_none(from_currency, "from_currency")
        Condition.not_none(to_currency, "to_currency")

        if from_currency == to_currency:
            # When the source and target currencies are identical,
            # no conversion is needed; return an exchange rate of 1.0.
            return 1.0

        cdef tuple quotes = self._build_quote_table(venue)

        try:
            return nautilus_pyo3.get_exchange_rate(
                from_currency=from_currency.code,
                to_currency=to_currency.code,
                price_type=nautilus_pyo3.PriceType.from_int(price_type),
                quotes_bid=quotes[0],  # Bid
                quotes_ask=quotes[1],  # Ask
            )
        except ValueError as e:
            self._log.error(f"Cannot calculate exchange rate: {e!r}")

    cdef tuple _build_quote_table(self, Venue venue):
        cdef dict bid_quotes = {}
        cdef dict ask_quotes = {}

        cdef:
            InstrumentId instrument_id
            str base_quote
            Price bid_price
            Price ask_price
            Bar bid_bar
            Bar ask_bar
        for instrument_id, base_quote in self._xrate_symbols.items():
            if instrument_id.venue != venue:
                continue

            ticks = self._quote_ticks.get(instrument_id)

            if ticks:
                bid_price = ticks[0].bid_price
                ask_price = ticks[0].ask_price
            else:
                # No quotes for instrument_id
                bid_bar = self._bars_bid.get(instrument_id)
                ask_bar = self._bars_ask.get(instrument_id)

                if bid_bar is None or ask_bar is None:
                    continue # No prices for instrument_id

                bid_price = bid_bar.close
                ask_price = ask_bar.close

            bid_quotes[base_quote] = bid_price.as_f64_c()
            ask_quotes[base_quote] = ask_price.as_f64_c()

        return bid_quotes, ask_quotes

    cpdef get_mark_xrate(
        self,
        Currency from_currency,
        Currency to_currency,
    ):
        """
        Return the exchange rate based on mark price.

        Will return ``None`` if an exchange rate has not been set.

        Parameters
        ----------
        from_currency : Currency
            The currency to convert from.
        to_currency : Currency
            The currency to convert to.

        Returns
        -------
        float or ``None``

        """
        Condition.not_none(from_currency, "from_currency")
        Condition.not_none(to_currency, "to_currency")

        if from_currency == to_currency:
            # When the source and target currencies are identical,
            # no conversion is needed; return an exchange rate of 1.0.
            return 1.0

        cdef tuple[Currency, Currency] key = (from_currency, to_currency)
        return self._mark_xrates.get(key)

    cpdef void set_mark_xrate(
        self,
        Currency from_currency,
        Currency to_currency,
        double xrate,
    ):
        """
        Set the exchange rate based on mark price.

        Will also set the inverse xrate automatically.

        Parameters
        ----------
        from_currency : Currency
            The base currency for the exchange rate to set.
        to_currency : Currency
            The quote currency for the exchange rate to set.
        xrate : double
            The exchange rate based on mark price.

        Raises
        ------
        ValueError
            If `xrate` is zero.

        """
        Condition.not_none(from_currency, "from_currency")
        Condition.not_none(to_currency, "to_currency")
        Condition.not_equal(xrate, 0.0, "xrate", "zero")

        self._mark_xrates[(from_currency, to_currency)] = xrate
        self._mark_xrates[(to_currency, from_currency)] = 1.0 / xrate

    cpdef void clear_mark_xrate(
        self,
        Currency from_currency,
        Currency to_currency,
    ):
        """
        Clear the exchange rate based on mark price.

        Parameters
        ----------
        from_currency : Currency
            The base currency for the exchange rate to clear.
        to_currency : Currency
            The quote currency for the exchange rate to clear.

        """
        Condition.not_none(from_currency, "from_currency")
        Condition.not_none(to_currency, "to_currency")

        self._mark_xrates.pop((from_currency, to_currency), None)

    cpdef void clear_mark_xrates(self):
        """
        Clear the exchange rates based on mark price.

        """
        self._mark_xrates.clear()

# -- INSTRUMENT QUERIES ---------------------------------------------------------------------------

    cpdef Instrument instrument(self, InstrumentId instrument_id):
        """
        Return the instrument corresponding to the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID of the instrument to return.

        Returns
        -------
        Instrument or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._instruments.get(instrument_id)

    cpdef list instrument_ids(self, Venue venue = None):
        """
        Return all instrument IDs held by the cache.

        Parameters
        ----------
        venue : Venue, optional
            The venue filter for the query.

        Returns
        -------
        list[InstrumentId]

        """
        cdef InstrumentId x

        return sorted([x for x in self._instruments.keys() if venue is None or venue == x.venue])

    cpdef list instruments(self, Venue venue = None, str underlying = None):
        """
        Return all instruments held by the cache.

        Parameters
        ----------
        venue : Venue, optional
            The venue filter for the query.
        underlying : str, optional
            The underlying root symbol for the query.

        Returns
        -------
        list[Instrument]

        """
        cdef Instrument x

        return [
            x for x in self._instruments.values()
            if (venue is None or venue == x.id.venue) and
            (underlying is None or (hasattr(x, "underlying") and underlying == x.underlying))
        ]

    cdef timedelta _get_timedelta(self, BarType bar_type):
        # Helper method to get the timedelta from a BarType
        cdef BarSpecification bar_spec = bar_type.spec

        if bar_spec.aggregation == BarAggregation.MONTH:
            return timedelta(days=bar_spec.step * 30)  # Reasonable value to fix sorting

        return bar_spec.timedelta

    cpdef list bar_types(
        self,
        InstrumentId instrument_id = None,
        object price_type = None,
        aggregation_source = None,
    ):
        """
        Return all bar types with the given query filters.

        If a filter parameter is ``None``, then no filtering occurs for that parameter.

        Parameters
        ----------
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        price_type : PriceType, optional
            The price type query filter.
        aggregation_source : AggregationSource, optional
            The aggregation source query filter.

        Returns
        -------
        list[BarType]

        """
        Condition.type_or_none(instrument_id, InstrumentId, "instrument_id")
        Condition.type_or_none(price_type, PriceType_py, "price_type")

        cdef list[BarType] bar_types = list(self._bars.keys())

        if instrument_id is not None:
            bar_types = [bar_type for bar_type in bar_types if bar_type.instrument_id == instrument_id]

        if price_type is not None:
            bar_types = [bar_type for bar_type in bar_types if bar_type.spec.price_type == price_type]

        if aggregation_source is not None:
            bar_types = [bar_type for bar_type in bar_types if bar_type.aggregation_source == aggregation_source]

        if instrument_id and price_type:
            bar_types.sort(key=self._get_timedelta)

        return bar_types

# -- SYNTHETIC QUERIES ----------------------------------------------------------------------------

    cpdef SyntheticInstrument synthetic(self, InstrumentId instrument_id):
        """
        Return the synthetic instrument corresponding to the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID of the synthetic instrument to return.

        Returns
        -------
        SyntheticInstrument or ``None``

        Raises
        ------
        ValueError
            If `instrument_id` is not a synthetic instrument ID.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(instrument_id.is_synthetic(), "instrument_id was not a synthetic")

        return self._synthetics.get(instrument_id)

    cpdef list synthetic_ids(self):
        """
        Return all synthetic instrument IDs held by the cache.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(self._synthetics.keys())

    cpdef list synthetics(self):
        """
        Return all synthetic instruments held by the cache.

        Returns
        -------
        list[SyntheticInstrument]

        """
        return list(self._synthetics.values())

# -- ACCOUNT QUERIES ------------------------------------------------------------------------------

    cpdef Account account(self, AccountId account_id):
        """
        Return the account matching the given ID (if found).

        Parameters
        ----------
        account_id : AccountId
            The account ID.

        Returns
        -------
        Account or ``None``

        """
        Condition.not_none(account_id, "account_id")

        return self._accounts.get(account_id)

    cpdef Account account_for_venue(self, Venue venue):
        """
        Return the account matching the given client ID (if found).

        If unique_venue is set, it will be used instead of the provided venue.

        Parameters
        ----------
        venue : Venue
            The venue for the account.

        Returns
        -------
        Account or ``None``

        """
        Condition.not_none(venue, "venue")

        # Use unique_venue if it's set
        cdef Venue used_venue = self._specific_venue or venue
        cdef AccountId account_id = self._index_venue_account.get(used_venue)

        if account_id is None:
            return None

        return self._accounts.get(account_id)

    cpdef AccountId account_id(self, Venue venue):
        """
        Return the account ID for the given venue (if found).

        Parameters
        ----------
        venue : Venue
            The venue for the account ID.

        Returns
        -------
        AccountId or ``None``

        """
        Condition.not_none(venue, "venue")

        return self._index_venue_account.get(venue)

    cpdef list accounts(self):
        """
        Return all accounts in the cache.

        Returns
        -------
        list[Account]

        """
        return list(self._accounts.values())

# -- IDENTIFIER QUERIES ---------------------------------------------------------------------------

    cdef set _build_order_query_filter_set(
        self,
        Venue venue,
        InstrumentId instrument_id,
        StrategyId strategy_id,
    ):
        cdef set query = None

        # Build potential query set
        if venue is not None:
            query = self._index_venue_orders.get(venue, set())

        if instrument_id is not None:
            if query is None:
                query = self._index_instrument_orders.get(instrument_id, set())
            else:
                query = query.intersection(self._index_instrument_orders.get(instrument_id, set()))

        if strategy_id is not None:
            if query is None:
                query = self._index_strategy_orders.get(strategy_id, set())
            else:
                query = query.intersection(self._index_strategy_orders.get(strategy_id, set()))

        return query

    cdef set _build_position_query_filter_set(
        self,
        Venue venue,
        InstrumentId instrument_id,
        StrategyId strategy_id,
    ):
        cdef set query = None

        # Build potential query set
        if venue is not None:
            query = self._index_venue_positions.get(venue, set())

        if instrument_id is not None:
            if query is None:
                query = self._index_instrument_positions.get(instrument_id, set())
            else:
                query = query.intersection(self._index_instrument_positions.get(instrument_id, set()))

        if strategy_id is not None:
            if query is None:
                query = self._index_strategy_positions.get(strategy_id, set())
            else:
                query = query.intersection(self._index_strategy_positions.get(strategy_id, set()))

        return query

    cdef list _get_orders_for_ids(self, set client_order_ids, OrderSide side):
        cdef list orders = []

        if not client_order_ids:
            return orders

        cdef:
            ClientOrderId client_order_id
            Order order

        try:
            for client_order_id in sorted(client_order_ids):
                order = self._orders[client_order_id]

                if side == OrderSide.NO_ORDER_SIDE or side == order.side:
                    orders.append(order)
        except KeyError as e:
            self._log.error(f"Cannot find `Order` object in cached orders {e}")

        return orders

    cdef list _get_positions_for_ids(self, set position_ids, PositionSide side):
        cdef list positions = []

        cdef:
            PositionId position_id
            Position position

        try:
            for position_id in sorted(position_ids):
                position = self._positions[position_id]

                if side == PositionSide.NO_POSITION_SIDE or side == position.side:
                    positions.append(position)
        except KeyError as e:
            self._log.error(f"Cannot find `Position` object in cached positions {e}")

        return positions

    cpdef set client_order_ids(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all client order IDs with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        set[ClientOrderId]

        """
        cdef set query = self._build_order_query_filter_set(venue, instrument_id, strategy_id)

        if query is None:
            return self._index_orders
        else:
            return self._index_orders.intersection(query)

    cpdef set client_order_ids_open(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all open client order IDs with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        set[ClientOrderId]

        """
        cdef set query = self._build_order_query_filter_set(venue, instrument_id, strategy_id)

        if query is None:
            return self._index_orders_open
        else:
            return self._index_orders_open.intersection(query)

    cpdef set client_order_ids_closed(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all closed client order IDs with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        set[ClientOrderId]

        """
        cdef set query = self._build_order_query_filter_set(venue, instrument_id, strategy_id)

        if query is None:
            return self._index_orders_closed
        else:
            return self._index_orders_closed.intersection(query)

    cpdef set client_order_ids_emulated(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all emulated client order IDs with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        set[ClientOrderId]

        """
        cdef set query = self._build_order_query_filter_set(venue, instrument_id, strategy_id)

        if query is None:
            return self._index_orders_emulated
        else:
            return self._index_orders_emulated.intersection(query)

    cpdef set client_order_ids_inflight(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all in-flight client order IDs with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        set[ClientOrderId]

        """
        cdef set query = self._build_order_query_filter_set(venue, instrument_id, strategy_id)

        if query is None:
            return self._index_orders_inflight
        else:
            return self._index_orders_inflight.intersection(query)

    cpdef set order_list_ids(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all order list IDs.

        Returns
        -------
        set[OrderListId]

        """
        cdef list order_lists = self.order_lists(venue, instrument_id, strategy_id)
        cdef OrderList ol

        return {ol.id for ol in order_lists}

    cpdef set position_ids(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all position IDs with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        set[PositionId]

        """
        cdef set query = self._build_position_query_filter_set(venue, instrument_id, strategy_id)

        if query is None:
            return self._index_positions
        else:
            return self._index_positions.intersection(query)

    cpdef set position_open_ids(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all open position IDs with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        set[PositionId]

        """
        cdef set query = self._build_position_query_filter_set(venue, instrument_id, strategy_id)

        if query is None:
            return self._index_positions_open
        else:
            return self._index_positions_open.intersection(query)

    cpdef set position_closed_ids(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all closed position IDs with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        set[PositionId]

        """
        cdef set query = self._build_position_query_filter_set(venue, instrument_id, strategy_id)

        if query is None:
            return self._index_positions_closed
        else:
            return self._index_positions_closed.intersection(query)

    cpdef set actor_ids(self):
        """
        Return all actor IDs.

        Returns
        -------
        set[ComponentId]

        """
        return self._index_actors.copy()

    cpdef set strategy_ids(self):
        """
        Return all strategy IDs.

        Returns
        -------
        set[StrategyId]

        """
        return self._index_strategies.copy()

    cpdef set exec_algorithm_ids(self):
        """
        Return all execution algorithm IDs.

        Returns
        -------
        set[ExecAlgorithmId]

        """
        return self._index_exec_algorithms.copy()

# -- ORDER QUERIES --------------------------------------------------------------------------------

    cpdef Order order(self, ClientOrderId client_order_id):
        """
        Return the order matching the given client order ID (if found).

        Returns
        -------
        Order or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        return self._orders.get(client_order_id)

    cpdef ClientOrderId client_order_id(self, VenueOrderId venue_order_id):
        """
        Return the client order ID matching the given venue order ID (if found).

        Parameters
        ----------
        venue_order_id : VenueOrderId
            The venue assigned order ID.

        Returns
        -------
        ClientOrderId or ``None``

        """
        Condition.not_none(venue_order_id, "venue_order_id")

        return self._index_venue_order_ids.get(venue_order_id)

    cpdef VenueOrderId venue_order_id(self, ClientOrderId client_order_id):
        """
        Return the order ID matching the given client order ID (if found).

        Returns
        -------
        VenueOrderId or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        return self._index_client_order_ids.get(client_order_id)

    cpdef ClientId client_id(self, ClientOrderId client_order_id):
        """
        Return the specific execution client ID matching the given client order ID (if found).

        Returns
        -------
        ClientId or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        return self._index_order_client.get(client_order_id)

    cpdef list orders(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return all orders matching the given query filters.

        *No particular order of list elements is guaranteed.*

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        list[Order]

        """
        cdef set client_order_ids = self.client_order_ids(venue, instrument_id, strategy_id)

        return self._get_orders_for_ids(client_order_ids, side)

    cpdef list orders_open(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return all open orders with the given query filters.

        *No particular order of list elements is guaranteed.*

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        list[Order]

        """
        cdef set client_order_ids = self.client_order_ids_open(venue, instrument_id, strategy_id)

        return self._get_orders_for_ids(client_order_ids, side)

    cpdef list orders_closed(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return all closed orders with the given query filters.

        *No particular order of list elements is guaranteed.*

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        list[Order]

        """
        cdef set client_order_ids = self.client_order_ids_closed(venue, instrument_id, strategy_id)

        return self._get_orders_for_ids(client_order_ids, side)

    cpdef list orders_emulated(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return all emulated orders with the given query filters.

        *No particular order of list elements is guaranteed.*

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        list[Order]

        """
        cdef set client_order_ids = self.client_order_ids_emulated(venue, instrument_id, strategy_id)

        return self._get_orders_for_ids(client_order_ids, side)

    cpdef list orders_inflight(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return all in-flight orders with the given query filters.

        *No particular order of list elements is guaranteed.*

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        list[Order]

        """
        cdef set client_order_ids = self.client_order_ids_inflight(venue, instrument_id, strategy_id)

        return self._get_orders_for_ids(client_order_ids, side)

    cpdef list orders_for_position(self, PositionId position_id):
        """
        Return all orders for the given position ID.

        Parameters
        ----------
        position_id : PositionId
            The position ID for the orders.

        Returns
        -------
        list[Order]

        """
        Condition.not_none(position_id, "position_id")

        cdef set client_order_ids = self._index_position_orders.get(position_id)

        if not client_order_ids:
            return []

        return [self._orders[client_order_id] for client_order_id in client_order_ids]

    cpdef bint order_exists(self, ClientOrderId client_order_id):
        """
        Return a value indicating whether an order with the given ID exists.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to check.

        Returns
        -------
        bool

        """
        Condition.not_none(client_order_id, "client_order_id")

        return client_order_id in self._index_orders

    cpdef bint is_order_open(self, ClientOrderId client_order_id):
        """
        Return a value indicating whether an order with the given ID is open.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to check.

        Returns
        -------
        bool

        """
        Condition.not_none(client_order_id, "client_order_id")

        return client_order_id in self._index_orders_open

    cpdef bint is_order_closed(self, ClientOrderId client_order_id):
        """
        Return a value indicating whether an order with the given ID is closed.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to check.

        Returns
        -------
        bool

        """
        Condition.not_none(client_order_id, "client_order_id")

        return client_order_id in self._index_orders_closed

    cpdef bint is_order_emulated(self, ClientOrderId client_order_id):
        """
        Return a value indicating whether an order with the given ID is emulated.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to check.

        Returns
        -------
        bool

        """
        Condition.not_none(client_order_id, "client_order_id")

        return client_order_id in self._index_orders_emulated

    cpdef bint is_order_inflight(self, ClientOrderId client_order_id):
        """
        Return a value indicating whether an order with the given ID is in-flight.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to check.

        Returns
        -------
        bool

        """
        Condition.not_none(client_order_id, "client_order_id")

        return client_order_id in self._index_orders_inflight

    cpdef bint is_order_pending_cancel_local(self, ClientOrderId client_order_id):
        """
        Return a value indicating whether an order with the given ID is pending cancel locally.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to check.

        Returns
        -------
        bool

        """
        Condition.not_none(client_order_id, "client_order_id")

        return client_order_id in self._index_orders_pending_cancel

    cpdef int orders_open_count(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return the count of open orders with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        int

        """
        return len(self.orders_open(venue, instrument_id, strategy_id, side))

    cpdef int orders_closed_count(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return the count of closed orders with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        int

        """
        return len(self.orders_closed(venue, instrument_id, strategy_id, side))

    cpdef int orders_emulated_count(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return the count of emulated orders with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        int

        """
        return len(self.orders_emulated(venue, instrument_id, strategy_id, side))

    cpdef int orders_inflight_count(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return the count of in-flight orders with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        int

        """
        return len(self.orders_inflight(venue, instrument_id, strategy_id, side))

    cpdef int orders_total_count(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return the total count of orders with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        int

        """
        return len(self.orders(venue, instrument_id, strategy_id, side))

# -- ORDER LIST QUERIES ---------------------------------------------------------------------------

    cpdef OrderList order_list(self, OrderListId order_list_id):
        """
        Return the order list matching the given order list ID (if found).

        Returns
        -------
        OrderList or ``None``

        """
        Condition.not_none(order_list_id, "order_list_id")

        return self._order_lists.get(order_list_id)

    cpdef list order_lists(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all order lists matching the given query filters.

        *No particular order of list elements is guaranteed.*

        Returns
        -------
        list[OrderList]

        """
        cdef list order_lists = list(self._order_lists.values())
        cdef OrderList ol

        if venue is not None:
            order_lists = [ol for ol in order_lists if ol.instrument_id.venue == venue]

        if instrument_id is not None:
            order_lists = [ol for ol in order_lists if ol.instrument_id == instrument_id]

        if strategy_id is not None:
            order_lists = [ol for ol in order_lists if ol.strategy_id == strategy_id]

        return order_lists

    cpdef bint order_list_exists(self, OrderListId order_list_id):
        """
        Return a value indicating whether an order list with the given ID exists.

        Parameters
        ----------
        order_list_id : OrderListId
            The order list ID to check.

        Returns
        -------
        bool

        """
        Condition.not_none(order_list_id, "order_list_id")

        return order_list_id in self._order_lists

# -- EXEC ALGORITHM QUERIES -----------------------------------------------------------------------

    cpdef list orders_for_exec_algorithm(
        self,
        ExecAlgorithmId exec_algorithm_id,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        OrderSide side = OrderSide.NO_ORDER_SIDE,
    ):
        """
        Return all execution algorithm orders for the given query filters.

        Parameters
        ----------
        exec_algorithm_id : ExecAlgorithmId
            The execution algorithm ID.
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : OrderSide, default ``NO_ORDER_SIDE`` (no filter)
            The order side query filter.

        Returns
        -------
        list[Order]

        """
        Condition.not_none(exec_algorithm_id, "exec_algorithm_id")

        cdef set query = self._build_order_query_filter_set(venue, instrument_id, strategy_id)
        cdef set exec_algorithm_order_ids = self._index_exec_algorithm_orders.get(exec_algorithm_id)

        if query is not None and exec_algorithm_order_ids is not None:
            exec_algorithm_order_ids = query.intersection(exec_algorithm_order_ids)

        return self._get_orders_for_ids(exec_algorithm_order_ids, side)

    cpdef list orders_for_exec_spawn(self, ClientOrderId exec_spawn_id):
        """
        Return all orders for the given execution spawn ID (if found).

        Will also include the primary (original) order.

        Parameters
        ----------
        exec_spawn_id : ClientOrderId
            The execution algorithm spawning primary (original) client order ID.

        Returns
        -------
        list[Order]

        """
        Condition.not_none(exec_spawn_id, "exec_spawn_id")

        return self._get_orders_for_ids(self._index_exec_spawn_orders.get(exec_spawn_id), OrderSide.NO_ORDER_SIDE)

    cpdef Quantity exec_spawn_total_quantity(self, ClientOrderId exec_spawn_id, bint active_only=False):
        """
        Return the total quantity for the given execution spawn ID (if found).

        If no execution spawn ID matches then returns ``None``.

        Parameters
        ----------
        exec_spawn_id : ClientOrderId
            The execution algorithm spawning primary (original) client order ID.
        active_only : bool, default False
            The flag to filter for active execution spawn orders only.

        Returns
        -------
        Quantity or ``None``

        Notes
        -----
        An "active" order is defined as one which is *not closed*.

        """
        Condition.not_none(exec_spawn_id, "exec_spawn_id")

        cdef list exec_spawn_orders = self.orders_for_exec_spawn(exec_spawn_id)

        if not exec_spawn_orders:
            return None

        cdef:
            Order spawn_order
            uint8_t precision = 0
            uint64_t raw_total_quantity = 0
        for spawn_order in exec_spawn_orders:
            precision = spawn_order.quantity._mem.precision

            if not active_only or not spawn_order.is_closed_c():
                raw_total_quantity += spawn_order.quantity._mem.raw

        return Quantity.from_raw_c(raw_total_quantity, precision)

    cpdef Quantity exec_spawn_total_filled_qty(self, ClientOrderId exec_spawn_id, bint active_only=False):
        """
        Return the total filled quantity for the given execution spawn ID (if found).

        If no execution spawn ID matches then returns ``None``.

        Parameters
        ----------
        exec_spawn_id : ClientOrderId
            The execution algorithm spawning primary (original) client order ID.
        active_only : bool, default False
            The flag to filter for active execution spawn orders only.

        Returns
        -------
        Quantity or ``None``

        Notes
        -----
        An "active" order is defined as one which is *not closed*.

        """
        Condition.not_none(exec_spawn_id, "exec_spawn_id")

        cdef list exec_spawn_orders = self.orders_for_exec_spawn(exec_spawn_id)

        if not exec_spawn_orders:
            return None

        cdef:
            Order spawn_order
            uint8_t precision = 0
            uint64_t raw_filled_qty = 0
        for spawn_order in exec_spawn_orders:
            precision = spawn_order.filled_qty._mem.precision

            if not active_only or not spawn_order.is_closed_c():
                raw_filled_qty += spawn_order.filled_qty._mem.raw

        return Quantity.from_raw_c(raw_filled_qty, precision)

    cpdef Quantity exec_spawn_total_leaves_qty(self, ClientOrderId exec_spawn_id, bint active_only=False):
        """
        Return the total leaves quantity for the given execution spawn ID (if found).

        If no execution spawn ID matches then returns ``None``.

        Parameters
        ----------
        exec_spawn_id : ClientOrderId
            The execution algorithm spawning primary (original) client order ID.
        active_only : bool, default False
            The flag to filter for active execution spawn orders only.

        Returns
        -------
        Quantity or ``None``

        Notes
        -----
        An "active" order is defined as one which is *not closed*.

        """
        Condition.not_none(exec_spawn_id, "exec_spawn_id")

        cdef list exec_spawn_orders = self.orders_for_exec_spawn(exec_spawn_id)

        if not exec_spawn_orders:
            return None

        cdef:
            Order spawn_order
            uint8_t precision = 0
            uint64_t raw_leaves_qty = 0
        for spawn_order in exec_spawn_orders:
            precision = spawn_order.leaves_qty._mem.precision

            if not active_only or not spawn_order.is_closed_c():
                raw_leaves_qty += spawn_order.leaves_qty._mem.raw

        return Quantity.from_raw_c(raw_leaves_qty, precision)

# -- POSITION QUERIES -----------------------------------------------------------------------------

    cpdef Position position(self, PositionId position_id):
        """
        Return the position associated with the given ID (if found).

        Parameters
        ----------
        position_id : PositionId
            The position ID.

        Returns
        -------
        Position or ``None``

        """
        Condition.not_none(position_id, "position_id")

        return self._positions.get(position_id)

    cpdef Position position_for_order(self, ClientOrderId client_order_id):
        """
        Return the position associated with the given client order ID (if found).

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID.

        Returns
        -------
        Position or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        cdef PositionId position_id = self._index_order_position.get(client_order_id)

        if position_id is None:
            return None

        return self._positions.get(position_id)

    cpdef PositionId position_id(self, ClientOrderId client_order_id):
        """
        Return the position ID associated with the given client order ID (if found).

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID associated with the position.

        Returns
        -------
        PositionId or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        return self._index_order_position.get(client_order_id)

    cpdef list position_snapshots(self, PositionId position_id = None):
        """
        Return all position snapshots with the given optional identifier filter.

        Parameters
        ----------
        position_id : PositionId, optional
            The position ID query filter.

        Returns
        -------
        list[Position]

        """
        cdef list snapshot_list
        cdef list snapshots

        if position_id is not None:
            snapshots = self._position_snapshots.get(position_id, [])
        else:
            snapshots = []

            for snapshot_list in self._position_snapshots.values():
                snapshots += snapshot_list

        cdef bytes s

        return [pickle.loads(s) for s in snapshots]

    cpdef set position_snapshot_ids(self, InstrumentId instrument_id = None):
        """
        Return all position IDs for position snapshots with the given instrument filter.

        Parameters
        ----------
        instrument_id : InstrumentId, optional
            The instrument ID query filter.

        Returns
        -------
        set[PositionId]

        """
        if instrument_id is not None:
            return self._index_instrument_position_snapshots.get(instrument_id, set())
        else:
            # Return all position IDs that have snapshots
            return set(self._position_snapshots.keys())

    cpdef list position_snapshot_bytes(self, PositionId position_id):
        """
        Return the raw pickled snapshot bytes for the given position ID.

        Parameters
        ----------
        position_id : PositionId
            The position ID to get snapshot bytes for.

        Returns
        -------
        list[bytes]
            The list of pickled snapshot bytes, or empty list if no snapshots exist.

        """
        Condition.not_none(position_id, "position_id")
        return self._position_snapshots.get(position_id, [])

    cpdef list positions(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        PositionSide side = PositionSide.NO_POSITION_SIDE,
    ):
        """
        Return all positions with the given query filters.

        *No particular order of list elements is guaranteed.*

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : PositionSide, default ``NO_POSITION_SIDE`` (no filter)
            The position side query filter.

        Returns
        -------
        list[Position]

        """
        cdef set position_ids = self.position_ids(venue, instrument_id, strategy_id)

        return self._get_positions_for_ids(position_ids, side)

    cpdef list positions_open(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        PositionSide side = PositionSide.NO_POSITION_SIDE,
    ):
        """
        Return all open positions with the given query filters.

        *No particular order of list elements is guaranteed.*

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : PositionSide, default ``NO_POSITION_SIDE`` (no filter)
            The position side query filter.

        Returns
        -------
        list[Position]

        """
        cdef set position_ids = self.position_open_ids(venue, instrument_id, strategy_id)

        return self._get_positions_for_ids(position_ids, side)

    cpdef list positions_closed(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return all closed positions with the given query filters.

        *No particular order of list elements is guaranteed.*

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        list[Position]

        """
        cdef set position_ids = self.position_closed_ids(venue, instrument_id, strategy_id)

        return self._get_positions_for_ids(position_ids, PositionSide.NO_POSITION_SIDE)

    cpdef bint position_exists(self, PositionId position_id):
        """
        Return a value indicating whether a position with the given ID exists.

        Parameters
        ----------
        position_id : PositionId
            The position ID.

        Returns
        -------
        int

        """
        Condition.not_none(position_id, "position_id")

        return position_id in self._index_positions

    cpdef bint is_position_open(self, PositionId position_id):
        """
        Return a value indicating whether a position with the given ID exists
        and is open.

        Parameters
        ----------
        position_id : PositionId
            The position ID.

        Returns
        -------
        bool

        """
        Condition.not_none(position_id, "position_id")

        return position_id in self._index_positions_open

    cpdef bint is_position_closed(self, PositionId position_id):
        """
        Return a value indicating whether a position with the given ID exists
        and is closed.

        Parameters
        ----------
        position_id : PositionId
            The position ID.

        Returns
        -------
        bool

        """
        Condition.not_none(position_id, "position_id")

        return position_id in self._index_positions_closed

    cpdef int positions_open_count(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        PositionSide side = PositionSide.NO_POSITION_SIDE,
    ):
        """
        Return the count of open positions with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : PositionSide, default ``NO_POSITION_SIDE`` (no filter)
            The position side query filter.

        Returns
        -------
        int

        """
        return len(self.positions_open(venue, instrument_id, strategy_id, side))

    cpdef int positions_closed_count(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
    ):
        """
        Return the count of closed positions with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.

        Returns
        -------
        int

        """
        return len(self.positions_closed(venue, instrument_id, strategy_id))

    cpdef int positions_total_count(
        self,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        PositionSide side = PositionSide.NO_POSITION_SIDE,
    ):
        """
        Return the total count of positions with the given query filters.

        Parameters
        ----------
        venue : Venue, optional
            The venue ID query filter.
        instrument_id : InstrumentId, optional
            The instrument ID query filter.
        strategy_id : StrategyId, optional
            The strategy ID query filter.
        side : PositionSide, default ``NO_POSITION_SIDE`` (no filter)
            The position side query filter.

        Returns
        -------
        int

        """
        return len(self.positions(venue, instrument_id, strategy_id, side))

# -- STRATEGY QUERIES -----------------------------------------------------------------------------

    cpdef StrategyId strategy_id_for_order(self, ClientOrderId client_order_id):
        """
        Return the strategy ID associated with the given ID (if found).

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID associated with the strategy.

        Returns
        -------
        StrategyId or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        return self._index_order_strategy.get(client_order_id)

    cpdef StrategyId strategy_id_for_position(self, PositionId position_id):
        """
        Return the strategy ID associated with the given ID (if found).

        Parameters
        ----------
        position_id : PositionId
            The position ID associated with the strategy.

        Returns
        -------
        StrategyId or ``None``

        """
        Condition.not_none(position_id, "position_id")

        return self._index_position_strategy.get(position_id)

    cpdef void heartbeat(self, datetime timestamp):
        """
        Add a heartbeat at the given `timestamp`.

        Parameters
        ----------
        timestamp : datetime
            The timestamp for the heartbeat.

        """
        Condition.not_none(timestamp, "timestamp")

        if self._database is None:
            self._log.warning(f"Cannot set heartbeat {timestamp} (no database configured)")
            return

        self._database.heartbeat(timestamp)

    cpdef void force_remove_from_own_order_book(self, ClientOrderId client_order_id):
        """
        Force removal of an order from own order books and clean up all indexes.

        This method is used when order.apply() fails and we need to ensure terminal
        orders are properly cleaned up from own books and all relevant indexes.
        Replicates the index cleanup that update_order performs for closed orders.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to remove.

        """
        Condition.not_none(client_order_id, "client_order_id")

        cdef Order order = self._orders.get(client_order_id)
        if order is None:
            return

        # Remove from all open/active indexes (mirrors update_order for closed orders)
        self._index_orders_open.discard(client_order_id)
        self._index_orders_pending_cancel.discard(client_order_id)
        self._index_orders_inflight.discard(client_order_id)
        self._index_orders_emulated.discard(client_order_id)

        if self._own_order_books:
            self._index_orders_open_pyo3.discard(nautilus_pyo3.ClientOrderId(client_order_id.value))

            own_book = self._own_order_books.get(order.instrument_id)
            if own_book is not None:
                try:
                    own_book_order = order.to_own_book_order()
                    own_book.delete(own_book_order)
                    self._log.debug(
                        f"Force deleted {client_order_id!r} from own book",
                        LogColor.MAGENTA,
                    )
                except Exception as e:
                    self._log.debug(
                        f"Could not force delete {client_order_id!r} from own book: {e}",
                        LogColor.MAGENTA,
                    )

        self._index_orders_closed.add(client_order_id)

    cpdef void audit_own_order_books(self):
        """
        Audit all own order books against open and inflight order indexes.

        Ensures closed orders are removed from own order books. This includes both
        orders tracked in _index_orders_open (ACCEPTED, TRIGGERED, PENDING_*, PARTIALLY_FILLED)
        and _index_orders_inflight (INITIALIZED, SUBMITTED) to prevent false positives
        during venue latency windows.

        Logs all failures as errors.

        """
        self._log.debug("Starting own books audit", LogColor.MAGENTA)
        cdef double start_us = time.time() * 1_000_000

        # Build union of open and inflight orders for audit,
        # this prevents false positives for SUBMITTED orders during venue latency.
        cdef set valid_order_ids = set()
        for client_order_id in self._index_orders_open:
            if self._own_order_books:
                valid_order_ids.add(nautilus_pyo3.ClientOrderId(client_order_id.value))

        for client_order_id in self._index_orders_inflight:
            if self._own_order_books:
                valid_order_ids.add(nautilus_pyo3.ClientOrderId(client_order_id.value))

        for own_book in self._own_order_books.values():
            own_book.audit_open_orders(valid_order_ids)

        cdef double audit_us = (time.time() * 1_000_000) - start_us
        self._log.debug(f"Completed own books audit in {int(audit_us)}us", LogColor.MAGENTA)


cdef inline dict[Decimal, list[Order]] process_own_order_map(
    dict[Decimal, list[nautilus_pyo3.OwnBookOrder]] own_order_map,
    dict[ClientOrderId, Order] order_cache,
):
    cdef dict[Decimal, Order] order_map = {}

    cdef:
        list[Order] orders = []
        ClientOrderId client_order_id
        Order order
    for level_price, own_orders in own_order_map.items():
        orders = []

        for own_order in own_orders:
            client_order_id = ClientOrderId(own_order.client_order_id.value)
            order = order_cache.get(client_order_id)

            if order is None:
                raise RuntimeError(f"{client_order_id!r} from own book not found in cache")

            orders.append(order)

        order_map[level_price] = orders

    return order_map

</document_content>
</document>
<document index="2237">
<source>nautilus_trader/cache/database.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import msgspec

from nautilus_trader.cache.config import CacheConfig
from nautilus_trader.cache.transformers import transform_account_from_pyo3
from nautilus_trader.cache.transformers import transform_currency_from_pyo3
from nautilus_trader.cache.transformers import transform_instrument_from_pyo3
from nautilus_trader.cache.transformers import transform_order_from_pyo3
from nautilus_trader.common.config import msgspec_encoding_hook
from nautilus_trader.core import nautilus_pyo3

from cpython.datetime cimport datetime
from libc.stdint cimport uint64_t

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.accounting.factory cimport AccountFactory
from nautilus_trader.cache.facade cimport CacheDatabaseFacade
from nautilus_trader.common.actor cimport Actor
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.rust.common cimport LogColor
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.events.order cimport OrderEvent
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.functions cimport currency_type_from_str
from nautilus_trader.model.functions cimport currency_type_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ComponentId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.identifiers cimport VenueOrderId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.limit cimport LimitOrder
from nautilus_trader.model.orders.market cimport MarketOrder
from nautilus_trader.model.orders.unpacker cimport OrderUnpacker
from nautilus_trader.model.position cimport Position
from nautilus_trader.serialization.base cimport Serializer
from nautilus_trader.trading.strategy cimport Strategy


cdef str _UTF8 = "utf-8"
cdef str _GENERAL = "general"
cdef str _CURRENCIES = "currencies"
cdef str _INSTRUMENTS = "instruments"
cdef str _SYNTHETICS = "synthetics"
cdef str _ACCOUNTS = "accounts"
cdef str _TRADER = "trader"
cdef str _ORDERS = "orders"
cdef str _POSITIONS = "positions"
cdef str _ACTORS = "actors"
cdef str _STRATEGIES = "strategies"

cdef str _INDEX_ORDER_IDS = "index:order_ids"
cdef str _INDEX_ORDER_POSITION = "index:order_position"
cdef str _INDEX_ORDER_CLIENT = "index:order_client"
cdef str _INDEX_ORDERS = "index:orders"
cdef str _INDEX_ORDERS_OPEN = "index:orders_open"
cdef str _INDEX_ORDERS_CLOSED = "index:orders_closed"
cdef str _INDEX_ORDERS_EMULATED = "index:orders_emulated"
cdef str _INDEX_ORDERS_INFLIGHT = "index:orders_inflight"
cdef str _INDEX_POSITIONS = "index:positions"
cdef str _INDEX_POSITIONS_OPEN = "index:positions_open"
cdef str _INDEX_POSITIONS_CLOSED = "index:positions_closed"

cdef str _SNAPSHOTS_ORDERS = "snapshots:orders"
cdef str _SNAPSHOTS_POSITIONS = "snapshots:positions"
cdef str _HEARTBEAT = "health:heartbeat"


cdef class CacheDatabaseAdapter(CacheDatabaseFacade):
    """
    Provides a generic cache database adapter.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the adapter.
    instance_id : UUID4
        The instance ID for the adapter.
    serializer : Serializer
        The serializer for database operations.
    config : CacheConfig, optional
        The configuration for the instance.

    Raises
    ------
    TypeError
        If `config` is not of type `CacheConfig`.

    Warnings
    --------
    Redis can only accurately store int64 types to 17 digits of precision.
    Therefore nanosecond timestamp int64's with 19 digits will lose 2 digits of
    precision when persisted. One way to solve this is to ensure the serializer
    converts timestamp int64's to strings on the way into Redis, and converts
    timestamp strings back to int64's on the way out. One way to achieve this is
    to set the `timestamps_as_str` flag to true for the `MsgSpecSerializer`, as
    per the default implementations for both `TradingNode` and `BacktestEngine`.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        UUID4 instance_id not None,
        Serializer serializer not None,
        config: CacheConfig | None = None,
    ) -> None:
        if config is None:
            config = CacheConfig()
        Condition.type(config, CacheConfig, "config")
        super().__init__(config)

        # Validate configuration
        if config.buffer_interval_ms and config.buffer_interval_ms > 1000:
            self._log.warning(
                f"High `buffer_interval_ms` at {config.buffer_interval_ms}, "
                "recommended range is [10, 1000] milliseconds",
            )

        # Configuration
        self._log.info(f"{config.database=}", LogColor.BLUE)
        self._log.info(f"{config.encoding=}", LogColor.BLUE)
        self._log.info(f"{config.timestamps_as_iso8601=}", LogColor.BLUE)
        self._log.info(f"{config.buffer_interval_ms=}", LogColor.BLUE)
        self._log.info(f"{config.flush_on_start=}", LogColor.BLUE)
        self._log.info(f"{config.use_trader_prefix=}", LogColor.BLUE)
        self._log.info(f"{config.use_instance_id=}", LogColor.BLUE)

        self._serializer = serializer

        self._backing = nautilus_pyo3.RedisCacheDatabase(
            trader_id=nautilus_pyo3.TraderId(trader_id.value),
            instance_id=nautilus_pyo3.UUID4.from_str(instance_id.value),
            config_json=msgspec.json.encode(config, enc_hook=msgspec_encoding_hook),
        )

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void close(self):
        """
        Close the backing database adapter.

        """
        self._log.debug("Closing cache database adapter")
        self._backing.close()
        self._log.info("Closed cache database adapter")

    cpdef void flush(self):
        """
        Flush the database which clears all data.

        """
        self._log.debug("Flushing cache database")
        self._backing.flushdb()
        self._log.info("Flushed cache database", LogColor.BLUE)

    cpdef list[str] keys(self, str pattern = "*"):
        """
        Return all keys in the database matching the given `pattern`.

        Parameters
        ----------
        pattern : str, default '*'
            The glob-style pattern to match against the keys in the database.

        Returns
        -------
        list[str]

        Raises
        ------
        ValueError
            If `pattern` is not a valid string.

        Warnings
        --------
        Using the default '*' pattern string can have serious performance implications and
        can take a long time to execute if many keys exist in the database. This operation
        can lead to high memory and CPU usage, and should be used with caution, especially
        in production environments.

        """
        Condition.valid_string(pattern, "pattern")

        return self._backing.keys(pattern)

    cpdef dict load_all(self):
        """
        Load all cache data from the database.

        Returns
        -------
        dict[str, dict]
            A dictionary containing all cache data organized by category.

        """
        cdef dict raw_data = self._backing.load_all()
        cdef dict result = {}

        cdef dict currencies_dict = raw_data.get("currencies", {})
        cdef dict instruments_dict = raw_data.get("instruments", {})
        cdef dict synthetics_dict = raw_data.get("synthetics", {})
        cdef dict accounts_dict = raw_data.get("accounts", {})
        cdef dict orders_dict = raw_data.get("orders", {})
        cdef dict positions_dict = raw_data.get("positions", {})

        result["currencies"] = {
            key: transform_currency_from_pyo3(value) for key, value in currencies_dict.items()
        }
        result["instruments"] = {
            key: transform_instrument_from_pyo3(value) for key, value in instruments_dict.items()
        }
        result["synthetics"] = synthetics_dict
        result["accounts"] = {
            key: transform_account_from_pyo3(value) for key, value in accounts_dict.items()
        }
        result["orders"] = {
            key: transform_order_from_pyo3(value) for key, value in orders_dict.items()
        }
        result["positions"] = positions_dict

        return result

    cpdef dict load(self):
        """
        Load all general objects from the database using bulk loading for efficiency.

        Returns
        -------
        dict[str, bytes]

        """
        cdef dict general = {}
        cdef list general_keys = self._backing.keys(f"{_GENERAL}:*")

        if not general_keys:
            return general

        # Use bulk loading for efficiency
        cdef list bulk_results = self._backing.read_bulk(general_keys)

        cdef bytes value_bytes
        cdef str key
        cdef str clean_key
        cdef int idx

        for idx in range(len(general_keys)):
            key = general_keys[idx]
            # Extract the clean key (remove trader_key prefix and general prefix)
            clean_key = key.split(':', maxsplit=1)[1]  # Remove trader_key prefix
            clean_key = clean_key.split(':', maxsplit=1)[1]  # Remove general prefix

            if idx < len(bulk_results) and bulk_results[idx] is not None:
                value_bytes = bulk_results[idx]
                general[clean_key] = value_bytes

        return general

    cpdef dict load_currencies(self):
        """
        Load all currencies from the database using bulk loading for efficiency.

        Returns
        -------
        dict[str, Currency]

        """
        cdef dict currencies = {}
        cdef list currency_keys = self._backing.keys(f"{_CURRENCIES}*")

        if not currency_keys:
            return currencies

        cdef list currency_codes = []
        cdef str key
        cdef str currency_code

        for key in currency_keys:
            currency_code = key.rsplit(':', maxsplit=1)[1]
            currency_codes.append(currency_code)

        cdef list bulk_results = self._backing.read_bulk(currency_keys)

        cdef bytes value_bytes
        cdef Currency currency
        cdef int idx
        cdef dict c_map

        for idx in range(len(currency_codes)):
            currency_code = currency_codes[idx]

            if idx < len(bulk_results) and bulk_results[idx] is not None:
                value_bytes = bulk_results[idx]
                try:
                    c_map = self._serializer.deserialize(value_bytes)
                    currency = Currency(
                        code=currency_code,
                        precision=int(c_map["precision"]),
                        iso4217=int(c_map["iso4217"]),
                        name=c_map["name"],
                        currency_type=currency_type_from_str(c_map["currency_type"]),
                    )
                    currencies[currency.code] = currency
                except Exception as e:
                    self._log.error(f"Failed to deserialize currency {currency_code}: {e}")

        return currencies

    cpdef dict load_instruments(self):
        """
        Load all instruments from the database using bulk loading for efficiency.

        Returns
        -------
        dict[InstrumentId, Instrument]

        """
        cdef dict instruments = {}
        cdef list instrument_keys = self._backing.keys(f"{_INSTRUMENTS}*")

        if not instrument_keys:
            return instruments

        # Use bulk loading for efficiency
        cdef list bulk_results = self._backing.read_bulk(instrument_keys)

        cdef:
            str key
            InstrumentId instrument_id
            Instrument instrument
            bytes instrument_bytes
            int idx

        for idx in range(len(instrument_keys)):
            key = instrument_keys[idx]
            instrument_id = InstrumentId.from_str_c(key.rsplit(':', maxsplit=1)[1])

            if idx < len(bulk_results) and bulk_results[idx] is not None:
                instrument_bytes = bulk_results[idx]
                try:
                    instrument = self._serializer.deserialize(instrument_bytes)
                    instruments[instrument.id] = instrument
                except Exception as e:
                    self._log.error(f"Failed to deserialize instrument {instrument_id}: {e}")

        return instruments

    cpdef dict load_synthetics(self):
        """
        Load all synthetic instruments from the database using bulk loading for efficiency.

        Returns
        -------
        dict[InstrumentId, SyntheticInstrument]

        """
        cdef dict synthetics = {}
        cdef list synthetic_keys = self._backing.keys(f"{_SYNTHETICS}*")

        if not synthetic_keys:
            return synthetics

        # Use bulk loading for efficiency
        cdef list bulk_results = self._backing.read_bulk(synthetic_keys)

        cdef:
            str key
            InstrumentId instrument_id
            SyntheticInstrument synthetic
            bytes synthetic_bytes
            int idx

        for idx in range(len(synthetic_keys)):
            key = synthetic_keys[idx]
            instrument_id = InstrumentId.from_str_c(key.rsplit(':', maxsplit=1)[1])

            if idx < len(bulk_results) and bulk_results[idx] is not None:
                synthetic_bytes = bulk_results[idx]
                try:
                    synthetic = self._serializer.deserialize(synthetic_bytes)
                    synthetics[synthetic.id] = synthetic
                except Exception as e:
                    self._log.error(f"Failed to deserialize synthetic {instrument_id}: {e}")

        return synthetics

    cpdef dict load_accounts(self):
        """
        Load all accounts from the database.

        Returns
        -------
        dict[AccountId, Account]

        """
        cdef dict accounts = {}
        cdef list account_keys = self._backing.keys(f"{_ACCOUNTS}*")

        if not account_keys:
            return accounts

        cdef:
            str key
            AccountId account_id
            Account account
        for key in account_keys:
            account_id = AccountId(key.rsplit(':', maxsplit=1)[1])
            account = self.load_account(account_id)

            if account is not None:
                accounts[account.id] = account

        return accounts

    cpdef dict load_orders(self):
        """
        Load all orders from the database.

        Returns
        -------
        dict[ClientOrderId, Order]

        """
        cdef dict orders = {}
        cdef list order_keys = self._backing.keys(f"{_ORDERS}*")

        if not order_keys:
            return orders

        cdef:
            str key
            ClientOrderId client_order_id
            Order order
        for key in order_keys:
            client_order_id = ClientOrderId(key.rsplit(':', maxsplit=1)[1])
            order = self.load_order(client_order_id)

            if order is not None:
                orders[order.client_order_id] = order

        return orders

    cpdef dict load_positions(self):
        """
        Load all positions from the database.

        Returns
        -------
        dict[PositionId, Position]

        """
        cdef dict positions = {}
        cdef list position_keys = self._backing.keys(f"{_POSITIONS}*")

        if not position_keys:
            return positions

        cdef:
            str key
            PositionId position_id
            Position position
        for key in position_keys:
            position_id = PositionId(key.rsplit(':', maxsplit=1)[1])
            position = self.load_position(position_id)

            if position is not None:
                positions[position.id] = position

        return positions

    cpdef dict load_index_order_position(self):
        """
        Load the order to position index from the database.

        Returns
        -------
        dict[ClientOrderId, PositionId]

        """
        cdef list result = self._backing.read(_INDEX_ORDER_POSITION)
        if not result:
            return {}

        cdef dict raw_index = msgspec.json.decode(result[0])
        return {ClientOrderId(k): PositionId(v) for k, v in raw_index.items()}

    cpdef dict load_index_order_client(self):
        """
        Load the order to execution client index from the database.

        Returns
        -------
        dict[ClientOrderId, ClientId]

        """
        cdef list result = self._backing.read(_INDEX_ORDER_CLIENT)
        if not result:
            return {}

        cdef dict raw_index = msgspec.json.decode(result[0])
        return {ClientOrderId(k): ClientId(v) for k, v in raw_index.items()}

    cpdef Currency load_currency(self, str code):
        """
        Load the currency associated with the given currency code (if found).

        Parameters
        ----------
        code : str
            The currency code to load.

        Returns
        -------
        Currency or ``None``

        """
        Condition.not_none(code, "code")

        cdef str key = f"{_CURRENCIES}:{code}"
        cdef list result = self._backing.read(key)

        if not result:
            return None

        cdef dict c_map = self._serializer.deserialize(result[0])

        return Currency(
            code=code,
            precision=int(c_map["precision"]),
            iso4217=int(c_map["iso4217"]),
            name=c_map["name"],
            currency_type=currency_type_from_str(c_map["currency_type"]),
        )

    cpdef Instrument load_instrument(self, InstrumentId instrument_id):
        """
        Load the instrument associated with the given instrument ID
        (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID to load.

        Returns
        -------
        Instrument or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef str key = f"{_INSTRUMENTS}:{instrument_id.to_str()}"
        cdef list result = self._backing.read(key)
        if not result:
            return None

        cdef bytes instrument_bytes = result[0]

        return self._serializer.deserialize(instrument_bytes)

    cpdef SyntheticInstrument load_synthetic(self, InstrumentId instrument_id):
        """
        Load the synthetic instrument associated with the given synthetic instrument ID
        (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The synthetic instrument ID to load.

        Returns
        -------
        SyntheticInstrument or ``None``

        Raises
        ------
        ValueError
            If `instrument_id` is not for a synthetic instrument.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(instrument_id.is_synthetic(), "instrument_id was not for a synthetic instrument")

        cdef str key = f"{_SYNTHETICS}:{instrument_id.to_str()}"
        cdef list result = self._backing.read(key)
        if not result:
            return None

        cdef bytes synthetic_bytes = result[0]

        return self._serializer.deserialize(synthetic_bytes)

    cpdef Account load_account(self, AccountId account_id):
        """
        Load the account associated with the given account ID (if found).

        Parameters
        ----------
        account_id : AccountId
            The account ID to load.

        Returns
        -------
        Account or ``None``

        """
        Condition.not_none(account_id, "account_id")

        cdef str key = f"{_ACCOUNTS}:{account_id.to_str()}"
        cdef list result = self._backing.read(key)
        if not result:
            return None

        cdef bytes initial_event = result.pop(0)
        cdef Account account = AccountFactory.create_c(self._serializer.deserialize(initial_event))

        cdef bytes event
        for event in result:
            account.apply(event=self._serializer.deserialize(event))

        return account

    cpdef Order load_order(self, ClientOrderId client_order_id):
        """
        Load the order associated with the given client order ID (if found).

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to load.

        Returns
        -------
        Order or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        cdef str key = f"{_ORDERS}:{client_order_id.to_str()}"
        cdef list result = self._backing.read(key)

        # Check there is at least one event to pop
        if not result:
            return None

        cdef OrderInitialized init = self._serializer.deserialize(result.pop(0))
        cdef Order order = OrderUnpacker.from_init_c(init)

        cdef int event_count = 0
        cdef bytes event_bytes
        cdef OrderEvent event
        for event_bytes in result:
            try:
                event = self._serializer.deserialize(event_bytes)
            except ValueError as e:
                raise RuntimeError(f"Error deserializing event for {client_order_id!r}: {e!r}") from e

            # Check event integrity
            if event in order._events:
                raise RuntimeError(f"Corrupt cache with duplicate event for order {event}")

            if event_count > 0 and isinstance(event, OrderInitialized):
                if event.order_type == OrderType.MARKET:
                    order = MarketOrder.transform(order, event.ts_init)
                elif event.order_type == OrderType.LIMIT:
                    price = Price.from_str_c(event.options["price"])
                    order = LimitOrder.transform(order, event.ts_init, price)
                else:
                    raise RuntimeError(  # pragma: no cover (design-time error)
                        f"Cannot transform order to {order_type_to_str(event.order_type)}",  # pragma: no cover (design-time error)
                    )
            else:
                order.apply(event)
            event_count += 1

        return order

    cpdef Position load_position(self, PositionId position_id):
        """
        Load the position associated with the given ID (if found).

        Parameters
        ----------
        position_id : PositionId
            The position ID to load.

        Returns
        -------
        Position or ``None``

        """
        Condition.not_none(position_id, "position_id")

        cdef str key = f"{_POSITIONS}:{position_id.to_str()}"
        cdef list result = self._backing.read(key)

        # Check there is at least one event to pop
        if not result:
            return None

        cdef OrderFilled initial_fill = self._serializer.deserialize(result.pop(0))
        cdef Instrument instrument = self.load_instrument(initial_fill.instrument_id)
        if instrument is None:
            self._log.error(
                f"Cannot load position: "
                f"no instrument found for {initial_fill.instrument_id}",
            )
            return

        cdef Position position = Position(instrument, initial_fill)

        cdef:
            bytes event_bytes
            OrderFilled fill
        for event_bytes in result:
            event = self._serializer.deserialize(event_bytes)

            # Check event integrity
            if event in position._events:
                raise RuntimeError(f"Corrupt cache with duplicate event for position {event}")

            position.apply(event)

        return position

    cpdef dict load_actor(self, ComponentId component_id):
        """
        Load the state for the given actor.

        Parameters
        ----------
        component_id : ComponentId
            The ID of the actor state dictionary to load.

        Returns
        -------
        dict[str, Any]

        """
        Condition.not_none(component_id, "component_id")

        cdef str key = f"{_ACTORS}:{component_id.to_str()}:state"
        cdef list result = self._backing.read(key)
        if not result:
            return {}

        return self._serializer.deserialize(result[0])

    cpdef void delete_actor(self, ComponentId component_id):
        """
        Delete the given actor from the database.

        Parameters
        ----------
        component_id : ComponentId
            The ID of the actor state dictionary to delete.

        """
        Condition.not_none(component_id, "component_id")

        cdef str key = f"{_ACTORS}:{component_id.to_str()}:state"
        self._backing.delete(key)

        self._log.debug(f"Deleted {repr(component_id)}")

    cpdef dict load_strategy(self, StrategyId strategy_id):
        """
        Load the state for the given strategy.

        Parameters
        ----------
        strategy_id : StrategyId
            The ID of the strategy state dictionary to load.

        Returns
        -------
        dict[str, bytes]

        """
        Condition.not_none(strategy_id, "strategy_id")

        cdef str key = f"{_STRATEGIES}:{strategy_id.to_str()}:state"
        cdef list result = self._backing.read(key)
        if not result:
            return {}

        return self._serializer.deserialize(result[0])

    cpdef void delete_strategy(self, StrategyId strategy_id):
        """
        Delete the given strategy from the database.

        Parameters
        ----------
        strategy_id : StrategyId
            The ID of the strategy state dictionary to delete.

        """
        Condition.not_none(strategy_id, "strategy_id")

        cdef str key = f"{_STRATEGIES}:{strategy_id.to_str()}:state"
        self._backing.delete(key)

        self._log.debug(f"Deleted {repr(strategy_id)}")

    cpdef void delete_order(self, ClientOrderId client_order_id):
        """
        Delete the given order from the database.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to delete.

        """
        Condition.not_none(client_order_id, "client_order_id")

        self._backing.delete_order(client_order_id.to_str())

        self._log.debug(f"Deleted order {repr(client_order_id)}")

    cpdef void delete_position(self, PositionId position_id):
        """
        Delete the given position from the database.

        Parameters
        ----------
        position_id : PositionId
            The position ID to delete.

        """
        Condition.not_none(position_id, "position_id")

        self._backing.delete_position(position_id.to_str())

        self._log.debug(f"Deleted position {repr(position_id)}")

    cpdef void delete_account_event(self, AccountId account_id, str event_id):
        """
        Delete the given account event from the database.

        Parameters
        ----------
        account_id : AccountId
            The account ID to delete events for.
        event_id : str
            The event ID to delete.

        """
        Condition.not_none(account_id, "account_id")
        Condition.not_none(event_id, "event_id")

        self._log.warning(f"Deleting account events currently a no-op (pending redesign), {repr(account_id)}: {event_id}")

        # TODO: No-op pending reimplementation to improve efficiency
        # self._backing.delete_account_event(account_id.to_str(), event_id)
        #
        # self._log.info(f"Deleted account event {repr(account_id)}:{event_id}")

    cpdef void add(self, str key, bytes value):
        """
        Add the given general object value to the database.

        Parameters
        ----------
        key : str
            The key to write to.
        value : bytes
            The object value.

        """
        Condition.not_none(key, "key")
        Condition.not_none(value, "value")

        self._backing.insert(f"{_GENERAL}:{key}", [value])
        self._log.debug(f"Added general object {key}")

    cpdef void add_currency(self, Currency currency):
        """
        Add the given currency to the database.

        Parameters
        ----------
        currency : Currency
            The currency to add.

        """
        Condition.not_none(currency, "currency")

        cdef dict currency_map = {
            "precision": currency.precision,
            "iso4217": currency.iso4217,
            "name": currency.name,
            "currency_type": currency_type_to_str(currency.currency_type)
        }

        cdef key = f"{_CURRENCIES}:{currency.code}"
        cdef list payload = [self._serializer.serialize(currency_map)]
        self._backing.insert(key, payload)

        self._log.debug(f"Added currency {currency.code}")

    cpdef void add_instrument(self, Instrument instrument):
        """
        Add the given instrument to the database.

        Parameters
        ----------
        instrument : Instrument
            The instrument to add.

        """
        Condition.not_none(instrument, "instrument")

        cdef str key = f"{_INSTRUMENTS}:{instrument.id.to_str()}"
        cdef list payload = [self._serializer.serialize(instrument)]
        self._backing.insert(key, payload)

        self._log.debug(f"Added instrument {instrument.id}")

    cpdef void add_synthetic(self, SyntheticInstrument synthetic):
        """
        Add the given synthetic instrument to the database.

        Parameters
        ----------
        synthetic : SyntheticInstrument
            The synthetic instrument to add.

        """
        Condition.not_none(synthetic, "synthetic")

        cdef str key = f"{_SYNTHETICS}:{synthetic.id.value}"
        cdef list payload = [self._serializer.serialize(synthetic)]
        self._backing.insert(key, payload)

        self._log.debug(f"Added synthetic instrument {synthetic.id}")

    cpdef void add_account(self, Account account):
        """
        Add the given account to the database.

        Parameters
        ----------
        account : Account
            The account to add.

        """
        Condition.not_none(account, "account")

        cdef str key = f"{_ACCOUNTS}:{account.id.value}"
        cdef list payload = [self._serializer.serialize(account.last_event_c())]
        self._backing.insert(key, payload)

        self._log.debug(f"Added {account}")

    cpdef void add_order(self, Order order, PositionId position_id = None, ClientId client_id = None):
        """
        Add the given order to the database.

        Parameters
        ----------
        order : Order
            The order to add.
        position_id : PositionId, optional
            The position ID to associate with this order.
        client_id : ClientId, optional
            The execution client ID to associate with this order.

        """
        Condition.not_none(order, "order")

        cdef client_order_id_str = order.client_order_id.to_str()
        cdef str key = f"{_ORDERS}:{client_order_id_str}"
        cdef list payload = [self._serializer.serialize(order.last_event_c())]
        self._backing.insert(key, payload)

        cdef bytes client_order_id_bytes = client_order_id_str.encode()
        payload = [client_order_id_bytes]
        self._backing.insert(_INDEX_ORDERS, payload)

        if order.emulation_trigger != TriggerType.NO_TRIGGER:
            self._backing.insert(_INDEX_ORDERS_EMULATED, payload)

        self._log.debug(f"Added {order}")

        if position_id is not None:
            self.index_order_position(order.client_order_id, position_id)
        if client_id is not None:
            payload = [client_order_id_bytes, client_id.to_str().encode()]
            self._backing.insert(_INDEX_ORDER_CLIENT, payload)
            self._log.debug(f"Indexed {order.client_order_id!r} -> {client_id!r}")

    cpdef void add_position(self, Position position):
        """
        Add the given position to the database.

        Parameters
        ----------
        position : Position
            The position to add.

        """
        Condition.not_none(position, "position")

        cdef str position_id_str = position.id.to_str()
        cdef str key = f"{_POSITIONS}:{position_id_str}"

        # In NETTING mode, position flips reuse the same position_id
        # Delete existing data to prevent appending to closed position events
        self._backing.delete(key, None)

        cdef list payload = [self._serializer.serialize(position.last_event_c())]
        self._backing.insert(key, payload)

        cdef bytes position_id_bytes = position_id_str.encode()
        self._backing.insert(_INDEX_POSITIONS, [position_id_bytes])
        self._backing.insert(_INDEX_POSITIONS_OPEN, [position_id_bytes])

        self._log.debug(f"Added {position}")

    cpdef void index_venue_order_id(self, ClientOrderId client_order_id, VenueOrderId venue_order_id):
        """
        Add an index entry for the given `venue_order_id` to `client_order_id`.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to index.
        venue_order_id : VenueOrderId
            The venue order ID to index.

        """
        Condition.not_none(client_order_id, "client_order_id")
        Condition.not_none(venue_order_id, "venue_order_id")

        cdef list payload = [client_order_id.to_str().encode(), venue_order_id.to_str().encode()]
        self._backing.insert(_INDEX_ORDER_IDS, payload)

        self._log.debug(f"Indexed {client_order_id!r} -> {venue_order_id!r}")

    cpdef void index_order_position(self, ClientOrderId client_order_id, PositionId position_id):
        """
        Add an index entry for the given `client_order_id` to `position_id`.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID to index.
        position_id : PositionId
            The position ID to index.

        """
        Condition.not_none(client_order_id, "client_order_id")
        Condition.not_none(position_id, "position_id")

        cdef list payload = [client_order_id.to_str().encode(), position_id.to_str().encode()]
        self._backing.insert(_INDEX_ORDER_POSITION, payload)

        self._log.debug(f"Indexed {client_order_id!r} -> {position_id!r}")

    cpdef void update_actor(self, Actor actor):
        """
        Update the given actor state in the database.

        Parameters
        ----------
        actor : Actor
            The actor to update.

        """
        Condition.not_none(actor, "actor")

        cdef dict state = actor.save()  # Extract state dictionary from strategy

        cdef key = f"{_ACTORS}:{actor.id.value}:state"
        cdef list payload = [self._serializer.serialize(state)]
        self._backing.insert(key, payload)

        self._log.debug(f"Saved actor state for {actor.id.value}")

    cpdef void update_strategy(self, Strategy strategy):
        """
        Update the given strategy state in the database.

        Parameters
        ----------
        strategy : Strategy
            The strategy to update.

        """
        Condition.not_none(strategy, "strategy")

        cdef dict state = strategy.save()  # Extract state dictionary from strategy

        cdef key = f"{_STRATEGIES}:{strategy.id.value}:state"
        cdef list payload = [self._serializer.serialize(state)]
        self._backing.insert(key, payload)

        self._log.debug(f"Saved strategy state for {strategy.id.value}")

    cpdef void update_account(self, Account account):
        """
        Update the given account in the database.

        Parameters
        ----------
        account : The account to update (from last event).

        """
        Condition.not_none(account, "account")

        cdef str key = f"{_ACCOUNTS}:{account.id.to_str()}"
        cdef list payload = [self._serializer.serialize(account.last_event_c())]
        self._backing.update(key, payload)

        self._log.debug(f"Updated {account}")

    cpdef void update_order(self, Order order):
        """
        Update the given order in the database.

        Parameters
        ----------
        order : Order
            The order to update (from last event).

        """
        Condition.not_none(order, "order")

        cdef str client_order_id_str = order.client_order_id.to_str()
        cdef str key = f"{_ORDERS}:{client_order_id_str}"
        cdef list payload = [self._serializer.serialize(order.last_event_c())]
        self._backing.update(key, payload)

        if order.venue_order_id is not None:
            # Assumes order_id does not change
            self.index_venue_order_id(order.client_order_id, order.venue_order_id)

        payload = [client_order_id_str.encode()]

        # Update in-flight state
        if order.is_inflight_c():
            self._backing.insert(_INDEX_ORDERS_INFLIGHT, payload)
        else:
            self._backing.delete(_INDEX_ORDERS_INFLIGHT, payload)

        # Update open/closed state
        if order.is_open_c():
            self._backing.delete(_INDEX_ORDERS_CLOSED, payload)
            self._backing.insert(_INDEX_ORDERS_OPEN, payload)
        elif order.is_closed_c():
            self._backing.delete(_INDEX_ORDERS_OPEN, payload)
            self._backing.insert(_INDEX_ORDERS_CLOSED, payload)

        # Update emulation state
        if order.emulation_trigger == TriggerType.NO_TRIGGER:
            self._backing.delete(_INDEX_ORDERS_EMULATED, payload)
        else:
            self._backing.insert(_INDEX_ORDERS_EMULATED, payload)

        self._log.debug(f"Updated {order}")

    cpdef void update_position(self, Position position):
        """
        Update the given position in the database.

        Parameters
        ----------
        position : Position
            The position to update (from last event).

        """
        Condition.not_none(position, "position")

        cdef str position_id_str = position.id.to_str()
        cdef str key = f"{_POSITIONS}:{position.id.to_str()}"
        cdef list payload = [self._serializer.serialize(position.last_event_c())]
        self._backing.update(key, payload)

        if position.is_open_c():
            self._backing.insert(_INDEX_POSITIONS_OPEN, payload)
            self._backing.delete(_INDEX_POSITIONS_CLOSED, payload)
        elif position.is_closed_c():
            self._backing.insert(_INDEX_POSITIONS_CLOSED, payload)
            self._backing.delete(_INDEX_POSITIONS_OPEN, payload)

        self._log.debug(f"Updated {position}")

    cpdef void snapshot_order_state(self, Order order):
        """
        Snapshot the state of the given `order`.

        Parameters
        ----------
        order : Order
            The order for the state snapshot.

        """
        Condition.not_none(order, "order")

        cdef str key = f"{_SNAPSHOTS_ORDERS}:{order.client_order_id.to_str()}"
        cdef list payload = [self._serializer.serialize(order.to_dict())]
        self._backing.insert(key, payload)

        self._log.debug(f"Added state snapshot {order}")

    cpdef void snapshot_position_state(
        self,
        Position position,
        uint64_t ts_snapshot,
        Money unrealized_pnl = None,
    ):
        """
        Snapshot the state of the given `position`.

        Parameters
        ----------
        position : Position
            The position for the state snapshot.
        ts_snapshot : uint64_t
            UNIX timestamp (nanoseconds) when the snapshot was taken.
        unrealized_pnl : Money, optional
            The unrealized PnL for the state snapshot.

        """
        Condition.not_none(position, "position")

        cdef dict position_state = position.to_dict()

        if unrealized_pnl is not None:
            position_state["unrealized_pnl"] = str(unrealized_pnl)

        position_state["ts_snapshot"] = ts_snapshot

        cdef str key = f"{_SNAPSHOTS_POSITIONS}:{position.id.to_str()}"
        cdef list payload = [self._serializer.serialize(position_state)]
        self._backing.insert(key, payload)

        self._log.debug(f"Added state snapshot {position}")

    cpdef void heartbeat(self, datetime timestamp):
        """
        Add a heartbeat at the given `timestamp`.

        Parameters
        ----------
        timestamp : datetime
            The timestamp for the heartbeat.

        """
        Condition.not_none(timestamp, "timestamp")

        cdef timestamp_str = format_iso8601(timestamp)
        self._backing.insert(_HEARTBEAT, [timestamp_str.encode()])

        self._log.debug(f"Set last heartbeat {timestamp_str}")

</document_content>
</document>
<document index="2239">
<source>nautilus_trader/cache/facade.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.cache.config import CacheConfig

from cpython.datetime cimport datetime
from libc.stdint cimport uint64_t

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.common.actor cimport Actor
from nautilus_trader.common.component cimport Logger
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.identifiers cimport VenueOrderId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.position cimport Position
from nautilus_trader.trading.strategy cimport Strategy


cdef class CacheDatabaseFacade:
    """
    The base class for all cache databases.

    Parameters
    ----------
    config : CacheConfig, optional
        The configuration for the database.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(self, config: CacheConfig | None = None) -> None:
        self._log = Logger(name=type(self).__name__)

        self._log.info("READY")

    cpdef void close(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `close` must be implemented in the subclass")  # pragma: no cover

    cpdef void flush(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `flush` must be implemented in the subclass")  # pragma: no cover

    cpdef list[str] keys(self, str pattern = "*"):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `keys` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_all(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_currencies(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_currencies` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_instruments(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_instruments` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_synthetics(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_synthetics` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_accounts(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_accounts` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_orders(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_orders` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_positions(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_positions` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_index_order_position(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_index_order_position` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_index_order_client(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_index_order_client` must be implemented in the subclass")  # pragma: no cover

    cpdef Currency load_currency(self, str code):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_currency` must be implemented in the subclass")  # pragma: no cover

    cpdef Instrument load_instrument(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_instrument` must be implemented in the subclass")  # pragma: no cover

    cpdef SyntheticInstrument load_synthetic(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_synthetic` must be implemented in the subclass")  # pragma: no cover

    cpdef Account load_account(self, AccountId account_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_account` must be implemented in the subclass")  # pragma: no cover

    cpdef Order load_order(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_order` must be implemented in the subclass")  # pragma: no cover

    cpdef Position load_position(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_position` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_actor(self, ComponentId component_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_actor` must be implemented in the subclass")  # pragma: no cover

    cpdef dict load_strategy(self, StrategyId strategy_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `load_strategy` must be implemented in the subclass")  # pragma: no cover

    cpdef void add(self, str key, bytes value):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add` must be implemented in the subclass")  # pragma: no cover

    cpdef void add_currency(self, Currency currency):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add_currency` must be implemented in the subclass")  # pragma: no cover

    cpdef void add_instrument(self, Instrument instrument):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add_instrument` must be implemented in the subclass")  # pragma: no cover

    cpdef void add_synthetic(self, SyntheticInstrument synthetic):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add_synthetic` must be implemented in the subclass")  # pragma: no cover

    cpdef void add_account(self, Account account):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add_account` must be implemented in the subclass")  # pragma: no cover

    cpdef void add_order(self, Order order, PositionId position_id = None, ClientId client_id = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add_order` must be implemented in the subclass")  # pragma: no cover

    cpdef void add_position(self, Position position):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `add_position` must be implemented in the subclass")  # pragma: no cover

    cpdef void index_venue_order_id(self, ClientOrderId client_order_id, VenueOrderId venue_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `index_venue_order_id` must be implemented in the subclass")  # pragma: no cover

    cpdef void index_order_position(self, ClientOrderId client_order_id, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `index_order_position` must be implemented in the subclass")  # pragma: no cover

    cpdef void update_account(self, Account event):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `update_account` must be implemented in the subclass")  # pragma: no cover

    cpdef void update_order(self, Order order):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `update_order` must be implemented in the subclass")  # pragma: no cover

    cpdef void update_position(self, Position position):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `update_position` must be implemented in the subclass")  # pragma: no cover

    cpdef void update_actor(self, Actor actor):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `update_actor` must be implemented in the subclass")  # pragma: no cover

    cpdef void update_strategy(self, Strategy strategy):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `update_strategy` must be implemented in the subclass")  # pragma: no cover

    cpdef void snapshot_order_state(self, Order order):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `snapshot_order_state` must be implemented in the subclass")  # pragma: no cover

    cpdef void snapshot_position_state(self, Position position, uint64_t ts_snapshot, Money unrealized_pnl = None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `snapshot_position_state` must be implemented in the subclass")  # pragma: no cover

    cpdef void delete_order(self, ClientOrderId client_order_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `delete_order` must be implemented in the subclass")  # pragma: no cover

    cpdef void delete_position(self, PositionId position_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `delete_position` must be implemented in the subclass")  # pragma: no cover

    cpdef void delete_account_event(self, AccountId account_id, str event_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `delete_account_event` must be implemented in the subclass")  # pragma: no cover

    cpdef void delete_actor(self, ComponentId component_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `delete_actor` must be implemented in the subclass")  # pragma: no cover

    cpdef void delete_strategy(self, StrategyId strategy_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `delete_strategy` must be implemented in the subclass")  # pragma: no cover

    cpdef void heartbeat(self, datetime timestamp):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `heartbeat` must be implemented in the subclass")  # pragma: no cover

</document_content>
</document>
<document index="2244">
<source>nautilus_trader/common/actor.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
The `Actor` class allows traders to implement their own customized components.

A user can inherit from `Actor` and optionally override any of the
"on" named event handler methods. The class is not entirely initialized in a stand-alone
way, the intended usage is to pass actors to a `Trader` so that they can be
fully "wired" into the platform. Exceptions will be raised if an `Actor`
attempts to operate without a managing `Trader` instance.

"""

import asyncio
from concurrent.futures import Executor
from typing import Any
from typing import Callable

import cython

from nautilus_trader.common.config import ActorConfig
from nautilus_trader.common.config import ImportableActorConfig
from nautilus_trader.common.executor import ActorExecutor
from nautilus_trader.common.executor import TaskId
from nautilus_trader.common.signal import generate_signal_class
from nautilus_trader.core import nautilus_pyo3

from cpython.datetime cimport datetime
from libc.stdint cimport uint64_t

from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.common.component cimport CMD
from nautilus_trader.common.component cimport REQ
from nautilus_trader.common.component cimport SENT
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Component
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport is_logging_initialized
from nautilus_trader.common.data_topics cimport TopicCache
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.common cimport ComponentState
from nautilus_trader.core.rust.common cimport LogColor
from nautilus_trader.core.rust.model cimport BookType
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.data.messages cimport DataResponse
from nautilus_trader.data.messages cimport RequestBars
from nautilus_trader.data.messages cimport RequestData
from nautilus_trader.data.messages cimport RequestInstrument
from nautilus_trader.data.messages cimport RequestInstruments
from nautilus_trader.data.messages cimport RequestJoin
from nautilus_trader.data.messages cimport RequestOrderBookDepth
from nautilus_trader.data.messages cimport RequestOrderBookSnapshot
from nautilus_trader.data.messages cimport RequestQuoteTicks
from nautilus_trader.data.messages cimport RequestTradeTicks
from nautilus_trader.data.messages cimport SubscribeBars
from nautilus_trader.data.messages cimport SubscribeData
from nautilus_trader.data.messages cimport SubscribeFundingRates
from nautilus_trader.data.messages cimport SubscribeIndexPrices
from nautilus_trader.data.messages cimport SubscribeInstrument
from nautilus_trader.data.messages cimport SubscribeInstrumentClose
from nautilus_trader.data.messages cimport SubscribeInstruments
from nautilus_trader.data.messages cimport SubscribeInstrumentStatus
from nautilus_trader.data.messages cimport SubscribeMarkPrices
from nautilus_trader.data.messages cimport SubscribeOrderBook
from nautilus_trader.data.messages cimport SubscribeQuoteTicks
from nautilus_trader.data.messages cimport SubscribeTradeTicks
from nautilus_trader.data.messages cimport UnsubscribeBars
from nautilus_trader.data.messages cimport UnsubscribeData
from nautilus_trader.data.messages cimport UnsubscribeFundingRates
from nautilus_trader.data.messages cimport UnsubscribeIndexPrices
from nautilus_trader.data.messages cimport UnsubscribeInstrument
from nautilus_trader.data.messages cimport UnsubscribeInstrumentClose
from nautilus_trader.data.messages cimport UnsubscribeInstruments
from nautilus_trader.data.messages cimport UnsubscribeInstrumentStatus
from nautilus_trader.data.messages cimport UnsubscribeMarkPrices
from nautilus_trader.data.messages cimport UnsubscribeOrderBook
from nautilus_trader.data.messages cimport UnsubscribeQuoteTicks
from nautilus_trader.data.messages cimport UnsubscribeTradeTicks
from nautilus_trader.indicators.base cimport Indicator
from nautilus_trader.model.book cimport OrderBook
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarSpecification
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport DataType
from nautilus_trader.model.data cimport FundingRateUpdate
from nautilus_trader.model.data cimport IndexPriceUpdate
from nautilus_trader.model.data cimport InstrumentClose
from nautilus_trader.model.data cimport InstrumentStatus
from nautilus_trader.model.data cimport MarkPriceUpdate
from nautilus_trader.model.data cimport OrderBookDelta
from nautilus_trader.model.data cimport OrderBookDeltas
from nautilus_trader.model.data cimport OrderBookDepth10
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.greeks cimport GreeksCalculator
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ComponentId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
from nautilus_trader.portfolio.base cimport PortfolioFacade


cdef class Actor(Component):
    """
    The base class for all actor components.

    Parameters
    ----------
    config : ActorConfig, optional
        The actor configuration.

    Raises
    ------
    TypeError
        If `config` is not of type `ActorConfig`.

    Warnings
    --------
    - This class should not be used directly, but through a concrete subclass.
    - Do not call components such as `clock` and `logger` in the `__init__` prior to registration.
    """

    def __init__(self, config: ActorConfig | None = None) -> None:
        if config is None:
            config = ActorConfig()

        Condition.type(config, ActorConfig, "config")

        if isinstance(config.component_id, str):
            component_id = ComponentId(config.component_id)
        else:
            component_id = config.component_id

        super().__init__(
            clock=Clock(),  # Use placeholder until registered
            component_id=component_id,
            config=config,
        )

        self._topic_cache = TopicCache()
        self._warning_events: set[type] = set()
        self._requests: dict[UUID4, RequestData] = {}
        self._pending_requests: dict[UUID4, Callable[[UUID4], None] | None] = {}
        self._pyo3_conversion_types = set()
        self._signal_classes: dict[str, type] = {}

        self._indicators: list[Indicator] = []
        self._indicators_for_quotes: dict[InstrumentId, list[Indicator]] = {}
        self._indicators_for_trades: dict[InstrumentId, list[Indicator]] = {}
        self._indicators_for_bars: dict[tuple[InstrumentId, BarSpecification], list[Indicator]] = {}

        # Topic cache

        # Configuration
        self._log_events = config.log_events
        self._log_commands = config.log_commands
        self.config = config

        self.trader_id = None  # Initialized when registered
        self.msgbus = None     # Initialized when registered
        self.cache = None      # Initialized when registered
        self.clock = None      # Initialized when registered
        self.greeks = None     # Initialized when registered
        self.log = self._log

    def to_importable_config(self) -> ImportableActorConfig:
        """
        Returns an importable configuration for this actor.

        Returns
        -------
        ImportableActorConfig

        """
        return ImportableActorConfig(
            actor_path=self.fully_qualified_name(),
            config_path=self.config.fully_qualified_name(),
            config=self.config.dict(),
        )

# -- ABSTRACT METHODS -----------------------------------------------------------------------------

    cpdef dict[str, bytes] on_save(self):
        """
        Actions to be performed when the actor state is saved.

        Create and return a state dictionary of values to be saved.

        Returns
        -------
        dict[str, bytes]
            The strategy state to save.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        return {}  # Optionally override in subclass

    cpdef void on_load(self, dict[str, bytes] state):
        """
        Actions to be performed when the actor state is loaded.

        Saved state values will be contained in the give state dictionary.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state to load.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_start(self):
        """
        Actions to be performed on start.

        The intent is that this method is called once per trading 'run', when
        initially starting.

        It is recommended to subscribe/request for data here.

        Warnings
        --------
        System method (not intended to be called by user code).

        Should be overridden in a user implementation.

        """
        # Should override in subclass
        self.log.warning(
            "The `Actor.on_start` handler was called when not overridden. "
            "It's expected that any actions required when starting the actor "
            "occur here, such as subscribing/requesting data",
        )

    cpdef void on_stop(self):
        """
        Actions to be performed on stop.

        The intent is that this method is called to pause, or when done for day.

        Warnings
        --------
        System method (not intended to be called by user code).

        Should be overridden in a user implementation.

        """
        # Should override in subclass
        self.log.warning(
            "The `Actor.on_stop` handler was called when not overridden. "
            "It's expected that any actions required when stopping the actor "
            "occur here, such as unsubscribing from data.",
        )

    cpdef void on_resume(self):
        """
        Actions to be performed on resume.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Should override in subclass
        self.log.warning(
            "The `Actor.on_resume` handler was called when not overridden. "
            "It's expected that any actions required when resuming the actor "
            "following a stop occur here"
        )

    cpdef void on_reset(self):
        """
        Actions to be performed on reset.

        Warnings
        --------
        System method (not intended to be called by user code).

        Should be overridden in a user implementation.

        """
        # Should override in subclass
        self.log.warning(
            "The `Actor.on_reset` handler was called when not overridden. "
            "It's expected that any actions required when resetting the actor "
            "occur here, such as resetting indicators and other state"
        )

    cpdef void on_dispose(self):
        """
        Actions to be performed on dispose.

        Cleanup/release any resources used here.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_degrade(self):
        """
        Actions to be performed on degrade.

        Warnings
        --------
        System method (not intended to be called by user code).

        Should be overridden in the actor implementation.

        """
        # Optionally override in subclass

    cpdef void on_fault(self):
        """
        Actions to be performed on fault.

        Cleanup any resources used by the actor here.

        Warnings
        --------
        System method (not intended to be called by user code).

        Should be overridden in the actor implementation.

        """
        # Optionally override in subclass

    cpdef void on_instrument_status(self, InstrumentStatus data):
        """
        Actions to be performed when running and receives an instrument status
        update.

        Parameters
        ----------
        data : InstrumentStatus
            The instrument status update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_instrument_close(self, InstrumentClose update):
        """
        Actions to be performed when running and receives an instrument close
        update.

        Parameters
        ----------
        update : InstrumentClose
            The instrument close received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_instrument(self, Instrument instrument):
        """
        Actions to be performed when running and receives an instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_book(self, OrderBook order_book):
        """
        Actions to be performed when running and receives an order book.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_book_deltas(self, deltas):
        """
        Actions to be performed when running and receives order book deltas.

        Parameters
        ----------
        deltas : OrderBookDeltas or nautilus_pyo3.OrderBookDeltas
            The order book deltas received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_book_depth(self, depth):
        """
        Actions to be performed when running and receives an order book depth.

        Parameters
        ----------
        depth : OrderBookDepth10
            The order book depth received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass


    cpdef void on_quote_tick(self, QuoteTick tick):
        """
        Actions to be performed when running and receives a quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_trade_tick(self, TradeTick tick):
        """
        Actions to be performed when running and receives a trade tick.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_mark_price(self, MarkPriceUpdate mark_price):
        """
        Actions to be performed when running and receives a mark price update.

        Parameters
        ----------
        mark_price : MarkPriceUpdate
            The mark price update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_index_price(self, IndexPriceUpdate index_price):
        """
        Actions to be performed when running and receives an index price update.

        Parameters
        ----------
        index_price : IndexPriceUpdate
            The index price update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_funding_rate(self, FundingRateUpdate funding_rate):
        """
        Actions to be performed when running and receives a funding rate update.

        Parameters
        ----------
        funding_rate : FundingRateUpdate
            The funding rate update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_bar(self, Bar bar):
        """
        Actions to be performed when running and receives a bar.

        Parameters
        ----------
        bar : Bar
            The bar received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_data(self, data):
        """
        Actions to be performed when running and receives data.

        Parameters
        ----------
        data : Data
            The data received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_signal(self, signal):
        """
        Actions to be performed when running and receives signal data.

        Parameters
        ----------
        signal : Data
            The signal received.

        Warnings
        --------
        System method (not intended to be called by user code).

        Notes
        -----
        This refers to a data signal, not an operating system signal (such as SIGTERM, SIGKILL, etc.).

        """
        # Optionally override in subclass

    cpdef void on_historical_data(self, data):
        """
        Actions to be performed when running and receives historical data.

        Parameters
        ----------
        data : Data
            The historical data received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_filled(self, OrderFilled event):
        """
        Actions to be performed when running and receives an order filled event.

        Parameters
        ----------
        event : OrderFilled
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_event(self, Event event):
        """
        Actions to be performed running and receives an event.

        Parameters
        ----------
        event : Event
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    @property
    def registered_indicators(self):
        """
        Return the registered indicators for the strategy.

        Returns
        -------
        list[Indicator]

        """
        return self._indicators.copy()

    cpdef bint indicators_initialized(self):
        """
        Return a value indicating whether all indicators are initialized.

        Returns
        -------
        bool
            True if all initialized, else False

        """
        if not self._indicators:
            return False

        cdef Indicator indicator
        for indicator in self._indicators:
            if not indicator.initialized:
                return False

        return True

# -- REGISTRATION ---------------------------------------------------------------------------------

    cpdef void register_base(
        self,
        PortfolioFacade portfolio,
        MessageBus msgbus,
        CacheFacade cache,
        Clock clock,
    ):
        """
        Register with a trader.

        Parameters
        ----------
        portfolio : PortfolioFacade
            The read-only portfolio for the actor.
        msgbus : MessageBus
            The message bus for the actor.
        cache : CacheFacade
            The read-only cache for the actor.
        clock : Clock
            The clock for the actor.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(portfolio, "portfolio")
        Condition.not_none(msgbus, "msgbus")
        Condition.not_none(cache, "cache")
        Condition.not_none(clock, "clock")

        clock.register_default_handler(self.handle_event)
        self._change_clock(clock)
        self._change_msgbus(msgbus)  # The trader ID is assigned here

        self.portfolio = portfolio  # Assigned as PortfolioFacade
        self.msgbus = msgbus
        self.cache = cache
        self.clock = self._clock
        self.log = self._log

        self.greeks = GreeksCalculator(msgbus, cache, self.clock)

    cpdef void register_executor(
        self,
        loop: asyncio.AbstractEventLoop,
        executor: Executor,
    ):
        """
        Register the given `Executor` for the actor.

        Parameters
        ----------
        loop : asyncio.AbstractEventLoop
            The event loop of the application.
        executor : concurrent.futures.Executor
            The executor to register.

        Raises
        ------
        TypeError
            If `executor` is not of type `concurrent.futures.Executor`

        """
        Condition.type(executor, Executor, "executor")

        self._executor = ActorExecutor(loop, executor, logger=self._log)
        if self._log is not None:
            self._log.debug(f"Registered {executor}")

    cpdef void register_warning_event(self, type event):
        """
        Register the given event type for warning log levels.

        Parameters
        ----------
        event : type
            The event class to register.

        """
        Condition.not_none(event, "event")

        self._warning_events.add(event)

    cpdef void deregister_warning_event(self, type event):
        """
        Deregister the given event type from warning log levels.

        Parameters
        ----------
        event : type
            The event class to deregister.

        """
        Condition.not_none(event, "event")

        self._warning_events.discard(event)
        if self._log is not None:
            self._log.debug(f"Deregistered `{event.__name__}` from warning log levels")

    cpdef void register_indicator_for_quote_ticks(self, InstrumentId instrument_id, Indicator indicator):
        """
        Register the given indicator with the actor/strategy to receive quote tick
        data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for tick updates.
        indicator : Indicator
            The indicator to register.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.not_none(indicator, "indicator")

        if indicator not in self._indicators:
            self._indicators.append(indicator)

        if instrument_id not in self._indicators_for_quotes:
            self._indicators_for_quotes[instrument_id] = []  # type: list[Indicator]

        if indicator not in self._indicators_for_quotes[instrument_id]:
            self._indicators_for_quotes[instrument_id].append(indicator)
            self.log.info(f"Registered Indicator {indicator} for {instrument_id} quotes")
        else:
            self.log.error(f"Indicator {indicator} already registered for {instrument_id} quotes")

    cpdef void register_indicator_for_trade_ticks(self, InstrumentId instrument_id, Indicator indicator):
        """
        Register the given indicator with the actor/strategy to receive trade tick
        data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for tick updates.
        indicator : indicator
            The indicator to register.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.not_none(indicator, "indicator")

        if indicator not in self._indicators:
            self._indicators.append(indicator)

        if instrument_id not in self._indicators_for_trades:
            self._indicators_for_trades[instrument_id] = []  # type: list[Indicator]

        if indicator not in self._indicators_for_trades[instrument_id]:
            self._indicators_for_trades[instrument_id].append(indicator)
            self.log.info(f"Registered Indicator {indicator} for {instrument_id} trades")
        else:
            self.log.error(f"Indicator {indicator} already registered for {instrument_id} trades")

    cpdef void register_indicator_for_bars(self, BarType bar_type, Indicator indicator):
        """
        Register the given indicator with the actor/strategy to receive bar data for the
        given bar type.

        Parameters
        ----------
        bar_type : BarType
            The bar type for bar updates.
        indicator : Indicator
            The indicator to register.

        """
        Condition.not_none(bar_type, "bar_type")
        Condition.not_none(indicator, "indicator")

        if indicator not in self._indicators:
            self._indicators.append(indicator)

        cdef tuple bar_key = bar_type.id_spec_key()
        if bar_key not in self._indicators_for_bars:
            self._indicators_for_bars[bar_key] = []  # type: list[Indicator]

        if indicator not in self._indicators_for_bars[bar_key]:
            self._indicators_for_bars[bar_key].append(indicator)
            self.log.info(f"Registered Indicator {indicator} for {bar_type.standard()} bars")
        else:
            self.log.error(f"Indicator {indicator} already registered for {bar_type.standard()} bars")

# -- ACTOR COMMANDS -------------------------------------------------------------------------------

    cpdef dict[str, bytes] save(self):
        """
        Return the actor/strategy state dictionary to be saved.

        Calls `on_save`.

        Returns
        -------
        dict[str, bytes]
            The strategy state to save.

        Warnings
        --------
        Exceptions raised will be caught, logged, and reraised.

        """
        if not self.is_initialized:
            self.log.error(
                "Cannot save: actor/strategy has not been registered with a trader",
            )
            return
        try:
            self.log.debug("Saving state")

            user_state = self.on_save()
            if len(user_state) > 0:
                self.log.info(f"Saved state: {list(user_state.keys())}", color=LogColor.BLUE)
            else:
                self.log.info("No user state to save", color=LogColor.BLUE)

            return user_state
        except Exception as e:
            self.log.exception("Error on save", e)
            raise  # Otherwise invalid state information could be saved

    cpdef void load(self, dict[str, bytes] state):
        """
        Load the actor/strategy state from the give state dictionary.

        Calls `on_load` and passes the state.

        Parameters
        ----------
        state : dict[str, bytes]
            The strategy state to load.

        Warnings
        --------
        Exceptions raised will be caught, logged, and reraised.

        """
        Condition.not_none(state, "state")

        if not state:
            self.log.info("No user state to load", color=LogColor.BLUE)
            return

        try:
            self.log.debug(f"Loading state")
            self.on_load(state)
            self.log.info(f"Loaded state {list(state.keys())}", color=LogColor.BLUE)
        except Exception as e:
            self.log.exception(f"Error on load {repr(state)}", e)
            raise

    cpdef void add_synthetic(self, SyntheticInstrument synthetic):
        """
        Add the created synthetic instrument to the cache.

        Parameters
        ----------
        synthetic : SyntheticInstrument
            The synthetic instrument to add to the cache.

        Raises
        ------
        KeyError
            If `synthetic` is already in the cache.

        Notes
        -----
        If you are updating the synthetic instrument then you should use the `update_synthetic` method.

        """
        Condition.not_none(synthetic, "synthetic")
        Condition.is_true(self.cache.synthetic(synthetic.id) is None, f"`synthetic` {synthetic.id} already exists")

        self.cache.add_synthetic(synthetic)

    cpdef void update_synthetic(self, SyntheticInstrument synthetic):
        """
        Update the synthetic instrument in the cache.

        Parameters
        ----------
        synthetic : SyntheticInstrument
            The synthetic instrument to update in the cache.

        Raises
        ------
        KeyError
            If `synthetic` does not already exist in the cache.

        Notes
        -----
        If you are adding a new synthetic instrument then you should use the `add_synthetic` method.

        """
        Condition.not_none(synthetic, "synthetic")
        Condition.is_true(self.cache.synthetic(synthetic.id) is not None, f"`synthetic` {synthetic.id} does not exist")

        # This will replace the previous synthetic
        self.cache.add_synthetic(synthetic)

    cpdef queue_for_executor(
        self,
        func: Callable[..., Any],
        tuple args = None,
        dict kwargs = None,
    ):
        """
        Queues the callable `func` to be executed as `fn(*args, **kwargs)` sequentially.

        Parameters
        ----------
        func : Callable
            The function to be executed.
        args : positional arguments
            The positional arguments for the call to `func`.
        kwargs : arbitrary keyword arguments
            The keyword arguments for the call to `func`.

        Raises
        ------
        TypeError
            If `func` is not of type `Callable`.

        Notes
        -----
        For backtesting the `func` is immediately executed, as there's no need for a `Future`
        object that can be awaited. In a backtesting scenario, the execution is not in real time,
        and so the results of `func` are 'immediately' available after it's called.

        """
        Condition.callable(func, "func")

        if args is None:
            args = ()

        if kwargs is None:
            kwargs = {}

        if self._executor is None:
            func(*args, **kwargs)
            task_id = TaskId.create()
        else:
            task_id = self._executor.queue_for_executor(
                func,
                *args,
                **kwargs,
            )

        if self._log is not None:
            self._log.debug(
                f"Executor: Queued {task_id}: {func.__name__}({args=}, {kwargs=})", LogColor.BLUE,
            )

        return task_id

    cpdef run_in_executor(
        self,
        func: Callable[..., Any],
        tuple args = None,
        dict kwargs = None,
    ):
        """
        Schedules the callable `func` to be executed as `fn(*args, **kwargs)`.

        Parameters
        ----------
        func : Callable
            The function to be executed.
        args : positional arguments
            The positional arguments for the call to `func`.
        kwargs : arbitrary keyword arguments
            The keyword arguments for the call to `func`.

        Returns
        -------
        TaskId
            The unique task identifier for the execution.
            This also corresponds to any future objects memory address.

        Raises
        ------
        TypeError
            If `func` is not of type `Callable`.

        Notes
        -----
        For backtesting the `func` is immediately executed, as there's no need for a `Future`
        object that can be awaited. In a backtesting scenario, the execution is not in real time,
        and so the results of `func` are 'immediately' available after it's called.

        """
        Condition.callable(func, "func")

        if args is None:
            args = ()

        if kwargs is None:
            kwargs = {}

        if self._executor is None:
            func(*args, **kwargs)
            task_id = TaskId.create()
        else:
            task_id = self._executor.run_in_executor(
                func,
                *args,
                **kwargs,
            )

        if self._log is not None:
            self._log.debug(
                f"Executor: Submitted {task_id}: {func.__name__}({args=}, {kwargs=})", LogColor.BLUE,
            )

        return task_id

    cpdef list queued_task_ids(self):
        """
        Return the queued task identifiers.

        Returns
        -------
        list[TaskId]

        """
        if self._executor is None:
            return []  # Tasks are immediately executed

        return self._executor.queued_task_ids()

    cpdef list active_task_ids(self):
        """
        Return the active task identifiers.

        Returns
        -------
        list[TaskId]

        """
        if self._executor is None:
            return []  # Tasks are immediately executed

        return self._executor.active_task_ids()

    cpdef bint has_queued_tasks(self):
        """
        Return a value indicating whether there are any queued tasks.

        Returns
        -------
        bool

        """
        if self._executor is None:
            return False

        return self._executor.has_queued_tasks()

    cpdef bint has_active_tasks(self):
        """
        Return a value indicating whether there are any active tasks.

        Returns
        -------
        bool

        """
        if self._executor is None:
            return False

        return self._executor.has_active_tasks()

    cpdef bint has_any_tasks(self):
        """
        Return a value indicating whether there are any queued OR active tasks.

        Returns
        -------
        bool

        """
        if self._executor is None:
            return False

        return self._executor.has_queued_tasks() or self._executor.has_active_tasks()

    cpdef void cancel_task(self, task_id: TaskId):
        """
        Cancel the task with the given `task_id` (if queued or active).

        If the task is not found then a warning is logged.

        Parameters
        ----------
        task_id : TaskId
            The task identifier.

        """
        if self._executor is None:
            if self._log is not None:
                self._log.warning(f"Executor: {task_id} not found")
            return

        self._executor.cancel_task(task_id)

    cpdef void cancel_all_tasks(self):
        """
        Cancel all queued and active tasks.
        """
        if self._executor is None:
            return

        self._executor.cancel_all_tasks()

# -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------

    cpdef void _start(self):
        self.on_start()

    cpdef void _stop(self):
        self.on_stop()

        # Clean up clock
        cdef list timer_names = self._clock.timer_names
        self._clock.cancel_timers()

        cdef str name
        for name in timer_names:
            if self._log is not None:
                self._log.info(f"Canceled Timer(name={name})")

        if self._executor is not None:
            if self._log is not None:
                self._log.info(f"Canceling executor tasks")
            self._executor.cancel_all_tasks()

    cpdef void _resume(self):
        self.on_resume()

    cpdef void _reset(self):
        self.on_reset()
        self._requests.clear()
        self._pending_requests.clear()

        self._indicators.clear()
        self._indicators_for_quotes.clear()
        self._indicators_for_trades.clear()
        self._indicators_for_bars.clear()

    cpdef void _dispose(self):
        Component._dispose(self)  # Call base cleanup (cancels timers)
        self.on_dispose()

    cpdef void _degrade(self):
        self.on_degrade()

    cpdef void _fault(self):
        self.on_fault()

# -- SUBSCRIPTIONS --------------------------------------------------------------------------------

    cpdef void subscribe_data(
        self,
        DataType data_type,
        ClientId client_id = None,
        InstrumentId instrument_id = None,
        bint update_catalog = False,
        dict[str, object] params = None,
    ):
        """
        Subscribe to data of the given data type.

        Once subscribed, any matching data published on the message bus is forwarded
        to the `on_data` handler.

        Parameters
        ----------
        data_type : DataType
            The data type to subscribe to.
        client_id : ClientId, optional
            The data client ID. If supplied then a `Subscribe` command will be
            sent to the corresponding data client.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
            Only useful when downloading data during a backtest.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(data_type, "data_type")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_custom_data_topic(data_type, instrument_id),
            handler=self.handle_data,
        )

        # TODO during a backtest, use any ClientId for subscribing to custom data from a catalog when not using instrument_id
        if client_id is None and instrument_id is None:
            return

        params = params or {}
        params["update_catalog"] = update_catalog

        cdef SubscribeData command = SubscribeData(
            data_type=data_type,
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue if instrument_id else None,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_instruments(
        self,
        Venue venue,
        ClientId client_id = None,
        bint update_catalog = False,
        dict[str, object] params = None,
    ):
        """
        Subscribe to update `Instrument` data for the given venue.

        Once subscribed, any matching instrument data published on the message bus is forwarded
        the `on_instrument` handler.

        Parameters
        ----------
        venue : Venue
            The venue for the subscription.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
            Only useful when downloading data during a backtest.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(venue, "venue")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_instruments_topic(venue),
            handler=self.handle_instrument,
        )

        params = params or {}
        params["update_catalog"] = update_catalog

        cdef SubscribeInstruments command = SubscribeInstruments(
            client_id=client_id,
            venue=venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_instrument(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        bint update_catalog = False,
        dict[str, object] params = None,
    ):
        """
        Subscribe to update `Instrument` data for the given instrument ID.

        Once subscribed, any matching instrument data published on the message bus is forwarded
        to the `on_instrument` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the subscription.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
            Only useful when downloading data during a backtest.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_instrument_topic(instrument_id),
            handler=self.handle_instrument,
        )

        params = params or {}
        params["update_catalog"] = update_catalog

        cdef SubscribeInstrument command = SubscribeInstrument(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_order_book_deltas(
        self,
        InstrumentId instrument_id,
        BookType book_type=BookType.L2_MBP,
        int depth = 0,
        ClientId client_id = None,
        bint managed = True,
        bint pyo3_conversion = False,
        dict[str, object] params = None,
    ):
        """
        Subscribe to the order book data stream, being a snapshot then deltas
        for the given instrument ID.

        Once subscribed, any matching order book data published on the message bus is forwarded
        to the `on_order_book_deltas` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument ID to subscribe to.
        book_type : BookType {``L1_MBP``, ``L2_MBP``, ``L3_MBO``}
            The order book type.
        depth : int, optional
            The maximum depth for the order book. A depth of 0 is maximum depth.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        managed : bool, default True
            If an order book should be managed by the data engine based on the subscribed feed.
        pyo3_conversion : bool, default False
            If received deltas should be converted to `nautilus_pyo3.OrderBookDeltas`
            prior to being passed to the `on_order_book_deltas` handler.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        if pyo3_conversion:
            self._pyo3_conversion_types.add(OrderBookDeltas)

        self._msgbus.subscribe(
            topic=self._topic_cache.get_deltas_topic(instrument_id),
            handler=self.handle_order_book_deltas,
        )
        cdef SubscribeOrderBook command = SubscribeOrderBook(
            instrument_id=instrument_id,
            book_data_type=OrderBookDelta,
            book_type=book_type,
            depth=depth,
            managed=managed,
            interval_ms=0,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_order_book_depth(
        self,
        InstrumentId instrument_id,
        BookType book_type=BookType.L2_MBP,
        int depth = 0,
        ClientId client_id = None,
        bint managed = True,
        bint pyo3_conversion = False,
        bint update_catalog = False,
        dict[str, object] params = None,
    ):
        """
        Subscribe to the order book depth stream for the given instrument ID.

        Once subscribed, any matching order book data published on the message bus is forwarded
        to the `on_order_book_depth` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument ID to subscribe to.
        book_type : BookType {``L1_MBP``, ``L2_MBP``, ``L3_MBO``}
            The order book type.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        managed : bool, default True
            If an order book should be managed by the data engine based on the subscribed feed.
        pyo3_conversion : bool, default False
            If received deltas should be converted to `nautilus_pyo3.OrderBookDepth`
            prior to being passed to the `on_order_book_depth` handler.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
            Only useful when downloading data during a backtest.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        if pyo3_conversion:
            self._pyo3_conversion_types.add(OrderBookDepth10)

        self._msgbus.subscribe(
            topic=self._topic_cache.get_depth_topic(instrument_id),
            handler=self.handle_order_book_depth,
        )

        params = params or {}
        params["update_catalog"] = update_catalog

        cdef SubscribeOrderBook command = SubscribeOrderBook(
            instrument_id=instrument_id,
            book_data_type=OrderBookDepth10,
            book_type=book_type,
            depth=depth,
            managed=managed,
            interval_ms=0,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_order_book_at_interval(
        self,
        InstrumentId instrument_id,
        BookType book_type=BookType.L2_MBP,
        int depth = 0,
        int interval_ms = 1000,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Subscribe to an `OrderBook` at a specified interval for the given instrument ID.

        Once subscribed, any matching order book updates published on the message bus are forwarded
        to the `on_order_book` handler.

        The `DataEngine` will only maintain one order book for each instrument.
        Because of this - the level, depth and params for the stream will be set
        as per the last subscription request (this will also affect all subscribers).

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument ID to subscribe to.
        book_type : BookType {``L1_MBP``, ``L2_MBP``, ``L3_MBO``}
            The order book type.
        depth : int, optional
            The maximum depth for the order book. A depth of 0 is maximum depth.
        interval_ms : int, default 1000
            The order book snapshot interval (milliseconds).
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        Raises
        ------
        ValueError
            If `depth` is negative (< 0).
        ValueError
            If `interval_ms` is not positive (> 0).

        Warnings
        --------
        Consider subscribing to order book deltas if you need intervals less than 100 milliseconds.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.not_negative(depth, "depth")
        Condition.positive_int(interval_ms, "interval_ms")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        if book_type == BookType.L1_MBP and depth > 1:
            self._log.error(
                "Cannot subscribe to order book snapshots: "
                f"L1 MBP book subscription depth > 1, was {depth}",
            )
            return

        self._msgbus.subscribe(
            topic=self._topic_cache.get_snapshots_topic(instrument_id, interval_ms),
            handler=self.handle_order_book,
        )
        cdef SubscribeOrderBook command = SubscribeOrderBook(
            instrument_id=instrument_id,
            book_data_type=OrderBookDelta,
            book_type=book_type,
            depth=depth,
            managed=True,  # Must be managed by DataEngine to provide snapshots at interval
            interval_ms=interval_ms,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_quote_ticks(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        bint update_catalog = False,
        dict[str, object] params = None,
    ):
        """
        Subscribe to streaming `QuoteTick` data for the given instrument ID.

        Once subscribed, any matching quote tick data published on the message bus is forwarded
        to the `on_quote_tick` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
            Only useful when downloading data during a backtest.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_quotes_topic(instrument_id),
            handler=self.handle_quote_tick,
        )

        params = params or {}
        params["update_catalog"] = update_catalog

        cdef SubscribeQuoteTicks command = SubscribeQuoteTicks(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_trade_ticks(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        bint update_catalog = False,
        dict[str, object] params = None,
    ):
        """
        Subscribe to streaming `TradeTick` data for the given instrument ID.

        Once subscribed, any matching trade tick data published on the message bus is forwarded
        to the `on_trade_tick` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
            Only useful when downloading data during a backtest.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_trades_topic(instrument_id),
            handler=self.handle_trade_tick,
        )

        params = params or {}
        params["update_catalog"] = update_catalog

        cdef SubscribeTradeTicks command = SubscribeTradeTicks(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_mark_prices(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Subscribe to streaming `MarkPriceUpdate` data for the given instrument ID.

        Once subscribed, any matching mark price updates published on the message bus are forwarded
        to the `on_mark_price` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_mark_prices_topic(instrument_id),
            handler=self.handle_mark_price,
        )
        cdef SubscribeMarkPrices command = SubscribeMarkPrices(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_index_prices(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Subscribe to streaming `IndexPriceUpdate` data for the given instrument ID.

        Once subscribed, any matching index price updates published on the message bus are forwarded
        to the `on_index_price` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_index_prices_topic(instrument_id),
            handler=self.handle_index_price,
        )
        cdef SubscribeIndexPrices command = SubscribeIndexPrices(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_funding_rates(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Subscribe to streaming `FundingRateUpdate` data for the given instrument ID.

        Once subscribed, any matching funding rate updates published on the message bus are forwarded
        to the `on_funding_rate` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_funding_rates_topic(instrument_id),
            handler=self.handle_funding_rate,
        )
        cdef SubscribeFundingRates command = SubscribeFundingRates(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_bars(
        self,
        BarType bar_type,
        ClientId client_id = None,
        bint update_catalog = False,
        dict[str, object] params = None,
    ):
        """
        Subscribe to streaming `Bar` data for the given bar type.

        Once subscribed, any matching bar data published on the message bus is forwarded
        to the `on_bar` handler.

        Parameters
        ----------
        bar_type : BarType
            The bar type to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
            Only useful when downloading data during a backtest.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(bar_type, "bar_type")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_bars_topic(bar_type.standard()),
            handler=self.handle_bar,
        )

        params = params or {}
        params["update_catalog"] = update_catalog

        cdef SubscribeBars command = SubscribeBars(
            bar_type=bar_type,
            client_id=client_id,
            venue=bar_type.instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_instrument_status(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Subscribe to status updates for the given instrument ID.

        Once subscribed, any matching instrument status data published on the message bus is forwarded
        to the `on_instrument_status` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to status updates for.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_status_topic(instrument_id),
            handler=self.handle_instrument_status,
        )
        cdef SubscribeInstrumentStatus command = SubscribeInstrumentStatus(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)
        self._log.info(f"Subscribed to {instrument_id} InstrumentStatus")

    cpdef void subscribe_instrument_close(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Subscribe to close updates for the given instrument ID.

        Once subscribed, any matching instrument close data published on the message bus is forwarded
        to the `on_instrument_close` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to status updates for.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_close_prices_topic(instrument_id),
            handler=self.handle_instrument_close,
        )
        cdef SubscribeInstrumentClose command = SubscribeInstrumentClose(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void subscribe_order_fills(self, InstrumentId instrument_id):
        """
        Subscribe to all order fills for the given instrument ID.

        Once subscribed, any matching order fills published on the message bus are forwarded
        to the `on_order_filled` handler.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to fills for.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.subscribe(
            topic=f"events.fills.{instrument_id}",
            handler=self._handle_order_filled,
        )

    cpdef void unsubscribe_data(
        self,
        DataType data_type,
        ClientId client_id = None,
        InstrumentId instrument_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from data of the given data type.

        Parameters
        ----------
        data_type : DataType
            The data type to unsubscribe from.
        client_id : ClientId, optional
            The data client ID. If supplied then an `Unsubscribe` command will
            be sent to the data client.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(data_type, "data_type")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_custom_data_topic(data_type, instrument_id),
            handler=self.handle_data,
        )

        # TODO during a backtest, use any ClientId for subscribing to custom data from a catalog when not using instrument_id
        if client_id is None and instrument_id is None:
            return

        cdef UnsubscribeData command = UnsubscribeData(
            data_type=data_type,
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue if instrument_id else None,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_instruments(
        self,
        Venue venue,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from update `Instrument` data for the given venue.

        Parameters
        ----------
        venue : Venue
            The venue for the subscription.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(venue, "venue")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_instruments_topic(venue),
            handler=self.handle_instrument,
        )
        cdef UnsubscribeInstruments command = UnsubscribeInstruments(
            client_id=client_id,
            venue=venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_instrument(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from update `Instrument` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to unsubscribe from.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_instrument_topic(instrument_id),
            handler=self.handle_instrument,
        )
        cdef UnsubscribeInstrument command = UnsubscribeInstrument(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_order_book_deltas(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe the order book deltas stream for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_deltas_topic(instrument_id),
            handler=self.handle_order_book_deltas,
        )
        cdef UnsubscribeOrderBook command = UnsubscribeOrderBook(
            instrument_id=instrument_id,
            book_data_type=OrderBookDelta,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_order_book_depth(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe the order book depth stream for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_depth_topic(instrument_id),
            handler=self.handle_order_book_depth,
        )
        cdef UnsubscribeOrderBook command = UnsubscribeOrderBook(
            instrument_id=instrument_id,
            book_data_type=OrderBookDepth10,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_order_book_at_interval(
        self,
        InstrumentId instrument_id,
        int interval_ms = 1000,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from an `OrderBook` at a specified interval for the given instrument ID.

        The interval must match the previously subscribed interval.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to subscribe to.
        interval_ms : int, default 1000
            The order book snapshot interval (milliseconds).
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_snapshots_topic(instrument_id, interval_ms),
            handler=self.handle_order_book,
        )
        cdef UnsubscribeOrderBook command = UnsubscribeOrderBook(
            instrument_id=instrument_id,
            book_data_type=OrderBookDelta,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_quote_ticks(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from streaming `QuoteTick` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to unsubscribe from.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_quotes_topic(instrument_id),
            handler=self.handle_quote_tick,
        )
        cdef UnsubscribeQuoteTicks command = UnsubscribeQuoteTicks(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_trade_ticks(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from streaming `TradeTick` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument ID to unsubscribe from.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_trades_topic(instrument_id),
            handler=self.handle_trade_tick,
        )
        cdef UnsubscribeTradeTicks command = UnsubscribeTradeTicks(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_mark_prices(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from streaming `MarkPriceUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_mark_prices_topic(instrument_id),
            handler=self.handle_mark_price,
        )
        cdef UnsubscribeMarkPrices command = UnsubscribeMarkPrices(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_index_prices(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from streaming `IndexPriceUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_index_prices_topic(instrument_id),
            handler=self.handle_index_price,
        )
        cdef UnsubscribeIndexPrices command = UnsubscribeIndexPrices(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_funding_rates(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from streaming `FundingRateUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to unsubscribe from.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_funding_rates_topic(instrument_id),
            handler=self.handle_funding_rate,
        )
        cdef UnsubscribeFundingRates command = UnsubscribeFundingRates(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)

    cpdef void unsubscribe_bars(
        self,
        BarType bar_type,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from streaming `Bar` data for the given bar type.

        Parameters
        ----------
        bar_type : BarType
            The bar type to unsubscribe from.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(bar_type, "bar_type")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_bars_topic(bar_type.standard()),
            handler=self.handle_bar,
        )

        cdef UnsubscribeBars command = UnsubscribeBars(
            bar_type=bar_type,
            client_id=client_id,
            venue=bar_type.instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)
        self._log.info(f"Unsubscribed from {bar_type} bar data")

    cpdef void unsubscribe_instrument_status(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from status updates for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to unsubscribe from status updates for.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=self._topic_cache.get_status_topic(instrument_id),
            handler=self.handle_instrument_status,
        )
        cdef UnsubscribeInstrumentStatus command = UnsubscribeInstrumentStatus(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)
        self._log.info(f"Unsubscribed from {instrument_id} InstrumentStatus")

    cpdef void unsubscribe_instrument_close(
        self,
        InstrumentId instrument_id,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Unsubscribe from close updates for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to unsubscribe from close updates for.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=f"data.venue.close_price.{instrument_id.to_str()}",
            handler=self.handle_instrument_close,
        )
        cdef UnsubscribeInstrumentClose command = UnsubscribeInstrumentClose(
            instrument_id=instrument_id,
            client_id=client_id,
            venue=instrument_id.venue,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._send_data_cmd(command)
        self._log.info(f"Unsubscribed from {instrument_id} InstrumentClose")

    cpdef void unsubscribe_order_fills(self, InstrumentId instrument_id):
        """
        Unsubscribe from all order fills for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to unsubscribe from fills for.

        """
        Condition.not_none(instrument_id, "instrument_id")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.unsubscribe(
            topic=f"events.fills.{instrument_id}",
            handler=self._handle_order_filled,
        )

    cpdef void publish_data(self, DataType data_type, Data data):
        """
        Publish the given data to the message bus.

        Parameters
        ----------
        data_type : DataType
            The data type being published.
        data : Data
            The data to publish.

        """
        Condition.not_none(data_type, "data_type")
        Condition.not_none(data, "data")
        Condition.type(data, data_type.type, "data", "data.type")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        self._msgbus.publish_c(topic=self._topic_cache.get_custom_data_topic(data_type), msg=data)

    cpdef void publish_signal(self, str name, value, uint64_t ts_event = 0):
        """
        Publish the given value as a signal to the message bus.

        Parameters
        ----------
        name : str
            The name of the signal being published.
            The signal name will be converted to title case, with each word capitalized
            (e.g., 'example' becomes 'SignalExample').
        value : object
            The signal data to publish.
        ts_event : uint64_t, optional
            UNIX timestamp (nanoseconds) when the signal event occurred.
            If ``None`` then will timestamp current time.

        """
        Condition.not_none(name, "name")
        Condition.not_none(value, "value")
        Condition.is_in(type(value), (int, float, str), "value", "int, float, str")
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")

        cdef type cls = self._signal_classes.get(name)

        if cls is None:
            cls = generate_signal_class(name=name, value_type=type(value))
            self._signal_classes[name] = cls

        cdef uint64_t now = self.clock.timestamp_ns()
        cdef Data data = cls(
            value=value,
            ts_event=ts_event or now,
            ts_init=now,
        )
        self.publish_data(data_type=DataType(cls), data=data)

    cpdef void subscribe_signal(self, str name = ""):
        """
        Subscribe to a specific signal by name, or to all signals if no name is provided.

        Once subscribed, any matching signal data published on the message bus is forwarded
        to the `on_signal` handler.

        Parameters
        ----------
        name : str, optional
            The name of the signal to subscribe to. If not provided or an empty
            string is passed, the subscription will include all signals.
            The signal name is case-insensitive and will be capitalized
            (e.g., 'example' becomes 'SignalExample*').

        """
        Condition.not_none(name, "name")

        self._msgbus.subscribe(
            topic=self._topic_cache.get_signal_topic(name),
            handler=self.handle_signal,
        )

# -- VALIDATIONS -------------------------------------------------------------------------

    cdef tuple _validate_datetime_range(
        self,
        datetime start,
        datetime end,
    ):
        """
        Validate datetime range parameters.

        Parameters
        ----------
        start : datetime
            The start datetime (UTC) of request time range.
        end : datetime, optional
            The end datetime (UTC) of request time range.

        Returns
        -------
        tuple[datetime, datetime]
            The validated start and end datetimes. If `end` was None,
            it will be replaced with the current UTC time.

        Raises
        ------
        TypeError
            If `start` is None.
        ValueError
            If `start` is > current timestamp (now).
        ValueError
            If `end` is > current timestamp (now).
        ValueError
            If `start` is > `end`.

        """
        cdef datetime now = self.clock.utc_now()
        if end is None:
            end = now

        Condition.not_none(start, "start")
        Condition.is_true(start <= now, "start was > now")
        Condition.is_true(end <= now, "end was > now")
        Condition.is_true(start <= end, "start was > end")

        return (start, end)

# -- REQUESTS -------------------------------------------------------------------------------------

    cpdef UUID4 request_data(
        self,
        DataType data_type,
        ClientId client_id,
        InstrumentId instrument_id = None,
        datetime start = None,
        datetime end = None,
        int limit = 0,
        callback: Callable[[UUID4], None] | None = None,
        bint update_catalog = False,
        dict[str, object] params = None,
        bint join_request = False,
    ):
        """
        Request custom data for the given data type from the given data client.

        Once the response is received, the data is forwarded from the message bus
        to the `on_historical_data` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        data_type : DataType
            The data type for the request.
        client_id : ClientId
            The data client ID.
        start : datetime
            The start datetime (UTC) of request time range.
            Cannot be `None`.
            Should be left-inclusive (start <= value), but inclusiveness is not currently guaranteed.
        end : datetime, optional
            The end datetime (UTC) of request time range.
            If `None` then will be replaced with the current UTC time.
            Should be right-inclusive (value <= end), but inclusiveness is not currently guaranteed.
        limit : int, optional
            The limit on the amount of data points received.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has
            completed processing.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.
        join_request: bool, optional, default to False
            If a request should be joined and sorted with another one by using request_join.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        TypeError
            If `start` is `None`.
        ValueError
            If `start` is > current timestamp (now).
        ValueError
            If `end` is > current timestamp (now).
        ValueError
            If `start` is > `end`.
        TypeError
            If `callback` is not `None` and not of type `Callable`.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(client_id, "client_id")
        Condition.not_none(data_type, "data_type")
        Condition.callable_or_none(callback, "callback")

        start, end = self._validate_datetime_range(start, end)

        params = params or {}
        params["update_catalog"] = update_catalog
        params["join_request"] = join_request

        cdef UUID4 request_id = UUID4()
        cdef RequestData request = RequestData(
            data_type=data_type,
            instrument_id=instrument_id,
            start=start,
            end=end,
            limit=limit,
            client_id=client_id,
            venue=None,
            callback=self._handle_data_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._requests[request_id] = request
        self._pending_requests[request_id] = callback

        self._msgbus.subscribe(
            topic=self._topic_cache.get_custom_data_topic(data_type, instrument_id, historical=True),
            handler=self.handle_historical_data,
        )

        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_instrument(
        self,
        InstrumentId instrument_id,
        datetime start = None,
        datetime end = None,
        ClientId client_id = None,
        callback: Callable[[UUID4], None] | None = None,
        bint update_catalog = False,
        dict[str, object] params = None,
        bint join_request = False,
    ):
        """
        Request `Instrument` data for the given instrument ID.

        If `end` is ``None`` then will request up to the most recent data.

        Once the response is received, the instrument data is forwarded from the message bus
        to the `on_instrument` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the request.
        start : datetime, optional
            The start datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        end : datetime, optional
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has
            completed processing.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.
        join_request: bool, optional, default to False
            If a request should be joined and sorted with another one by using request_join.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        ValueError
            If `start` is not `None` and > current timestamp (now).
        ValueError
            If `end` is not `None` and > current timestamp (now).
        ValueError
            If `start` and `end` are not `None` and `start` is >= `end`.
        TypeError
            If `callback` is not `None` and not of type `Callable`.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(instrument_id, "instrument_id")
        Condition.callable_or_none(callback, "callback")

        cdef datetime now = self.clock.utc_now()

        if start is not None:
            Condition.is_true(start <= now, "start was > now")

        if end is not None:
            Condition.is_true(end <= now, "end was > now")

        if start is not None and end is not None:
            Condition.is_true(start <= end, "start was > end")

        params = params or {}
        params["update_catalog"] = update_catalog
        params["join_request"] = join_request

        cdef UUID4 request_id = UUID4()
        cdef RequestInstrument request = RequestInstrument(
            instrument_id=instrument_id,
            start=start,
            end=end,
            client_id=client_id,
            venue=instrument_id.venue,
            callback=self._handle_instruments_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._requests[request_id] = request
        self._pending_requests[request_id] = callback

        self._msgbus.subscribe(
            topic=self._topic_cache.get_instrument_topic(instrument_id),
            handler=self.handle_instrument,
        )

        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_instruments(
        self,
        Venue venue,
        datetime start = None,
        datetime end = None,
        ClientId client_id = None,
        callback: Callable[[UUID4], None] | None = None,
        bint update_catalog = False,
        dict[str, object] params = None,
        bint join_request = False,
    ):
        """
        Request all `Instrument` data for the given venue.

        If `end` is ``None`` then will request up to the most recent data.

        Once the response is received, the instrument data is forwarded from the message bus
        to the `on_instrument` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        venue : Venue
            The venue for the request.
        start : datetime, optional
            The start datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        end : datetime, optional
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has
            completed processing.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client:
            - `only_last` (default `True`) retains only the latest instrument record per instrument_id, based on the most recent ts_init.
        join_request: bool, optional, default to False
            If a request should be joined and sorted with another one by using request_join.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        ValueError
            If `start` is not `None` and > current timestamp (now).
        ValueError
            If `end` is not `None` and > current timestamp (now).
        ValueError
            If `start` and `end` are not `None` and `start` is >= `end`.
        TypeError
            If `callback` is not `None` and not of type `Callable`.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(venue, "venue")
        Condition.callable_or_none(callback, "callback")

        cdef datetime now = self.clock.utc_now()

        if start is not None:
            Condition.is_true(start <= now, "start was > now")

        if end is not None:
            Condition.is_true(end <= now, "end was > now")

        if start is not None and end is not None:
            Condition.is_true(start <= end, "start was > end")

        params = params or {}
        params["update_catalog"] = update_catalog
        params["join_request"] = join_request

        cdef UUID4 request_id = UUID4()
        cdef RequestInstruments request = RequestInstruments(
            start=start,
            end=end,
            client_id=client_id,
            venue=venue,
            callback=self._handle_instruments_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._requests[request_id] = request
        self._pending_requests[request_id] = callback

        self._msgbus.subscribe(
            topic=self._topic_cache.get_instruments_topic(venue),
            handler=self.handle_instrument,
        )

        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_order_book_snapshot(
        self,
        InstrumentId instrument_id,
        int limit = 0,
        ClientId client_id = None,
        callback: Callable[[UUID4], None] | None = None,
        dict[str, object] params = None,
        bint join_request = False,
    ):
        """
        Request an order book snapshot.

        Once the response is received, the order book data is forwarded from the message bus
        to the `on_historical_data` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the order book snapshot request.
        limit : int, optional
            The limit on the depth of the order book snapshot.
        client_id : ClientId, optional
            The specific client ID for the command.
            If None, it will be inferred from the venue in the instrument ID.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has completed processing.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.
        join_request: bool, optional, default to False
            If a request should be joined and sorted with another one by using request_join.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        ValueError
            If the instrument_id is None.
        TypeError
            If callback is not None and not of type Callable.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(instrument_id, "instrument_id")
        Condition.callable_or_none(callback, "callback")

        params = params or {}
        params["join_request"] = join_request

        cdef UUID4 request_id = UUID4()
        cdef RequestOrderBookSnapshot request = RequestOrderBookSnapshot(
            instrument_id=instrument_id,
            limit=limit,
            client_id=client_id,
            venue=instrument_id.venue,
            callback=self._handle_data_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._pending_requests[request_id] = callback
        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_order_book_depth(
        self,
        InstrumentId instrument_id,
        datetime start,
        datetime end = None,
        int limit = 0,
        int depth = 10,
        ClientId client_id = None,
        callback: Callable[[UUID4], None] | None = None,
        bint update_catalog = False,
        dict[str, object] params = None,
        bint join_request = False,
    ):
        """
        Request historical `OrderBookDepth10` snapshots.

        Once the response is received, the order book depth data is forwarded from the message bus
        to the `on_historical_data` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the order book depths request.
        start : datetime
            The start datetime (UTC) of request time range (inclusive).
        end : datetime, optional
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        limit : int, optional
            The limit on the amount of depth snapshots received.
        depth : int, optional
            The maximum depth for the returned order book data (default is 10).
        client_id : ClientId, optional
            The specific client ID for the command.
            If None, it will be inferred from the venue in the instrument ID.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has completed processing.
        update_catalog : bool, default False
            If the data catalog should be updated with the received data.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.
        join_request: bool, optional, default to False
            If a request should be joined and sorted with another one by using request_join.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        ValueError
            If the instrument_id is None.
        TypeError
            If callback is not None and not of type Callable.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(instrument_id, "instrument_id")
        Condition.callable_or_none(callback, "callback")

        start, end = self._validate_datetime_range(start, end)

        params = params or {}
        params["update_catalog"] = update_catalog
        params["join_request"] = join_request

        cdef UUID4 request_id = UUID4()
        cdef RequestOrderBookDepth request = RequestOrderBookDepth(
            instrument_id=instrument_id,
            start=start,
            end=end,
            limit=limit,
            depth=depth,
            client_id=client_id,
            venue=instrument_id.venue,
            callback=self._handle_order_book_depth_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._requests[request_id] = request
        self._pending_requests[request_id] = callback

        self._msgbus.subscribe(
            topic=self._topic_cache.get_depth_topic(instrument_id, historical=True),
            handler=self.handle_historical_order_book_depth,
        )

        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_quote_ticks(
        self,
        InstrumentId instrument_id,
        datetime start,
        datetime end = None,
        int limit = 0,
        ClientId client_id = None,
        callback: Callable[[UUID4], None] | None = None,
        bint update_catalog = False,
        dict[str, object] params = None,
        bint join_request = False,
    ):
        """
        Request historical `QuoteTick` data.

        If `end` is ``None`` then will request up to the most recent data.

        Once the response is received, the quote tick data is forwarded from the message bus
        to the `on_historical_data` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument ID for the request.
        start : datetime
            The start datetime (UTC) of request time range.
            Should be left-inclusive (start <= value), but inclusiveness is not currently guaranteed.
        end : datetime, optional
            The end datetime (UTC) of request time range.
            If `None` then will be replaced with the current UTC time.
            Should be right-inclusive (value <= end), but inclusiveness is not currently guaranteed.
        limit : int, optional
            The limit on the amount of quote ticks received.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has
            completed processing.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.
        join_request: bool, optional, default to False
            If a request should be joined and sorted with another one by using request_join.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        TypeError
            If `start` is `None`.
        ValueError
            If `start` is > current timestamp (now).
        ValueError
            If `end` is > current timestamp (now).
        ValueError
            If `start` is > `end`.
        TypeError
            If `callback` is not `None` and not of type `Callable`.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(instrument_id, "instrument_id")
        Condition.callable_or_none(callback, "callback")

        start, end = self._validate_datetime_range(start, end)

        params = params or {}
        params["update_catalog"] = update_catalog
        params["join_request"] = join_request

        cdef UUID4 request_id = UUID4()
        cdef RequestQuoteTicks request = RequestQuoteTicks(
            instrument_id=instrument_id,
            start=start,
            end=end,
            limit=limit,
            client_id=client_id,
            venue=instrument_id.venue,
            callback=self._handle_quote_ticks_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._requests[request_id] = request
        self._pending_requests[request_id] = callback

        self._msgbus.subscribe(
            topic=self._topic_cache.get_quotes_topic(instrument_id, historical=True),
            handler=self.handle_historical_quote_tick,
        )

        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_trade_ticks(
        self,
        InstrumentId instrument_id,
        datetime start,
        datetime end = None,
        int limit = 0,
        ClientId client_id = None,
        callback: Callable[[UUID4], None] | None = None,
        bint update_catalog = False,
        dict[str, object] params = None,
        bint join_request = False,
    ):
        """
        Request historical `TradeTick` data.

        If `end` is ``None`` then will request up to the most recent data.

        Once the response is received, the trade tick data is forwarded from the message bus
        to the `on_historical_data` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument ID for the request.
        start : datetime
            The start datetime (UTC) of request time range.
            Should be left-inclusive (start <= value), but inclusiveness is not currently guaranteed.
        end : datetime, optional
            The end datetime (UTC) of request time range.
            If `None` then will be replaced with the current UTC time.
            Should be right-inclusive (value <= end), but inclusiveness is not currently guaranteed.
        limit : int, optional
            The limit on the amount of trade ticks received.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has
            completed processing.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        TypeError
            If `start` is `None`.
        ValueError
            If `start` is > current timestamp (now).
        ValueError
            If `end` is > current timestamp (now).
        ValueError
            If `start` is > `end`.
        TypeError
            If `callback` is not `None` and not of type `Callable`.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(instrument_id, "instrument_id")
        Condition.callable_or_none(callback, "callback")

        start, end = self._validate_datetime_range(start, end)

        params = params or {}
        params["update_catalog"] = update_catalog
        params["join_request"] = join_request

        cdef UUID4 request_id = UUID4()
        cdef RequestTradeTicks request = RequestTradeTicks(
            instrument_id=instrument_id,
            start=start,
            end=end,
            limit=limit,
            client_id=client_id,
            venue=instrument_id.venue,
            callback=self._handle_trade_ticks_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._requests[request_id] = request
        self._pending_requests[request_id] = callback

        self._msgbus.subscribe(
            topic=self._topic_cache.get_trades_topic(instrument_id, historical=True),
            handler=self.handle_historical_trade_tick,
        )

        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_bars(
        self,
        BarType bar_type,
        datetime start,
        datetime end = None,
        int limit = 0,
        ClientId client_id = None,
        callback: Callable[[UUID4], None] | None = None,
        bint update_catalog = False,
        dict[str, object] params = None,
        bint join_request = False,
    ):
        """
        Request historical `Bar` data.

        If `end` is ``None`` then will request up to the most recent data.

        Once the response is received, the bar data is forwarded from the message bus
        to the `on_historical_data` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        bar_type : BarType
            The bar type for the request.
        start : datetime
            The start datetime (UTC) of request time range.
            Should be left-inclusive (start <= value), but inclusiveness is not currently guaranteed.
        end : datetime, optional
            The end datetime (UTC) of request time range.
            If `None` then will be replaced with the current UTC time.
            Should be right-inclusive (value <= end), but inclusiveness is not currently guaranteed.
        limit : int, optional
            The limit on the amount of bars received.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has
            completed processing.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.
        join_request: bool, optional, default to False
            If a request should be joined and sorted with another one by using request_join.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        TypeError
            If `start` is `None`.
        ValueError
            If `start` is > current timestamp (now).
        ValueError
            If `end` is > current timestamp (now).
        ValueError
            If `start` is > `end`.
        TypeError
            If `callback` is not `None` and not of type `Callable`.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(bar_type, "bar_type")
        Condition.is_true(bar_type.is_standard(), "Use a standard bar type with request_bars. Composite bar types can be used with request_aggregated_bars")
        Condition.callable_or_none(callback, "callback")

        start, end = self._validate_datetime_range(start, end)

        params = params or {}
        params["update_catalog"] = update_catalog
        params["join_request"] = join_request

        cdef UUID4 request_id = UUID4()
        cdef BarType standard_bar_type = bar_type.standard()
        cdef RequestBars request = RequestBars(
            bar_type=bar_type,
            start=start,
            end=end,
            limit=limit,
            client_id=client_id,
            venue=bar_type.instrument_id.venue,
            callback=self._handle_bars_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._requests[request_id] = request
        self._pending_requests[request_id] = callback

        self._msgbus.subscribe(
            topic=self._topic_cache.get_bars_topic(standard_bar_type, historical=True),
            handler=self.handle_historical_bar,
        )

        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_aggregated_bars(
        self,
        list bar_types,
        datetime start,
        datetime end = None,
        int limit = 0,
        ClientId client_id = None,
        callback: Callable[[UUID4], None] | None = None,
        bint include_external_data = False,
        bint update_subscriptions = False,
        bint update_catalog = False,
        dict[str, object] params = None,
    ):
        """
        Request historical aggregated `Bar` data for multiple bar types.
        The first bar is used to determine which market data type will be queried.
        This can either be quotes, trades or bars. If bars are queried,
        the first bar type needs to have a composite bar that is external (i.e. not internal/aggregated).
        This external bar type will be queried.

        If `end` is ``None`` then will request up to the most recent data.

        Once the response is received, the bar data is forwarded from the message bus
        to the `on_historical_data` handler. Any tick data used for aggregation is also
        forwarded to the `on_historical_data` handler.

        If the request fails, then an error is logged.

        Parameters
        ----------
        bar_types : list[BarType]
            The list of bar types for the request. Composite bars can also be used and need to
            figure in the list after a BarType on which it depends.
        start : datetime
            The start datetime (UTC) of request time range.
            Should be left-inclusive (start <= value), but inclusiveness is not currently guaranteed.
        end : datetime, optional
            The end datetime (UTC) of request time range.
            If `None` then will be replaced with the current UTC time.
            Should be right-inclusive (value <= end), but inclusiveness is not currently guaranteed.
        limit : int, optional
            The limit on the amount of data received (quote ticks, trade ticks or bars).
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has
            completed processing.
        include_external_data : bool, default False
            If True, includes the queried external data in the response.
        update_subscriptions : bool, default False
            If True, persists the aggregator of each bar_type so it's up to date for a subsequent
            market data subscription.
        update_catalog : bool, default False
            Whether to update a catalog with the received data.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        TypeError
            If `start` is `None`.
        ValueError
            If `start` is > current timestamp (now).
        ValueError
            If `end` is > current timestamp (now).
        ValueError
            If `start` is > `end`.
        ValueError
            If `bar_types` is empty.
        TypeError
            If `callback` is not `None` and not of type `Callable`.
        TypeError
            If `bar_types` is empty or contains elements not of type `BarType`.

        Notes
        -----
        - Make sure no subscription is active for the same underlying market data as the requested bar types.
        - A subscription can follow request_aggregated_bars and use an up to date aggregator when
          using the `update_subscriptions` parameter.
        - Subscribe to market data as a callback to request_aggregated_bars.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_empty(bar_types, "bar_types")
        Condition.list_type(bar_types, BarType, "bar_types")
        Condition.callable_or_none(callback, "callback")

        start, end = self._validate_datetime_range(start, end)

        for bar_type in bar_types:
            if not bar_type.is_internally_aggregated():
                self._log.error(f"request_aggregated_bars: {bar_type} must be internally aggregated")
                return

        cdef UUID4 request_id = UUID4()
        cdef BarType first_bar_type = bar_types[0]

        params = params or {}
        params["bar_types"] = tuple(bar_types)
        params["include_external_data"] = include_external_data
        params["update_subscriptions"] = update_subscriptions
        params["update_catalog"] = update_catalog

        # Subscribe to all requested bar types (historical topics for aggregated bars)
        for bar_type in bar_types:
            self._msgbus.subscribe(
                topic=self._topic_cache.get_bars_topic(bar_type.standard(), historical=True),
                handler=self.handle_historical_bar,
            )

        if first_bar_type.is_composite():
            request = RequestBars(
                bar_type=first_bar_type.composite(),
                start=start,
                end=end,
                limit=limit,
                client_id=client_id,
                venue=first_bar_type.instrument_id.venue,
                callback=self._handle_aggregated_bars_response,
                request_id=request_id,
                ts_init=self._clock.timestamp_ns(),
                params=params,
            )

            if include_external_data:
                self._msgbus.subscribe(
                    topic=self._topic_cache.get_bars_topic(first_bar_type.composite(), historical=True),
                    handler=self.handle_historical_bar,
                )
        elif first_bar_type.spec.price_type == PriceType.LAST:
            request = RequestTradeTicks(
                instrument_id=first_bar_type.instrument_id,
                start=start,
                end=end,
                limit=limit,
                client_id=client_id,
                venue=first_bar_type.instrument_id.venue,
                callback=self._handle_aggregated_bars_response,
                request_id=request_id,
                ts_init=self._clock.timestamp_ns(),
                params=params,
            )

            if include_external_data:
                self._msgbus.subscribe(
                    topic=self._topic_cache.get_trades_topic(first_bar_type.instrument_id, historical=True),
                    handler=self.handle_historical_trade_tick,
                )
        else:
            request = RequestQuoteTicks(
                instrument_id=first_bar_type.instrument_id,
                start=start,
                end=end,
                limit=limit,
                client_id=client_id,
                venue=first_bar_type.instrument_id.venue,
                callback=self._handle_aggregated_bars_response,
                request_id=request_id,
                ts_init=self._clock.timestamp_ns(),
                params=params,
            )

            if include_external_data:
                self._msgbus.subscribe(
                    topic=self._topic_cache.get_quotes_topic(first_bar_type.instrument_id, historical=True),
                    handler=self.handle_historical_quote_tick,
                )

        self._pending_requests[request_id] = callback
        self._send_data_req(request)

        return request_id

    cpdef UUID4 request_join(
        self,
        tuple request_ids,
        datetime start,
        datetime end = None,
        ClientId client_id = None,
        Venue venue = None,
        callback: Callable[[UUID4], None] | None = None,
        dict[str, object] params = None,
    ):
        """
        Request a join of multiple data requests.

        This method creates a RequestJoin message that will coordinate multiple
        sub-requests and combine their results.

        Parameters
        ----------
        request_ids : tuple[UUID4]
            The tuple of request IDs to join.
        start : datetime
            The start datetime (UTC) of request time range (inclusive).
        end : datetime, optional
            The end datetime (UTC) of request time range.
            If `None` then will be replaced with the current UTC time.
        client_id : ClientId, optional
            The data client ID for the request.
        venue : Venue, optional
            The venue for the request.
        callback : Callable[[UUID4], None], optional
            The registered callback, to be called with the request ID when the response has
            completed processing.
        params : dict[str, Any], optional
            Additional parameters for the request.


        Returns
        -------
        UUID4
            The `request_id` for the request.

        Raises
        ------
        ValueError
            If both `client_id` and `venue` are both ``None`` (not enough routing info).
        TypeError
            If `callback` is not `None` and not of type `Callable`.

        """
        Condition.is_true(self.trader_id is not None, "The actor has not been registered")
        Condition.not_none(request_ids, "request_ids")
        Condition.callable_or_none(callback, "callback")

        start, end = self._validate_datetime_range(start, end)

        params = params or {}

        cdef UUID4 request_id = UUID4()
        cdef RequestJoin request = RequestJoin(
            request_ids=request_ids,
            start=start,
            end=end,
            callback=self._handle_join_response,
            request_id=request_id,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._pending_requests[request_id] = callback
        self._send_data_req(request)

        return request_id

    cpdef bint is_pending_request(self, UUID4 request_id):
        """
        Return whether the request for the given identifier is pending processing.

        Parameters
        ----------
        request_id : UUID4
            The request ID to check.

        Returns
        -------
        bool
            True if request is pending, else False.

        """
        return request_id in self._pending_requests

    cpdef bint has_pending_requests(self):
        """
        Return whether the actor is pending processing for any requests.

        Returns
        -------
        bool
            True if any requests are pending, else False.

        """
        return len(self._pending_requests) > 0

    cpdef set pending_requests(self):
        """
        Return the request IDs which are currently pending processing.

        Returns
        -------
        set[UUID4]

        """
        return set(self._pending_requests.keys())

# -- HANDLERS -------------------------------------------------------------------------------------

    cpdef void handle_instrument(self, Instrument instrument):
        """
        Handle the given instrument.

        Passes to `on_instrument` if state is ``RUNNING``.

        Parameters
        ----------
        instrument : Instrument
            The instrument received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(instrument, "instrument")

        if self._fsm.state in (ComponentState.STARTING, ComponentState.RUNNING):
            try:
                self.on_instrument(instrument)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(instrument)}", e)

    cpdef void handle_order_book_deltas(self, deltas):
        """
        Handle the given order book deltas.

        Passes to `on_order_book_deltas` if state is ``RUNNING``.
        The `deltas` will be `nautilus_pyo3.OrderBookDeltas` if the
        pyo3_conversion flag was set for the subscription.

        Parameters
        ----------
        deltas : OrderBookDeltas or nautilus_pyo3.OrderBookDeltas
            The order book deltas received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(deltas, "deltas")

        if OrderBookDeltas in self._pyo3_conversion_types:
            deltas = deltas.to_pyo3()

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_order_book_deltas(deltas)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(deltas)}", e)
                raise

    cpdef void handle_historical_order_book_depth(self, OrderBookDepth10 depth):
        self.handle_order_book_depth(depth, True)

    cpdef void handle_order_book_depth(self, OrderBookDepth10 depth, bint historical=False):
        """
        Handle the given order book depth

        Passes to `on_order_book_depth` if state is ``RUNNING``.

        Parameters
        ----------
        depth : OrderBookDepth10
            The order book depth received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(depth, "depth")

        if historical:
            self.handle_historical_data(depth)
        elif self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_order_book_depth(depth)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(depth)}", e)
                raise

    cpdef void handle_order_book(self, OrderBook order_book):
        """
        Handle the given order book.

        Passes to `on_order_book` if state is ``RUNNING``.

        Parameters
        ----------
        order_book : OrderBook
            The order book received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(order_book, "order_book")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_order_book(order_book)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(order_book)}", e)
                raise

    cpdef void handle_historical_quote_tick(self, QuoteTick tick):
        self.handle_quote_tick(tick, True)

    cpdef void handle_quote_tick(self, QuoteTick tick, bint historical=False):
        """
        Handle the given quote tick.

        If state is ``RUNNING`` then passes to `on_quote_tick`.

        Parameters
        ----------
        tick : QuoteTick
            The tick received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(tick, "tick")

        # Update indicators
        cdef list indicators = self._indicators_for_quotes.get(tick.instrument_id)
        if indicators:
            self._handle_indicators_for_quote(indicators, tick)

        if historical:
            self.handle_historical_data(tick)
        elif self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_quote_tick(tick)
            except Exception as e:
                self.log.exception(f"Error on handling {repr(tick)}", e)
                raise

    cpdef void _handle_indicators_for_quote(self, list indicators, QuoteTick tick):
        cdef Indicator indicator
        for indicator in indicators:
            indicator.handle_quote_tick(tick)

    cpdef void handle_historical_trade_tick(self, TradeTick tick):
        self.handle_trade_tick(tick, True)

    cpdef void handle_trade_tick(self, TradeTick tick, bint historical=False):
        """
        Handle the given trade tick.

        If state is ``RUNNING`` then passes to `on_trade_tick`.

        Parameters
        ----------
        tick : TradeTick
            The tick received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(tick, "tick")

        # Update indicators
        cdef list indicators = self._indicators_for_trades.get(tick.instrument_id)
        if indicators:
            self._handle_indicators_for_trade(indicators, tick)

        if historical:
            self.handle_historical_data(tick)
        elif self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_trade_tick(tick)
            except Exception as e:
                self.log.exception(f"Error on handling {repr(tick)}", e)
                raise

    cpdef void _handle_indicators_for_trade(self, list indicators, TradeTick tick):
        cdef Indicator indicator
        for indicator in indicators:
            indicator.handle_trade_tick(tick)

    cpdef void handle_mark_price(self, MarkPriceUpdate mark_price):
        """
        Handle the given mark price update.

        If state is ``RUNNING`` then passes to `on_mark_price`.

        Parameters
        ----------
        mark_price : MarkPriceUpdate
            The mark price update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(mark_price, "mark_price")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_mark_price(mark_price)
            except Exception as e:
                self.log.exception(f"Error on handling {repr(mark_price)}", e)
                raise

    cpdef void handle_index_price(self, IndexPriceUpdate index_price):
        """
        Handle the given index price update.

        If state is ``RUNNING`` then passes to `on_index_price`.

        Parameters
        ----------
        index_price : IndexPriceUpdate
            The index price update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(index_price, "index_price")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_index_price(index_price)
            except Exception as e:
                self.log.exception(f"Error on handling {repr(index_price)}", e)
                raise

    cpdef void handle_funding_rate(self, FundingRateUpdate funding_rate):
        """
        Handle the given funding rate update.

        If state is ``RUNNING`` then passes to `on_funding_rate`.

        Parameters
        ----------
        funding_rate : FundingRateUpdate
            The funding rate update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(funding_rate, "funding_rate")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_funding_rate(funding_rate)
            except Exception as e:
                self.log.exception(f"Error on handling {repr(funding_rate)}", e)
                raise

    cpdef void handle_historical_bar(self, Bar bar):
        self.handle_bar(bar, True)

    cpdef void handle_bar(self, Bar bar, bint historical=False):
        """
        Handle the given bar data.

        If state is ``RUNNING`` then passes to `on_bar`.

        Parameters
        ----------
        bar : Bar
            The bar received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(bar, "bar")

        # Update indicators
        cdef list indicators = self._indicators_for_bars.get(bar.bar_type.id_spec_key())
        if indicators:
            self._handle_indicators_for_bar(indicators, bar)

        if historical:
            self.handle_historical_data(bar)
        elif self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_bar(bar)
            except Exception as e:
                self.log.exception(f"Error on handling {repr(bar)}", e)
                raise

    cpdef void _handle_indicators_for_bar(self, list indicators, Bar bar):
        cdef Indicator indicator
        for indicator in indicators:
            indicator.handle_bar(bar)

    cpdef void handle_instrument_status(self, InstrumentStatus data):
        """
        Handle the given instrument status update.

        If state is ``RUNNING`` then passes to `on_instrument_status`.

        Parameters
        ----------
        data : InstrumentStatus
            The status update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(data, "data")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_instrument_status(data)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(data)}", e)
                raise

    cpdef void handle_instrument_close(self, InstrumentClose update):
        """
        Handle the given instrument close update.

        If state is ``RUNNING`` then passes to `on_instrument_close`.

        Parameters
        ----------
        update : InstrumentClose
            The update received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(update, "update")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_instrument_close(update)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(update)}", e)
                raise

    cpdef void _handle_order_filled(self, OrderFilled event):
        if str(event.strategy_id) == str(self.id):
            # This represents a strategies automatic subscription to it's own
            # order events, so we don't need to pass this event to the handler twice
            return

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_order_filled(event)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(event)}", e)
                raise

    cpdef void handle_data(self, Data data):
        """
        Handle the given data.

        If state is ``RUNNING`` then passes to `on_data`.

        Parameters
        ----------
        data : Data
            The data received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(data, "data")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_data(data)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(data)}", e)
                raise

    cpdef void handle_signal(self, Data signal):
        """
        Handle the given signal.

        If state is ``RUNNING`` then passes to `on_signal`.

        Parameters
        ----------
        signal : Data
            The signal received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(signal, "signal")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_signal(signal)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(signal)}", e)
                raise

    cpdef void handle_historical_data(self, data):
        """
        Handle the given historical data.

        Parameters
        ----------
        data : Data
            The historical data received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(data, "data")

        if self._fsm.state in (ComponentState.STARTING, ComponentState.RUNNING):
            try:
                self.on_historical_data(data)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(data)}", e)
                raise

    cpdef void handle_event(self, Event event):
        """
        Handle the given event.

        If state is ``RUNNING`` then passes to `on_event`.

        Parameters
        ----------
        event : Event
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(event, "event")

        if self._fsm.state == ComponentState.RUNNING:
            try:
                self.on_event(event)
            except Exception as e:
                self._log.exception(f"Error on handling {repr(event)}", e)
                raise

    cpdef void _handle_data_response(self, DataResponse response):
        cdef RequestData request = self._requests.pop(response.correlation_id, None)
        if request is not None:
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_custom_data_topic(request.data_type, request.instrument_id, historical=True),
                handler=self.handle_historical_data,
            )

        self._finish_response(response.correlation_id)

    cpdef void _handle_join_response(self, DataResponse response):
        self._finish_response(response.correlation_id)

    cpdef void _handle_instruments_response(self, DataResponse response):
        cdef RequestData request = self._requests.pop(response.correlation_id, None)
        if request is not None:
            if isinstance(request, RequestInstruments):
                self._msgbus.unsubscribe(
                    topic=self._topic_cache.get_instruments_topic(request.venue),
                    handler=self.handle_instrument,
                )
            else:
                self._msgbus.unsubscribe(
                    topic=self._topic_cache.get_instrument_topic(request.instrument_id),
                    handler=self.handle_instrument,
                )

        self._finish_response(response.correlation_id)

    cpdef void _handle_quote_ticks_response(self, DataResponse response):
        cdef RequestQuoteTicks request = self._requests.pop(response.correlation_id, None)
        if request is not None:
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_quotes_topic(request.instrument_id, historical=True),
                handler=self.handle_historical_quote_tick,
            )

        cdef int length = response.params.get("data_count", 0)
        cdef InstrumentId instrument_id = request.instrument_id

        if length > 0:
            self._log.info(f"Received <QuoteTick[{length}]> data for {instrument_id}")
        else:
            self._log.warning(f"Received <QuoteTick[]> data with no ticks for {instrument_id}")

        self._finish_response(response.correlation_id)

    cpdef void _handle_trade_ticks_response(self, DataResponse response):
        cdef RequestTradeTicks request = self._requests.pop(response.correlation_id, None)
        if request is not None:
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_trades_topic(request.instrument_id, historical=True),
                handler=self.handle_historical_trade_tick,
            )

        cdef int length = response.params.get("data_count", 0)
        cdef InstrumentId instrument_id = request.instrument_id

        if length > 0:
            self._log.info(f"Received <TradeTick[{length}]> data for {instrument_id}")
        else:
            self._log.warning(f"Received <TradeTick[]> data with no ticks for {instrument_id}")

        self._finish_response(response.correlation_id)

    cpdef void _handle_order_book_depth_response(self, DataResponse response):
        cdef RequestOrderBookDepth request = self._requests.pop(response.correlation_id, None)
        if request is not None:
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_depth_topic(request.instrument_id, historical=True),
                handler=self.handle_historical_order_book_depth,
            )

        cdef int length = response.params.get("data_count", 0)
        cdef InstrumentId instrument_id = request.instrument_id

        if length > 0:
            self._log.info(f"Received <OrderBookDepth10[{length}]> data for {instrument_id}")
        else:
            self._log.warning(f"Received <OrderBookDepth10[]> data with no ticks for {instrument_id}")

        self._finish_response(response.correlation_id)

    cpdef void _handle_bars_response(self, DataResponse response):
        cdef RequestBars request = self._requests.pop(response.correlation_id, None)
        if request is not None:
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_bars_topic(request.bar_type.standard(), historical=True),
                handler=self.handle_historical_bar,
            )

        cdef int length = response.params.get("data_count", 0)
        cdef BarType bar_type = request.bar_type

        if length > 0:
            self._log.info(f"Received <Bar[{length}]> data for {bar_type}")
        else:
            self._log.warning(f"Received <Bar[]> data with no bar for {bar_type}")

        self._finish_response(response.correlation_id)

    cpdef void _handle_aggregated_bars_response(self, DataResponse response):
        # Can be useful to keep subscriptions in place for example for later requesting order books that convert to quotes
        keep_subscriptions = response.params.get("keep_subscriptions", False)

        if not keep_subscriptions:
            bar_types = response.params.get("bar_types", ())
            include_external_data = response.params.get("include_external_data", False)
            self._unsubscribe_historical_aggregated_bars(bar_types, include_external_data)

        self._finish_response(response.correlation_id)

    cpdef void _unsubscribe_historical_aggregated_bars(self, tuple bar_types, bint include_external_data = False):
        # Unsubscribe from all aggregated bar types (historical topics)
        for bar_type in bar_types:
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_bars_topic(bar_type.standard(), historical=True),
                handler=self.handle_historical_bar,
            )

        # Unsubscribe from underlying data topic based on first bar type (historical topics)
        first_bar_type = bar_types[0] if bar_types else None
        if include_external_data and first_bar_type is not None:
            if first_bar_type.is_composite():
                # Unsubscribe from composite bar topic
                self._msgbus.unsubscribe(
                    topic=self._topic_cache.get_bars_topic(first_bar_type.composite().standard(), historical=True),
                    handler=self.handle_historical_bar,
                )
            elif first_bar_type.spec.price_type == PriceType.LAST:
                # Unsubscribe from trade ticks topic
                self._msgbus.unsubscribe(
                    topic=self._topic_cache.get_trades_topic(first_bar_type.instrument_id, historical=True),
                    handler=self.handle_historical_trade_tick,
                )
            else:
                # Unsubscribe from quote ticks topic
                self._msgbus.unsubscribe(
                    topic=self._topic_cache.get_quotes_topic(first_bar_type.instrument_id, historical=True),
                    handler=self.handle_historical_quote_tick,
                )

    cpdef void _finish_response(self, UUID4 request_id):
        callback: Callable | None = self._pending_requests.pop(request_id, None)
        if callback is not None:
            callback(request_id)

# -- EGRESS ---------------------------------------------------------------------------------------

    cdef void _send_data_cmd(self, DataCommand command):
        if self._log_commands and is_logging_initialized():
            self._log.info(f"{CMD}{SENT} {command}")

        self._msgbus.send(endpoint="DataEngine.execute", msg=command)

    cdef void _send_data_req(self, RequestData request):
        if is_logging_initialized():
            self._log.info(f"{REQ}{SENT} {request}")

        self._msgbus.request(endpoint="DataEngine.request", request=request)

</document_content>
</document>
<document index="2247">
<source>nautilus_trader/common/component.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import asyncio
import copy
import socket
import sys
import traceback
from collections import deque
from typing import Any
from typing import Callable

import cython
import msgspec
import numpy as np
import pandas as pd
import pytz

from nautilus_trader.common.config import NautilusConfig
from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.core.rust.common import ComponentState as PyComponentState

cimport numpy as np
from cpython.datetime cimport datetime
from cpython.datetime cimport timedelta
from cpython.datetime cimport tzinfo
from cpython.object cimport PyObject
from cpython.pycapsule cimport PyCapsule_GetPointer
from libc.stdint cimport int64_t
from libc.stdint cimport uint32_t
from libc.stdint cimport uint64_t

from nautilus_trader.common.messages cimport ComponentStateChanged
from nautilus_trader.common.messages cimport ShutdownSystem
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport dt_to_unix_nanos
from nautilus_trader.core.datetime cimport maybe_dt_to_unix_nanos
from nautilus_trader.core.fsm cimport FiniteStateMachine
from nautilus_trader.core.fsm cimport InvalidStateTrigger
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.common cimport ComponentState
from nautilus_trader.core.rust.common cimport ComponentTrigger
from nautilus_trader.core.rust.common cimport LogColor
from nautilus_trader.core.rust.common cimport LogGuard_API
from nautilus_trader.core.rust.common cimport LogLevel
from nautilus_trader.core.rust.common cimport TimeEventHandler_t
from nautilus_trader.core.rust.common cimport component_state_from_cstr
from nautilus_trader.core.rust.common cimport component_state_to_cstr
from nautilus_trader.core.rust.common cimport component_trigger_from_cstr
from nautilus_trader.core.rust.common cimport component_trigger_to_cstr
from nautilus_trader.core.rust.common cimport is_matching_ffi
from nautilus_trader.core.rust.common cimport live_clock_cancel_timer
from nautilus_trader.core.rust.common cimport live_clock_drop
from nautilus_trader.core.rust.common cimport live_clock_new
from nautilus_trader.core.rust.common cimport live_clock_next_time
from nautilus_trader.core.rust.common cimport live_clock_register_default_handler
from nautilus_trader.core.rust.common cimport live_clock_set_time_alert
from nautilus_trader.core.rust.common cimport live_clock_set_timer
from nautilus_trader.core.rust.common cimport live_clock_timer_count
from nautilus_trader.core.rust.common cimport live_clock_timer_names
from nautilus_trader.core.rust.common cimport live_clock_timestamp
from nautilus_trader.core.rust.common cimport live_clock_timestamp_ms
from nautilus_trader.core.rust.common cimport live_clock_timestamp_ns
from nautilus_trader.core.rust.common cimport live_clock_timestamp_us
from nautilus_trader.core.rust.common cimport log_color_from_cstr
from nautilus_trader.core.rust.common cimport log_color_to_cstr
from nautilus_trader.core.rust.common cimport log_level_from_cstr
from nautilus_trader.core.rust.common cimport log_level_to_cstr
from nautilus_trader.core.rust.common cimport logger_drop
from nautilus_trader.core.rust.common cimport logger_flush
from nautilus_trader.core.rust.common cimport logger_log
from nautilus_trader.core.rust.common cimport logging_clock_set_realtime_mode
from nautilus_trader.core.rust.common cimport logging_clock_set_static_mode
from nautilus_trader.core.rust.common cimport logging_clock_set_static_time
from nautilus_trader.core.rust.common cimport logging_init
from nautilus_trader.core.rust.common cimport logging_is_initialized
from nautilus_trader.core.rust.common cimport logging_log_header
from nautilus_trader.core.rust.common cimport logging_log_sysinfo
from nautilus_trader.core.rust.common cimport test_clock_advance_time
from nautilus_trader.core.rust.common cimport test_clock_cancel_timer
from nautilus_trader.core.rust.common cimport test_clock_cancel_timers
from nautilus_trader.core.rust.common cimport test_clock_drop
from nautilus_trader.core.rust.common cimport test_clock_new
from nautilus_trader.core.rust.common cimport test_clock_next_time
from nautilus_trader.core.rust.common cimport test_clock_register_default_handler
from nautilus_trader.core.rust.common cimport test_clock_set_time
from nautilus_trader.core.rust.common cimport test_clock_set_time_alert
from nautilus_trader.core.rust.common cimport test_clock_set_timer
from nautilus_trader.core.rust.common cimport test_clock_timer_count
from nautilus_trader.core.rust.common cimport test_clock_timer_names
from nautilus_trader.core.rust.common cimport test_clock_timestamp
from nautilus_trader.core.rust.common cimport test_clock_timestamp_ms
from nautilus_trader.core.rust.common cimport test_clock_timestamp_ns
from nautilus_trader.core.rust.common cimport test_clock_timestamp_us
from nautilus_trader.core.rust.common cimport time_event_new
from nautilus_trader.core.rust.common cimport time_event_to_cstr
from nautilus_trader.core.rust.common cimport vec_time_event_handlers_drop
from nautilus_trader.core.rust.core cimport CVec
from nautilus_trader.core.rust.core cimport secs_to_nanos
from nautilus_trader.core.rust.core cimport uuid4_from_cstr
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.core.string cimport pybytes_to_cstr
from nautilus_trader.core.string cimport pystr_to_cstr
from nautilus_trader.core.string cimport ustr_to_pystr
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.identifiers cimport ComponentId
from nautilus_trader.model.identifiers cimport Identifier
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.serialization.base cimport _EXTERNAL_PUBLISHABLE_TYPES
from nautilus_trader.serialization.base cimport Serializer


cdef class Clock:
    """
    The base class for all clocks.

    Notes
    -----
    An *active* timer is one which has not expired.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    @property
    def timer_names(self) -> list[str]:
        """
        Return the names of *active* timers running in the clock.

        Returns
        -------
        list[str]

        """
        raise NotImplementedError("method `timer_names` must be implemented in the subclass")  # pragma: no cover

    @property
    def timer_count(self) -> int:
        """
        Return the count of *active* timers running in the clock.

        Returns
        -------
        int

        """
        raise NotImplementedError("method `timer_count` must be implemented in the subclass")  # pragma: no cover

    cpdef double timestamp(self):
        """
        Return the current UNIX timestamp in seconds.

        Returns
        -------
        double

        References
        ----------
        https://en.wikipedia.org/wiki/Unix_time

        """
        raise NotImplementedError("method `timestamp` must be implemented in the subclass")  # pragma: no cover

    cpdef uint64_t timestamp_ms(self):
        """
        Return the current UNIX timestamp in milliseconds (ms).

        Returns
        -------
        uint64_t

        References
        ----------
        https://en.wikipedia.org/wiki/Unix_time

        """
        raise NotImplementedError("method `timestamp_ms` must be implemented in the subclass")  # pragma: no cover

    cpdef uint64_t timestamp_us(self):
        """
        Return the current UNIX timestamp in microseconds (μs).

        Returns
        -------
        uint64_t

        References
        ----------
        https://en.wikipedia.org/wiki/Unix_time

        """
        raise NotImplementedError("method `timestamp_us` must be implemented in the subclass")  # pragma: no cover

    cpdef uint64_t timestamp_ns(self):
        """
        Return the current UNIX timestamp in nanoseconds (ns).

        Returns
        -------
        uint64_t

        References
        ----------
        https://en.wikipedia.org/wiki/Unix_time

        """
        raise NotImplementedError("method `timestamp_ns` must be implemented in the subclass")  # pragma: no cover

    cpdef datetime utc_now(self):
        """
        Return the current time (UTC).

        Returns
        -------
        datetime
            The current tz-aware UTC time of the clock.

        """
        return pd.Timestamp(self.timestamp_ns(), tz=pytz.utc)

    cpdef datetime local_now(self, tzinfo tz = None):
        """
        Return the current datetime of the clock in the given local timezone.

        Parameters
        ----------
        tz : tzinfo, optional
            The local timezone (if None the system local timezone is assumed for
            the target timezone).

        Returns
        -------
        datetime
            tz-aware in local timezone.

        """
        return self.utc_now().astimezone(tz)

    cpdef void register_default_handler(self, handler: Callable[[TimeEvent], None]):
        """
        Register the given handler as the clocks default handler.

        Parameters
        ----------
        handler : Callable[[TimeEvent], None]
            The handler to register.

        Raises
        ------
        TypeError
            If `handler` is not of type `Callable`.

        """
        raise NotImplementedError("method `register_default_handler` must be implemented in the subclass")  # pragma: no cover

    cpdef uint64_t next_time_ns(self, str name):
        """
        Find a particular timer.

        Parameters
        ----------
        name : str
            The name of the timer.

        Returns
        -------
        uint64_t

        Raises
        ------
        ValueError
            If `name` is not a valid string.

        """
        raise NotImplementedError("method `next_time_ns` must be implemented in the subclass")  # pragma: no cover

    cpdef void set_time_alert(
        self,
        str name,
        datetime alert_time,
        callback: Callable[[TimeEvent], None] = None,
        bint override = False,
        bint allow_past = True,
    ):
        """
        Set a time alert for the given time.

        When the time is reached the handler will be passed the `TimeEvent`
        containing the timers unique name. If no handler is passed then the
        default handler (if registered) will receive the `TimeEvent`.

        Parameters
        ----------
        name : str
            The name for the alert (must be unique for this clock).
        alert_time : datetime
            The time for the alert.
        callback : Callable[[TimeEvent], None], optional
            The callback to receive time events.
        override: bool, default False
            If override is set to True an alert with a given name can be overwritten if it exists already.
        allow_past : bool, default True
            If True, allows an `alert_time` in the past and adjusts it to the current time
            for immediate firing. If False, raises an error when the `alert_time` is in the
            past, requiring it to be in the future.

        Raises
        ------
        ValueError
            If `name` is not a valid string.
        KeyError
            If `name` is not unique for this clock.
        TypeError
            If `handler` is not of type `Callable` or ``None``.
        ValueError
            If `handler` is ``None`` and no default handler is registered.

        Warnings
        --------
        If `alert_time` is in the past or at current time, then an immediate
        time event will be generated (rather than being invalid and failing a condition check).

        """
        if override and self.next_time_ns(name) > 0:
            self.cancel_timer(name)

        self.set_time_alert_ns(
            name=name,
            alert_time_ns=dt_to_unix_nanos(alert_time),
            callback=callback,
            allow_past=allow_past,
        )

    cpdef void set_time_alert_ns(
        self,
        str name,
        uint64_t alert_time_ns,
        callback: Callable[[TimeEvent], None] = None,
        bint allow_past = True,
    ):
        """
        Set a time alert for the given time.

        When the time is reached the handler will be passed the `TimeEvent`
        containing the timers unique name. If no callback is passed then the
        default handler (if registered) will receive the `TimeEvent`.

        Parameters
        ----------
        name : str
            The name for the alert (must be unique for this clock).
        alert_time_ns : uint64_t
            The UNIX timestamp (nanoseconds) for the alert.
        callback : Callable[[TimeEvent], None], optional
            The callback to receive time events.
        allow_past : bool, default True
            If True, allows an `alert_time_ns` in the past and adjusts it to the current time
            for immediate firing. If False, panics when the `alert_time_ns` is in the
            past, requiring it to be in the future.

        Raises
        ------
        ValueError
            If `name` is not a valid string.
        ValueError
            If `name` is not unique for this clock.
        TypeError
            If `callback` is not of type `Callable` or ``None``.
        ValueError
            If `callback` is ``None`` and no default handler is registered.

        Warnings
        --------
        If `alert_time_ns` is in the past or at current time, then an immediate
        time event will be generated (rather than being invalid and failing a condition check).

        """
        raise NotImplementedError("method `set_time_alert_ns` must be implemented in the subclass")  # pragma: no cover

    cpdef void set_timer(
        self,
        str name,
        timedelta interval,
        datetime start_time = None,
        datetime stop_time = None,
        callback: Callable[[TimeEvent], None] | None = None,
        bint allow_past = True,
        bint fire_immediately = False,
    ):
        """
        Set a timer to run.

        The timer will run from the start time (optionally until the stop time).
        When the intervals are reached the handlers will be passed the
        `TimeEvent` containing the timers unique name. If no handler is passed
        then the default handler (if registered) will receive the `TimeEvent`.

        Parameters
        ----------
        name : str
            The name for the timer (must be unique for this clock).
        interval : timedelta
            The time interval for the timer.
        start_time : datetime, optional
            The start time for the timer (if None then starts immediately).
        stop_time : datetime, optional
            The stop time for the timer (if None then repeats indefinitely).
        callback : Callable[[TimeEvent], None], optional
            The callback to receive time events.
        allow_past : bool, default True
            If True, allows timers where the next event time may be in the past.
            If False, raises an error when the next event time would be in the past.
        fire_immediately : bool, default False
            If True, the timer will fire immediately at the start time,
            then fire again after each interval. If False, the timer will
            fire after the first interval has elapsed (default behavior).

        Raises
        ------
        ValueError
            If `name` is not a valid string.
        KeyError
            If `name` is not unique for this clock.
        ValueError
            If `interval` is not positive (> 0).
        ValueError
            If `stop_time` is not ``None`` and `stop_time` < time now.
        ValueError
            If `stop_time` is not ``None`` and `start_time` + `interval` > `stop_time`.
        TypeError
            If `handler` is not of type `Callable` or ``None``.
        ValueError
            If `handler` is ``None`` and no default handler is registered.

        """
        self.set_timer_ns(
            name=name,
            interval_ns=pd.Timedelta(interval).value,
            start_time_ns=maybe_dt_to_unix_nanos(start_time) or 0,
            stop_time_ns=maybe_dt_to_unix_nanos(stop_time) or 0,
            callback=callback,
            allow_past=allow_past,
            fire_immediately=fire_immediately,
        )

    cpdef void set_timer_ns(
        self,
        str name,
        uint64_t interval_ns,
        uint64_t start_time_ns,
        uint64_t stop_time_ns,
        callback: Callable[[TimeEvent], None] | None = None,
        bint allow_past = True,
        bint fire_immediately = False,
    ):
        """
        Set a timer to run.

        The timer will run from the start time until the stop time.
        When the intervals are reached the handlers will be passed the
        `TimeEvent` containing the timers unique name. If no handler is passed
        then the default handler (if registered) will receive the `TimeEvent`.

        Parameters
        ----------
        name : str
            The name for the timer (must be unique for this clock).
        interval_ns : uint64_t
            The time interval (nanoseconds) for the timer.
        start_time_ns : uint64_t
            The start UNIX timestamp (nanoseconds) for the timer.
        stop_time_ns : uint64_t
            The stop UNIX timestamp (nanoseconds) for the timer.
        callback : Callable[[TimeEvent], None], optional
            The callback to receive time events.
        allow_past : bool, default True
            If True, allows timers where the next event time may be in the past.
            If False, raises an error when the next event time would be in the past.
        fire_immediately : bool, default False
            If True, the timer will fire immediately at the start time,
            then fire again after each interval. If False, the timer will
            fire after the first interval has elapsed (default behavior).

        Raises
        ------
        ValueError
            If `name` is not a valid string.
        KeyError
            If `name` is not unique for this clock.
        ValueError
            If `interval` is not positive (> 0).
        ValueError
            If `stop_time` is not ``None`` and `stop_time` < time now.
        ValueError
            If `stop_time` is not ``None`` and `start_time` + interval > `stop_time`.
        TypeError
            If `callback` is not of type `Callable` or ``None``.
        ValueError
            If `callback` is ``None`` and no default handler is registered.

        """
        raise NotImplementedError("method `set_timer_ns` must be implemented in the subclass")  # pragma: no cover

    cpdef void cancel_timer(self, str name):
        """
        Cancel the timer corresponding to the given label.

        Parameters
        ----------
        name : str
            The name for the timer to cancel.

        Raises
        ------
        ValueError
            If `name` is not a valid string.
        KeyError
            If `name` is not an active timer name for this clock.

        """
        raise NotImplementedError("method `cancel_timer` must be implemented in the subclass")  # pragma: no cover

    cpdef void cancel_timers(self):
        """
        Cancel all timers.
        """
        raise NotImplementedError("method `cancel_timers` must be implemented in the subclass")  # pragma: no cover


# Global map of clocks per kernel instance used when running a `BacktestEngine`
_COMPONENT_CLOCKS = {}


cdef list[TestClock] get_component_clocks(UUID4 instance_id):
    # Create a shallow copy of the clocks list, in case a new
    # clock is registered during iteration.
    return _COMPONENT_CLOCKS[instance_id].copy()


cpdef void register_component_clock(UUID4 instance_id, Clock clock):
    Condition.not_none(instance_id, "instance_id")
    Condition.not_none(clock, "clock")

    cdef list[Clock] clocks = _COMPONENT_CLOCKS.get(instance_id)
    if clocks is None:
        clocks = []
        _COMPONENT_CLOCKS[instance_id] = clocks

    if clock not in clocks:
        clocks.append(clock)


cpdef void deregister_component_clock(UUID4 instance_id, Clock clock):
    Condition.not_none(instance_id, "instance_id")
    Condition.not_none(clock, "clock")

    cdef list[Clock] clocks = _COMPONENT_CLOCKS.get(instance_id)

    if clocks is None:
        return

    if clock in clocks:
        clocks.remove(clock)


cpdef void remove_instance_component_clocks(UUID4 instance_id):
    Condition.not_none(instance_id, "instance_id")

    _COMPONENT_CLOCKS.pop(instance_id, None)


# Global backtest force stop flag
_FORCE_STOP = False

cpdef void set_backtest_force_stop(bint value):
    global FORCE_STOP
    FORCE_STOP = value


cpdef bint is_backtest_force_stop():
    return FORCE_STOP


cdef class TestClock(Clock):
    """
    Provides a monotonic clock for backtesting and unit testing.

    """

    __test__ = False  # Prevents pytest from collecting this as a test class

    def __init__(self):
        self._mem = test_clock_new()

    def __del__(self) -> None:
        if self._mem._0 != NULL:
            test_clock_drop(self._mem)

    @property
    def timer_names(self) -> list[str]:
        cdef str timer_names = cstr_to_pystr(test_clock_timer_names(&self._mem))
        if not timer_names:
            return []

        # For simplicity we split a string on a reasonably unique delimiter.
        # This is a temporary solution pending the removal of Cython.
        return sorted(timer_names.split("<,>"))

    @property
    def timer_count(self) -> int:
        return test_clock_timer_count(&self._mem)

    cpdef double timestamp(self):
        return test_clock_timestamp(&self._mem)

    cpdef uint64_t timestamp_ms(self):
        return test_clock_timestamp_ms(&self._mem)

    cpdef uint64_t timestamp_us(self):
        return test_clock_timestamp_us(&self._mem)

    cpdef uint64_t timestamp_ns(self):
        return test_clock_timestamp_ns(&self._mem)

    cpdef void register_default_handler(self, callback: Callable[[TimeEvent], None]):
        Condition.callable(callback, "callback")

        test_clock_register_default_handler(&self._mem, <PyObject *>callback)

    cpdef void set_time_alert_ns(
        self,
        str name,
        uint64_t alert_time_ns,
        callback: Callable[[TimeEvent], None] | None = None,
        bint allow_past = True,
    ):
        Condition.valid_string(name, "name")
        Condition.not_in(name, self.timer_names, "name", "self.timer_names")

        # Validate allow_past logic to prevent Rust errors
        cdef uint64_t ts_now = self.timestamp_ns()

        if not allow_past:
            if alert_time_ns < ts_now:
                alert_dt = datetime.fromtimestamp(alert_time_ns / 1e9).isoformat()
                current_dt = datetime.fromtimestamp(ts_now / 1e9).isoformat()
                raise ValueError(
                    f"Timer '{name}' alert time {alert_dt} was in the past "
                    f"(current time is {current_dt})"
                )

        test_clock_set_time_alert(
            &self._mem,
            pystr_to_cstr(name),
            alert_time_ns,
            <PyObject *>callback,
            allow_past,
        )

    cpdef void set_timer_ns(
        self,
        str name,
        uint64_t interval_ns,
        uint64_t start_time_ns,
        uint64_t stop_time_ns,
        callback: Callable[[TimeEvent], None] | None = None,
        bint allow_past = True,
        bint fire_immediately = False,
    ):
        Condition.valid_string(name, "name")
        Condition.not_in(name, self.timer_names, "name", "self.timer_names")
        Condition.positive_int(interval_ns, "interval_ns")

        # Validate callback availability to prevent Rust panics
        # Note: We can't easily check if default handler is registered from Cython,
        # but we can provide a more informative error than a Rust panic
        # The existing tests in the codebase show this validation should be done

        cdef uint64_t ts_now = self.timestamp_ns()

        if start_time_ns == 0:
            start_time_ns = ts_now
        if stop_time_ns:
            Condition.is_true(stop_time_ns > ts_now, "`stop_time_ns` was < `ts_now`")
            Condition.is_true(start_time_ns + interval_ns <= stop_time_ns, "`start_time_ns` + `interval_ns` was > `stop_time_ns`")

        # Validate allow_past logic to prevent Rust errors
        cdef uint64_t next_event_time

        if not allow_past:
            if fire_immediately:
                next_event_time = start_time_ns
            else:
                next_event_time = start_time_ns + interval_ns

            if next_event_time < ts_now:
                next_dt = datetime.fromtimestamp(next_event_time / 1e9).isoformat()
                current_dt = datetime.fromtimestamp(ts_now / 1e9).isoformat()
                raise ValueError(
                    f"Timer '{name}' next event time {next_dt} would be in the past "
                    f"(current time is {current_dt})"
                )

        test_clock_set_timer(
            &self._mem,
            pystr_to_cstr(name),
            interval_ns,
            start_time_ns,
            stop_time_ns,
            <PyObject *>callback,
            allow_past,
            fire_immediately,
        )

    cpdef uint64_t next_time_ns(self, str name):
        Condition.valid_string(name, "name")
        return test_clock_next_time(&self._mem, pystr_to_cstr(name))

    cpdef void cancel_timer(self, str name):
        Condition.valid_string(name, "name")
        Condition.is_in(name, self.timer_names, "name", "self.timer_names")

        test_clock_cancel_timer(&self._mem, pystr_to_cstr(name))

    cpdef void cancel_timers(self):
        test_clock_cancel_timers(&self._mem)

    cpdef void set_time(self, uint64_t to_time_ns):
        """
        Set the clocks datetime to the given time (UTC).

        Parameters
        ----------
        to_time_ns : uint64_t
            The UNIX timestamp (nanoseconds) to set.

        """
        test_clock_set_time(&self._mem, to_time_ns)

    cdef CVec advance_time_c(self, uint64_t to_time_ns, bint set_time=True):
        Condition.is_true(to_time_ns >= test_clock_timestamp_ns(&self._mem), "to_time_ns was < time_ns (not monotonic)")

        return <CVec>test_clock_advance_time(&self._mem, to_time_ns, set_time)

    cpdef list advance_time(self, uint64_t to_time_ns, bint set_time=True):
        """
        Advance the clocks time to the given `to_time_ns`.

        Parameters
        ----------
        to_time_ns : uint64_t
            The UNIX timestamp (nanoseconds) to advance the clock to.
        set_time : bool
            If the clock should also be set to the given `to_time_ns`.

        Returns
        -------
        list[TimeEventHandler]
            Sorted chronologically.

        Raises
        ------
        ValueError
            If `to_time_ns` is < the clocks current time.

        """
        cdef CVec raw_handler_vec = self.advance_time_c(to_time_ns, set_time)
        cdef TimeEventHandler_t* raw_handlers = <TimeEventHandler_t*>raw_handler_vec.ptr
        cdef list event_handlers = []

        cdef:
            uint64_t i
            object callback
            TimeEvent event
            TimeEventHandler_t raw_handler
            TimeEventHandler event_handler
            PyObject *raw_callback
        for i in range(raw_handler_vec.len):
            raw_handler = <TimeEventHandler_t>raw_handlers[i]
            event = TimeEvent.from_mem_c(raw_handler.event)

            # Cast raw `PyObject *` to a `PyObject`
            raw_callback = <PyObject *>raw_handler.callback_ptr
            callback = <object>raw_callback

            event_handler = TimeEventHandler(event, callback)
            event_handlers.append(event_handler)

        vec_time_event_handlers_drop(raw_handler_vec)

        return event_handlers


cdef class LiveClock(Clock):
    """
    Provides a monotonic clock for live trading.

    All times are tz-aware UTC.

    Parameters
    ----------
    loop : asyncio.AbstractEventLoop
        The event loop for the clocks timers.
    """

    def __init__(self):
        self._mem = live_clock_new()

    def __del__(self) -> None:
        if self._mem._0 != NULL:
            live_clock_drop(self._mem)

    @property
    def timer_names(self) -> list[str]:
        cdef str timer_names = cstr_to_pystr(live_clock_timer_names(&self._mem))
        if not timer_names:
            return []

        # For simplicity we split a string on a reasonably unique delimiter.
        # This is a temporary solution pending the removal of Cython.
        return sorted(timer_names.split("<,>"))

    @property
    def timer_count(self) -> int:
        return live_clock_timer_count(&self._mem)

    cpdef double timestamp(self):
        return live_clock_timestamp(&self._mem)

    cpdef uint64_t timestamp_ms(self):
        return live_clock_timestamp_ms(&self._mem)

    cpdef uint64_t timestamp_us(self):
        return live_clock_timestamp_us(&self._mem)

    cpdef uint64_t timestamp_ns(self):
        return live_clock_timestamp_ns(&self._mem)

    cpdef void register_default_handler(self, callback: Callable[[TimeEvent], None]):
        Condition.callable(callback, "callback")

        callback = create_pyo3_conversion_wrapper(callback)

        live_clock_register_default_handler(&self._mem, <PyObject *>callback)

    cpdef void set_time_alert_ns(
        self,
        str name,
        uint64_t alert_time_ns,
        callback: Callable[[TimeEvent], None] | None = None,
        bint allow_past = True,
    ):
        Condition.valid_string(name, "name")
        Condition.not_in(name, self.timer_names, "name", "self.timer_names")

        # Validate allow_past logic to prevent Rust errors
        cdef uint64_t ts_now = self.timestamp_ns()

        if not allow_past:
            if alert_time_ns < ts_now:
                alert_dt = datetime.fromtimestamp(alert_time_ns / 1e9).isoformat()
                current_dt = datetime.fromtimestamp(ts_now / 1e9).isoformat()
                raise ValueError(
                    f"Timer '{name}' alert time {alert_dt} was in the past "
                    f"(current time is {current_dt})"
                )

        if callback is not None:
            callback = create_pyo3_conversion_wrapper(callback)

        live_clock_set_time_alert(
            &self._mem,
            pystr_to_cstr(name),
            alert_time_ns,
            <PyObject *>callback,
            allow_past,
        )

    cpdef void set_timer_ns(
        self,
        str name,
        uint64_t interval_ns,
        uint64_t start_time_ns,
        uint64_t stop_time_ns,
        callback: Callable[[TimeEvent], None] | None = None,
        bint allow_past = True,
        bint fire_immediately = False,
    ):
        Condition.valid_string(name, "name")
        Condition.not_in(name, self.timer_names, "name", "self.timer_names")
        Condition.positive_int(interval_ns, "interval_ns")

        # Validate callback availability to prevent Rust panics
        # For LiveClock, we need either a callback or a default handler
        # Since we can't easily check default handler from Cython, we need some validation
        if callback is None:
            # If no callback provided, we rely on default handler being set
            # This will be validated by Rust, but we can't prevent the panic here
            pass

        # Validate allow_past logic to prevent Rust errors
        cdef uint64_t ts_now = self.timestamp_ns()
        cdef uint64_t next_event_time

        if not allow_past:
            if start_time_ns != 0:  # Only validate if start_time is explicitly set
                if fire_immediately:
                    next_event_time = start_time_ns
                else:
                    next_event_time = start_time_ns + interval_ns

                if next_event_time < ts_now:
                    from datetime import datetime
                    next_dt = datetime.fromtimestamp(next_event_time / 1e9).isoformat()
                    current_dt = datetime.fromtimestamp(ts_now / 1e9).isoformat()
                    raise ValueError(
                        f"Timer '{name}' next event time {next_dt} would be in the past "
                        f"(current time is {current_dt})"
                    )

        if callback is not None:
            callback = create_pyo3_conversion_wrapper(callback)

        live_clock_set_timer(
            &self._mem,
            pystr_to_cstr(name),
            interval_ns,
            start_time_ns,
            stop_time_ns,
            <PyObject *>callback,
            allow_past,
            fire_immediately,
        )

    cpdef uint64_t next_time_ns(self, str name):
        Condition.valid_string(name, "name")

        return live_clock_next_time(&self._mem, pystr_to_cstr(name))

    cpdef void cancel_timer(self, str name):
        Condition.valid_string(name, "name")
        Condition.is_in(name, self.timer_names, "name", "self.timer_names")

        live_clock_cancel_timer(&self._mem, pystr_to_cstr(name))

    cpdef void cancel_timers(self):
        cdef str name
        for name in self.timer_names:
            # Using a list of timer names from the property and passing this
            # to cancel_timer() handles the clean removal of both the handler
            # and timer.
            self.cancel_timer(name)


def create_pyo3_conversion_wrapper(callback) -> Callable:
    def wrapper(capsule):
        callback(capsule_to_time_event(capsule))

    return wrapper


cdef class TimeEvent(Event):
    """
    Represents a time event occurring at the event timestamp.

    Parameters
    ----------
    name : str
        The event name.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the time event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        str name not None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        # Precondition: `name` validated in Rust
        self._mem = time_event_new(
            pystr_to_cstr(name),
            event_id._mem,
            ts_event,
            ts_init,
        )

    def __getstate__(self):
        return (
            self.to_str(),
            self.id.value,
            self.ts_event,
            self.ts_init,
        )

    def __setstate__(self, state):
        self._mem = time_event_new(
            pystr_to_cstr(state[0]),
            uuid4_from_cstr(pystr_to_cstr(state[1])),
            self.ts_event,
            self.ts_init,
        )

    cdef str to_str(self):
        return ustr_to_pystr(self._mem.name)

    def __eq__(self, TimeEvent other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return cstr_to_pystr(time_event_to_cstr(&self._mem))

    @property
    def name(self) -> str:
        """
        Return the name of the time event.

        Returns
        -------
        str

        """
        return ustr_to_pystr(self._mem.name)

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        cdef UUID4 uuid4 = UUID4.__new__(UUID4)
        uuid4._mem = self._mem.event_id

        return uuid4

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef TimeEvent from_mem_c(TimeEvent_t mem):
        cdef TimeEvent event = TimeEvent.__new__(TimeEvent)
        event._mem = mem

        return event


cdef inline TimeEvent capsule_to_time_event(capsule):
    cdef TimeEvent_t* ptr = <TimeEvent_t*>PyCapsule_GetPointer(capsule, NULL)
    cdef TimeEvent event = TimeEvent.__new__(TimeEvent)
    event._mem = ptr[0]

    return event


cdef class TimeEventHandler:
    """
    Represents a time event with its associated handler.

    Parameters
    ----------
    event : TimeEvent
        The time event to handle
    handler : Callable[[TimeEvent], None]
        The handler to call.

    """

    def __init__(
        self,
        TimeEvent event not None,
        handler not None: Callable[[TimeEvent], None],
    ) -> None:
        self.event = event
        self._handler = handler

    cpdef void handle(self):
        """
        Call the handler with the contained time event.
        """
        self._handler(self.event)

    def __eq__(self, TimeEventHandler other) -> bool:
        if other is None:
            return False
        return self.event.ts_event == other.event.ts_event

    def __lt__(self, TimeEventHandler other) -> bool:
        if other is None:
            return NotImplemented
        return self.event.ts_event < other.event.ts_event

    def __le__(self, TimeEventHandler other) -> bool:
        if other is None:
            return NotImplemented
        return self.event.ts_event <= other.event.ts_event

    def __gt__(self, TimeEventHandler other) -> bool:
        if other is None:
            return NotImplemented
        return self.event.ts_event > other.event.ts_event

    def __ge__(self, TimeEventHandler other) -> bool:
        if other is None:
            return NotImplemented
        return self.event.ts_event >= other.event.ts_event

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"event={repr(self.event)})"
        )


RECV = "<--"
SENT = "-->"
CMD = "[CMD]"
EVT = "[EVT]"
DOC = "[DOC]"
RPT = "[RPT]"
REQ = "[REQ]"
RES = "[RES]"


cdef void set_logging_clock_realtime_mode():
    logging_clock_set_realtime_mode()


cdef void set_logging_clock_static_mode():
    logging_clock_set_static_mode()


cdef void set_logging_clock_static_time(uint64_t time_ns):
    logging_clock_set_static_time(time_ns)


cpdef LogColor log_color_from_str(str value):
    return log_color_from_cstr(pystr_to_cstr(value))


cpdef str log_color_to_str(LogColor value):
    return cstr_to_pystr(log_color_to_cstr(value))


cpdef LogLevel log_level_from_str(str value):
    return log_level_from_cstr(pystr_to_cstr(value))


cpdef str log_level_to_str(LogLevel value):
    return cstr_to_pystr(log_level_to_cstr(value))


cdef class LogGuard:
    """
    Provides a `LogGuard` which serves as a token to signal the initialization
    of the logging subsystem. It also ensures that the global logger is flushed
    of any buffered records when the instance is destroyed.
    """

    def __del__(self) -> None:
        if self._mem._0 != NULL:
            logger_drop(self._mem)


cpdef LogGuard init_logging(
    TraderId trader_id = None,
    str machine_id = None,
    UUID4 instance_id = None,
    LogLevel level_stdout = LogLevel.INFO,
    LogLevel level_file = LogLevel.OFF,
    str directory = None,
    str file_name = None,
    str file_format = None,
    dict component_levels = None,
    bint log_components_only = False,
    bint colors = True,
    bint bypass = False,
    bint print_config = False,
    uint64_t max_file_size = 0,
    uint32_t max_backup_count = 5,
):
    """
    Initialize the logging subsystem.

    Provides an interface into the logging subsystem implemented in Rust.

    This function should only be called once per process, at the beginning of the application
    run. Subsequent calls will raise a `RuntimeError`, as there can only be one `LogGuard`
    per initialized system.

    Parameters
    ----------
    trader_id : TraderId, optional
        The trader ID for the logger.
    machine_id : str, optional
        The machine ID.
    instance_id : UUID4, optional
        The instance ID.
    level_stdout : LogLevel, default ``INFO``
        The minimum log level to write to stdout.
    level_file : LogLevel, default ``OFF``
        The minimum log level to write to a file.
    directory : str, optional
        The path to the log file directory.
        If ``None`` then will write to the current working directory.
    file_name : str, optional
        The custom log file name (will use a '.log' suffix for plain text or '.json' for JSON).
        If ``None`` will not log to a file.
    file_format : str { 'JSON' }, optional
        The log file format. If ``None`` (default) then will log in plain text.
        If set to 'JSON' then logs will be in JSON format.
    component_levels : dict[str, str], optional
        The additional per component log level filters, where keys are component
        IDs as strings (e.g. actor/strategy IDs) and values are log level strings (case-insensitive).
    log_components_only : bool, default False
        If only components with explicit component-level filters should be logged.
        When enabled, only log messages from components that have been explicitly
        configured in `component_levels` will be output.
    colors : bool, default True
        If ANSI codes should be used to produce colored log lines.
    bypass : bool, default False
        If the output for the core logging subsystem is bypassed (useful for logging tests).
    print_config : bool, default False
        If the core logging configuration should be printed to stdout on initialization.
    max_file_size : uint64_t, default 0
        The maximum size of log files in bytes before rotation occurs.
        If set to 0, file rotation is disabled.
    max_backup_count : uint32_t, default 5
        The maximum number of backup log files to keep when rotating.

    Returns
    -------
    LogGuard

    Raises
    ------
    RuntimeError
        If the logging subsystem has already been initialized.

    """
    if trader_id is None:
        trader_id = TraderId("TRADER-000")
    if machine_id is None:
        machine_id = socket.gethostname()
    if instance_id is None:
        instance_id = UUID4()

    if logging_is_initialized():
        raise RuntimeError("Logging subsystem already initialized")

    cdef LogGuard_API log_guard_api = logging_init(
        trader_id._mem,
        instance_id._mem,
        level_stdout,
        level_file,
        pystr_to_cstr(directory) if directory else NULL,
        pystr_to_cstr(file_name) if file_name else NULL,
        pystr_to_cstr(file_format) if file_format else NULL,
        pybytes_to_cstr(msgspec.json.encode(component_levels)) if component_levels else NULL,
        colors,
        bypass,
        print_config,
        log_components_only,
        max_file_size,
        max_backup_count,
    )

    cdef LogGuard log_guard = LogGuard.__new__(LogGuard)
    log_guard._mem = log_guard_api

    return log_guard


LOGGING_PYO3 = False


cpdef bint is_logging_initialized():
    if LOGGING_PYO3:
        return True
    return <bint>logging_is_initialized()


cpdef bint is_logging_pyo3():
    return LOGGING_PYO3


cpdef void set_logging_pyo3(bint value):
    global LOGGING_PYO3
    LOGGING_PYO3 = value


cpdef void flush_logger():
    logger_flush()


cdef class Logger:
    """
    Provides a logger adapter into the logging subsystem.

    Parameters
    ----------
    name : str
        The name of the logger. This will appear within each log line.

    """

    def __init__(self, str name not None) -> None:
        Condition.valid_string(name, "name")

        self._name = name  # Reference to `name` needs to be kept alive
        self._name_ptr = pystr_to_cstr(self._name)

    @property
    def name(self) -> str:
        """
        Return the name of the logger.

        Returns
        -------
        str

        """
        return self._name

    cpdef void debug(
        self,
        str message,
        LogColor color = LogColor.NORMAL,
    ):
        """
        Log the given DEBUG level message.

        Parameters
        ----------
        message : str
            The log message text (valid UTF-8).
        color : LogColor, optional
            The log message color.

        """
        if LOGGING_PYO3:
            nautilus_pyo3.logger_log(
                nautilus_pyo3.LogLevel.DEBUG,
                nautilus_pyo3.LogColor(log_color_to_str(color)),
                self._name,
                message,
            )
            return

        if not logging_is_initialized():
            return

        logger_log(
            LogLevel.DEBUG,
            color,
            self._name_ptr,
            pystr_to_cstr(message) if message is not None else NULL,
        )

    cpdef void info(
        self, str message,
        LogColor color = LogColor.NORMAL,
    ):
        """
        Log the given INFO level message.

        Parameters
        ----------
        message : str
            The log message text (valid UTF-8).
        color : LogColor, optional
            The log message color.

        """
        if LOGGING_PYO3:
            nautilus_pyo3.logger_log(
                nautilus_pyo3.LogLevel.INFO,
                nautilus_pyo3.LogColor(log_color_to_str(color)),
                self._name,
                message,
            )
            return

        if not logging_is_initialized():
            return

        logger_log(
            LogLevel.INFO,
            color,
            self._name_ptr,
            pystr_to_cstr(message) if message is not None else NULL,
        )

    cpdef void warning(
        self,
        str message,
        LogColor color = LogColor.YELLOW,
    ):
        """
        Log the given WARNING level message.

        Parameters
        ----------
        message : str
            The log message text (valid UTF-8).
        color : LogColor, optional
            The log message color.

        """
        if LOGGING_PYO3:
            nautilus_pyo3.logger_log(
                nautilus_pyo3.LogLevel.WARNING,
                nautilus_pyo3.LogColor(log_color_to_str(color)),
                self._name,
                message,
            )
            return

        if not logging_is_initialized():
            return

        logger_log(
            LogLevel.WARNING,
            color,
            self._name_ptr,
            pystr_to_cstr(message) if message is not None else NULL,
        )

    cpdef void error(
        self,
        str message,
        LogColor color = LogColor.RED,
    ):
        """
        Log the given ERROR level message.

        Parameters
        ----------
        message : str
            The log message text (valid UTF-8).
        color : LogColor, optional
            The log message color.

        """
        if LOGGING_PYO3:
            nautilus_pyo3.logger_log(
                nautilus_pyo3.LogLevel.ERROR,
                nautilus_pyo3.LogColor(log_color_to_str(color)),
                self._name,
                message,
            )
            return

        if not logging_is_initialized():
            return

        logger_log(
            LogLevel.ERROR,
            color,
            self._name_ptr,
            pystr_to_cstr(message) if message is not None else NULL,
        )

    cpdef void exception(
        self,
        str message,
        ex,
    ):
        """
        Log the given exception including stack trace information.

        Parameters
        ----------
        message : str
            The log message text (valid UTF-8).
        ex : Exception
            The exception to log.

        """
        Condition.not_none(ex, "ex")

        cdef str ex_string = f"{type(ex).__name__}({ex})"
        ex_type, ex_value, ex_traceback = sys.exc_info()
        stack_trace = traceback.format_exception(ex_type, ex_value, ex_traceback)

        cdef str stack_trace_lines = ""
        cdef str line
        for line in stack_trace[:len(stack_trace) - 1]:
            stack_trace_lines += line

        self.error(f"{message}\n{ex_string}\n{stack_trace_lines}")


cpdef void log_header(
    TraderId trader_id,
    str machine_id,
    UUID4 instance_id,
    str component,
):
    logging_log_header(
        trader_id._mem,
        pystr_to_cstr(machine_id),
        instance_id._mem,
        pystr_to_cstr(component),
    )


cpdef void log_sysinfo(str component):
    logging_log_sysinfo(pystr_to_cstr(component))


cpdef ComponentState component_state_from_str(str value):
    return component_state_from_cstr(pystr_to_cstr(value))


cpdef str component_state_to_str(ComponentState value):
    return cstr_to_pystr(component_state_to_cstr(value))


cpdef ComponentTrigger component_trigger_from_str(str value):
    return component_trigger_from_cstr(pystr_to_cstr(value))


cpdef str component_trigger_to_str(ComponentTrigger value):
    return cstr_to_pystr(component_trigger_to_cstr(value))


cdef dict[tuple[ComponentState, ComponentTrigger], ComponentState] _COMPONENT_STATE_TABLE = {
    (ComponentState.PRE_INITIALIZED, ComponentTrigger.INITIALIZE): ComponentState.READY,
    (ComponentState.READY, ComponentTrigger.RESET): ComponentState.RESETTING,  # Transitional state
    (ComponentState.READY, ComponentTrigger.START): ComponentState.STARTING,  # Transitional state
    (ComponentState.READY, ComponentTrigger.DISPOSE): ComponentState.DISPOSING,  # Transitional state
    (ComponentState.RESETTING, ComponentTrigger.RESET_COMPLETED): ComponentState.READY,
    (ComponentState.STARTING, ComponentTrigger.START_COMPLETED): ComponentState.RUNNING,
    (ComponentState.STARTING, ComponentTrigger.STOP): ComponentState.STOPPING,  # Transitional state
    (ComponentState.STARTING, ComponentTrigger.FAULT): ComponentState.FAULTING,  # Transitional state
    (ComponentState.RUNNING, ComponentTrigger.STOP): ComponentState.STOPPING,  # Transitional state
    (ComponentState.RUNNING, ComponentTrigger.DEGRADE): ComponentState.DEGRADING,  # Transitional state
    (ComponentState.RUNNING, ComponentTrigger.FAULT): ComponentState.FAULTING,  # Transitional state
    (ComponentState.RESUMING, ComponentTrigger.STOP): ComponentState.STOPPING,  # Transitional state
    (ComponentState.RESUMING, ComponentTrigger.RESUME_COMPLETED): ComponentState.RUNNING,
    (ComponentState.RESUMING, ComponentTrigger.FAULT): ComponentState.FAULTING,  # Transitional state
    (ComponentState.STOPPING, ComponentTrigger.STOP_COMPLETED): ComponentState.STOPPED,
    (ComponentState.STOPPING, ComponentTrigger.FAULT): ComponentState.FAULTING,  # Transitional state
    (ComponentState.STOPPED, ComponentTrigger.RESET): ComponentState.RESETTING,  # Transitional state
    (ComponentState.STOPPED, ComponentTrigger.RESUME): ComponentState.RESUMING,  # Transitional state
    (ComponentState.STOPPED, ComponentTrigger.DISPOSE): ComponentState.DISPOSING,  # Transitional state
    (ComponentState.STOPPED, ComponentTrigger.FAULT): ComponentState.FAULTING,  # Transitional state
    (ComponentState.DEGRADING, ComponentTrigger.DEGRADE_COMPLETED): ComponentState.DEGRADED,
    (ComponentState.DEGRADED, ComponentTrigger.RESUME): ComponentState.RESUMING,  # Transitional state
    (ComponentState.DEGRADED, ComponentTrigger.STOP): ComponentState.STOPPING,  # Transitional state
    (ComponentState.DEGRADED, ComponentTrigger.FAULT): ComponentState.FAULTING,  # Transition state
    (ComponentState.DISPOSING, ComponentTrigger.DISPOSE_COMPLETED): ComponentState.DISPOSED,  # Terminal state
    (ComponentState.FAULTING, ComponentTrigger.FAULT_COMPLETED): ComponentState.FAULTED,  # Terminal state
}

cdef class ComponentFSMFactory:
    """
    Provides a generic component Finite-State Machine.
    """

    @staticmethod
    def get_state_transition_table() -> dict:
        """
        The default state transition table.

        Returns
        -------
        dict[int, int]
            C Enums.

        """
        return _COMPONENT_STATE_TABLE.copy()

    @staticmethod
    cdef create():
        """
        Create a new generic component FSM.

        Returns
        -------
        FiniteStateMachine

        """
        return FiniteStateMachine(
            state_transition_table=ComponentFSMFactory.get_state_transition_table(),
            initial_state=ComponentState.PRE_INITIALIZED,
            trigger_parser=component_trigger_to_str,
            state_parser=component_state_to_str,
        )


cdef class Component:
    """
    The base class for all system components.

    A component is not considered initialized until a message bus is registered
    (this either happens when one is passed to the constructor, or when
    registered with a trader).

    Thus, if the component does not receive a message bus through the constructor,
    then it will be in a ``PRE_INITIALIZED`` state, otherwise if one is passed
    then it will be in an ``INITIALIZED`` state.

    Parameters
    ----------
    clock : Clock
        The clock for the component.
    trader_id : TraderId, optional
        The trader ID associated with the component.
    component_id : Identifier, optional
        The component ID. If ``None`` is passed then the identifier will be
        taken from `type(self).__name__`.
    component_name : str, optional
        The custom component name.
    msgbus : MessageBus, optional
        The message bus for the component (required before initialized).
    config : NautilusConfig, optional
        The configuration for the component.

    Raises
    ------
    ValueError
        If `component_name` is not a valid string.
    TypeError
        If `config` is not of type `NautilusConfig`.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        Clock clock not None,
        TraderId trader_id = None,
        Identifier component_id = None,
        str component_name = None,
        MessageBus msgbus = None,
        config: NautilusConfig | None = None,
    ):
        if component_id is None:
            component_id = ComponentId(type(self).__name__)

        if component_name is None:
            component_name = component_id.value

        Condition.valid_string(component_name, "component_name")
        Condition.type_or_none(config, NautilusConfig, "config")

        self.trader_id = msgbus.trader_id if msgbus is not None else None
        self.id = component_id
        self.type = type(self)

        self._clock = clock
        self._log = Logger(name=component_name)
        self._msgbus = msgbus
        self._fsm = ComponentFSMFactory.create()
        self._config = config.json_primitives() if config is not None else {}

        if self._msgbus is not None:
            self._initialize()

    def __eq__(self, Component other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return self.id.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self.id.to_str()})"

    @classmethod
    def fully_qualified_name(cls) -> str:
        """
        Return the fully qualified name for the components class.

        Returns
        -------
        str

        References
        ----------
        https://www.python.org/dev/peps/pep-3155/

        """
        return cls.__module__ + ':' + cls.__qualname__

    @property
    def state(self) -> ComponentState:
        """
        Return the components current state.

        Returns
        -------
        ComponentState

        """
        return PyComponentState(self._fsm.state)

    @property
    def is_initialized(self) -> bool:
        """
        Return whether the component has been initialized (component.state >= ``INITIALIZED``).

        Returns
        -------
        bool

        """
        return self._fsm.state >= ComponentState.READY

    @property
    def is_running(self) -> bool:
        """
        Return whether the current component state is ``RUNNING``.

        Returns
        -------
        bool

        """
        return self._fsm.state == ComponentState.RUNNING

    @property
    def is_stopped(self) -> bool:
        """
        Return whether the current component state is ``STOPPED``.

        Returns
        -------
        bool

        """
        return self._fsm.state == ComponentState.STOPPED

    @property
    def is_disposed(self) -> bool:
        """
        Return whether the current component state is ``DISPOSED``.

        Returns
        -------
        bool

        """
        return self._fsm.state == ComponentState.DISPOSED

    @property
    def is_degraded(self) -> bool:
        """
        Return whether the current component state is ``DEGRADED``.

        Returns
        -------
        bool

        """
        return self._fsm.state == ComponentState.DEGRADED

    @property
    def is_faulted(self) -> bool:
        """
        Return whether the current component state is ``FAULTED``.

        Returns
        -------
        bool

        """
        return self._fsm.state == ComponentState.FAULTED

    cdef void _change_clock(self, Clock clock):
        Condition.not_none(clock, "clock")

        self._clock = clock

    cdef void _change_msgbus(self, MessageBus msgbus):
        # As an additional system wiring check: if a message bus is being added
        # here, then there should not be an existing trader ID or message bus.
        Condition.not_none(msgbus, "msgbus")
        Condition.none(self.trader_id, "self.trader_id")
        Condition.none(self._msgbus, "self._msgbus")

        self.trader_id = msgbus.trader_id
        self._msgbus = msgbus
        self._initialize()

# -- ABSTRACT METHODS -----------------------------------------------------------------------------

    cpdef void _start(self):
        # Optionally override in subclass
        pass

    cpdef void _stop(self):
        # Optionally override in subclass
        pass

    cpdef void _resume(self):
        # Optionally override in subclass
        pass

    cpdef void _reset(self):
        # Optionally override in subclass
        pass

    cpdef void _dispose(self):
        # Cancel all active timers to prevent post-disposal execution
        if self._clock is not None:
            self._clock.cancel_timers()

        # Optionally override in subclass

    cpdef void _degrade(self):
        # Optionally override in subclass
        pass

    cpdef void _fault(self):
        # Optionally override in subclass
        pass

# -- COMMANDS -------------------------------------------------------------------------------------

    cdef void _initialize(self):
        # This is a protected method dependent on registration of a message bus
        try:
            self._trigger_fsm(
                trigger=ComponentTrigger.INITIALIZE,  # -> INITIALIZED
                is_transitory=False,
                action=None,
            )
        except Exception as e:
            self._log.exception(f"{repr(self)}: Error on initialize", e)
            raise

    cpdef void start(self):
        """
        Start the component.

        While executing `on_start()` any exception will be logged and reraised, then the component
        will remain in a ``STARTING`` state.

        Warnings
        --------
        Do not override.

        If the component is not in a valid state from which to execute this method,
        then the component state will not change, and an error will be logged.

        """
        try:
            self._trigger_fsm(
                trigger=ComponentTrigger.START,  # -> STARTING
                is_transitory=True,
                action=self._start,
            )
        except Exception as e:
            self._log.exception(f"{repr(self)}: Error on START", e)
            raise  # Halt state transition

        self._trigger_fsm(
            trigger=ComponentTrigger.START_COMPLETED,
            is_transitory=False,
            action=None,
        )

    cpdef void stop(self):
        """
        Stop the component.

        While executing `on_stop()` any exception will be logged and reraised, then the component
        will remain in a ``STOPPING`` state.

        Warnings
        --------
        Do not override.

        If the component is not in a valid state from which to execute this method,
        then the component state will not change, and an error will be logged.

        """
        try:
            self._trigger_fsm(
                trigger=ComponentTrigger.STOP,  # -> STOPPING
                is_transitory=True,
                action=self._stop,
            )
        except Exception as e:
            self._log.exception(f"{repr(self)}: Error on STOP", e)
            raise  # Halt state transition

        self._trigger_fsm(
            trigger=ComponentTrigger.STOP_COMPLETED,
            is_transitory=False,
            action=None,
        )

    cpdef void resume(self):
        """
        Resume the component.

        While executing `on_resume()` any exception will be logged and reraised, then the component
        will remain in a ``RESUMING`` state.

        Warnings
        --------
        Do not override.

        If the component is not in a valid state from which to execute this method,
        then the component state will not change, and an error will be logged.

        """
        try:
            self._trigger_fsm(
                trigger=ComponentTrigger.RESUME,  # -> RESUMING
                is_transitory=True,
                action=self._resume,
            )
        except Exception as e:
            self._log.exception(f"{repr(self)}: Error on RESUME", e)
            raise  # Halt state transition

        self._trigger_fsm(
            trigger=ComponentTrigger.RESUME_COMPLETED,
            is_transitory=False,
            action=None,
        )

    cpdef void reset(self):
        """
        Reset the component.

        All stateful fields are reset to their initial value.

        While executing `on_reset()` any exception will be logged and reraised, then the component
        will remain in a ``RESETTING`` state.

        Warnings
        --------
        Do not override.

        If the component is not in a valid state from which to execute this method,
        then the component state will not change, and an error will be logged.

        """
        try:
            self._trigger_fsm(
                trigger=ComponentTrigger.RESET,  # -> RESETTING
                is_transitory=True,
                action=self._reset,
            )
        except Exception as e:
            self._log.exception(f"{repr(self)}: Error on RESET", e)
            raise  # Halt state transition

        self._trigger_fsm(
            trigger=ComponentTrigger.RESET_COMPLETED,
            is_transitory=False,
            action=None,
        )

    cpdef void dispose(self):
        """
        Dispose of the component.

        While executing `on_dispose()` any exception will be logged and reraised, then the component
        will remain in a ``DISPOSING`` state.

        Warnings
        --------
        Do not override.

        If the component is not in a valid state from which to execute this method,
        then the component state will not change, and an error will be logged.

        """
        try:
            self._trigger_fsm(
                trigger=ComponentTrigger.DISPOSE,  # -> DISPOSING
                is_transitory=True,
                action=self._dispose,
            )
        except Exception as e:
            self._log.exception(f"{repr(self)}: Error on DISPOSE", e)
            raise  # Halt state transition

        self._trigger_fsm(
            trigger=ComponentTrigger.DISPOSE_COMPLETED,
            is_transitory=False,
            action=None,
        )

    cpdef void degrade(self):
        """
        Degrade the component.

        While executing `on_degrade()` any exception will be logged and reraised, then the component
        will remain in a ``DEGRADING`` state.

        Warnings
        --------
        Do not override.

        If the component is not in a valid state from which to execute this method,
        then the component state will not change, and an error will be logged.

        """
        try:
            self._trigger_fsm(
                trigger=ComponentTrigger.DEGRADE,  # -> DEGRADING
                is_transitory=True,
                action=self._degrade,
            )
        except Exception as e:
            self._log.exception(f"{repr(self)}: Error on DEGRADE", e)
            raise  # Halt state transition

        self._trigger_fsm(
            trigger=ComponentTrigger.DEGRADE_COMPLETED,
            is_transitory=False,
            action=None,
        )

    cpdef void fault(self):
        """
        Fault the component.

        Calling this method multiple times has the same effect as calling it once (it is idempotent).
        Once called, it cannot be reversed, and no other methods should be called on this instance.

        While executing `on_fault()` any exception will be logged and reraised, then the component
        will remain in a ``FAULTING`` state.

        Warnings
        --------
        Do not override.

        If the component is not in a valid state from which to execute this method,
        then the component state will not change, and an error will be logged.

        """
        try:
            self._trigger_fsm(
                trigger=ComponentTrigger.FAULT,  # -> FAULTING
                is_transitory=True,
                action=self._fault,
            )
        except Exception as e:
            self._log.exception(f"{repr(self)}: Error on FAULT", e)
            raise  # Halt state transition

        self._trigger_fsm(
            trigger=ComponentTrigger.FAULT_COMPLETED,
            is_transitory=False,
            action=None,
        )

    cpdef void shutdown_system(self, str reason = None):
        """
        Initiate a system-wide shutdown by generating and publishing a `ShutdownSystem` command.

        The command is handled by the system's `NautilusKernel`, which will invoke either `stop` (synchronously)
        or `stop_async` (asynchronously) depending on the execution context and the presence of an active event loop.

        Parameters
        ----------
        reason : str, optional
            The reason for issuing the shutdown command.

        """
        cdef ShutdownSystem command = ShutdownSystem(
            trader_id=self.trader_id,
            component_id=self.id,
            reason=reason,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
        )
        self._msgbus.publish("commands.system.shutdown", command)

# --------------------------------------------------------------------------------------------------

    cdef void _trigger_fsm(
        self,
        ComponentTrigger trigger,
        bint is_transitory,
        action: Callable[[None], None] | None = None,
    ):
        try:
            self._fsm.trigger(trigger)
        except InvalidStateTrigger as e:
            self._log.error(f"{repr(e)} state {self._fsm.state_string_c()}")
            return  # Guards against invalid state

        if is_transitory:
            self._log.debug(f"{self._fsm.state_string_c()}")
        else:
            self._log.info(f"{self._fsm.state_string_c()}")

        if action is not None:
            action()

        if self._fsm == ComponentState.PRE_INITIALIZED:
            return  # Cannot publish event

        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef ComponentStateChanged event = ComponentStateChanged(
            trader_id=self.trader_id,
            component_id=self.id,
            component_type=self.type.__name__,
            state=self._fsm.state,
            config=self._config,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

        self._msgbus.publish(
            topic=f"events.system.{self.id}",
            msg=event,
        )


cdef class MessageBus:
    """
    Provides a generic message bus to facilitate various messaging patterns.

    The bus provides both a producer and consumer API for Pub/Sub, Req/Rep, as
    well as direct point-to-point messaging to registered endpoints.

    Pub/Sub wildcard patterns for hierarchical topics are possible:
     - `*` asterisk represents one or more characters in a pattern.
     - `?` question mark represents a single character in a pattern.

    Given a topic and pattern potentially containing wildcard characters, i.e.
    `*` and `?`, where `?` can match any single character in the topic, and `*`
    can match any number of characters including zero characters.

    The asterisk in a wildcard matches any character zero or more times. For
    example, `comp*` matches anything beginning with `comp` which means `comp`,
    `complete`, and `computer` are all matched.

    A question mark matches a single character once. For example, `c?mp` matches
    `camp` and `comp`. The question mark can also be used more than once.
    For example, `c??p` would match both of the above examples and `coop`.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the message bus.
    clock : Clock
        The clock for the message bus.
    name : str, optional
        The custom name for the message bus.
    serializer : Serializer, optional
        The serializer for database operations.
    database : nautilus_pyo3.RedisMessageBusDatabase, optional
        The backing database for the message bus.
    config : MessageBusConfig, optional
        The configuration for the message bus.

    Raises
    ------
    ValueError
        If `name` is not ``None`` and not a valid string.

    Warnings
    --------
    This message bus is not thread-safe and must be called from the same thread
    as the event loop.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        Clock clock,
        UUID4 instance_id = None,
        str name = None,
        Serializer serializer = None,
        database: nautilus_pyo3.RedisMessageBusDatabase | None = None,
        config: Any | None = None,
    ) -> None:
        # Temporary fix for import error
        from nautilus_trader.common.config import MessageBusConfig

        if instance_id is None:
            instance_id = UUID4()

        if name is None:
            name = type(self).__name__

        Condition.valid_string(name, "name")

        if config is None:
            config = MessageBusConfig()

        Condition.type(config, MessageBusConfig, "config")

        self.trader_id = trader_id
        self.serializer = serializer
        self.has_backing = database is not None

        self._clock = clock
        self._log = Logger(name)
        self._database = database
        self._listeners = []

        # Validate configuration
        if config.buffer_interval_ms and config.buffer_interval_ms > 1000:
            self._log.warning(
                f"High `buffer_interval_ms` at {config.buffer_interval_ms}, "
                "recommended range is [10, 1000] milliseconds",
            )

        # Configuration
        self._log.info(f"{config.database=}", LogColor.BLUE)
        self._log.info(f"{config.encoding=}", LogColor.BLUE)
        self._log.info(f"{config.timestamps_as_iso8601=}", LogColor.BLUE)
        self._log.info(f"{config.buffer_interval_ms=}", LogColor.BLUE)
        self._log.info(f"{config.autotrim_mins=}", LogColor.BLUE)
        self._log.info(f"{config.use_trader_prefix=}", LogColor.BLUE)
        self._log.info(f"{config.use_trader_id=}", LogColor.BLUE)
        self._log.info(f"{config.use_instance_id=}", LogColor.BLUE)
        self._log.info(f"{config.streams_prefix=}", LogColor.BLUE)
        self._log.info(f"{config.types_filter=}", LogColor.BLUE)

        # Copy and clear `types_filter` before passing down to the core MessageBus
        cdef list types_filter = copy.copy(config.types_filter)
        if config.types_filter is not None:
            config.types_filter.clear()

        self._endpoints: dict[str, Callable[[Any], None]] = {}
        self._patterns: dict[str, Subscription[:]] = {}
        self._subscriptions: dict[Subscription, list[str]] = {}
        self._correlation_index: dict[UUID4, Callable[[Any], None]] = {}

        self._publishable_types = tuple(_EXTERNAL_PUBLISHABLE_TYPES)
        if types_filter is not None:
            self._publishable_types = tuple(o for o in _EXTERNAL_PUBLISHABLE_TYPES if o not in types_filter)

        self._streaming_types = set()
        self._resolved = False

        # Counters
        self.sent_count = 0
        self.req_count = 0
        self.res_count = 0
        self.pub_count = 0

    cpdef list endpoints(self):
        """
        Return all endpoint addresses registered with the message bus.

        Returns
        -------
        list[str]

        """
        return list(self._endpoints.keys())

    cpdef list topics(self):
        """
        Return all topics with active subscribers.

        Returns
        -------
        list[str]

        """
        return sorted(set([s.topic for s in self._subscriptions.keys()]))

    cpdef list subscriptions(self, str pattern = None):
        """
        Return all subscriptions matching the given topic `pattern`.

        Parameters
        ----------
        pattern : str, optional
            The topic pattern filter. May include wildcard characters `*` and `?`.
            If ``None`` then query is for **all** topics.

        Returns
        -------
        list[Subscription]

        """
        if pattern is None:
            pattern = "*"  # Wildcard

        Condition.valid_string(pattern, "pattern")

        return [s for s in self._subscriptions if is_matching(s.topic, pattern)]

    cpdef set streaming_types(self):
        """
        Return all types registered for external streaming -> internal publishing.

        Returns
        -------
        set[type]

        """
        return self._streaming_types.copy()

    cpdef bint has_subscribers(self, str pattern = None):
        """
        If the message bus has subscribers for the give topic `pattern`.

        Parameters
        ----------
        pattern : str, optional
            The topic filter. May include wildcard characters `*` and `?`.
            If ``None`` then query is for **all** topics.

        Returns
        -------
        bool

        """
        return len(self.subscriptions(pattern)) > 0

    cpdef bint is_subscribed(self, str topic, handler: Callable[[Any], None]):
        """
        Return if topic and handler is subscribed to the message bus.

        Does not consider any previous `priority`.

        Parameters
        ----------
        topic : str
            The topic of the subscription.
        handler : Callable[[Any], None]
            The handler of the subscription.

        Returns
        -------
        bool

        """
        Condition.valid_string(topic, "topic")
        Condition.callable(handler, "handler")

        # Create subscription
        cdef Subscription sub = Subscription(
            topic=topic,
            handler=handler,
        )

        return sub in self._subscriptions

    cpdef bint is_pending_request(self, UUID4 request_id):
        """
        Return if the given `request_id` is still pending a response.

        Parameters
        ----------
        request_id : UUID4
            The request ID to check (to match the correlation_id).

        Returns
        -------
        bool

        """
        Condition.not_none(request_id, "request_id")

        return request_id in self._correlation_index

    cpdef bint is_streaming_type(self, type cls):
        """
        Return whether the given type has been registered for external message streaming.

        Returns
        -------
        bool
            True if registered, else False.

        """
        return cls in self._streaming_types

    cpdef void dispose(self):
        """
        Dispose of the message bus which will close the internal channel and thread.

        """
        self._log.debug("Closing message bus")

        if self._database is not None:
            self._database.close()

        self._log.info("Closed message bus")

    cpdef void register(self, str endpoint, handler: Callable[[Any], None]):
        """
        Register the given `handler` to receive messages at the `endpoint` address.

        Parameters
        ----------
        endpoint : str
            The endpoint address to register.
        handler : Callable[[Any], None]
            The handler for the registration.

        Raises
        ------
        ValueError
            If `endpoint` is not a valid string.
        ValueError
            If `handler` is not of type `Callable`.
        KeyError
            If `endpoint` already registered.

        """
        Condition.valid_string(endpoint, "endpoint")
        Condition.callable(handler, "handler")
        Condition.not_in(endpoint, self._endpoints, "endpoint", "_endpoints")

        self._endpoints[endpoint] = handler

        self._log.debug(f"Added endpoint '{endpoint}' {handler}")

    cpdef void deregister(self, str endpoint, handler: Callable[[Any], None]):
        """
        Deregister the given `handler` from the `endpoint` address.

        Parameters
        ----------
        endpoint : str
            The endpoint address to deregister.
        handler : Callable[[Any], None]
            The handler to deregister.

        Raises
        ------
        ValueError
            If `endpoint` is not a valid string.
        ValueError
            If `handler` is not of type `Callable`.
        KeyError
            If `endpoint` is not registered.
        ValueError
            If `handler` is not registered at the endpoint.

        """
        Condition.valid_string(endpoint, "endpoint")
        Condition.callable(handler, "handler")
        Condition.is_in(endpoint, self._endpoints, "endpoint", "self._endpoints")
        Condition.equal(handler, self._endpoints[endpoint], "handler", "self._endpoints[endpoint]")

        del self._endpoints[endpoint]

        self._log.debug(f"Removed endpoint '{endpoint}' {handler}")

    cpdef void add_streaming_type(self, type cls):
        """
        Register the given type for external->internal message bus streaming.

        Parameters
        ----------
        type : cls
            The type to add for streaming.

        """
        Condition.not_none(cls, "cls")

        self._streaming_types.add(cls)

        self._log.debug(f"Added streaming type {cls}")

    cpdef void add_listener(self, listener: nautilus_pyo3.MessageBusListener):
        """
        Adds the given listener to the message bus.

        Parameters
        ----------
        listener : nautilus_pyo3.MessageBusListener
            The listener to add.

        """
        self._listeners.append(listener)

    cpdef void send(self, str endpoint, msg: Any):
        """
        Send the given message to the given `endpoint` address.

        Parameters
        ----------
        endpoint : str
            The endpoint address to send the message to.
        msg : object
            The message to send.

        """
        Condition.not_none(endpoint, "endpoint")
        Condition.not_none(msg, "msg")

        handler = self._endpoints.get(endpoint)
        if handler is None:
            self._log.error(
                f"Cannot send message: no endpoint registered at '{endpoint}'",
            )
            return  # Cannot send

        handler(msg)
        self.sent_count += 1

    cpdef void request(self, str endpoint, Request request):
        """
        Handle the given `request`.

        Will log an error if the correlation ID already exists.

        Parameters
        ----------
        endpoint : str
            The endpoint address to send the request to.
        request : Request
            The request to handle.

        """
        Condition.not_none(endpoint, "endpoint")
        Condition.not_none(request, "request")

        if request.id in self._correlation_index:
            self._log.error(
                f"Cannot handle request: "
                f"duplicate ID {request.id} found in correlation index",
            )
            return  # Do not handle duplicates

        if request.callback is not None:
            self._correlation_index[request.id] = request.callback

        handler = self._endpoints.get(endpoint)
        if handler is None:
            self._log.error(
                f"Cannot handle request: no endpoint registered at '{endpoint}'",
            )
            return  # Cannot handle

        handler(request)
        self.req_count += 1

    cpdef void response(self, Response response):
        """
        Handle the given `response`.

        Will log an error if the correlation ID is not found.

        Parameters
        ----------
        response : Response
            The response to handle

        """
        Condition.not_none(response, "response")

        callback = self._correlation_index.pop(response.correlation_id, None)
        if callback is None:
            self._log.debug(
                f"No callback for correlation_id {response.correlation_id}",
            )  # Cannot handle
        else:
            callback(response)

        self.res_count += 1

    cpdef void subscribe(
        self,
        str topic,
        handler: Callable[[Any], None],
        int priority = 0,
    ):
        """
        Subscribe to the given message `topic` with the given callback `handler`.

        Parameters
        ----------
        topic : str
            The topic for the subscription. May include wildcard characters
            `*` and `?`.
        handler : Callable[[Any], None]
            The handler for the subscription.
        priority : int, optional
            The priority for the subscription. Determines the ordering of
            handlers receiving messages being processed, higher priority
            handlers will receive messages prior to lower priority handlers.

        Raises
        ------
        ValueError
            If `topic` is not a valid string.
        ValueError
            If `handler` is not of type `Callable`.

        Warnings
        --------
        Assigning priority handling is an advanced feature which *shouldn't
        normally be needed by most users*. **Only assign a higher priority to the
        subscription if you are certain of what you're doing**. If an inappropriate
        priority is assigned then the handler may receive messages before core
        system components have been able to process necessary calculations and
        produce potential side effects for logically sound behavior.

        """
        Condition.valid_string(topic, "topic")
        Condition.callable(handler, "handler")

        # Create subscription
        cdef Subscription sub = Subscription(
            topic=topic,
            handler=handler,
            priority=priority,
        )

        # Check if already exists
        if sub in self._subscriptions:
            self._log.debug(f"{sub} already exists")
            return

        cdef list matches = []
        cdef list patterns = list(self._patterns.keys())
        cdef str pattern
        cdef list subs

        for pattern in patterns:
            if is_matching(topic, pattern):
                subs = list(self._patterns[pattern])
                subs.append(sub)
                subs = sorted(subs, reverse=True)
                self._patterns[pattern] = np.ascontiguousarray(subs, dtype=Subscription)
                matches.append(pattern)

        self._subscriptions[sub] = sorted(matches)

        self._resolved = False

        self._log.debug(f"Added {sub}")

    cpdef void unsubscribe(self, str topic, handler: Callable[[Any], None]):
        """
        Unsubscribe the given callback `handler` from the given message `topic`.

        Parameters
        ----------
        topic : str, optional
            The topic to unsubscribe from. May include wildcard characters `*`
            and `?`.
        handler : Callable[[Any], None]
            The handler for the subscription.

        Raises
        ------
        ValueError
            If `topic` is not a valid string.
        ValueError
            If `handler` is not of type `Callable`.

        """
        Condition.valid_string(topic, "topic")
        Condition.callable(handler, "handler")

        cdef Subscription sub = Subscription(topic=topic, handler=handler)

        # Check if patterns exist for sub
        cdef list patterns = self._subscriptions.get(sub)
        if patterns is None:
            self._log.warning(f"{sub} not found")
            return

        cdef str pattern
        for pattern in patterns:
            subs = list(self._patterns[pattern])
            subs.remove(sub)
            subs = sorted(subs, reverse=True)
            self._patterns[pattern] = np.ascontiguousarray(subs, dtype=Subscription)

        del self._subscriptions[sub]

        self._resolved = False

        self._log.debug(f"Removed {sub}")

    cpdef void publish(self, str topic, msg: Any, bint external_pub = True):
        """
        Publish the given message for the given `topic`.

        Subscription handlers will receive the message in priority order
        (highest first).

        Parameters
        ----------
        topic : str
            The topic to publish on.
        msg : object
            The message to publish.
        external_pub : bool, default True
            If the message should also be published externally.

        """
        self.publish_c(topic, msg, external_pub)

    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef void publish_c(self, str topic, msg: Any, bint external_pub = True):
        Condition.not_none(topic, "topic")
        Condition.not_none(msg, "msg")

        # Get all subscriptions matching topic pattern
        # Note: cannot use truthiness on array
        cdef Subscription[:] subs = self._patterns.get(topic)
        if subs is None or (not self._resolved and len(subs) == 0):
            # Add the topic pattern and get matching subscribers
            subs = self._resolve_subscriptions(topic)
            self._resolved = True

        # Send message to all matched subscribers
        cdef:
            int i
            Subscription sub
        for i in range(len(subs)):
            sub = subs[i]
            sub.handler(msg)

        # Publish externally (if configured)
        cdef bytes payload_bytes = None
        if isinstance(msg, self._publishable_types):
            if external_pub and self._database is not None and not self._database.is_closed():
                if isinstance(msg, bytes):
                    payload_bytes = msg
                else:
                    payload_bytes = self.serializer.serialize(msg)

                self._database.publish(
                    topic,
                    payload_bytes,
                )

            for listener in self._listeners:
                if listener.is_closed():
                    continue

                if payload_bytes is None:
                    if isinstance(msg, bytes):
                        payload_bytes = msg
                    else:
                        payload_bytes = self.serializer.serialize(msg)

                listener.publish(topic, payload_bytes)

        self.pub_count += 1

    cdef Subscription[:] _resolve_subscriptions(self, str topic):
        cdef list subs_list = []
        cdef Subscription existing_sub

        # Copy to handle subscription changes on iteration
        for existing_sub in self._subscriptions.copy():
            if is_matching(topic, existing_sub.topic):
                subs_list.append(existing_sub)

        subs_list = sorted(subs_list, reverse=True)
        cdef Subscription[:] subs_array = np.ascontiguousarray(subs_list, dtype=Subscription)
        self._patterns[topic] = subs_array

        cdef list matches
        for sub in subs_array:
            matches = self._subscriptions.get(sub, [])

            if topic not in matches:
                matches.append(topic)

            self._subscriptions[sub] = sorted(matches)

        return subs_array


cdef inline bint is_matching(str topic, str pattern):
    return is_matching_ffi(pystr_to_cstr(topic), pystr_to_cstr(pattern))


# Python wrapper for test access
def is_matching_py(str topic, str pattern) -> bool:
    return is_matching(topic, pattern)


cdef class Subscription:
    """
    Represents a subscription to a particular topic.

    This is an internal class intended to be used by the message bus to organize
    topics and their subscribers.

    Parameters
    ----------
    topic : str
        The topic for the subscription. May include wildcard characters `*` and `?`.
    handler : Callable[[Message], None]
        The handler for the subscription.
    priority : int
        The priority for the subscription.

    Raises
    ------
    ValueError
        If `topic` is not a valid string.
    ValueError
        If `handler` is not of type `Callable`.
    ValueError
        If `priority` is negative (< 0).

    Notes
    -----
    The subscription equality is determined by the topic and handler,
    priority is not considered (and could change).
    """

    def __init__(
        self,
        str topic,
        handler not None: Callable[[Any], None],
        int priority=0,
    ):
        Condition.valid_string(topic, "topic")
        Condition.callable(handler, "handler")
        Condition.not_negative_int(priority, "priority")

        self.topic = topic
        self.handler = handler
        self.priority = priority

    def __eq__(self, Subscription other) -> bool:
        if other is None:
            return False
        return self.topic == other.topic and self.handler == other.handler

    def __lt__(self, Subscription other) -> bool:
        return self.priority < other.priority

    def __le__(self, Subscription other) -> bool:
        return self.priority <= other.priority

    def __gt__(self, Subscription other) -> bool:
        return self.priority > other.priority

    def __ge__(self, Subscription other) -> bool:
        return self.priority >= other.priority

    def __hash__(self) -> int:
        # Convert handler to string to avoid builtin_function_or_method hashing issues
        return hash((self.topic, str(self.handler)))

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"topic={self.topic}, "
            f"handler={self.handler}, "
            f"priority={self.priority})"
        )


cdef class Throttler:
    """
    Provides a generic throttler which can either buffer or drop messages.

    Will throttle messages to the given maximum limit-interval rate.
    If an `output_drop` handler is provided, then will drop messages which
    would exceed the rate limit. Otherwise will buffer messages until within
    the rate limit, then send.

    Parameters
    ----------
    name : str
        The unique name of the throttler.
    limit : int
        The limit setting for the throttling.
    interval : timedelta
        The interval setting for the throttling.
    clock : Clock
        The clock for the throttler.
    output_send : Callable[[Any], None]
        The output handler to send messages from the throttler.
    output_drop : Callable[[Any], None], optional
        The output handler to drop messages from the throttler.
        If ``None`` then messages will be buffered.

    Raises
    ------
    ValueError
        If `name` is not a valid string.
    ValueError
        If `limit` is not positive (> 0).
    ValueError
        If `interval` is not positive (> 0).
    ValueError
        If `output_send` is not of type `Callable`.
    ValueError
        If `output_drop` is not of type `Callable` or ``None``.

    Warnings
    --------
    This throttler is not thread-safe and must be called from the same thread as
    the event loop.

    The internal buffer queue is unbounded and so a bounded queue should be
    upstream.

    """

    def __init__(
        self,
        str name,
        int limit,
        timedelta interval not None,
        Clock clock not None,
        output_send not None: Callable[[Any], None],
        output_drop: Callable[[Any], None] | None = None,
    ) -> None:
        Condition.valid_string(name, "name")
        Condition.positive_int(limit, "limit")
        Condition.positive(interval.total_seconds(), "interval.total_seconds()")
        Condition.callable(output_send, "output_send")
        Condition.callable_or_none(output_drop, "output_drop")

        self._clock = clock
        self._log = Logger(name=f"Throttler-{name}")
        self._interval_ns = secs_to_nanos(interval.total_seconds())
        self._buffer = deque()
        self._timer_name = f"{name}|DEQUE"
        self._timestamps = deque(maxlen=limit)
        self._output_send = output_send
        self._output_drop = output_drop
        self._warm = False  # If throttler has sent at least limit number of msgs

        self.name = name
        self.limit = limit
        self.interval = interval
        self.is_limiting = False
        self.recv_count = 0
        self.sent_count = 0

        self._log.info("READY")

    @property
    def qsize(self) -> int:
        """
        Return the qsize of the internal buffer.

        Returns
        -------
        int

        """
        return len(self._buffer)

    cpdef void reset(self):
        """
        Reset the state of the throttler.

        """
        self._buffer.clear()
        self._warm = False
        self.recv_count = 0
        self.sent_count = 0
        self.is_limiting = False

    cpdef double used(self):
        """
        Return the percentage of maximum rate currently used.

        Returns
        -------
        double
            [0, 1.0].

        """
        if not self._warm:
            if self.sent_count < 2:
                return 0

        cdef int64_t diff = self._clock.timestamp_ns() - self._timestamps[-1]
        diff = max_uint64(0, self._interval_ns - diff)
        cdef double used = <double>diff / <double>self._interval_ns

        if not self._warm:
            used *= <double>self.sent_count / <double>self.limit

        return used

    cpdef void send(self, msg):
        """
        Send the given message through the throttler.

        Parameters
        ----------
        msg : object
            The message to send.

        """
        self.recv_count += 1

        # Throttling is active
        if self.is_limiting:
            self._limit_msg(msg)
            return

        # Check msg rate
        cdef int64_t delta_next = self._delta_next()
        if delta_next <= 0:
            self._send_msg(msg)
        else:
            # Start throttling
            self._limit_msg(msg)

    cdef int64_t _delta_next(self):
        if not self._warm:
            if self.sent_count < self.limit:
                return 0

            self._warm = True

        cdef int64_t diff = self._clock.timestamp_ns() - self._timestamps[-1]

        return self._interval_ns - diff

    cdef void _limit_msg(self, msg):
        if self._output_drop is None:
            # Buffer
            self._buffer.appendleft(msg)
            timer_target = self._process
            self._log.warning(f"Buffering {msg}")
        else:
            # Drop
            self._output_drop(msg)
            timer_target = self._resume
            self._log.warning(f"Dropped {msg}")

        if not self.is_limiting:
            self._set_timer(timer_target)
            self.is_limiting = True

    cdef void _set_timer(self, handler: Callable[[TimeEvent], None]):
        # Cancel any existing timer
        if self._timer_name in self._clock.timer_names:
            self._clock.cancel_timer(self._timer_name)

        self._clock.set_time_alert_ns(
            name=self._timer_name,
            alert_time_ns=self._clock.timestamp_ns() + self._delta_next(),
            callback=handler,
        )

    cpdef void _process(self, TimeEvent event):
        # Send next msg on buffer
        msg = self._buffer.pop()
        self._send_msg(msg)

        # Send remaining messages if within rate
        cdef int64_t delta_next
        while self._buffer:
            delta_next = self._delta_next()
            msg = self._buffer.pop()

            if delta_next <= 0:
                self._send_msg(msg)
            else:
                self._set_timer(self._process)
                return

        # No longer throttling
        self.is_limiting = False

    cpdef void _resume(self, TimeEvent event):
        self.is_limiting = False

    cdef void _send_msg(self, msg):
        self._timestamps.appendleft(self._clock.timestamp_ns())
        self._output_send(msg)
        self.sent_count += 1


cdef inline uint64_t max_uint64(uint64_t a, uint64_t b):
    if a > b:
        return a
    else:
        return b

</document_content>
</document>
<document index="2250">
<source>nautilus_trader/common/data_topics.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
Provides a centralized topic cache for managing message bus topic generation and caching.

The `TopicCache` consolidates all topic generation methods and their caching dictionaries
that were previously scattered across the data engine and other components.
"""

from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport DataType
from nautilus_trader.model.data cimport OrderBookDelta
from nautilus_trader.model.data cimport OrderBookDepth10
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Venue


cdef class TopicCache:
    """
    Provides a centralized cache for message bus topic generation and caching.

    This class consolidates all topic generation methods and their caching dictionaries
    that were previously scattered across the data engine and other components.
    """

    def __init__(self):
        # Initialize all topic cache dictionaries
        self._topic_cache_instruments = {}
        self._topic_cache_instruments_pattern = {}
        self._topic_cache_deltas = {}
        self._topic_cache_depth = {}
        self._topic_cache_quotes = {}
        self._topic_cache_trades = {}
        self._topic_cache_status = {}
        self._topic_cache_mark_prices = {}
        self._topic_cache_index_prices = {}
        self._topic_cache_funding_rates = {}
        self._topic_cache_close_prices = {}
        self._topic_cache_snapshots = {}
        self._topic_cache_custom = {}
        self._topic_cache_custom_simple = {}
        self._topic_cache_bars = {}
        self._topic_cache_signal = {}

    cpdef str get_instrument_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_instruments.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.instrument.{instrument_id.venue}.{instrument_id.symbol}"
            self._topic_cache_instruments[key] = topic

        return topic

    cpdef str get_instruments_topic(self, Venue venue):
        """
        Get the topic pattern for all instruments at a venue.

        Parameters
        ----------
        venue : Venue
            The venue for the pattern.

        Returns
        -------
        str
            The topic pattern string.

        """
        cdef str topic = self._topic_cache_instruments_pattern.get(venue)
        if topic is None:
            topic = f"data.instrument.{venue}.*"
            self._topic_cache_instruments_pattern[venue] = topic

        return topic

    cpdef str get_book_topic(self, type book_data_type, InstrumentId instrument_id, bint historical = False):
        if book_data_type == OrderBookDelta:
            return self.get_deltas_topic(instrument_id, historical)
        elif book_data_type == OrderBookDepth10:
            return self.get_depth_topic(instrument_id, historical)
        else:  # pragma: no cover (design-time error)
            raise TypeError(f"Invalid book data type, was {book_data_type}")

    cpdef str get_deltas_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_deltas.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.book.deltas.{instrument_id.venue}.{instrument_id.symbol.topic()}"
            self._topic_cache_deltas[key] = topic

        return topic

    cpdef str get_depth_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_depth.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.book.depth.{instrument_id.venue}.{instrument_id.symbol.topic()}"
            self._topic_cache_depth[key] = topic

        return topic

    cpdef str get_quotes_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_quotes.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.quotes.{instrument_id.venue}.{instrument_id.symbol}"
            self._topic_cache_quotes[key] = topic

        return topic

    cpdef str get_trades_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_trades.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.trades.{instrument_id.venue}.{instrument_id.symbol}"
            self._topic_cache_trades[key] = topic

        return topic

    cpdef str get_status_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_status.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.status.{instrument_id.venue}.{instrument_id.symbol}"
            self._topic_cache_status[key] = topic

        return topic

    cpdef str get_mark_prices_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_mark_prices.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.mark_prices.{instrument_id.venue}.{instrument_id.symbol}"
            self._topic_cache_mark_prices[key] = topic

        return topic

    cpdef str get_index_prices_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_index_prices.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.index_prices.{instrument_id.venue}.{instrument_id.symbol}"
            self._topic_cache_index_prices[key] = topic

        return topic

    cpdef str get_funding_rates_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_funding_rates.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.funding_rates.{instrument_id.venue}.{instrument_id.symbol}"
            self._topic_cache_funding_rates[key] = topic

        return topic

    cpdef str get_close_prices_topic(self, InstrumentId instrument_id, bint historical = False):
        cdef tuple key = (instrument_id, historical)
        cdef str topic = self._topic_cache_close_prices.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.venue.close_price.{instrument_id}"
            self._topic_cache_close_prices[key] = topic

        return topic

    cpdef str get_snapshots_topic(self, InstrumentId instrument_id, int interval_ms, bint historical = False):
        cdef tuple key = (instrument_id, interval_ms, historical)
        cdef str topic = self._topic_cache_snapshots.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.book.snapshots.{instrument_id.venue}.{instrument_id.symbol}.{interval_ms}"
            self._topic_cache_snapshots[key] = topic

        return topic

    cpdef str get_custom_data_topic(self, DataType data_type, InstrumentId instrument_id = None, bint historical = False):
        cdef:
            tuple key
            str topic

        # Handle both cases: with and without instrument_id
        if instrument_id is not None:
            key = (data_type, instrument_id, historical)
            topic = self._topic_cache_custom.get(key)
            if topic is None:
                if data_type.metadata:
                    topic = f"{'historical.' if historical else ''}data.{data_type.topic}"
                else:
                    topic = f"{'historical.' if historical else ''}data.{data_type.type.__name__}.{instrument_id.venue}.{instrument_id.symbol.topic()}"
                self._topic_cache_custom[key] = topic
        else:
            key = (data_type, historical)
            topic = self._topic_cache_custom_simple.get(key)
            if topic is None:
                topic = f"{'historical.' if historical else ''}data.{data_type.topic}"
                self._topic_cache_custom_simple[key] = topic

        return topic

    cpdef str get_bars_topic(self, BarType bar_type, bint historical = False):
        cdef tuple key = (bar_type, historical)
        cdef str topic = self._topic_cache_bars.get(key)
        if topic is None:
            topic = f"{'historical.' if historical else ''}data.bars.{bar_type}"
            self._topic_cache_bars[key] = topic

        return topic

    cpdef str get_signal_topic(self, str name):
        """
        Get the topic for a signal subscription.

        Parameters
        ----------
        name : str
            The signal name.

        Returns
        -------
        str
            The topic string.

        """
        cdef str topic = self._topic_cache_signal.get(name)
        if topic is None:
            topic = f"data.Signal{name.title()}*"
            self._topic_cache_signal[name] = topic

        return topic

    cpdef void clear_cache(self):
        self._topic_cache_instruments.clear()
        self._topic_cache_instruments_pattern.clear()
        self._topic_cache_deltas.clear()
        self._topic_cache_depth.clear()
        self._topic_cache_quotes.clear()
        self._topic_cache_trades.clear()
        self._topic_cache_status.clear()
        self._topic_cache_mark_prices.clear()
        self._topic_cache_index_prices.clear()
        self._topic_cache_funding_rates.clear()
        self._topic_cache_close_prices.clear()
        self._topic_cache_snapshots.clear()
        self._topic_cache_custom.clear()
        self._topic_cache_custom_simple.clear()
        self._topic_cache_bars.clear()
        self._topic_cache_signal.clear()

</document_content>
</document>
<document index="2255">
<source>nautilus_trader/common/factories.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from cpython.datetime cimport datetime

from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.generators cimport ClientOrderIdGenerator
from nautilus_trader.common.generators cimport OrderListIdGenerator
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport dt_to_unix_nanos
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TrailingOffsetType
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.limit cimport LimitOrder
from nautilus_trader.model.orders.limit_if_touched cimport LimitIfTouchedOrder
from nautilus_trader.model.orders.list cimport OrderList
from nautilus_trader.model.orders.market_if_touched cimport MarketIfTouchedOrder
from nautilus_trader.model.orders.market_to_limit cimport MarketToLimitOrder
from nautilus_trader.model.orders.stop_market cimport StopMarketOrder
from nautilus_trader.model.orders.trailing_stop_limit cimport TrailingStopLimitOrder
from nautilus_trader.model.orders.trailing_stop_market cimport TrailingStopMarketOrder


cdef class OrderFactory:
    """
    A factory class which provides different order types.

    The `TraderId` tag and `StrategyId` tag will be inserted into all IDs generated.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID (only numerical tag sent to venue).
    strategy_id : StrategyId
        The strategy ID (only numerical tag sent to venue).
    clock : Clock
        The clock for the factory.
    cache : CacheFacade, optional
        The cache facade for the order factory.
    use_uuid_client_order_ids : bool, default False
        If UUID4's should be used for client order ID values.
    use_hyphens_in_client_order_ids : bool, default True
        If hyphens should be used in generated client order ID values.

    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        Clock clock not None,
        CacheFacade cache: CacheFacade | None = None,
        bint use_uuid_client_order_ids = False,
        bint use_hyphens_in_client_order_ids = True,
    ) -> None:
        self._clock = clock
        self._cache = cache
        self.trader_id = trader_id
        self.strategy_id = strategy_id
        self.use_uuid_client_order_ids = use_uuid_client_order_ids
        self.use_hyphens_in_client_order_ids = use_hyphens_in_client_order_ids

        self._order_id_generator = ClientOrderIdGenerator(
            trader_id=trader_id,
            strategy_id=strategy_id,
            clock=clock,
            use_uuids=use_uuid_client_order_ids,
            use_hyphens=use_hyphens_in_client_order_ids,
        )
        self._order_list_id_generator = OrderListIdGenerator(
            trader_id=trader_id,
            strategy_id=strategy_id,
            clock=clock,
        )

    cpdef get_client_order_id_count(self):
        """
        Return the client order ID count for the factory.

        Returns
        -------
        int

        """
        return self._order_id_generator.count

    cpdef get_order_list_id_count(self):
        """
        Return the order list ID count for the factory.

        Returns
        -------
        int

        """
        return self._order_list_id_generator.count

    cpdef void set_client_order_id_count(self, int count):
        """
        Set the internal order ID generator count to the given count.

        Parameters
        ----------
        count : int
            The count to set.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        self._order_id_generator.set_count(count)

    cpdef void set_order_list_id_count(self, int count):
        """
        Set the internal order list ID generator count to the given count.

        Parameters
        ----------
        count : int
            The count to set.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        self._order_list_id_generator.set_count(count)

    cpdef ClientOrderId generate_client_order_id(self):
        """
        Generate and return a new client order ID.

        The identifier will be the next in the logical sequence.

        Returns
        -------
        ClientOrderId

        """
        cdef ClientOrderId client_order_id = self._order_id_generator.generate()

        if self._order_id_generator.use_uuids:
            return client_order_id

        if self._cache is not None:
            while self._cache.order(client_order_id) is not None:
                client_order_id = self._order_id_generator.generate()

        return client_order_id

    cpdef OrderListId generate_order_list_id(self):
        """
        Generate and return a new order list ID.

        The identifier will be the next in the logical sequence.

        Returns
        -------
        OrderListId

        """
        cdef OrderListId order_list_id = self._order_list_id_generator.generate()

        if self._cache is not None:
            while self._cache.order_list(order_list_id) is not None:
                order_list_id = self._order_list_id_generator.generate()

        return order_list_id

    cpdef void reset(self):
        """
        Reset the order factory.

        All stateful fields are reset to their initial value.
        """
        self._order_id_generator.reset()
        self._order_list_id_generator.reset()

    cpdef OrderList create_list(self, list orders):
        """
        Return a new order list containing the given `orders`.

        Parameters
        ----------
        orders : list[Order]
            The orders for the list.

        Returns
        -------
        OrderList

        Raises
        ------
        ValueError
            If `orders` is empty.

        Notes
        -----
        The order at index 0 in the list will be considered the 'first' order.

        """
        Condition.not_empty(orders, "orders")

        return OrderList(
            order_list_id=self._order_list_id_generator.generate(),
            orders=orders,
        )

    cpdef MarketOrder market(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        TimeInForce time_in_force = TimeInForce.GTC,
        bint reduce_only = False,
        bint quote_quantity = False,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``MARKET`` order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
            The orders time in force. Often not applicable for market orders.
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        MarketOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `time_in_force` is ``GTD``.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return MarketOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            time_in_force=time_in_force,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef LimitOrder limit(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        Price price,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint post_only = False,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``LIMIT`` order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        price : Price
            The orders price.
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
            The orders time in force.
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        post_only : bool, default False
            If the order will only provide liquidity (make a market).
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        display_qty : Quantity, optional
            The quantity of the order to display on the public book (iceberg).
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        trigger_instrument_id : InstrumentId, optional
            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        LimitOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.
        ValueError
            If `display_qty` is negative (< 0) or greater than `quantity`.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return LimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            price=price,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            post_only=post_only,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            display_qty=display_qty,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef StopMarketOrder stop_market(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        Price trigger_price,
        TriggerType trigger_type = TriggerType.DEFAULT,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint reduce_only = False,
        bint quote_quantity = False,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``STOP_MARKET`` conditional order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        trigger_price : Price
            The orders trigger price (STOP).
        trigger_type : TriggerType, default ``DEFAULT``
            The order trigger type.
        time_in_force : TimeInForce  {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
            The orders time in force.
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        trigger_instrument_id : InstrumentId, optional
            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        StopMarketOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `trigger_type` is ``NO_TRIGGER``.
        ValueError
            If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return StopMarketOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            trigger_price=trigger_price,
            trigger_type=trigger_type,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef StopLimitOrder stop_limit(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        Price price,
        Price trigger_price,
        TriggerType trigger_type = TriggerType.DEFAULT,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint post_only = False,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``STOP_LIMIT`` conditional order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        price : Price
            The orders limit price.
        trigger_price : Price
            The orders trigger stop price.
        trigger_type : TriggerType, default ``DEFAULT``
            The order trigger type.
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
            The orders time in force.
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        post_only : bool, default False
            If the order will only provide liquidity (make a market).
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        display_qty : Quantity, optional
            The quantity of the order to display on the public book (iceberg).
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        trigger_instrument_id : InstrumentId, optional
            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        StopLimitOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `trigger_type` is ``NO_TRIGGER``.
        ValueError
            If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.
        ValueError
            If `display_qty` is negative (< 0) or greater than `quantity`.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return StopLimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            price=price,
            trigger_price=trigger_price,
            trigger_type=trigger_type,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            post_only=post_only,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            display_qty=display_qty,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef MarketToLimitOrder market_to_limit(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``MARKET`` order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        time_in_force : TimeInForce {``GTC``, ``GTD``, ``IOC``, ``FOK``}, default ``GTC``
            The orders time in force.
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        display_qty : Quantity, optional
            The quantity of the limit order to display on the public book (iceberg).
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        MarketToLimitOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return MarketToLimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            reduce_only=reduce_only,
            display_qty=display_qty,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef MarketIfTouchedOrder market_if_touched(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        Price trigger_price,
        TriggerType trigger_type = TriggerType.DEFAULT,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint reduce_only = False,
        bint quote_quantity = False,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``MARKET_IF_TOUCHED`` (MIT) conditional order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        trigger_price : Price
            The orders trigger price (STOP).
        trigger_type : TriggerType, default ``DEFAULT``
            The order trigger type.
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
            The orders time in force.
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        trigger_instrument_id : InstrumentId, optional
            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        MarketIfTouchedOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `trigger_type` is ``NO_TRIGGER``.
        ValueError
            If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return MarketIfTouchedOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            trigger_price=trigger_price,
            trigger_type=trigger_type,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef LimitIfTouchedOrder limit_if_touched(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        Price price,
        Price trigger_price,
        TriggerType trigger_type = TriggerType.DEFAULT,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint post_only = False,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``LIMIT_IF_TOUCHED`` (LIT) conditional order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        price : Price
            The orders limit price.
        trigger_price : Price
            The orders trigger stop price.
        trigger_type : TriggerType, default ``DEFAULT``
            The order trigger type.
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
            The orders time in force.
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        post_only : bool, default False
            If the order will only provide liquidity (make a market).
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        display_qty : Quantity, optional
            The quantity of the order to display on the public book (iceberg).
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        trigger_instrument_id : InstrumentId, optional
            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        LimitIfTouchedOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `trigger_type` is ``NO_TRIGGER``.
        ValueError
            If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.
        ValueError
            If `display_qty` is negative (< 0) or greater than `quantity`.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return LimitIfTouchedOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            price=price,
            trigger_price=trigger_price,
            trigger_type=trigger_type,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            post_only=post_only,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            display_qty=display_qty,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef TrailingStopMarketOrder trailing_stop_market(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        trailing_offset: Decimal,
        Price activation_price = None,
        Price trigger_price = None,
        TriggerType trigger_type = TriggerType.DEFAULT,
        TrailingOffsetType trailing_offset_type = TrailingOffsetType.PRICE,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint reduce_only = False,
        bint quote_quantity = False,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``TRAILING_STOP_MARKET`` conditional order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        trailing_offset : Decimal
            The trailing offset for the trigger price (STOP).
        activation_price : Price, optional
            The price for the order to become active. If ``None`` then the order will be activated right after the order is accepted.
        trigger_price : Price, optional
            The order trigger price (STOP). If ``None`` then will typically default
            to the delta of market price and `trailing_offset`.
        trigger_type : TriggerType, default ``DEFAULT``
            The order trigger type.
        trailing_offset_type : TrailingOffsetType, default ``PRICE``
            The order trailing offset type.
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
            The orders time in force.
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        TrailingStopMarketOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `trigger_type` is ``NO_TRIGGER``.
        ValueError
            If `trailing_offset_type` is ``NO_TRAILING_OFFSET``.
        ValueError
            If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return TrailingStopMarketOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            activation_price=activation_price,
            trigger_price=trigger_price,
            trigger_type=trigger_type,
            trailing_offset=trailing_offset,
            trailing_offset_type=trailing_offset_type,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef TrailingStopLimitOrder trailing_stop_limit(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        limit_offset: Decimal,
        trailing_offset: Decimal,
        Price price = None,
        Price activation_price = None,
        Price trigger_price = None,
        TriggerType trigger_type = TriggerType.DEFAULT,
        TrailingOffsetType trailing_offset_type = TrailingOffsetType.PRICE,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint post_only = False,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        list[str] tags = None,
        ClientOrderId client_order_id = None,
    ):
        """
        Create a new ``TRAILING_STOP_LIMIT`` conditional order.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The orders side.
        quantity : Quantity
            The orders quantity (> 0).
        trailing_offset : Decimal
            The trailing offset for the trigger price (STOP).
        limit_offset : Decimal
            The trailing offset for the order price (LIMIT).
        price : Price, optional
            The order price (LIMIT). If ``None`` then will typically default to the
            delta of market price and `limit_offset`.
        activation_price : Price, optional
            The price for the order to become active. If ``None`` then the order will be activated right after the order is accepted.
        trigger_price : Price, optional
            The order trigger price (STOP). If ``None`` then will typically default
            to the delta of market price and `trailing_offset`.
        trigger_type : TriggerType, default ``DEFAULT``
            The order trigger type.
        trailing_offset_type : TrailingOffsetType, default ``PRICE``
            The order trailing offset type.
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
            The orders time in force.
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        post_only : bool, default False
            If the order will only provide liquidity (make a market).
        reduce_only : bool, default False
            If the order carries the 'reduce-only' execution instruction.
        quote_quantity : bool
            If the order quantity is denominated in the quote currency.
        display_qty : Quantity, optional
            The quantity of the order to display on the public book (iceberg).
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        trigger_instrument_id : InstrumentId, optional
            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
        exec_algorithm_id : ExecAlgorithmId, optional
            The execution algorithm ID for the order.
        exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tags : list[str], optional
            The custom user tags for the order.
        client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        TrailingStopLimitOrder

        Raises
        ------
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `trigger_type` is ``NO_TRIGGER``.
        ValueError
            If `trailing_offset_type` is ``NO_TRAILING_OFFSET``.
        ValueError
            If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.
        ValueError
            If `display_qty` is negative (< 0) or greater than `quantity`.

        """
        if client_order_id is None:
            client_order_id = self.generate_client_order_id()
        return TrailingStopLimitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            quantity=quantity,
            price=price,
            activation_price=activation_price,
            trigger_price=trigger_price,
            trigger_type=trigger_type,
            limit_offset=limit_offset,
            trailing_offset=trailing_offset,
            trailing_offset_type=trailing_offset_type,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            post_only=post_only,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            display_qty=display_qty,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=ContingencyType.NO_CONTINGENCY,
            order_list_id=None,
            linked_order_ids=None,
            parent_order_id=None,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=client_order_id if exec_algorithm_id is not None else None,
            tags=tags,
        )

    cpdef OrderList bracket(
        self,
        InstrumentId instrument_id,
        OrderSide order_side,
        Quantity quantity,
        bint quote_quantity = False,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ContingencyType contingency_type = ContingencyType.OUO,

        # Entry order
        OrderType entry_order_type = OrderType.MARKET,
        Price entry_price = None,
        Price entry_trigger_price = None,
        datetime expire_time = None,
        TimeInForce time_in_force = TimeInForce.GTC,
        bint entry_post_only = False,
        ExecAlgorithmId entry_exec_algorithm_id = None,
        dict entry_exec_algorithm_params = None,
        list[str] entry_tags = None,
        ClientOrderId entry_client_order_id = None,

        # Take-profit order
        OrderType tp_order_type = OrderType.LIMIT,
        Price tp_price = None,
        Price tp_trigger_price = None,
        TriggerType tp_trigger_type = TriggerType.DEFAULT,
        Price tp_activation_price = None,
        tp_trailing_offset:Decimal = None,
        TrailingOffsetType tp_trailing_offset_type = TrailingOffsetType.PRICE,
        tp_limit_offset:Decimal = None,
        TimeInForce tp_time_in_force = TimeInForce.GTC,
        bint tp_post_only = True,
        ExecAlgorithmId tp_exec_algorithm_id = None,
        dict tp_exec_algorithm_params = None,
        list[str] tp_tags = None,
        ClientOrderId tp_client_order_id = None,

        # Stop-loss order
        OrderType sl_order_type = OrderType.STOP_MARKET,
        Price sl_trigger_price = None,
        TriggerType sl_trigger_type = TriggerType.DEFAULT,
        Price sl_activation_price = None,
        sl_trailing_offset:Decimal = None,
        TrailingOffsetType sl_trailing_offset_type = TrailingOffsetType.PRICE,
        TimeInForce sl_time_in_force = TimeInForce.GTC,
        ExecAlgorithmId sl_exec_algorithm_id = None,
        dict sl_exec_algorithm_params = None,
        list[str] sl_tags = None,
        ClientOrderId sl_client_order_id = None,
    ):
        """
        Create a bracket order with optional entry of take-profit order types.

        The stop-loss order will always be ``STOP_MARKET``.

        Parameters
        ----------
        instrument_id : InstrumentId
            The orders instrument ID.
        order_side : OrderSide {``BUY``, ``SELL``}
            The entry orders side.
        quantity : Quantity
            The entry orders quantity (> 0).
        quote_quantity : bool
            If order quantity is denominated in the quote currency.
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        trigger_instrument_id : InstrumentId, optional
            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
        contingency_type : ContingencyType, default ``OUO``
            The contingency type for the TP and SL bracket orders.
        entry_order_type : OrderType {``MARKET``, ``LIMIT``, ``LIMIT_IF_TOUCHED``, ``MARKET_IF_TOUCHED``, ``STOP_LIMIT``}, default ``MARKET``
            The entry order type.
        entry_price : Price, optional
            The entry order price (LIMIT).
        entry_trigger_price : Price, optional
            The entry order trigger price (STOP).
        expire_time : datetime, optional
            The order expiration (for ``GTD`` orders).
        time_in_force : TimeInForce, default ``GTC``
            The entry orders time in force.
        entry_post_only : bool, default False
            If the entry order will only provide liquidity (make a market).
        entry_exec_algorithm_id : ExecAlgorithmId, optional
            The entry order execution algorithm ID.
        entry_exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        entry_tags : list[str], default ["ENTRY"]
            The custom user tags for the entry order.
        entry_client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.
        tp_order_type : OrderType {``LIMIT``, ``LIMIT_IF_TOUCHED``, ``MARKET_IF_TOUCHED``}, default ``LIMIT``
            The take-profit order type.
        tp_price : Price, optional
            The take-profit child order price (LIMIT).
        tp_trigger_price : Price, optional
            The take-profit child order trigger price (STOP).
        tp_trigger_type : TriggerType, default ''DEFAULT''
            The take-profit order's trigger type
        tp_activation_price : Price, optional
            The price for the take-profit order to become active.
        tp_trailing_offset : Decimal
            The trailing offset for the take-profit order's trigger price (STOP).
        tp_trailing_offset_type : TrailingOffsetType, default ``PRICE``
            The trailing offset type for the take-profit order.
        tp_limit_offset : Decimal
            The trailing offset for the take-profit order's price (LIMIT).
        tp_time_in_force : TimeInForce, default ``GTC``
            The take-profit orders time in force.
        tp_post_only : bool, default False
            If the take-profit order will only provide liquidity (make a market).
        tp_exec_algorithm_id : ExecAlgorithmId, optional
            The take-profit order execution algorithm ID.
        tp_exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        tp_tags : list[str], default ["TAKE_PROFIT"]
            The custom user tags for the take-profit order.
        tp_client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.
        sl_order_type : OrderType {``STOP_MARKET``, ``TRAILING_STOP_MARKET``}, default ``STOP_MARKET``
            The stop-loss order type.
        sl_trigger_price : Price, optional
            The stop-loss child order trigger price (STOP).
        sl_trigger_type : TriggerType, default ''DEFAULT''
            The stop-loss order's trigger type
        sl_activation_price : Price, optional
            The price for the stop-loss order to become active.
        sl_trailing_offset : Decimal
            The trailing offset for the stoploss order's trigger price (STOP).
        sl_trailing_offset_type : TrailingOffsetType, default ``PRICE``
            The trailing offset type for the stop-loss order.
        sl_time_in_force : TimeInForce, default ``GTC``
            The stop-loss orders time in force.
        sl_exec_algorithm_id : ExecAlgorithmId, optional
            The stop-loss order execution algorithm ID.
        sl_exec_algorithm_params : dict[str, Any], optional
            The execution algorithm parameters for the order.
        sl_tags : list[str], default ["STOP_LOSS"]
            The custom user tags for the stop-loss order.
        sl_client_order_id : ClientOrderId, optional
            The custom client order ID for the order.
            If a client order ID is not provided then one will be generated by the factory.

        Returns
        -------
        OrderList

        """
        entry_tags = entry_tags if entry_tags is not None else ["ENTRY"]
        sl_tags = sl_tags if sl_tags is not None else ["STOP_LOSS"]
        tp_tags = tp_tags if tp_tags is not None else ["TAKE_PROFIT"]

        cdef OrderListId order_list_id = self._order_list_id_generator.generate()

        if entry_client_order_id is None:
            entry_client_order_id = self.generate_client_order_id()
        if sl_client_order_id is None:
            sl_client_order_id = self.generate_client_order_id()
        if tp_client_order_id is None:
            tp_client_order_id = self.generate_client_order_id()

        ########################################################################
        # ENTRY ORDER
        ########################################################################
        if entry_order_type == OrderType.MARKET:
            entry_order = MarketOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=instrument_id,
                client_order_id=entry_client_order_id,
                order_side=order_side,
                quantity=quantity,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=time_in_force,
                quote_quantity=quote_quantity,
                contingency_type=ContingencyType.OTO,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id, tp_client_order_id],
                parent_order_id=None,
                exec_algorithm_id=entry_exec_algorithm_id,
                exec_algorithm_params=entry_exec_algorithm_params,
                exec_spawn_id=entry_client_order_id if entry_exec_algorithm_id is not None else None,
                tags=entry_tags,
            )
        elif entry_order_type == OrderType.LIMIT:
            entry_order = LimitOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=instrument_id,
                client_order_id=entry_client_order_id,
                order_side=order_side,
                quantity=quantity,
                price=entry_price,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=time_in_force,
                expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
                post_only=entry_post_only,
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=ContingencyType.OTO,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id, tp_client_order_id],
                parent_order_id=None,
                exec_algorithm_id=entry_exec_algorithm_id,
                exec_algorithm_params=entry_exec_algorithm_params,
                exec_spawn_id=entry_client_order_id if entry_exec_algorithm_id is not None else None,
                tags=entry_tags,
            )
        elif entry_order_type == OrderType.MARKET_IF_TOUCHED:
            entry_order = MarketIfTouchedOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=instrument_id,
                client_order_id=entry_client_order_id,
                order_side=order_side,
                quantity=quantity,
                trigger_price=entry_trigger_price,
                trigger_type=TriggerType.DEFAULT,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=time_in_force,
                expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=ContingencyType.OTO,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id, tp_client_order_id],
                parent_order_id=None,
                exec_algorithm_id=entry_exec_algorithm_id,
                exec_algorithm_params=entry_exec_algorithm_params,
                exec_spawn_id=entry_client_order_id if entry_exec_algorithm_id is not None else None,
                tags=entry_tags,
            )
        elif entry_order_type == OrderType.LIMIT_IF_TOUCHED:
            entry_order = LimitIfTouchedOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=instrument_id,
                client_order_id=entry_client_order_id,
                order_side=order_side,
                quantity=quantity,
                price=entry_price,
                trigger_price=entry_trigger_price,
                trigger_type=TriggerType.DEFAULT,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=time_in_force,
                expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
                post_only=entry_post_only,
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=ContingencyType.OTO,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id, tp_client_order_id],
                parent_order_id=None,
                exec_algorithm_id=entry_exec_algorithm_id,
                exec_algorithm_params=entry_exec_algorithm_params,
                exec_spawn_id=entry_client_order_id if entry_exec_algorithm_id is not None else None,
                tags=entry_tags,
            )
        elif entry_order_type == OrderType.STOP_LIMIT:
            entry_order = StopLimitOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=instrument_id,
                client_order_id=entry_client_order_id,
                order_side=order_side,
                quantity=quantity,
                price=entry_price,
                trigger_price=entry_trigger_price,
                trigger_type=TriggerType.DEFAULT,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=time_in_force,
                expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
                post_only=entry_post_only,
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=ContingencyType.OTO,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id, tp_client_order_id],
                parent_order_id=None,
                exec_algorithm_id=entry_exec_algorithm_id,
                exec_algorithm_params=entry_exec_algorithm_params,
                exec_spawn_id=entry_client_order_id if entry_exec_algorithm_id is not None else None,
                tags=entry_tags,
            )
        else:
            raise ValueError(f"invalid `entry_order_type`, was {order_type_to_str(entry_order_type)}")

        ########################################################################
        # TAKE-PROFIT ORDER
        ########################################################################
        if tp_order_type == OrderType.LIMIT:
            tp_order = LimitOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=entry_order.instrument_id,
                client_order_id=tp_client_order_id,
                order_side=Order.opposite_side_c(entry_order.side),
                quantity=quantity,
                price=tp_price,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=tp_time_in_force,
                post_only=tp_post_only,
                reduce_only=True,
                quote_quantity=quote_quantity,
                display_qty=None,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=contingency_type,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id],
                parent_order_id=entry_client_order_id,
                exec_algorithm_id=tp_exec_algorithm_id,
                exec_algorithm_params=tp_exec_algorithm_params,
                exec_spawn_id=tp_client_order_id if tp_exec_algorithm_id is not None else None,
                tags=tp_tags,
            )
        elif tp_order_type == OrderType.LIMIT_IF_TOUCHED:
            tp_order = LimitIfTouchedOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=entry_order.instrument_id,
                client_order_id=tp_client_order_id,
                order_side=Order.opposite_side_c(entry_order.side),
                quantity=quantity,
                price=tp_price,
                trigger_price=tp_trigger_price,
                trigger_type=tp_trigger_type,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=tp_time_in_force,
                post_only=tp_post_only,
                reduce_only=True,
                quote_quantity=quote_quantity,
                display_qty=None,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=contingency_type,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id],
                parent_order_id=entry_client_order_id,
                exec_algorithm_id=tp_exec_algorithm_id,
                exec_algorithm_params=tp_exec_algorithm_params,
                exec_spawn_id=tp_client_order_id if tp_exec_algorithm_id is not None else None,
                tags=tp_tags,
            )
        elif tp_order_type == OrderType.MARKET_IF_TOUCHED:
            tp_order = MarketIfTouchedOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=entry_order.instrument_id,
                client_order_id=tp_client_order_id,
                order_side=Order.opposite_side_c(entry_order.side),
                quantity=quantity,
                trigger_price=tp_trigger_price,
                trigger_type=tp_trigger_type,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=tp_time_in_force,
                reduce_only=True,
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=contingency_type,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id],
                parent_order_id=entry_client_order_id,
                exec_algorithm_id=tp_exec_algorithm_id,
                exec_algorithm_params=tp_exec_algorithm_params,
                exec_spawn_id=tp_client_order_id if tp_exec_algorithm_id is not None else None,
                tags=tp_tags,
            )
        elif tp_order_type == OrderType.TRAILING_STOP_MARKET:
            tp_order = TrailingStopMarketOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=entry_order.instrument_id,
                client_order_id=tp_client_order_id,
                order_side=Order.opposite_side_c(entry_order.side),
                quantity=quantity,
                activation_price=tp_activation_price,
                trigger_price=tp_trigger_price,
                trigger_type=tp_trigger_type,
                trailing_offset=tp_trailing_offset,
                trailing_offset_type=tp_trailing_offset_type,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=tp_time_in_force,
                reduce_only=True,
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=contingency_type,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id],
                parent_order_id=entry_client_order_id,
                exec_algorithm_id=tp_exec_algorithm_id,
                exec_algorithm_params=tp_exec_algorithm_params,
                exec_spawn_id=tp_client_order_id if tp_exec_algorithm_id is not None else None,
                tags=tp_tags,
            )
        elif tp_order_type == OrderType.TRAILING_STOP_LIMIT:
            tp_order = TrailingStopLimitOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=entry_order.instrument_id,
                client_order_id=tp_client_order_id,
                order_side=Order.opposite_side_c(entry_order.side),
                quantity=quantity,
                price=tp_price,
                activation_price=tp_activation_price,
                trigger_price=tp_trigger_price,
                trigger_type=tp_trigger_type,
                limit_offset=tp_limit_offset,
                trailing_offset=tp_trailing_offset,
                trailing_offset_type=tp_trailing_offset_type,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=tp_time_in_force,
                reduce_only=True,
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=contingency_type,
                order_list_id=order_list_id,
                linked_order_ids=[sl_client_order_id],
                parent_order_id=entry_client_order_id,
                exec_algorithm_id=tp_exec_algorithm_id,
                exec_algorithm_params=tp_exec_algorithm_params,
                exec_spawn_id=tp_client_order_id if tp_exec_algorithm_id is not None else None,
                tags=tp_tags,
            )
        else:
            raise ValueError(f"invalid `tp_order_type`, was {order_type_to_str(tp_order_type)}")

        ########################################################################
        # STOP-LOSS ORDER
        ########################################################################
        if sl_order_type == OrderType.STOP_MARKET:
            sl_order = StopMarketOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=entry_order.instrument_id,
                client_order_id=sl_client_order_id,
                order_side=Order.opposite_side_c(entry_order.side),
                quantity=quantity,
                trigger_price=sl_trigger_price,
                trigger_type=TriggerType.DEFAULT,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=sl_time_in_force,
                reduce_only=True,
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=contingency_type,
                order_list_id=order_list_id,
                linked_order_ids=[tp_client_order_id],
                parent_order_id=entry_client_order_id,
                exec_algorithm_id=sl_exec_algorithm_id,
                exec_algorithm_params=sl_exec_algorithm_params,
                exec_spawn_id=sl_client_order_id if sl_exec_algorithm_id is not None else None,
                tags=sl_tags,
            )
        elif sl_order_type == OrderType.TRAILING_STOP_MARKET:
            sl_order = TrailingStopMarketOrder(
                trader_id=self.trader_id,
                strategy_id=self.strategy_id,
                instrument_id=entry_order.instrument_id,
                client_order_id=sl_client_order_id,
                order_side=Order.opposite_side_c(entry_order.side),
                quantity=quantity,
                activation_price=sl_activation_price,
                trigger_price=sl_trigger_price,
                trigger_type=sl_trigger_type,
                trailing_offset=sl_trailing_offset,
                trailing_offset_type=sl_trailing_offset_type,
                init_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
                time_in_force=sl_time_in_force,
                reduce_only=True,
                quote_quantity=quote_quantity,
                emulation_trigger=emulation_trigger,
                trigger_instrument_id=trigger_instrument_id,
                contingency_type=contingency_type,
                order_list_id=order_list_id,
                linked_order_ids=[tp_client_order_id],
                parent_order_id=entry_client_order_id,
                exec_algorithm_id=sl_exec_algorithm_id,
                exec_algorithm_params=sl_exec_algorithm_params,
                exec_spawn_id=sl_client_order_id if sl_exec_algorithm_id is not None else None,
                tags=sl_tags,
            )
        else:
            raise ValueError(f"invalid `sl_order_type`, was {order_type_to_str(sl_order_type)}")

        return OrderList(
            order_list_id=order_list_id,
            orders=[entry_order, sl_order, tp_order],
        )

</document_content>
</document>
<document index="2258">
<source>nautilus_trader/common/generators.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from cpython.datetime cimport datetime

from nautilus_trader.common.component cimport Clock
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId


cdef class IdentifierGenerator:
    """
    Provides a generator for unique ID strings.

    Parameters
    ----------
    trader_id : TraderId
        The ID tag for the trader.
    clock : Clock
        The internal clock.
    """

    def __init__(self, TraderId trader_id not None, Clock clock not None):
        self._clock = clock
        self._id_tag_trader = trader_id.get_tag()

    cdef str _get_datetime_tag(self):
        """
        Return the tag string for the current timestamp (UTC).

        Returns
        -------
        str

        """
        cdef datetime now = self._clock.utc_now()
        return (
            f"{now.year}"
            f"{now.month:02d}"
            f"{now.day:02d}-"
            f"{now.hour:02d}"
            f"{now.minute:02d}"
            f"{now.second:02d}"
        )


cdef class ClientOrderIdGenerator(IdentifierGenerator):
    """
    Provides a generator for unique `ClientOrderId`(s).

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the generator.
    strategy_id : StrategyId
        The strategy ID for the generator.
    clock : Clock
        The clock for the generator.
    initial_count : int
        The initial count for the generator.
    use_uuids : bool, default False
        If UUID4's should be used for client order ID values.
    use_hyphens : bool, default True
        If hyphens should be used in generated client order ID values.

    Raises
    ------
    ValueError
        If `initial_count` is negative (< 0).
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        Clock clock not None,
        int initial_count=0,
        bint use_uuids=False,
        bint use_hyphens=True,
    ):
        Condition.not_negative_int(initial_count, "initial_count")
        super().__init__(trader_id, clock)

        self._id_tag_strategy = strategy_id.get_tag()
        self.count = initial_count
        self.use_uuids = use_uuids
        self.use_hyphens = use_hyphens

    cpdef void set_count(self, int count):
        """
        Set the internal counter to the given count.

        Parameters
        ----------
        count : int
            The count to set.

        """
        self.count = count

    cpdef ClientOrderId generate(self):
        """
        Return a unique client order ID.

        Returns
        -------
        ClientOrderId

        """
        cdef str client_order_id_value
        cdef str datetime_tag

        if self.use_uuids:
            client_order_id_value = UUID4().value
            if not self.use_hyphens:
                client_order_id_value = client_order_id_value.replace("-", "")
        else:
            self.count += 1
            if not self.use_hyphens:
                datetime_tag = self._get_datetime_tag().replace("-", "")
                client_order_id_value = (
                    f"O"
                    f"{datetime_tag}"
                    f"{self._id_tag_trader}"
                    f"{self._id_tag_strategy}"
                    f"{self.count}"
                )
            else:
                client_order_id_value = (
                    f"O-"
                    f"{self._get_datetime_tag()}-"
                    f"{self._id_tag_trader}-"
                    f"{self._id_tag_strategy}-"
                    f"{self.count}"
                )

        return ClientOrderId(client_order_id_value)

    cpdef void reset(self):
        """
        Reset the ID generator.

        All stateful fields are reset to their initial value.
        """
        self.count = 0


cdef class OrderListIdGenerator(IdentifierGenerator):
    """
    Provides a generator for unique `OrderListId`(s).

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the generator.
    strategy_id : StrategyId
        The strategy ID for the generator.
    clock : Clock
        The clock for the generator.
    initial_count : int
        The initial count for the generator.

    Raises
    ------
    ValueError
        If `initial_count` is negative (< 0).
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        Clock clock not None,
        int initial_count=0,
    ):
        Condition.not_negative_int(initial_count, "initial_count")
        super().__init__(trader_id, clock)

        self._id_tag_strategy = strategy_id.get_tag()
        self.count = initial_count

    cpdef void set_count(self, int count):
        """
        Set the internal counter to the given count.

        Parameters
        ----------
        count : int
            The count to set.

        """
        self.count = count

    cpdef OrderListId generate(self):
        """
        Return a unique order list ID.

        Returns
        -------
        OrderListId

        """
        self.count += 1

        return OrderListId(
            f"OL-"
            f"{self._get_datetime_tag()}-"
            f"{self._id_tag_trader}-"
            f"{self._id_tag_strategy}-"
            f"{self.count}",
        )

    cpdef void reset(self):
        """
        Reset the ID generator.

        All stateful fields are reset to their initial value.
        """
        self.count = 0


cdef class PositionIdGenerator(IdentifierGenerator):
    """
    Provides a generator for unique PositionId(s).

    Parameters
    ----------
    trader_id : TraderId
        The trader ID tag for the generator.
    """

    def __init__(self, TraderId trader_id not None, Clock clock not None):
        super().__init__(trader_id, clock)

        self._counts: dict[StrategyId, int] = {}

    cpdef void set_count(self, StrategyId strategy_id, int count):
        """
        Set the internal position count for the given strategy ID.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the count.
        count : int
            The count to set.

        Raises
        ------
        ValueError
            If `count` is negative (< 0).

        """
        Condition.not_none(strategy_id, "strategy_id")
        Condition.not_negative_int(count, "count")

        self._counts[strategy_id] = count

    cpdef int get_count(self, StrategyId strategy_id):
        """
        Return the internal position count for the given strategy ID.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the count.

        Returns
        -------
        int

        """
        Condition.not_none(strategy_id, "strategy_id")

        return self._counts.get(strategy_id, 0)

    cpdef PositionId generate(self, StrategyId strategy_id, bint flipped=False):
        """
        Return a unique position ID.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the position.
        flipped : bool
            If the position is being flipped. If True, then the generated id
            will be appended with 'F'.

        Returns
        -------
        PositionId

        """
        Condition.not_none(strategy_id, "strategy_id")

        cdef int count = self._counts.get(strategy_id, 0)
        count += 1
        self._counts[strategy_id] = count

        return PositionId(
            f"P-"
            f"{self._get_datetime_tag()}-"
            f"{self._id_tag_trader}-"
            f"{strategy_id.get_tag()}-"
            f"{count}{'F' if flipped else ''}",
        )

    cpdef void reset(self):
        """
        Reset the ID generator.

        All stateful fields are reset to their initial value.
        """
        self._counts.clear()

</document_content>
</document>
<document index="2261">
<source>nautilus_trader/common/messages.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import decimal
import json
import re

from libc.stdint cimport uint64_t

from nautilus_trader.common.component cimport component_state_from_str
from nautilus_trader.common.component cimport component_state_to_str
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.message cimport Command
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.common cimport ComponentState
from nautilus_trader.core.rust.model cimport TradingState
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.functions cimport trading_state_from_str
from nautilus_trader.model.functions cimport trading_state_to_str
from nautilus_trader.model.identifiers cimport ComponentId
from nautilus_trader.model.identifiers cimport Identifier
from nautilus_trader.model.identifiers cimport TraderId


cdef class ShutdownSystem(Command):
    """
    Represents a command to shut down a system and terminate the process.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the event.
    component_id : Identifier
        The component ID associated with the event.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reason : str, optional
        The reason for the shutdown command (can be None).
    """

    def __init__(
        self,
        TraderId trader_id not None,
        Identifier component_id not None,
        UUID4 command_id not None,
        uint64_t ts_init,
        str reason = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(command_id, ts_init, correlation_id)
        self.trader_id = trader_id
        self.component_id = component_id
        self.reason = reason
        self._command_id = command_id
        self._ts_init = ts_init

    def __eq__(self, Command other) -> bool:
        if other is None:
            return False
        return self._command_id == other.id

    def __hash__(self) -> int:
        return hash(self._command_id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id.to_str()}, "
            f"component_id={self.component_id.to_str()}, "
            f"reason='{self.reason}', "
            f"command_id={self._command_id.to_str()})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id.to_str()}, "
            f"component_id={self.component_id.to_str()}, "
            f"reason='{self.reason}', "
            f"command_id={self._command_id.to_str()}, "
            f"ts_init={self._ts_init})"
        )

    @staticmethod
    cdef ShutdownSystem from_dict_c(dict values):
        Condition.not_none(values, "values")
        return ShutdownSystem(
            trader_id=TraderId(values["trader_id"]),
            component_id=ComponentId(values["component_id"]),
            reason=values["reason"],
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
            correlation_id=UUID4.from_str_c(values["correlation_id"]) if values.get("correlation_id") else None,
        )

    @staticmethod
    cdef dict to_dict_c(ShutdownSystem obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "ShutdownSystem",
            "trader_id": obj.trader_id.to_str(),
            "component_id": obj.component_id.to_str(),
            "reason": obj.reason,
            "command_id": obj._command_id.to_str(),
            "ts_init": obj._ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> ShutdownSystem:
        """
        Return a shutdown system command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        ShutdownSystem

        """
        return ShutdownSystem.from_dict_c(values)

    @staticmethod
    def to_dict(ShutdownSystem obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return ShutdownSystem.to_dict_c(obj)



cdef class ComponentStateChanged(Event):
    """
    Represents an event which includes information on the state of a component.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the event.
    component_id : Identifier
        The component ID associated with the event.
    component_type : str
        The component type.
    state : ComponentState
        The component state.
    config : dict[str, Any]
        The component configuration for the event.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the component state event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        Identifier component_id not None,
        str component_type not None,
        ComponentState state,
        dict config not None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        self.trader_id = trader_id
        self.component_id = component_id
        self.component_type = component_type
        self.state = state
        self.config = config
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self._event_id == other.id

    def __hash__(self) -> int:
        return hash(self._event_id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id.to_str()}, "
            f"component_id={self.component_id.to_str()}, "
            f"component_type={self.component_type}, "
            f"state={component_state_to_str(self.state)}, "
            f"config={self.config}, "
            f"event_id={self._event_id.to_str()})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id.to_str()}, "
            f"component_id={self.component_id.to_str()}, "
            f"component_type={self.component_type}, "
            f"state={component_state_to_str(self.state)}, "
            f"config={self.config}, "
            f"event_id={self._event_id.to_str()}, "
            f"ts_init={self._ts_init})"
        )

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef ComponentStateChanged from_dict_c(dict values):
        Condition.not_none(values, "values")
        return ComponentStateChanged(
            trader_id=TraderId(values["trader_id"]),
            component_id=ComponentId(values["component_id"]),
            component_type=values["component_type"],
            state=component_state_from_str(values["state"]),
            config=values["config"],
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(ComponentStateChanged obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "ComponentStateChanged",
            "trader_id": obj.trader_id.to_str(),
            "component_id": obj.component_id.to_str(),
            "component_type": obj.component_type,
            "state": component_state_to_str(obj.state),
            "config": obj.config,
            "event_id": obj._event_id.to_str(),
            "ts_event": obj._ts_event,
            "ts_init": obj._ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> ComponentStateChanged:
        """
        Return a component state changed event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        ComponentStateChanged

        """
        return ComponentStateChanged.from_dict_c(values)

    @staticmethod
    def to_dict(ComponentStateChanged obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return ComponentStateChanged.to_dict_c(obj)


cdef class RiskEvent(Event):
    """
    The base class for all risk events.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the event.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the component state event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        self.trader_id = trader_id
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self._event_id == other.id

    def __hash__(self) -> int:
        return hash(self._event_id)

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init


cdef class TradingStateChanged(RiskEvent):
    """
    Represents an event where trading state has changed at the `RiskEngine`.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the event.
    state : TradingState
        The trading state for the event.
    config : dict[str, Any]
        The configuration of the risk engine.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the component state event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        TradingState state,
        dict config not None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        self.trader_id = trader_id
        self.state = state
        self.config = config
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id.to_str()}, "
            f"state={trading_state_to_str(self.state)}, "
            f"config={self.config}, "
            f"event_id={self._event_id.to_str()})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id.to_str()}, "
            f"state={trading_state_to_str(self.state)}, "
            f"config={self.config}, "
            f"event_id={self._event_id.to_str()}, "
            f"ts_init={self._ts_init})"
        )

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef TradingStateChanged from_dict_c(dict values):
        Condition.not_none(values, "values")
        return TradingStateChanged(
            trader_id=TraderId(values["trader_id"]),
            state=trading_state_from_str(values["state"]),
            config=values["config"],
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(TradingStateChanged obj):
        Condition.not_none(obj, "obj")

        return {
            "type": "TradingStateChanged",
            "trader_id": obj.trader_id.to_str(),
            "state": trading_state_to_str(obj.state),
            "config": obj.config,
            "event_id": obj._event_id.to_str(),
            "ts_event": obj._ts_event,
            "ts_init": obj._ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> TradingStateChanged:
        """
        Return a trading state changed event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        TradingStateChanged

        """
        return TradingStateChanged.from_dict_c(values)

    @staticmethod
    def to_dict(TradingStateChanged obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return TradingStateChanged.to_dict_c(obj)

</document_content>
</document>
<document index="2269">
<source>nautilus_trader/core/correctness.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
Defines static condition checks similar to the `design by contract` philosophy
to help ensure software correctness.
"""

from cpython.object cimport PyCallable_Check


cdef class Condition:
    """
    Provides checking of function or method conditions.

    A condition is a predicate which must be true just prior to the execution of
    some section of code - for correct behavior as per the design specification.

    If a check fails, then an Exception is thrown with a descriptive message.
    """

    @staticmethod
    cdef void is_true(bint predicate, str fail_msg, ex_type = None):
        """
        Check the condition predicate is True.

        Parameters
        ----------
        predicate : bool
            The condition predicate to check.
        fail_msg : str
            The failure message when the predicate is False.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
            If `predicate` condition is False.

        """
        if predicate:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=fail_msg,
        )

    @staticmethod
    cdef void is_false(bint predicate, str fail_msg, ex_type = None):
        """
        Check the condition predicate is False.

        Parameters
        ----------
        predicate : bool
            The condition predicate to check.
        fail_msg : str
            The failure message when the predicate is True.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
            If `predicate` condition is True.

        """
        if not predicate:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=fail_msg,
        )

    @staticmethod
    cdef void none(object argument, str param, ex_type = None):
        """
        Check the argument is ``None``.

        Parameters
        ----------
        argument : object
            The argument to check.
        param : str
            The argument parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not ``None``.

        """
        if argument is None:
            return  # Check passed

        raise make_exception(
            ex_default=TypeError,
            ex_type=ex_type,
            msg=f"\'{param}\' argument was not `None`",
        )

    @staticmethod
    cdef void not_none(object argument, str param, ex_type = None):
        """
        Check the argument is not ``None``.

        Parameters
        ----------
        argument : object
            The argument to check.
        param : str
            The argument parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is ``None``.

        """
        if argument is not None:
            return  # Check passed

        raise make_exception(
            ex_default=TypeError,
            ex_type=ex_type,
            msg=f"\'{param}\' argument was `None`",
        )

    @staticmethod
    cdef void type(
        object argument,
        object expected,
        str param,
        ex_type = None,
    ):
        """
        Check the argument is of the specified type.

        Parameters
        ----------
        argument : object
            The object to check.
        expected : type or tuple of types
            The expected type(s).
        param : str
            The argument parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `object` is not of the expected type.

        """
        if isinstance(argument, expected):
            return  # Check passed

        raise make_exception(
            ex_default=TypeError,
            ex_type=ex_type,
            msg=f"\'{param}\' argument not of type {expected}, was {type(argument)}",
        )

    @staticmethod
    cdef void type_or_none(
        object argument,
        object expected,
        str param,
        ex_type = None,
    ):
        """
        Check the argument is of the specified type, or is ``None``.

        Parameters
        ----------
        argument : object
            The object to check.
        expected : type or tuple of types
            The expected type(s) (if not ``None``).
        param : str
            The argument parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `object` is not ``None`` and not of the expected type.

        """
        if argument is None:
            return  # Check passed

        Condition.type(argument, expected, param, ex_type)

    @staticmethod
    cdef void callable(object argument, str param, ex_type = None):
        """
        Check the object is of type `Callable`.

        Parameters
        ----------
        argument : object
            The object to check.
        param : str
            The object parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not of type `Callable`.

        """
        if PyCallable_Check(argument):
            return  # Check passed

        raise make_exception(
            ex_default=TypeError,
            ex_type=ex_type,
            msg=f"\'{param}\' object was not callable",
        )

    @staticmethod
    cdef void callable_or_none(object argument, str param, ex_type = None):
        """
        Check the object is of type `Callable` or ``None``.

        Parameters
        ----------
        argument : object
            The object to check.
        param : str
            The object parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not ``None`` and not of type `Callable`.

        """
        if argument is None:
            return  # Check passed

        Condition.callable(argument, param, ex_type)

    @staticmethod
    cdef void equal(
        object argument1,
        object argument2,
        str param1,
        str param2,
        ex_type = None,
    ):
        """
        Check the objects are equal.

        Parameters
        ----------
        argument1 : object
            The first object to check.
        argument2 : object
            The second object to check.
        param1 : str
            The first objects parameter name.
        param2 : str
            The second objects parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
            If objects are not equal.

        """
        if argument1 == argument2:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=(f"\'{param1}\' {type(argument1)} of {argument1} "
                 f"was not equal to \'{param2}\' {type(argument2)} of {argument2}"),
        )

    @staticmethod
    cdef void not_equal(
        object object1,
        object object2,
        str param1,
        str param2,
        ex_type = None,
    ):
        """
        Check the objects are not equal.

        Parameters
        ----------
        object1 : object
            The first object to check.
        object2 : object
            The second object to check.
        param1 : str
            The first objects parameter name.
        param2 : str
            The second objects parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
            If objects are equal.

        """
        if object1 != object2:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=(f"\'{param1}\' {type(object1)} of {object1} "
                 f"was equal to \'{param2}\' {type(object2)} of {object1}"),
        )

    @staticmethod
    cdef void list_type(
        list argument,
        type expected_type,
        str param,
        ex_type = None,
    ):
        """
        Check the list only contains types of the given expected type.

        Parameters
        ----------
        argument : list
            The list to check.
        expected_type : type
            The expected element type (if not empty).
        param : str
            The list parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
             If `argument` is not empty and contains a type other than `expected_type`.

        """
        Condition.not_none(argument, param, ex_type)

        if all(isinstance(element, expected_type) for element in argument):
            return  # Check passed

        raise make_exception(
            ex_default=TypeError,
            ex_type=ex_type,
            msg=f"\'{param}\' collection contained an element with type other than {expected_type}",
        )

    @staticmethod
    cdef void dict_types(
        dict argument,
        type key_type,
        type value_type,
        str param,
        ex_type = None,
    ):
        """
        Check the dictionary only contains types of the given key and value types to contain.

        Parameters
        ----------
        argument : dict
            The dictionary to check.
        key_type : type
            The expected type of the keys (if not empty).
        value_type : type
            The expected type of the values (if not empty).
        param : str
            The dictionary parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not empty and contains a key type other than `key_type`.
            If `argument` is not empty and contains a value type other than `value_type`.

        """
        Condition.not_none(argument, param, ex_type)
        Condition.list_type(list(argument.keys()), key_type, f"{param} keys", ex_type)
        Condition.list_type(list(argument.values()), value_type, f"{param} values", ex_type)

    @staticmethod
    cdef void is_in(
        object element,
        object collection,
        str param1,
        str param2,
        ex_type = None,
    ):
        """
        Check the element is contained within the specified collection.

        Parameters
        ----------
        element : object
            The element to check.
        collection : iterable
            The collection to check.
        param1 : str
            The elements parameter name.
        param2 : str
            The collections name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        KeyError
            If `element` is not contained in the `collection`.

        """
        Condition.not_none(collection, param2, ex_type)

        if element in collection:
            return  # Check passed

        raise make_exception(
            ex_default=KeyError,
            ex_type=ex_type,
            msg=f"\'{param1}\' {element} not contained in \'{param2}\' collection",
        )

    @staticmethod
    cdef void not_in(
        object element,
        object collection,
        str param1,
        str param2,
        ex_type = None,
    ):
        """
        Check the element is not contained within the specified collection.

        Parameters
        ----------
        element : object
            The element to check.
        collection : iterable
            The collection to check.
        param1 : str
            The elements parameter name.
        param2 : str
            The collections name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        KeyError
            If `element` is contained in the `collection`.

        """
        Condition.not_none(collection, param2, ex_type)

        if element not in collection:
            return  # Check passed

        raise make_exception(
            ex_default=KeyError,
            ex_type=ex_type,
            msg=f"\'{param1}\' {element} already contained in \'{param2}\' collection",
        )

    @staticmethod
    cdef void not_empty(object collection, str param, ex_type = None):
        """
        Check the collection is not empty.

        Parameters
        ----------
        collection : iterable
            The collection to check.
        param : str
            The collection parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
             If `collection` is empty.

        """
        Condition.not_none(collection, param, ex_type)

        if collection:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' collection was empty",
        )

    @staticmethod
    cdef void empty(object collection, str param, ex_type = None):
        """
        Check the collection is empty.

        Parameters
        ----------
        collection : iterable
            The collection to check.
        param : str
            The collection parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
             If `collection` is not empty.

        """
        Condition.not_none(collection, param)

        if not collection:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' collection was not empty",
        )

    @staticmethod
    cdef void positive(double value, str param, ex_type = None):
        """
        Check the real number value is positive (> 0).

        Parameters
        ----------
        value : scalar
            The value to check.
        param : str
            The name of the values parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
             If `value` is not positive (> 0).

        """
        if value > 0:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' not a positive real, was {value:_}",
        )

    @staticmethod
    cdef void positive_int(value: int, str param, ex_type = None):
        """
        Check the integer value is a positive integer (> 0).

        Parameters
        ----------
        value : int
            The value to check.
        param : str
            The name of the values parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
             If `value` is not positive (> 0).

        """
        if value > 0:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' not a positive integer, was {value:_}",
        )

    @staticmethod
    cdef void not_negative(double value, str param, ex_type = None):
        """
        Check the real number value is not negative (< 0).

        Parameters
        ----------
        value : scalar
            The value to check.
        param : str
            The name of the values parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `value` is negative (< 0).

        """
        if value >= 0.0:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' not greater than or equal to zero (>= 0), was {value:_}",
        )

    @staticmethod
    cdef void not_negative_int(value: int, str param, ex_type = None):
        """
        Check the integer value is not negative (< 0).

        Parameters
        ----------
        value : int
            The value to check.
        param : str
            The name of the values parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `value` is negative (< 0).

        """
        if value >= 0:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' not greater than or equal to zero (>= 0), was {value:_}",
        )

    @staticmethod
    cdef void in_range(
        double value,
        double start,
        double end,
        str param,
        ex_type = None,
    ):
        """
        Check the real number value is within the specified range (inclusive).

        This function accounts for potential floating-point precision issues by using a small
        epsilon value of 1e-15.

        Parameters
        ----------
        value : scalar
            The value to check.
        start : scalar
            The start of the range.
        end : scalar
            The end of the range.
        param : str
            The name of the values parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `value` is not within the range (inclusive of the end points).

        """
        cdef double epsilon = 1e-15  # Epsilon to account for floating-point precision issues
        if start - epsilon <= value <= end + epsilon:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' out of range [{start:_}, {end:_}], was {value:_}",
        )

    @staticmethod
    cdef void in_range_int(
        value,
        start,
        end,
        str param,
        ex_type = None,
    ):
        """
        Check the integer value is within the specified range (inclusive).

        Parameters
        ----------
        value : int
            The value to check.
        start : int
            The start of the range.
        end : int
            The end of the range.
        param : str
            The name of the values parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `value` is not within the range (inclusive of the end points).

        """
        if start <= value <= end:
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' out of range [{start:_}, {end:_}], was {value:_}",
        )

    @staticmethod
    cdef void valid_string(str argument, str param, ex_type = None):
        """
        Check the string argument is valid (not ``None``, empty or whitespace).

        Parameters
        ----------
        argument : str
            The string argument to check.
        param : str
            The arguments parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `argument` is ``None``, empty or whitespace.

        """
        Condition.not_none(argument, param, ex_type)

        if argument != "" and not argument.isspace():
            return  # Check passed

        raise make_exception(
            ex_default=ValueError,
            ex_type=ex_type,
            msg=f"\'{param}\' string was invalid, was \'{argument}\'",
        )


class PyCondition:

    @staticmethod
    def is_true(bint predicate, str fail_msg, ex_type = None):
        """
        Check the condition predicate is True.

        Parameters
        ----------
        predicate : bool
            The condition predicate to check.
        fail_msg : str
            The failure message when the predicate is False.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
            If `predicate` condition is False.

        """
        Condition.is_true(predicate, fail_msg, ex_type)

    @staticmethod
    def is_false(bint predicate, str fail_msg, ex_type = None):
        """
        Check the condition predicate is False.

        Parameters
        ----------
        predicate : bool
            The condition predicate to check.
        fail_msg : str
            The failure message when the predicate is True
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
            If `predicate` condition is True.

        """
        Condition.is_false(predicate, fail_msg, ex_type)

    @staticmethod
    def none(argument, str param, ex_type = None):
        """
        Check the argument is ``None``.

        Parameters
        ----------
        argument : object
            The argument to check.
        param : str
            The arguments parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not ``None``.

        """
        Condition.none(argument, param, ex_type)

    @staticmethod
    def not_none(argument, str param, ex_type = None):
        """
        Check the argument is not ``None``.

        Parameters
        ----------
        argument : object
            The argument to check.
        param : str
            The arguments parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is ``None``.

        """
        Condition.not_none(argument, param, ex_type)

    @staticmethod
    def type(argument, expected, str param, ex_type = None):
        """
        Check the argument is of the specified type.

        Parameters
        ----------
        argument : object
            The object to check.
        expected : object
            The expected class type.
        param : str
            The arguments parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not of the expected type.

        """
        Condition.type(argument, expected, param, ex_type)

    @staticmethod
    def type_or_none(argument, expected, str param, ex_type = None):
        """
        Check the argument is of the specified type, or is ``None``.

        Parameters
        ----------
        argument : object
            The object to check.
        expected : object
            The expected class type (if not ``None``).
        param : str
            The arguments parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not ``None`` and not of the expected type.

        """
        Condition.type_or_none(argument, expected, param, ex_type)

    @staticmethod
    def callable(argument, str param, ex_type = None):
        """
        Check the object is of type `Callable`.

        Parameters
        ----------
        argument : object
            The object to check.
        param : str
            The objects parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not of type `Callable`.

        """
        Condition.callable(argument, param, ex_type)

    @staticmethod
    def callable_or_none(argument, str param, ex_type = None):
        """
        Check the object is of type `Callable` or ``None``.

        Parameters
        ----------
        argument : object
            The object to check.
        param : str
            The objects parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not ``None`` and not of type `Callable`.

        """
        Condition.callable_or_none(argument, param, ex_type)

    @staticmethod
    def equal(argument1, argument2, str param1, str param2, ex_type = None):
        """
        Check the objects are equal.

        Parameters
        ----------
        argument1 : object
            The first object to check.
        argument2 : object
            The second object to check.
        param1 : str
            The first objects parameter name.
        param2 : str
            The second objects parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
            If objects are not equal.

        """
        Condition.equal(argument1, argument2, param1, param2, ex_type)

    @staticmethod
    def not_equal(argument1, argument2, str param1, str param2, ex_type = None):
        """
        Check the objects are not equal.

        Parameters
        ----------
        argument1 : object
            The first object to check.
        argument2 : object
            The second object to check.
        param1 : str
            The first objects parameter name.
        param2 : str
            The second objects parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
            If objects are equal.

        """
        Condition.not_equal(argument1, argument2, param1, param2, ex_type)

    @staticmethod
    def list_type(argument, expected_type, str param, ex_type = None):
        """
        Check the list only contains types of the given expected type.

        Parameters
        ----------
        argument : list
            The list to check.
        expected_type : type
            The expected element type (if not empty).
        param : str
            The list parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
             If `argument` is not empty and contains a type other than `expected_type`.

        """
        Condition.list_type(argument, expected_type, param, ex_type)

    @staticmethod
    def dict_types(argument, key_type, value_type, str param, ex_type = None):
        """
        Check the dictionary only contains types of the given key and value types to contain.

        Parameters
        ----------
        argument : dict
            The dictionary to check.
        key_type : type
            The expected type of the keys (if not empty).
        value_type : type
            The expected type of the values (if not empty).
        param : str
            The dictionary parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        TypeError
            If `argument` is not empty and contains a key type other than `key_type`.
            If `argument` is not empty and contains a value type other than `value_type`.

        """
        Condition.dict_types(argument, key_type, value_type, param, ex_type)

    @staticmethod
    def is_in(object element, collection, str param1, str param2, ex_type = None):
        """
        Check the element is contained within the specified collection.

        Parameters
        ----------
        element : object
            The element to check.
        collection : iterable
            The collection to check.
        param1 : str
            The element parameter name.
        param2 : str
            The collection name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        KeyError
            If `element` is not contained in the `collection`.

        """
        Condition.is_in(element, collection, param1, param2, ex_type)

    @staticmethod
    def not_in(object element, collection, str param1, str param2, ex_type = None):
        """
        Check the element is not contained within the specified collection.

        Parameters
        ----------
        element : object
            The element to check.
        collection : iterable
            The collection to check.
        param1 : str
            The elements parameter name.
        param2 : str
            The collections name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        KeyError
            If `element` is contained in the `collection`.

        """
        Condition.not_in(element, collection, param1, param2, ex_type)

    @staticmethod
    def not_empty(argument, str param, ex_type = None):
        """
        Check the collection is not empty.

        Parameters
        ----------
        argument : iterable
            The collection to check.
        param : str
            The collection parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
             If `collection` is empty.

        """
        Condition.not_empty(argument, param, ex_type)

    @staticmethod
    def empty(argument, str param, ex_type = None):
        """
        Check the collection is empty.

        Parameters
        ----------
        argument : iterable
            The collection to check.
        param : str
            The collection parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
             If `collection` is not empty.

        """
        Condition.empty(argument, param, ex_type)

    @staticmethod
    def positive(double value, str param, ex_type = None):
        """
        Check the real number value is positive (> 0).

        Parameters
        ----------
        value : scalar
            The value to check.
        param : str
            The name of the value parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
             If `value` is not positive (> 0).

        """
        Condition.positive(value, param, ex_type)

    @staticmethod
    def positive_int(value: int, str param, ex_type = None):
        """
        Check the integer value is a positive integer (> 0).

        Parameters
        ----------
        value : int
            The value to check.
        param : str
            The name of the value parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
             If `value` is not positive (> 0).

        """
        Condition.positive_int(value, param, ex_type)

    @staticmethod
    def not_negative(double value, str param, ex_type = None):
        """
        Check the real number value is not negative (< 0).

        Parameters
        ----------
        value : scalar
            The value to check.
        param : str
            The name of the value parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `value` is negative (< 0).

        """
        Condition.not_negative(value, param, ex_type)

    @staticmethod
    def not_negative_int(value: int, str param, ex_type = None):
        """
        Check the integer value is not negative (< 0).

        Parameters
        ----------
        value : int
            The value to check.
        param : str
            The name of the value parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `value` is negative (< 0).

        """
        Condition.not_negative_int(value, param, ex_type)

    @staticmethod
    def in_range(double value, double start, double end, str param, ex_type = None):
        """
        Check the real number value is within the specified range (inclusive).

        Parameters
        ----------
        value : scalar
            The value to check.
        start : scalar
            The start of the range.
        end : scalar
            The end of the range.
        param : str
            The name of the value parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `value` is not within the range (inclusive of the end points).

        """
        Condition.in_range(value, start, end, param, ex_type)

    @staticmethod
    def in_range_int(value: int, start: int, end: int, param, ex_type = None):
        """
        Check the integer value is within the specified range (inclusive).

        Parameters
        ----------
        value : int
            The value to check.
        start : int
            The start of the range.
        end : int
            The end of the range.
        param : str
            The name of the value parameter.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `value` is not within the range (inclusive of the end points).

        """
        Condition.in_range_int(value, start, end, param, ex_type)

    @staticmethod
    def valid_string(str argument, str param, ex_type = None):
        """
        Check the string argument is valid (not ``None``, empty or whitespace).

        Parameters
        ----------
        argument : str
            The string argument to check.
        param : str
            The argument parameter name.
        ex_type : Exception, optional
            The custom exception type to be raised on a failed check.

        Raises
        -------
        ValueError
              If `argument` is ``None``, empty or whitespace.

        """
        Condition.valid_string(argument, param, ex_type)

</document_content>
</document>
<document index="2271">
<source>nautilus_trader/core/data.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import cython


@cython.auto_pickle(False)
cdef class Data:
    """
    The abstract base class for all data.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the instance was created.

        Returns
        -------
        int

        """
        raise NotImplementedError("abstract property must be implemented")

    @classmethod
    def fully_qualified_name(cls) -> str:
        """
        Return the fully qualified name for the `Data` class.

        Returns
        -------
        str

        References
        ----------
        https://www.python.org/dev/peps/pep-3155/

        """
        return cls.__module__ + ':' + cls.__qualname__

    @classmethod
    def is_signal(cls, str name = "") -> bool:
        """
        Determine if the current class is a signal type, optionally checking for a specific signal name.

        Parameters
        ----------
        name : str, optional
            The specific signal name to check.
            If `name` not provided or if an empty string is passed, the method checks whether the
            class name indicates a general signal type.
            If `name` is provided, the method checks if the class name corresponds to that specific signal.

        Returns
        -------
        bool
            True if the class name matches the signal type or the specific signal name, otherwise False.

        """
        if name == "":
            return cls.__name__.startswith("Signal")

        return cls.__name__ == f"Signal{name.title()}"

</document_content>
</document>
<document index="2274">
<source>nautilus_trader/core/datetime.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
This module provides efficient functions for performing standard datetime related operations.

Functions include awareness/tz checks and conversions, as well as ISO 8601 (RFC 3339) conversion.
"""

import pandas as pd
import pytz
from pandas.api.types import is_datetime64_ns_dtype

# Re-exports
from nautilus_trader.core.nautilus_pyo3 import micros_to_nanos as micros_to_nanos
from nautilus_trader.core.nautilus_pyo3 import millis_to_nanos as millis_to_nanos
from nautilus_trader.core.nautilus_pyo3 import nanos_to_micros as nanos_to_micros
from nautilus_trader.core.nautilus_pyo3 import nanos_to_millis as nanos_to_millis
from nautilus_trader.core.nautilus_pyo3 import nanos_to_secs as nanos_to_secs
from nautilus_trader.core.nautilus_pyo3 import secs_to_millis as secs_to_millis
from nautilus_trader.core.nautilus_pyo3 import secs_to_nanos as secs_to_nanos

cimport cpython.datetime
from cpython.datetime cimport datetime_tzinfo
from cpython.unicode cimport PyUnicode_Contains
from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.core cimport unix_nanos_to_iso8601_cstr
from nautilus_trader.core.rust.core cimport unix_nanos_to_iso8601_millis_cstr
from nautilus_trader.core.string cimport cstr_to_pystr


# UNIX epoch is the UTC time at 00:00:00 on 1/1/1970
# https://en.wikipedia.org/wiki/Unix_time
cdef datetime UNIX_EPOCH = pd.Timestamp("1970-01-01", tz=pytz.utc)


cpdef unix_nanos_to_dt(uint64_t nanos):
    """
    Return the datetime (UTC) from the given UNIX timestamp (nanoseconds).

    Parameters
    ----------
    nanos : uint64_t
        The UNIX timestamp (nanoseconds) to convert.

    Returns
    -------
    pd.Timestamp

    """
    return pd.Timestamp(nanos, unit="ns", tz=pytz.utc)


cpdef dt_to_unix_nanos(dt: pd.Timestamp):
    """
    Return the UNIX timestamp (nanoseconds) from the given datetime (UTC).

    Parameters
    ----------
    dt : pd.Timestamp | str | int
        The datetime to convert.

    Returns
    -------
    uint64_t

    Warnings
    --------
    This function expects a pandas `Timestamp` as standard Python `datetime`
    objects are only accurate to 1 microsecond (μs).

    """
    Condition.not_none(dt, "dt")

    if not isinstance(dt, pd.Timestamp):
        dt = pd.Timestamp(dt)

    return <uint64_t>dt.value


cpdef str unix_nanos_to_iso8601(uint64_t unix_nanos, bint nanos_precision = True):
    """
    Convert the given `unix_nanos` to an ISO 8601 (RFC 3339) format string.

    Parameters
    ----------
    unix_nanos : int
        The UNIX timestamp (nanoseconds) to be converted.
    nanos_precision : bool, default True
        If True, use nanosecond precision. If False, use millisecond precision.

    Returns
    -------
    str

    """
    if nanos_precision:
        return cstr_to_pystr(unix_nanos_to_iso8601_cstr(unix_nanos))
    else:
        return cstr_to_pystr(unix_nanos_to_iso8601_millis_cstr(unix_nanos))


cpdef str format_iso8601(datetime dt, bint nanos_precision = True):
    """
    Format the given datetime as an ISO 8601 (RFC 3339) specification string.

    Parameters
    ----------
    dt : pd.Timestamp
        The datetime to format.
    nanos_precision : bool, default True
        If True, use nanosecond precision. If False, use millisecond precision.

    Returns
    -------
    str

    """
    Condition.type(dt, pd.Timestamp, "dt")

    if nanos_precision:
        return cstr_to_pystr(unix_nanos_to_iso8601_cstr(dt.value))
    else:
        return cstr_to_pystr(unix_nanos_to_iso8601_millis_cstr(dt.value))


cpdef str format_optional_iso8601(datetime dt, bint nanos_precision = True):
    """
    Format the given optional datetime as an ISO 8601 (RFC 3339) specification string.

    If value is `None` then will return the string "None".

    Parameters
    ----------
    dt : pd.Timestamp, optional
        The datetime to format.
    nanos_precision : bool, default True
        If True, use nanosecond precision. If False, use millisecond precision.

    Returns
    -------
    str

    """
    if dt is None:
        return str(None)

    return format_iso8601(dt, nanos_precision)


cpdef maybe_unix_nanos_to_dt(nanos):
    """
    Return the datetime (UTC) from the given UNIX timestamp (nanoseconds), or ``None``.

    If nanos is ``None``, then will return ``None``.

    Parameters
    ----------
    nanos : int, optional
        The UNIX timestamp (nanoseconds) to convert.

    Returns
    -------
    pd.Timestamp or ``None``

    """
    if nanos is None:
        return None
    else:
        return pd.Timestamp(nanos, unit="ns", tz=pytz.utc)


cpdef maybe_dt_to_unix_nanos(dt: pd.Timestamp):
    """
    Return the UNIX timestamp (nanoseconds) from the given datetime, or ``None``.

    If dt is ``None``, then will return ``None``.

    Parameters
    ----------
    dt : pd.Timestamp, optional
        The datetime to convert.

    Returns
    -------
    int64 or ``None``

    Warnings
    --------
    If the input is not ``None`` then this function expects a pandas `Timestamp`
    as standard Python `datetime` objects are only accurate to 1 microsecond (μs).

    """
    if dt is None:
        return None

    if not isinstance(dt, pd.Timestamp):
        dt = pd.Timestamp(dt)

    return <uint64_t>dt.value


cpdef bint is_datetime_utc(datetime dt):
    """
    Return a value indicating whether the given timestamp is timezone aware UTC.

    Parameters
    ----------
    dt : datetime
        The datetime to check.

    Returns
    -------
    bool
        True if timezone aware UTC, else False.

    """
    Condition.not_none(dt, "dt")

    return datetime_tzinfo(dt) == pytz.utc


cpdef bint is_tz_aware(time_object):
    """
    Return a value indicating whether the given object is timezone aware.

    Parameters
    ----------
    time_object : datetime, pd.Timestamp, pd.Series, pd.DataFrame
        The time object to check.

    Returns
    -------
    bool
        True if timezone aware, else False.

    """
    Condition.not_none(time_object, "time_object")

    if isinstance(time_object, datetime):
        return datetime_tzinfo(time_object) is not None
    elif isinstance(time_object, pd.DataFrame):
        return hasattr(time_object.index, "tz") or time_object.index.tz is not None
    else:
        raise ValueError(f"Cannot check timezone awareness of a {type(time_object)} object")


cpdef bint is_tz_naive(time_object):
    """
    Return a value indicating whether the given object is timezone naive.

    Parameters
    ----------
    time_object : datetime, pd.Timestamp, pd.DataFrame
        The time object to check.

    Returns
    -------
    bool
        True if object timezone naive, else False.

    """
    return not is_tz_aware(time_object)


cpdef datetime as_utc_timestamp(datetime dt):
    """
    Ensure the given timestamp is tz-aware UTC.

    Parameters
    ----------
    dt : datetime
        The timestamp to check.

    Returns
    -------
    datetime

    """
    Condition.not_none(datetime, "datetime")

    if dt.tzinfo is None:  # tz-naive
        return pytz.utc.localize(dt)
    elif dt.tzinfo != pytz.utc:
        return dt.astimezone(pytz.utc)
    else:
        return dt  # Already UTC


cpdef object as_utc_index(data: pd.DataFrame):
    """
    Ensure the given data has a DateTimeIndex which is tz-aware UTC.

    Parameters
    ----------
    data : pd.Series or pd.DataFrame.
        The object to ensure is UTC.

    Returns
    -------
    pd.Series, pd.DataFrame or ``None``

    """
    Condition.not_none(data, "data")

    if data.empty:
        return data

    # Ensure the index is localized to UTC
    if data.index.tzinfo is None:  # tz-naive
        data = data.tz_localize(pytz.utc)
    elif data.index.tzinfo != pytz.utc:
        data = data.tz_convert(None).tz_localize(pytz.utc)

    # Check if the index is in nanosecond resolution, convert if not
    if not is_datetime64_ns_dtype(data.index.dtype):
        data.index = data.index.astype("datetime64[ns, UTC]")

    return data


cpdef datetime time_object_to_dt(time_object):
    """
    Return the datetime (UTC) from the given UNIX timestamp as integer (nanoseconds), string or pd.Timestamp.

    Parameters
    ----------
    time_object : pd.Timestamp | str | int | None
        The time object to convert.

    Returns
    -------
    pd.Timestamp or ``None``
        Returns None if the input is None.

    """
    if time_object is None:
        return None

    if isinstance(time_object, pd.Timestamp):
        used_date = time_object
    else:
        used_date = pd.Timestamp(time_object)

    return as_utc_timestamp(used_date)



def max_date(date1: pd.Timestamp | str | int | None = None, date2: str | int | None = None) -> pd.Timestamp | None:
    """
    Return the maximum date as a datetime (UTC).

    Parameters
    ----------
    date1 : pd.Timestamp | str | int | None, optional
        The first date to compare. Can be a string, integer (timestamp), or None. Default is None.
    date2 : pd.Timestamp | str | int | None, optional
        The second date to compare. Can be a string, integer (timestamp), or None. Default is None.

    Returns
    -------
    pd.Timestamp | None
        The maximum date, or None if both input dates are None.

    """
    if date1 is None and date2 is None:
        return None

    if date1 is None:
        return time_object_to_dt(date2)

    if date2 is None:
        return time_object_to_dt(date1)

    return max(time_object_to_dt(date1), time_object_to_dt(date2))


def min_date(date1: pd.Timestamp | str | int | None = None, date2: str | int | None = None) -> pd.Timestamp | None:
    """
    Return the minimum date as a datetime (UTC).

    Parameters
    ----------
    date1 : pd.Timestamp | str | int | None, optional
        The first date to compare. Can be a string, integer (timestamp), or None. Default is None.
    date2 : pd.Timestamp | str | int | None, optional
        The second date to compare. Can be a string, integer (timestamp), or None. Default is None.

    Returns
    -------
    pd.Timestamp | None
        The minimum date, or None if both input dates are None.

    """
    if date1 is None and date2 is None:
        return None

    if date1 is None:
        return time_object_to_dt(date2)

    if date2 is None:
        return time_object_to_dt(date1)

    return min(time_object_to_dt(date1), time_object_to_dt(date2))


def ensure_pydatetime_utc(timestamp: pd.Timestamp) -> dt.datetime | None:
    """
    Convert an optional ``pandas.Timestamp`` to a timezone-aware ``datetime`` in UTC.

    The underlying Python ``datetime`` type only supports microsecond precision. When
    the provided ``timestamp`` contains non-zero nanoseconds these **cannot** be
    represented and are therefore truncated to microseconds before the conversion
    takes place.  This avoids the "Discarding nonzero nanoseconds in conversion"
    ``UserWarning`` raised by pandas when calling :py:meth:`Timestamp.to_pydatetime`.

    Parameters
    ----------
    timestamp : pd.Timestamp, optional
        The timestamp to convert. If ``None`` the function immediately returns
        ``None``.

    Returns
    -------
    datetime.datetime | None
        The converted timestamp with tz-info set to ``UTC`` or ``None`` if the
        input was ``None``.

    """
    if timestamp is None:
        return None

    # ``to_pydatetime`` emits a warning when nanoseconds are present because the
    # Python ``datetime`` type cannot store them.  We truncate to the closest
    # microsecond to silence the warning while keeping deterministic behaviour.
    if timestamp.nanosecond:
        timestamp = timestamp.floor("us")

    return timestamp.tz_convert("UTC").to_pydatetime()

</document_content>
</document>
<document index="2276">
<source>nautilus_trader/core/fsm.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
Defines a generic `Finite-State Machine` (FSM).

The FSM operates with a state-transition table of tuples and C-level enums. The
intended use case is to ensure correct state transitions, as well as holding a
deterministic state value.

References
----------
https://en.wikipedia.org/wiki/Finite-state_machine

"""

from typing import Callable

from nautilus_trader.core.correctness cimport Condition


cdef class InvalidStateTrigger(Exception):
    """
    Represents an invalid trigger for the current state.
    """
    pass


cdef class FiniteStateMachine:
    """
    Provides a generic finite state machine.

    Parameters
    ----------
    state_transition_table : dict of tuples and states
        The state-transition table for the FSM consisting of a tuple of
        starting state and trigger as keys, and resulting states as values.
    initial_state : int / C Enum
        The initial state for the FSM.
    trigger_parser : Callable[[int], str], optional
        The trigger parser needed to convert C Enum ints into strings.
        If ``None`` then will just print the integer.
    state_parser : Callable[[int], str], optional
        The state parser needed to convert C Enum ints into strings.
        If ``None`` then will just print the integer.

    Raises
    ------
    ValueError
        If `state_transition_table` is empty.
    ValueError
        If `state_transition_table` key not tuple.
    ValueError
        If `trigger_parser` not of type `Callable` or ``None``.
    ValueError
        If `state_parser` not of type `Callable` or ``None``.
    """

    def __init__(
        self,
        dict state_transition_table not None,
        int initial_state,
        trigger_parser: Callable[[int], str] = str,
        state_parser: Callable[[int], str] = str,
    ):
        if trigger_parser is None:
            trigger_parser = str
        if state_parser is None:
            state_parser = str
        Condition.not_empty(state_transition_table, "state_transition_table")
        Condition.dict_types(state_transition_table, tuple, object, "state_transition_table")
        Condition.callable_or_none(trigger_parser, "trigger_parser")
        Condition.callable_or_none(state_parser, "state_parser")

        self._state_transition_table = state_transition_table
        self._trigger_parser = trigger_parser
        self._state_parser = state_parser

        self.state = initial_state

    cdef str state_string_c(self):
        return self._state_parser(self.state)

    @property
    def state_string(self) -> str:
        """
        Return the current state as a string.

        Returns
        -------
        str

        """
        return self.state_string_c()

    cpdef void trigger(self, int trigger):
        """
        Process the FSM with the given trigger. The trigger must be valid for
        the FSMs current state.

        Parameters
        ----------
        trigger : int / C Enum
            The trigger to combine with the current state providing the key for
            the transition table lookup.

        Raises
        ------
        InvalidStateTrigger
            If the state and `trigger` combination is not found in the transition table.

        """
        cdef int next_state = self._state_transition_table.get((self.state, trigger), -1)
        if next_state == -1:  # Invalid
            raise InvalidStateTrigger(f"{self.state_string_c()} -> {self._trigger_parser(trigger)}")

        self.state = next_state

</document_content>
</document>
<document index="2282">
<source>nautilus_trader/core/math.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import numpy as np

cimport numpy as np


cdef inline double linear_weight(double x1, double x2, double x):
    return (x - x1) / (x2 - x1)


cdef inline double linear_weighting(double y1, double y2, double x1_diff):
    return y1 + x1_diff * (y2 - y1)


cdef inline int pos_search(double x, np.ndarray xs):
    cdef int n_elem = xs.shape[0]
    cdef int pos = max(min(int(np.searchsorted(xs, x, side='right')), n_elem - 1) - 1, 0)
    return pos


cdef inline double quad_polynomial(double x, double x0, double x1, double x2, double y0, double y1, double y2):
    return (y0 * (x - x1) * (x - x2) / ((x0 - x1) * (x0 - x2))
            + y1 * (x - x0) * (x - x2) / ((x1 - x0) * (x1 - x2))
            + y2 * (x - x0) * (x - x1) / ((x2 - x0) * (x2 - x1)))


cpdef double quadratic_interpolation(double x, np.ndarray xs, np.ndarray ys):
    cdef int n_elem = xs.shape[0]
    cdef int pos
    cdef double w

    if x <= xs[0]:
        return ys[0]

    if x >= xs[n_elem-1]:
        return ys[n_elem-1]

    pos = pos_search(x, xs)

    if xs[pos] == x:
        return ys[pos]

    if pos == 0:
        return quad_polynomial(x, xs[0], xs[1], xs[2], ys[0], ys[1], ys[2])

    if pos == n_elem - 2:
        return quad_polynomial(x, xs[n_elem-3], xs[n_elem-2], xs[n_elem-1], ys[n_elem-3], ys[n_elem-2], ys[n_elem-1])

    w = linear_weight(xs[pos], xs[pos+1], x)

    return linear_weighting(
        quad_polynomial(x, xs[pos-1], xs[pos], xs[pos+1], ys[pos-1], ys[pos], ys[pos+1]),
        quad_polynomial(x, xs[pos], xs[pos+1], xs[pos+2], ys[pos], ys[pos+1], ys[pos+2]),
        w
    )

</document_content>
</document>
<document index="2284">
<source>nautilus_trader/core/message.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from typing import Any
from typing import Callable

import cython

from nautilus_trader.core.uuid cimport UUID4


cdef class Command:
    """
    The base class for all command messages.

    Parameters
    ----------
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    correlation_id : UUID4, optional
        The correlation ID. If provided, this command is correlated to another command or request.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        UUID4 command_id not None,
        uint64_t ts_init,
        UUID4 correlation_id = None,
    ):
        self.id = command_id
        self.ts_init = ts_init
        self.correlation_id = correlation_id

    def __getstate__(self):
        return (
            self.id.to_str(),
            self.ts_init,
            self.correlation_id.to_str() if self.correlation_id is not None else None,
        )

    def __setstate__(self, state):
        self.id = UUID4.from_str_c(state[0])
        self.ts_init = state[1]
        self.correlation_id = UUID4.from_str_c(state[2]) if state[2] is not None else None

    def __eq__(self, Command other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __repr__(self) -> str:
        correlation_str = f", correlation_id={self.correlation_id}" if self.correlation_id is not None else ""
        return f"{type(self).__name__}(id={self.id}, ts_init={self.ts_init}{correlation_str})"


cdef class Document:
    """
    The base class for all document messages.

    Parameters
    ----------
    document_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        UUID4 document_id not None,
        uint64_t ts_init,
    ):
        self.id = document_id
        self.ts_init = ts_init

    def __getstate__(self):
        return (
            self.id.to_str(),
            self.ts_init,
        )

    def __setstate__(self, state):
        self.id = UUID4.from_str_c(state[0])
        self.ts_init = state[1]

    def __eq__(self, Document other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __repr__(self) -> str:
        return f"{type(self).__name__}(id={self.id}, ts_init={self.ts_init})"


@cython.auto_pickle(False)
cdef class Event:
    """
    The abstract base class for all event messages.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        raise NotImplementedError("abstract property must be implemented")


cdef class Request:
    """
    The base class for all request messages.

    Parameters
    ----------
    callback : Callable[[Any], None]
        The delegate to call with the response.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    correlation_id : UUID4, optional
        The correlation ID. If provided, this request is correlated to another request.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        UUID4 correlation_id = None,
    ):
        self.callback = callback
        self.id = request_id
        self.ts_init = ts_init
        self.correlation_id = correlation_id

    def __getstate__(self):
        return (
            self.callback,
            self.id.to_str(),
            self.ts_init,
            self.correlation_id.to_str() if self.correlation_id is not None else None,
        )

    def __setstate__(self, state):
        self.callback = state[0]
        self.id = UUID4.from_str_c(state[1])
        self.ts_init = state[2]
        self.correlation_id = UUID4.from_str_c(state[3]) if state[3] is not None else None

    def __eq__(self, Request other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __repr__(self) -> str:
        correlation_str = f", correlation_id={self.correlation_id}" if self.correlation_id is not None else ""

        return f"{type(self).__name__}(id={self.id}, callback={self.callback}, ts_init={self.ts_init}{correlation_str})"


cdef class Response:
    """
    The base class for all response messages.

    Parameters
    ----------
    correlation_id : UUID4
        The correlation ID.
    response_id : UUID4
        The response ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        UUID4 correlation_id not None,
        UUID4 response_id not None,
        uint64_t ts_init,
    ):
        self.correlation_id = correlation_id
        self.id = response_id
        self.ts_init = ts_init

    def __getstate__(self):
        return (
            self.correlation_id.to_str(),
            self.id.to_str(),
            self.ts_init,
        )

    def __setstate__(self, state):
        self.correlation_id = UUID4.from_str_c(state[0])
        self.id = UUID4.from_str_c(state[1])
        self.ts_init = state[2]

    def __eq__(self, Response other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"correlation_id={self.correlation_id}, "
            f"id={self.id}, "
            f"ts_init={self.ts_init})"
        )

</document_content>
</document>
<document index="2289">
<source>nautilus_trader/core/rust/common.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

# Allows importing as Python enum from other modules

from nautilus_trader.core.rust.common cimport ComponentState  # type: ignore
from nautilus_trader.core.rust.common cimport ComponentTrigger  # type: ignore
from nautilus_trader.core.rust.common cimport LogColor  # type: ignore
from nautilus_trader.core.rust.common cimport LogLevel  # type: ignore

</document_content>
</document>
<document index="2292">
<source>nautilus_trader/core/rust/model.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

# Allows importing as Python enum from other modules

from nautilus_trader.core.rust.model cimport AccountType  # type: ignore
from nautilus_trader.core.rust.model cimport AggregationSource  # type: ignore
from nautilus_trader.core.rust.model cimport AggressorSide  # type: ignore
from nautilus_trader.core.rust.model cimport AssetClass  # type: ignore
from nautilus_trader.core.rust.model cimport BookAction  # type: ignore
from nautilus_trader.core.rust.model cimport BookType  # type: ignore
from nautilus_trader.core.rust.model cimport ContingencyType  # type: ignore
from nautilus_trader.core.rust.model cimport CurrencyType  # type: ignore
from nautilus_trader.core.rust.model cimport InstrumentClass  # type: ignore
from nautilus_trader.core.rust.model cimport InstrumentCloseType  # type: ignore
from nautilus_trader.core.rust.model cimport LiquiditySide  # type: ignore
from nautilus_trader.core.rust.model cimport MarketStatus  # type: ignore
from nautilus_trader.core.rust.model cimport MarketStatusAction  # type: ignore
from nautilus_trader.core.rust.model cimport OmsType  # type: ignore
from nautilus_trader.core.rust.model cimport OptionKind  # type: ignore
from nautilus_trader.core.rust.model cimport OrderSide  # type: ignore
from nautilus_trader.core.rust.model cimport OrderStatus  # type: ignore
from nautilus_trader.core.rust.model cimport OrderType  # type: ignore
from nautilus_trader.core.rust.model cimport PositionSide  # type: ignore
from nautilus_trader.core.rust.model cimport PriceType  # type: ignore
from nautilus_trader.core.rust.model cimport TimeInForce  # type: ignore
from nautilus_trader.core.rust.model cimport TradingState  # type: ignore
from nautilus_trader.core.rust.model cimport TrailingOffsetType  # type: ignore
from nautilus_trader.core.rust.model cimport TriggerType  # type: ignore

</document_content>
</document>
<document index="2294">
<source>nautilus_trader/core/stats.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import cython

cimport numpy as np
from libc.math cimport sqrt


@cython.boundscheck(False)
@cython.wraparound(False)
cpdef double fast_mean(np.ndarray values):
    """
    Return the average value for numpy.ndarray values.

    Parameters
    ----------
    values : numpy.ndarray
        The array to evaluate.

    Returns
    -------
    double

    Notes
    -----
    > 10x faster than `np.mean` if the array length < ~200.

    """
    if values is None or values.ndim != 1:
        raise ValueError("values must be valid numpy.ndarray with ndim == 1")

    cdef double[:] mv = values
    cdef int length = len(mv)

    if length == 0:
        return 0.0

    cdef double total = 0.0
    cdef int i
    with nogil:
        for i in range(length):
            total += mv[i]

    return total / length


@cython.boundscheck(False)
@cython.wraparound(False)
cpdef inline double fast_mean_iterated(
    np.ndarray values,
    double next_value,
    double current_value,
    int expected_length,
    bint drop_left=True,
):
    """
    Return the calculated average from the given inputs.

    Parameters
    ----------
    values : list[double]
        The values for the calculation.
    next_value : double
        The next input value for the average.
    current_value : double
        The current value for the average.
    expected_length : int
        The expected length of the inputs.
    drop_left : bool
        If the value to be dropped should be from the left side of the inputs
        (index 0).

    Returns
    -------
    double

    Notes
    -----
    > 10x faster than `np.mean`.

    """
    if values is None or values.ndim != 1:
        raise ValueError("values must be valid ndarray with ndim == 1")

    cdef double[:] mv = values
    cdef int length = len(mv)

    if length < expected_length:
        return fast_mean(values)

    assert length == expected_length

    cdef double value_to_drop = mv[0] if drop_left else mv[length - 1]
    return current_value + (next_value - value_to_drop) / length


cpdef inline double fast_std(np.ndarray values):
    """
    Return the standard deviation from the given values.

    Parameters
    ----------
    values : numpy.ndarray
        The array for the calculation.

    Returns
    -------
    double

    Notes
    -----
    > 10x faster than `np.std`.

    """
    return fast_std_with_mean(values, fast_mean(values))


@cython.boundscheck(False)
@cython.wraparound(False)
cpdef double fast_std_with_mean(np.ndarray values, double mean):
    """
    Return the standard deviation from the given values and mean.

    Parameters
    ----------
    values : numpy.ndarray
        The array for the calculation.
    mean : double
        The pre-calculated mean of the given values.

    Returns
    -------
    double

    Notes
    -----
    > 25x faster than `np.std` if the array length < ~200.

    """
    if values is None or values.ndim != 1:
        raise ValueError("values must be valid ndarray with ndim == 1")

    cdef double[:] mv = values
    cdef int length = len(mv)

    if length == 0:
        return 0.0

    cdef double std_dev = 0.0
    cdef double v
    cdef int i
    with nogil:
        for i in range(length):
            v = mv[i] - mean
            std_dev += v * v

    return sqrt(std_dev / length)


cpdef inline double fast_mad(np.ndarray values):
    """
    Return the mean absolute deviation from the given values.

    Parameters
    ----------
    values : numpy.ndarray
        The array for the calculation.

    Returns
    -------
    double

    """
    return fast_mad_with_mean(values, fast_mean(values))


@cython.boundscheck(False)
@cython.wraparound(False)
cpdef double fast_mad_with_mean(np.ndarray values, double mean):
    """
    Return the mean absolute deviation from the given values and mean.

    Parameters
    ----------
    values : numpy.ndarray
        The array for the calculation.
    mean : double
        The pre-calculated mean of the given values.

    Returns
    -------
    double

    """
    if values is None or values.ndim != 1:
        raise ValueError("values must be valid ndarray with ndim == 1")

    cdef double[:] mv = values
    cdef int length = len(mv)

    if length == 0:
        return 0.0

    cdef double mad = 0.0
    cdef double v
    cdef int i
    with nogil:
        for i in range(length):
            v = abs(mv[i] - mean)
            mad += v

    return mad / length


cpdef inline double basis_points_as_percentage(double basis_points):
    """
    Return the given basis points expressed as a percentage where 100% = 1.0.

    Parameters
    ----------
    basis_points : double
        The basis points to convert to percentage.

    Returns
    -------
    double

    Notes
    -----
    1 basis point = 0.01%.

    """
    return basis_points * 0.0001

</document_content>
</document>
<document index="2298">
<source>nautilus_trader/core/uuid.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import uuid

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.core cimport UUID4_t
from nautilus_trader.core.rust.core cimport uuid4_eq
from nautilus_trader.core.rust.core cimport uuid4_from_cstr
from nautilus_trader.core.rust.core cimport uuid4_hash
from nautilus_trader.core.rust.core cimport uuid4_new
from nautilus_trader.core.rust.core cimport uuid4_to_cstr
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.core.string cimport pystr_to_cstr


cdef class UUID4:
    """
    Represents a Universally Unique Identifier (UUID)
    version 4 based on a 128-bit label as specified in RFC 4122.

    References
    ----------
    https://en.wikipedia.org/wiki/Universally_unique_identifier
    """

    def __init__(self):
        self._mem = uuid4_new()

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = uuid4_from_cstr(pystr_to_cstr(state))

    def __eq__(self, UUID4 other) -> bool:
        if other is None:
            return False
        return uuid4_eq(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return uuid4_hash(&self._mem)

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}('{self}')"

    cdef str to_str(self):
        return cstr_to_pystr(uuid4_to_cstr(&self._mem), False)

    @property
    def value(self) -> str:
        return self.to_str()

    @staticmethod
    cdef UUID4 from_mem_c(UUID4_t mem):
        cdef UUID4 uuid4 = UUID4.__new__(UUID4)
        uuid4._mem = mem
        return uuid4

    @staticmethod
    cdef UUID4 from_str_c(str value):
        Condition.valid_string(value, "value")
        uuid_obj = uuid.UUID(value)
        Condition.is_true(uuid_obj.version == 4, "UUID value is not version 4")
        Condition.is_true(uuid_obj.variant == uuid.RFC_4122, "UUID value is not RFC 4122")

        cdef UUID4 uuid4 = UUID4.__new__(UUID4)
        uuid4._mem = uuid4_from_cstr(pystr_to_cstr(value))
        return uuid4

    @staticmethod
    def from_str(str value) -> UUID4:
        """
        Create a new UUID4 from the given string value.

        Parameters
        ----------
        value : str
            The UUID value.

        Returns
        -------
        UUID4

        Raises
        ------
        ValueError
            If `value` is not a valid UUID version 4 RFC 4122 string.

        """
        return UUID4.from_str_c(value)

</document_content>
</document>
<document index="2302">
<source>nautilus_trader/data/aggregation.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal
from typing import Callable

import numpy as np
import pandas as pd

cimport numpy as np
from cpython.datetime cimport datetime
from cpython.datetime cimport timedelta
from libc.stdint cimport uint64_t

from datetime import timedelta

from nautilus_trader.core.datetime import unix_nanos_to_dt

from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Logger
from nautilus_trader.common.component cimport TimeEvent
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport dt_to_unix_nanos
from nautilus_trader.core.rust.core cimport millis_to_nanos
from nautilus_trader.core.rust.core cimport secs_to_nanos
from nautilus_trader.core.rust.model cimport FIXED_SCALAR
from nautilus_trader.core.rust.model cimport AggressorSide
from nautilus_trader.core.rust.model cimport QuantityRaw
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarAggregation
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.functions cimport bar_aggregation_to_str
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class BarBuilder:
    """
    Provides a generic bar builder for aggregation.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the builder.
    bar_type : BarType
        The bar type for the builder.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
    ) -> None:
        Condition.equal(instrument.id, bar_type.instrument_id, "instrument.id", "bar_type.instrument_id")

        self._bar_type = bar_type

        self.price_precision = instrument.price_precision
        self.size_precision = instrument.size_precision
        self.initialized = False
        self.ts_last = 0
        self.count = 0

        self._last_close = None
        self._open = None
        self._high = None
        self._low = None
        self._close = None
        self.volume = Quantity.zero_c(precision=self.size_precision)

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"{self._bar_type},"
            f"{self._open},"
            f"{self._high},"
            f"{self._low},"
            f"{self._close},"
            f"{self.volume})"
        )

    cpdef void update(self, Price price, Quantity size, uint64_t ts_init):
        """
        Update the bar builder.

        Parameters
        ----------
        price : Price
            The update price.
        size : Decimal
            The update size.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) of the update.

        """
        Condition.not_none(price, "price")
        Condition.not_none(size, "size")

        if ts_init < self.ts_last:
            return  # Not applicable

        if self._open is None:
            # Initialize builder
            self._open = price
            self._high = price
            self._low = price
            self.initialized = True
        elif price._mem.raw > self._high._mem.raw:
            self._high = price
        elif price._mem.raw < self._low._mem.raw:
            self._low = price

        self._close = price
        self.volume._mem.raw += size._mem.raw
        self.count += 1
        self.ts_last = ts_init

    cpdef void update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        """
        Update the bar builder.

        Parameters
        ----------
        bar : Bar
            The update Bar.

        """
        Condition.not_none(bar, "bar")

        if ts_init < self.ts_last:
            return  # Not applicable

        if self._open is None:
            # Initialize builder
            self._open = bar.open
            self._high = bar.high
            self._low = bar.low
            self.initialized = True
        else:
            if bar.high > self._high:
                self._high = bar.high

            if bar.low < self._low:
                self._low = bar.low

        self._close = bar.close
        self.volume._mem.raw += volume._mem.raw
        self.count += 1
        self.ts_last = ts_init

    cpdef void reset(self):
        """
        Reset the bar builder.

        All stateful fields are reset to their initial value.
        """
        self._open = None
        self._high = None
        self._low = None

        self.volume = Quantity.zero_c(precision=self.size_precision)
        self.count = 0

    cpdef Bar build_now(self):
        """
        Return the aggregated bar and reset.

        Returns
        -------
        Bar

        """
        return self.build(self.ts_last, self.ts_last)

    cpdef Bar build(self, uint64_t ts_event, uint64_t ts_init):
        """
        Return the aggregated bar with the given closing timestamp, and reset.

        Parameters
        ----------
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) for the bar event.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) for the bar initialization.

        Returns
        -------
        Bar

        """
        if self._open is None:  # No tick was received
            self._open = self._last_close
            self._high = self._last_close
            self._low = self._last_close
            self._close = self._last_close

        self._low._mem.raw = min(self._close._mem.raw, self._low._mem.raw)
        self._high._mem.raw = max(self._close._mem.raw, self._high._mem.raw)

        cdef Bar bar = Bar(
            bar_type=self._bar_type,
            open=self._open,
            high=self._high,
            low=self._low,
            close=self._close,
            volume=Quantity(self.volume, self.size_precision),
            ts_event=ts_event,
            ts_init=ts_init,
        )

        self._last_close = self._close
        self.reset()

        return bar


cdef class BarAggregator:
    """
    Provides a means of aggregating specified bars and sending to a registered handler.

    The aggregator maintains two state flags exposed as properties:
    - `historical_mode`: Indicates the aggregator is processing historical data.
    - `is_running`: Indicates the aggregator is receiving data from the message bus.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        Condition.equal(instrument.id, bar_type.instrument_id, "instrument.id", "bar_type.instrument_id")

        self._handler = handler
        self._handler_backup = None
        self._log = Logger(name=type(self).__name__)
        self._builder = BarBuilder(
            instrument=instrument,
            bar_type=bar_type,
        )

        self.bar_type = bar_type
        self.historical_mode = False
        self.is_running = False

    cpdef void set_historical_mode(self, bint historical_mode, handler: Callable[[Bar], None]):
        """
        Set the historical mode state of the aggregator.

        Parameters
        ----------
        historical_mode : bool
            Whether the aggregator is processing historical data.
        handler : Callable[[Bar], None]
            The bar handler to use in this mode.

        Raises
        ------
        TypeError
            If `handler` is ``None`` or not callable.

        """
        Condition.callable(handler, "handler")

        self.historical_mode = historical_mode
        self._handler = handler

    cpdef void set_running(self, bint is_running):
        """
        Set the running state of the aggregator.

        Parameters
        ----------
        is_running : bool
            Whether the aggregator is running (receiving data from message bus).

        """
        self.is_running = is_running

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the aggregator with the given tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick for the update.

        """
        Condition.not_none(tick, "tick")

        self._apply_update(
            price=tick.extract_price(self.bar_type.spec.price_type),
            size=tick.extract_size(self.bar_type.spec.price_type),
            ts_init=tick.ts_init,
        )

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the aggregator with the given tick.

        Parameters
        ----------
        tick : TradeTick
            The tick for the update.

        """
        Condition.not_none(tick, "tick")

        self._apply_update(
            price=tick.price,
            size=tick.size,
            ts_init=tick.ts_init,
        )

    cpdef void handle_bar(self, Bar bar):
        """
        Update the aggregator with the given bar.

        Parameters
        ----------
        bar : Bar
            The bar for the update.

        """
        Condition.not_none(bar, "bar")

        self._apply_update_bar(
            bar=bar,
            volume=bar.volume,
            ts_init=bar.ts_init,
        )

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        raise NotImplementedError("method `_apply_update` must be implemented in the subclass")

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        raise NotImplementedError("method `_apply_update` must be implemented in the subclass") # pragma: no cover

    cdef void _build_now_and_send(self):
        cdef Bar bar = self._builder.build_now()
        self._handler(bar)

    cdef void _build_and_send(self, uint64_t ts_event, uint64_t ts_init):
        cdef Bar bar = self._builder.build(ts_event=ts_event, ts_init=ts_init)
        self._handler(bar)


cdef class TickBarAggregator(BarAggregator):
    """
    Provides a means of building tick bars from ticks.

    When received tick count reaches the step threshold of the bar
    specification, then a bar is created and sent to the handler.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        self._builder.update(price, size, ts_init)

        if self._builder.count == self.bar_type.spec.step:
            self._build_now_and_send()

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        self._builder.update_bar(bar, volume, ts_init)

        if self._builder.count == self.bar_type.spec.step:
            self._build_now_and_send()


cdef class TickImbalanceBarAggregator(BarAggregator):
    """
    Provides a means of building tick imbalance bars from ticks.

    When the absolute difference between buy and sell ticks reaches the step
    threshold of the bar specification, then a bar is created and sent to the
    handler.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )
        self._imbalance = 0

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        self._builder.update(price, size, ts_init)

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        self._builder.update_bar(bar, volume, ts_init)

    cpdef void handle_trade_tick(self, TradeTick tick):
        Condition.not_none(tick, "tick")

        cdef AggressorSide side = tick.aggressor_side
        if side == AggressorSide.NO_AGGRESSOR:
            self._apply_update(tick.price, tick.size, tick.ts_init)
            return

        self._apply_update(tick.price, tick.size, tick.ts_init)

        if side == AggressorSide.BUYER:
            self._imbalance += 1
        else:
            self._imbalance -= 1

        if abs(self._imbalance) >= self.bar_type.spec.step:
            self._build_now_and_send()
            self._imbalance = 0


cdef class TickRunsBarAggregator(BarAggregator):
    """
    Provides a means of building tick runs bars from ticks.

    When consecutive ticks of the same aggressor side reach the step threshold
    of the bar specification, then a bar is created and sent to the handler.
    The run resets when the aggressor side changes.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )

        self._current_run_side = AggressorSide.NO_AGGRESSOR
        self._has_run_side = False
        self._run_count = 0

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        self._builder.update(price, size, ts_init)

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        self._builder.update_bar(bar, volume, ts_init)

    cpdef void handle_trade_tick(self, TradeTick tick):
        Condition.not_none(tick, "tick")

        cdef AggressorSide side = tick.aggressor_side
        if side == AggressorSide.NO_AGGRESSOR:
            self._apply_update(tick.price, tick.size, tick.ts_init)
            return

        if not self._has_run_side or self._current_run_side != side:
            self._current_run_side = side
            self._has_run_side = True
            self._run_count = 0
            self._builder.reset()

        self._apply_update(tick.price, tick.size, tick.ts_init)
        self._run_count += 1

        if self._run_count >= self.bar_type.spec.step:
            self._build_now_and_send()
            self._run_count = 0
            self._has_run_side = False


cdef class VolumeBarAggregator(BarAggregator):
    """
    Provides a means of building volume bars from ticks.

    When received volume reaches the step threshold of the bar
    specification, then a bar is created and sent to the handler.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        cdef QuantityRaw raw_size_update = size._mem.raw
        cdef QuantityRaw raw_step = <QuantityRaw>(self.bar_type.spec.step * <QuantityRaw>FIXED_SCALAR)
        cdef QuantityRaw raw_size_diff = 0

        while raw_size_update > 0:  # While there is size to apply
            if self._builder.volume._mem.raw + raw_size_update < raw_step:
                # Update and break
                self._builder.update(
                    price=price,
                    size=Quantity.from_raw_c(raw_size_update, precision=size._mem.precision),
                    ts_init=ts_init,
                )
                break

            raw_size_diff = raw_step - self._builder.volume._mem.raw
            # Update builder to the step threshold
            self._builder.update(
                price=price,
                size=Quantity.from_raw_c(raw_size_diff, precision=size._mem.precision),
                ts_init=ts_init,
            )

            # Build a bar and reset builder
            self._build_now_and_send()

            # Decrement the update size
            raw_size_update -= raw_size_diff
            assert raw_size_update >= 0

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        cdef QuantityRaw raw_volume_update = volume._mem.raw
        cdef QuantityRaw raw_step = <QuantityRaw>(self.bar_type.spec.step * <QuantityRaw>FIXED_SCALAR)
        cdef QuantityRaw raw_volume_diff = 0

        while raw_volume_update > 0:  # While there is volume to apply
            if self._builder.volume._mem.raw + raw_volume_update < raw_step:
                # Update and break
                self._builder.update_bar(
                    bar=bar,
                    volume=Quantity.from_raw_c(raw_volume_update, precision=volume._mem.precision),
                    ts_init=ts_init,
                )
                break

            raw_volume_diff = raw_step - self._builder.volume._mem.raw
            # Update builder to the step threshold
            self._builder.update_bar(
                bar=bar,
                volume=Quantity.from_raw_c(raw_volume_diff, precision=volume._mem.precision),
                ts_init=ts_init,
            )

            # Build a bar and reset builder
            self._build_now_and_send()

            # Decrement the update volume
            raw_volume_update -= raw_volume_diff
            assert raw_volume_update >= 0


cdef class VolumeImbalanceBarAggregator(BarAggregator):
    """
    Provides a means of building volume imbalance bars from ticks.

    When the absolute difference between buy and sell volume reaches the step
    threshold of the bar specification, then a bar is created and sent to the
    handler.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )
        cdef long long step_value = self.bar_type.spec.step
        self._imbalance_raw = 0
        self._raw_step = <long long>(step_value * FIXED_SCALAR)

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        self._builder.update(price, size, ts_init)

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        self._builder.update_bar(bar, volume, ts_init)

    cpdef void handle_trade_tick(self, TradeTick tick):
        Condition.not_none(tick, "tick")

        cdef AggressorSide side = tick.aggressor_side
        if side == AggressorSide.NO_AGGRESSOR:
            self._apply_update(tick.price, tick.size, tick.ts_init)
            return

        cdef long long side_sign = 1 if side == AggressorSide.BUYER else -1
        cdef double size_remaining = float(tick.size)
        cdef double size_chunk
        cdef double needed_qty
        cdef long long imbalance_abs
        cdef long long needed

        while size_remaining > 0.0:
            imbalance_abs = abs(self._imbalance_raw)
            needed = self._raw_step - imbalance_abs
            if needed <= 0:
                needed = 1

            # Convert needed from raw (10^9 scale) to quantity
            needed_qty = <double>needed / <double>FIXED_SCALAR
            if size_remaining <= needed_qty:
                self._imbalance_raw += side_sign * <long long>(size_remaining * FIXED_SCALAR)
                self._apply_update(
                    tick.price,
                    Quantity(size_remaining, precision=tick.size.precision),
                    tick.ts_init,
                )

                if abs(self._imbalance_raw) >= self._raw_step:
                    self._build_now_and_send()
                    self._imbalance_raw = 0
                break

            size_chunk = needed_qty
            self._apply_update(
                tick.price,
                Quantity(size_chunk, precision=tick.size.precision),
                tick.ts_init,
            )
            self._imbalance_raw += side_sign * needed
            size_remaining -= size_chunk

            if abs(self._imbalance_raw) >= self._raw_step:
                self._build_now_and_send()
                self._imbalance_raw = 0


cdef class VolumeRunsBarAggregator(BarAggregator):
    """
    Provides a means of building volume runs bars from ticks.

    When consecutive volume of the same aggressor side reaches the step
    threshold of the bar specification, then a bar is created and sent to the
    handler. The run resets when the aggressor side changes.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )
        cdef long long step_value = self.bar_type.spec.step
        self._current_run_side = AggressorSide.NO_AGGRESSOR
        self._has_run_side = False
        self._run_volume_raw = 0
        self._raw_step = <long long>(step_value * FIXED_SCALAR)

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        self._builder.update(price, size, ts_init)

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        self._builder.update_bar(bar, volume, ts_init)

    cpdef void handle_trade_tick(self, TradeTick tick):
        Condition.not_none(tick, "tick")

        cdef AggressorSide side = tick.aggressor_side
        if side == AggressorSide.NO_AGGRESSOR:
            self._apply_update(tick.price, tick.size, tick.ts_init)
            return

        if not self._has_run_side or self._current_run_side != side:
            self._current_run_side = side
            self._has_run_side = True
            self._run_volume_raw = 0
            self._builder.reset()

        cdef double size_remaining = float(tick.size)
        cdef double size_chunk
        cdef double needed_qty
        cdef long long needed

        while size_remaining > 0.0:
            needed = self._raw_step - self._run_volume_raw
            if needed <= 0:
                needed = 1

            # Convert needed from raw (10^9 scale) to quantity
            needed_qty = <double>needed / <double>FIXED_SCALAR
            if size_remaining <= needed_qty:
                self._run_volume_raw += <long long>(size_remaining * FIXED_SCALAR)
                self._apply_update(
                    tick.price,
                    Quantity(size_remaining, precision=tick.size.precision),
                    tick.ts_init,
                )

                if self._run_volume_raw >= self._raw_step:
                    self._build_now_and_send()
                    self._run_volume_raw = 0
                    self._has_run_side = False
                break

            size_chunk = needed_qty
            self._apply_update(
                tick.price,
                Quantity(size_chunk, precision=tick.size.precision),
                tick.ts_init,
            )
            self._run_volume_raw += needed
            size_remaining -= size_chunk

            if self._run_volume_raw >= self._raw_step:
                self._build_now_and_send()
                self._run_volume_raw = 0
                self._has_run_side = False


cdef class ValueBarAggregator(BarAggregator):
    """
    Provides a means of building value bars from ticks.

    When received value reaches the step threshold of the bar
    specification, then a bar is created and sent to the handler.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )

        self._cum_value = Decimal(0)  # Cumulative value

    cpdef object get_cumulative_value(self):
        """
        Return the current cumulative value of the aggregator.

        Returns
        -------
        Decimal

        """
        return self._cum_value

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        size_update = size

        while size_update > 0:  # While there is value to apply
            value_update = price * size_update  # Calculated value in quote currency
            if self._cum_value + value_update < self.bar_type.spec.step:
                # Update and break
                self._cum_value = self._cum_value + value_update
                self._builder.update(
                    price=price,
                    size=Quantity(size_update, precision=size._mem.precision),
                    ts_init=ts_init,
                )
                break

            value_diff: Decimal = self.bar_type.spec.step - self._cum_value
            size_diff: Decimal = size_update * (value_diff / value_update)
            # Update builder to the step threshold
            self._builder.update(
                price=price,
                size=Quantity(size_diff, precision=size._mem.precision),
                ts_init=ts_init,
            )

            # Build a bar and reset builder and cumulative value
            self._build_now_and_send()
            self._cum_value = Decimal(0)

            # Decrement the update size
            size_update -= size_diff
            assert size_update >= 0

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        volume_update = volume
        average_price = Quantity((bar.high + bar.low + bar.close) / Decimal(3.0),
                                 precision=self._builder.price_precision)

        while volume_update > 0:  # While there is value to apply
            value_update = average_price * volume_update  # Calculated value in quote currency
            if self._cum_value + value_update < self.bar_type.spec.step:
                # Update and break
                self._cum_value = self._cum_value + value_update
                self._builder.update_bar(
                    bar=bar,
                    volume=Quantity(volume_update, precision=volume._mem.precision),
                    ts_init=ts_init,
                )
                break

            value_diff: Decimal = self.bar_type.spec.step - self._cum_value
            volume_diff: Decimal = volume_update * (value_diff / value_update)
            # Update builder to the step threshold
            self._builder.update_bar(
                bar=bar,
                volume=Quantity(volume_diff, precision=volume._mem.precision),
                ts_init=ts_init,
            )

            # Build a bar and reset builder and cumulative value
            self._build_now_and_send()
            self._cum_value = Decimal(0)

            # Decrement the update volume
            volume_update -= volume_diff
            assert volume_update >= 0


cdef class ValueImbalanceBarAggregator(BarAggregator):
    """
    Provides a means of building value imbalance bars from ticks.

    When the absolute difference between buy and sell notional value reaches
    the step threshold of the bar specification, then a bar is created and
    sent to the handler.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )
        self._imbalance_value = 0.0
        self._step_value = float(self.bar_type.spec.step)

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        self._builder.update(price, size, ts_init)

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        self._builder.update_bar(bar, volume, ts_init)

    cpdef void handle_trade_tick(self, TradeTick tick):
        Condition.not_none(tick, "tick")

        cdef double price_f64 = float(tick.price)
        if price_f64 == 0.0:
            self._apply_update(tick.price, tick.size, tick.ts_init)
            return

        cdef AggressorSide side = tick.aggressor_side
        if side == AggressorSide.NO_AGGRESSOR:
            self._apply_update(tick.price, tick.size, tick.ts_init)
            return

        cdef double side_sign = 1.0 if side == AggressorSide.BUYER else -1.0
        cdef double size_remaining = float(tick.size)
        cdef double value_remaining
        cdef double current_sign
        cdef double needed
        cdef double value_chunk
        cdef double size_chunk
        cdef double imbalance_abs
        cdef double value_to_flatten

        while size_remaining > 0.0:
            value_remaining = price_f64 * size_remaining
            current_sign = 0.0
            if self._imbalance_value > 0.0:
                current_sign = 1.0
            elif self._imbalance_value < 0.0:
                current_sign = -1.0

            if current_sign == 0.0 or current_sign == side_sign:
                needed = self._step_value - abs(self._imbalance_value)
                if value_remaining <= needed:
                    self._imbalance_value += side_sign * value_remaining
                    self._apply_update(
                        tick.price,
                        Quantity(size_remaining, precision=tick.size.precision),
                        tick.ts_init,
                    )

                    if abs(self._imbalance_value) >= self._step_value:
                        self._build_now_and_send()
                        self._imbalance_value = 0.0
                    break

                value_chunk = needed
                size_chunk = value_chunk / price_f64
                self._apply_update(
                    tick.price,
                    Quantity(size_chunk, precision=tick.size.precision),
                    tick.ts_init,
                )
                self._imbalance_value += side_sign * value_chunk
                size_remaining -= size_chunk

                if abs(self._imbalance_value) >= self._step_value:
                    self._build_now_and_send()
                    self._imbalance_value = 0.0
            else:
                imbalance_abs = abs(self._imbalance_value)
                value_to_flatten = value_remaining if value_remaining < imbalance_abs else imbalance_abs
                size_chunk = value_to_flatten / price_f64
                self._apply_update(
                    tick.price,
                    Quantity(size_chunk, precision=tick.size.precision),
                    tick.ts_init,
                )
                self._imbalance_value += side_sign * value_to_flatten
                size_remaining -= size_chunk


cdef class ValueRunsBarAggregator(BarAggregator):
    """
    Provides a means of building value runs bars from ticks.

    When consecutive notional value of the same aggressor side reaches the
    step threshold of the bar specification, then a bar is created and sent
    to the handler. The run resets when the aggressor side changes.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )
        self._current_run_side = AggressorSide.NO_AGGRESSOR
        self._has_run_side = False
        self._run_value = 0.0
        self._step_value = float(self.bar_type.spec.step)

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        self._builder.update(price, size, ts_init)

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        self._builder.update_bar(bar, volume, ts_init)

    cpdef void handle_trade_tick(self, TradeTick tick):
        Condition.not_none(tick, "tick")

        cdef double price_f64 = float(tick.price)
        if price_f64 == 0.0:
            self._apply_update(tick.price, tick.size, tick.ts_init)
            return

        cdef AggressorSide side = tick.aggressor_side
        if side == AggressorSide.NO_AGGRESSOR:
            self._apply_update(tick.price, tick.size, tick.ts_init)
            return

        if not self._has_run_side or self._current_run_side != side:
            self._current_run_side = side
            self._has_run_side = True
            self._run_value = 0.0
            self._builder.reset()

        cdef double size_remaining = float(tick.size)
        cdef double value_update
        cdef double value_needed
        cdef double size_chunk

        while size_remaining > 0.0:
            value_update = price_f64 * size_remaining
            if self._run_value + value_update < self._step_value:
                self._run_value += value_update
                self._apply_update(
                    tick.price,
                    Quantity(size_remaining, precision=tick.size.precision),
                    tick.ts_init,
                )

                if self._run_value >= self._step_value:
                    self._build_now_and_send()
                    self._run_value = 0.0
                    self._has_run_side = False
                break

            value_needed = self._step_value - self._run_value
            size_chunk = value_needed / price_f64
            self._apply_update(
                tick.price,
                Quantity(size_chunk, precision=tick.size.precision),
                tick.ts_init,
            )

            self._build_now_and_send()
            self._run_value = 0.0
            self._has_run_side = False
            size_remaining -= size_chunk


cdef class RenkoBarAggregator(BarAggregator):
    """
    Provides a means of building Renko bars from ticks.

    Renko bars are created when the price moves by a fixed amount (brick size)
    regardless of time or volume. Each bar represents a price movement equal
    to the step size in the bar specification.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )

        # Calculate brick size from step and instrument price increment
        # step represents number of ticks, so brick_size = step * price_increment
        self.brick_size = instrument.price_increment.as_decimal() * Decimal(bar_type.spec.step)
        self._last_close = None

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        # Initialize last_close if this is the first update
        if self._last_close is None:
            self._last_close = price
            # For the first update, just store the price and add to builder
            self._builder.update(price, size, ts_init)
            return

        # Always update the builder with the current tick
        self._builder.update(price, size, ts_init)

        last_close = self._last_close
        price_diff_decimal = price.as_decimal() - last_close.as_decimal()
        abs_price_diff = abs(price_diff_decimal)

        # Check if we need to create one or more Renko bars
        if abs_price_diff >= self.brick_size:
            num_bricks = int(abs_price_diff // self.brick_size)
            direction = 1 if price_diff_decimal > 0 else -1
            current_close = last_close

            # Store the current builder volume to distribute across bricks
            total_volume = self._builder.volume

            for i in range(num_bricks):
                # Calculate the close price for this brick
                brick_close_decimal = current_close.as_decimal() + (direction * self.brick_size)
                brick_close = Price.from_str(str(brick_close_decimal))

                # Set the builder's OHLC for this specific brick
                self._builder._open = current_close
                self._builder._close = brick_close

                if direction > 0:
                    # Upward movement: high = brick_close, low = current_close
                    self._builder._high = brick_close
                    self._builder._low = current_close
                else:
                    # Downward movement: high = current_close, low = brick_close
                    self._builder._high = current_close
                    self._builder._low = brick_close

                # Set the volume for this brick (all accumulated volume goes to each brick)
                self._builder.volume = total_volume

                # Build and send the bar
                self._build_and_send(ts_init, ts_init)

                # Update current_close for the next brick
                current_close = brick_close

            # Update last_close to the final brick close
            self._last_close = current_close
        # If price movement is less than brick size, we accumulate in the builder

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        # Initialize last_close if this is the first update
        if self._last_close is None:
            self._last_close = bar.close
            # For the first update, just store the price and add to builder
            self._builder.update_bar(bar, volume, ts_init)
            return

        # Always update the builder with the current bar
        self._builder.update_bar(bar, volume, ts_init)

        last_close = self._last_close
        price_diff_decimal = bar.close.as_decimal() - last_close.as_decimal()
        abs_price_diff = abs(price_diff_decimal)

        # Check if we need to create one or more Renko bars
        if abs_price_diff >= self.brick_size:
            num_bricks = int(abs_price_diff // self.brick_size)
            direction = 1 if price_diff_decimal > 0 else -1
            current_close = last_close

            # Store the current builder volume to distribute across bricks
            total_volume = self._builder.volume

            for i in range(num_bricks):
                # Calculate the close price for this brick
                brick_close_decimal = current_close.as_decimal() + (direction * self.brick_size)
                brick_close = Price.from_str(str(brick_close_decimal))

                # Set the builder's OHLC for this specific brick
                self._builder._open = current_close
                self._builder._close = brick_close

                if direction > 0:
                    # Upward movement: high = brick_close, low = current_close
                    self._builder._high = brick_close
                    self._builder._low = current_close
                else:
                    # Downward movement: high = current_close, low = brick_close
                    self._builder._high = current_close
                    self._builder._low = brick_close

                # Set the volume for this brick (all accumulated volume goes to each brick)
                self._builder.volume = total_volume

                # Build and send the bar
                self._build_and_send(ts_init, ts_init)

                # Update current_close for the next brick
                current_close = brick_close

            # Update last_close to the final brick close
            self._last_close = current_close
        # If price movement is less than brick size, we accumulate in the builder


cdef class TimeBarAggregator(BarAggregator):
    """
    Provides a means of building time bars from ticks with an internal timer.

    When the time reaches the next time interval of the bar specification, then
    a bar is created and sent to the handler.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the aggregator.
    bar_type : BarType
        The bar type for the aggregator.
    handler : Callable[[Bar], None]
        The bar handler for the aggregator.
    clock : Clock
        The clock for the aggregator.
    interval_type : str, default 'left-open'
        Determines the type of interval used for time aggregation.
        - 'left-open': start time is excluded and end time is included (default).
        - 'right-open': start time is included and end time is excluded.
    timestamp_on_close : bool, default True
        If True, then timestamp will be the bar close time.
        If False, then timestamp will be the bar open time.
    skip_first_non_full_bar : bool, default False
        If will skip emitting a bar if the aggregation starts mid-interval.
    build_with_no_updates : bool, default True
        If build and emit bars with no new market updates.
    time_bars_origin_offset : pd.Timedelta or pd.DateOffset, optional
        The origin time offset.
    bar_build_delay : int, default 0
        The time delay (microseconds) before building and emitting a composite bar type.
        15 microseconds can be useful in a backtest context, when aggregating internal bars
        from internal bars several times so all messages are processed before a timer triggers.

    Raises
    ------
    ValueError
        If `instrument.id` != `bar_type.instrument_id`.
    """

    def __init__(
        self,
        Instrument instrument not None,
        BarType bar_type not None,
        handler not None: Callable[[Bar], None],
        Clock clock not None,
        str interval_type = "left-open",
        bint timestamp_on_close = True,
        bint skip_first_non_full_bar = False,
        bint build_with_no_updates = True,
        object time_bars_origin_offset: pd.Timedelta | pd.DateOffset = None,
        int bar_build_delay = 0,
    ) -> None:
        super().__init__(
            instrument=instrument,
            bar_type=bar_type,
            handler=handler,
        )
        self._clock = clock
        self._timestamp_on_close = timestamp_on_close
        self._skip_first_non_full_bar = skip_first_non_full_bar
        self._build_with_no_updates = build_with_no_updates
        self._bar_build_delay = bar_build_delay
        self._time_bars_origin_offset = time_bars_origin_offset or 0
        self._timer_name = str(self.bar_type)
        self.interval = self._get_interval()
        self.interval_ns = self._get_interval_ns()
        self.stored_open_ns = 0
        self.next_close_ns = 0
        self.historical_mode = False
        self._historical_events = []

        if interval_type == "left-open":
            self._is_left_open = True
        elif interval_type == "right-open":
            self._is_left_open = False
        else:
            raise ValueError(
                f"Invalid interval_type: {interval_type}. Must be 'left-open' or 'right-open'.",
            )

        if type(self._time_bars_origin_offset) is int:
            self._time_bars_origin_offset = pd.Timedelta(self._time_bars_origin_offset)

    def __str__(self):
        return f"{type(self).__name__}(interval_ns={self.interval_ns}, next_close_ns={self.next_close_ns})"

    cpdef void set_clock(self, Clock clock):
        self._clock = clock

    cpdef void start_timer(self):
        # Computing start_time
        cdef datetime now = self._clock.utc_now()
        cdef datetime start_time = self.get_start_time(now)
        start_time += timedelta(microseconds=self._bar_build_delay)

        # Closing a partial bar at the transition from historical to backtest data
        cdef bint fire_immediately = (start_time == now)

        self._skip_first_non_full_bar = self._skip_first_non_full_bar and now > start_time

        if self.bar_type.spec.aggregation not in (BarAggregation.MONTH, BarAggregation.YEAR):
            self._clock.set_timer(
                name=self._timer_name,
                interval=self.interval,
                start_time=start_time,
                stop_time=None,
                callback=self._build_bar,
                allow_past=True,
                fire_immediately=fire_immediately,
            )

            if fire_immediately:
                self.next_close_ns = dt_to_unix_nanos(start_time)
            else:
                self.next_close_ns = dt_to_unix_nanos(start_time + self.interval)

            self.stored_open_ns = self.next_close_ns - self.interval_ns
        else:
            # The monthly/yearly alert time is defined iteratively at each alert time as there is no regular interval
            if self.bar_type.spec.aggregation == BarAggregation.MONTH:
                alert_time = start_time + (pd.DateOffset(months=self.bar_type.spec.step) if not fire_immediately else pd.Timedelta(0))
            elif self.bar_type.spec.aggregation == BarAggregation.YEAR:
                alert_time = start_time + (pd.DateOffset(years=self.bar_type.spec.step) if not fire_immediately else pd.Timedelta(0))
            else:
                alert_time = start_time

            self._clock.set_time_alert(
                name=self._timer_name,
                alert_time=alert_time,
                callback=self._build_bar,
                override=True,
                allow_past=True,
            )
            self.next_close_ns = alert_time.value
            self.stored_open_ns = start_time.value

        self._log.debug(f"Started timer {self._timer_name}, {start_time=}, {self.historical_mode=}, "
                        f"{fire_immediately=}, {start_time=}, {now=}, {self._bar_build_delay=}")

    cpdef void stop_timer(self):
        self._clock.cancel_timer(str(self.bar_type))

    def get_start_time(self, now: datetime) -> datetime:
        """
        Return the start time for the aggregator's next bar.
        """
        step = self.bar_type.spec.step
        aggregation = self.bar_type.spec.aggregation

        if aggregation == BarAggregation.MILLISECOND:
            start_time = find_closest_smaller_time(now, self._time_bars_origin_offset, pd.Timedelta(milliseconds=step))
        elif aggregation == BarAggregation.SECOND:
            start_time = find_closest_smaller_time(now, self._time_bars_origin_offset, pd.Timedelta(seconds=step))
        elif aggregation == BarAggregation.MINUTE:
            start_time = find_closest_smaller_time(now, self._time_bars_origin_offset, pd.Timedelta(minutes=step))
        elif aggregation == BarAggregation.HOUR:
            start_time = find_closest_smaller_time(now, self._time_bars_origin_offset, pd.Timedelta(hours=step))
        elif aggregation == BarAggregation.DAY:
            start_time = find_closest_smaller_time(now, self._time_bars_origin_offset, pd.Timedelta(days=step))
        elif aggregation == BarAggregation.WEEK:
            start_time = (now - pd.Timedelta(days=now.dayofweek)).floor(freq="d")

            if self._time_bars_origin_offset is not None:
                start_time += self._time_bars_origin_offset

            if now < start_time:
                start_time -= pd.Timedelta(weeks=step)
        elif aggregation == BarAggregation.MONTH:
            start_time = (now - pd.DateOffset(months=now.month - 1, days=now.day - 1)).floor(freq="d")

            if self._time_bars_origin_offset is not None:
                start_time += self._time_bars_origin_offset

            if now < start_time:
                start_time -= pd.DateOffset(years=1)

            while start_time <= now:
                start_time += pd.DateOffset(months=step)

            start_time -= pd.DateOffset(months=step)
        elif aggregation == BarAggregation.YEAR:
            start_time = (now - pd.DateOffset(months=now.month - 1, days=now.day - 1)).floor(freq="d")

            if self._time_bars_origin_offset is not None:
                start_time += self._time_bars_origin_offset

            if now < start_time:
                start_time -= pd.DateOffset(years=step)
        else:  # pragma: no cover (design-time error)
            raise ValueError(
                f"Aggregation type not supported for time bars, "
                f"was {bar_aggregation_to_str(aggregation)}",
            )

        return start_time

    cdef uint64_t _get_interval_ns(self):
        return self._get_interval().value

    def _get_interval(self) -> pd.Timedelta:
        cdef BarAggregation aggregation = self.bar_type.spec.aggregation
        cdef int step = self.bar_type.spec.step

        if aggregation == BarAggregation.MILLISECOND:
            return pd.Timedelta(milliseconds=(1 * step))
        elif aggregation == BarAggregation.SECOND:
            return pd.Timedelta(seconds=(1 * step))
        elif aggregation == BarAggregation.MINUTE:
            return pd.Timedelta(minutes=(1 * step))
        elif aggregation == BarAggregation.HOUR:
            return pd.Timedelta(hours=(1 * step))
        elif aggregation == BarAggregation.DAY:
            return pd.Timedelta(days=(1 * step))
        elif aggregation == BarAggregation.WEEK:
            return pd.Timedelta(days=(7 * step))
        elif aggregation in (BarAggregation.MONTH, BarAggregation.YEAR):
            # not actually used
            return pd.Timedelta(days=0)
        else:
            # Design time error
            raise ValueError(
                f"Aggregation not time based, was {bar_aggregation_to_str(aggregation)}",
            )

    cdef void _apply_update(self, Price price, Quantity size, uint64_t ts_init):
        if self.historical_mode:
            self._preprocess_historical_events(ts_init)

        self._builder.update(price, size, ts_init)

        if self.historical_mode:
            self._postprocess_historical_events(ts_init)

    cdef void _apply_update_bar(self, Bar bar, Quantity volume, uint64_t ts_init):
        if self.historical_mode:
            self._preprocess_historical_events(ts_init)

        self._builder.update_bar(bar, volume, ts_init)

        if self.historical_mode:
            self._postprocess_historical_events(ts_init)

    cdef void _preprocess_historical_events(self, uint64_t ts_init):
        if self._clock.timestamp_ns() == 0:
            self._clock.set_time(ts_init)
            self.start_timer()

        # Advance this aggregator's independent clock and collect timer events
        self._historical_events = self._clock.advance_time(ts_init, set_time=True)

    cdef void _postprocess_historical_events(self, uint64_t ts_init):
        # Process timer events after data processing
        for event_handler in self._historical_events:
            self._build_bar(event_handler.event)

    cpdef void _build_bar(self, TimeEvent event):
        if not self._builder.initialized:
            return

        if not self._build_with_no_updates and self._builder.count == 0:
            return  # Do not build bar when no update

        cdef uint64_t ts_init = event.ts_event
        cdef uint64_t ts_event

        if self._is_left_open:
            ts_event = event.ts_event if self._timestamp_on_close else self.stored_open_ns
        else:
            ts_event = self.stored_open_ns

        self._build_and_send(ts_event=ts_event, ts_init=ts_init)

        # Close time becomes the next open time
        self.stored_open_ns = event.ts_event

        if self.bar_type.spec.aggregation == BarAggregation.MONTH:
            alert_time = unix_nanos_to_dt(event.ts_event) + pd.DateOffset(months=self.bar_type.spec.step)
            self._clock.set_time_alert(
                name=self._timer_name,
                alert_time=alert_time,
                callback=self._build_bar,
                override=True,
            )
            self.next_close_ns = dt_to_unix_nanos(alert_time)
        elif self.bar_type.spec.aggregation == BarAggregation.YEAR:
            alert_time = unix_nanos_to_dt(event.ts_event) + pd.DateOffset(years=self.bar_type.spec.step)
            self._clock.set_time_alert(
                name=self._timer_name,
                alert_time=alert_time,
                callback=self._build_bar,
                override=True,
            )
            self.next_close_ns = dt_to_unix_nanos(alert_time)
        else:
            # On receiving this event, timer should now have a new `next_time_ns`
            self.next_close_ns = self._clock.next_time_ns(self._timer_name)

    cdef void _build_and_send(self, uint64_t ts_event, uint64_t ts_init):
        if self._skip_first_non_full_bar:
            self._builder.reset()
            self._skip_first_non_full_bar = False
        else:
            BarAggregator._build_and_send(self, ts_event, ts_init)


def find_closest_smaller_time(
    now: pd.Timestamp,
    daily_time_origin: pd.Timedelta,
    period: pd.Timedelta
) -> pd.Timestamp:
    """Find the closest bar start_time <= now"""
    day_start = now.floor(freq="d")
    base_time = day_start + daily_time_origin

    time_difference = now - base_time
    num_periods = time_difference // period

    closest_time = base_time + num_periods * period

    return closest_time

</document_content>
</document>
<document index="2304">
<source>nautilus_trader/data/client.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.common.config import NautilusConfig

from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Component
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.data.messages cimport DataResponse
from nautilus_trader.data.messages cimport RequestBars
from nautilus_trader.data.messages cimport RequestData
from nautilus_trader.data.messages cimport RequestInstrument
from nautilus_trader.data.messages cimport RequestInstruments
from nautilus_trader.data.messages cimport RequestOrderBookSnapshot
from nautilus_trader.data.messages cimport RequestQuoteTicks
from nautilus_trader.data.messages cimport RequestTradeTicks
from nautilus_trader.data.messages cimport SubscribeBars
from nautilus_trader.data.messages cimport SubscribeData
from nautilus_trader.data.messages cimport SubscribeFundingRates
from nautilus_trader.data.messages cimport SubscribeIndexPrices
from nautilus_trader.data.messages cimport SubscribeInstrument
from nautilus_trader.data.messages cimport SubscribeInstrumentClose
from nautilus_trader.data.messages cimport SubscribeInstruments
from nautilus_trader.data.messages cimport SubscribeInstrumentStatus
from nautilus_trader.data.messages cimport SubscribeMarkPrices
from nautilus_trader.data.messages cimport SubscribeOrderBook
from nautilus_trader.data.messages cimport SubscribeQuoteTicks
from nautilus_trader.data.messages cimport SubscribeTradeTicks
from nautilus_trader.data.messages cimport UnsubscribeBars
from nautilus_trader.data.messages cimport UnsubscribeData
from nautilus_trader.data.messages cimport UnsubscribeFundingRates
from nautilus_trader.data.messages cimport UnsubscribeIndexPrices
from nautilus_trader.data.messages cimport UnsubscribeInstrument
from nautilus_trader.data.messages cimport UnsubscribeInstrumentClose
from nautilus_trader.data.messages cimport UnsubscribeInstruments
from nautilus_trader.data.messages cimport UnsubscribeInstrumentStatus
from nautilus_trader.data.messages cimport UnsubscribeMarkPrices
from nautilus_trader.data.messages cimport UnsubscribeOrderBook
from nautilus_trader.data.messages cimport UnsubscribeQuoteTicks
from nautilus_trader.data.messages cimport UnsubscribeTradeTicks
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport OrderBookDepth10
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.base cimport Instrument


cdef class DataClient(Component):
    """
    The base class for all data clients.

    Parameters
    ----------
    client_id : ClientId
        The data client ID.
    msgbus : MessageBus
        The message bus for the client.
    clock : Clock
        The clock for the client.
    venue : Venue, optional
        The client venue. If multi-venue then can be ``None``.
    config : NautilusConfig, optional
        The configuration for the instance.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        ClientId client_id not None,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
        Venue venue: Venue | None = None,
        config: NautilusConfig | None = None,
    ):
        super().__init__(
            clock=clock,
            component_id=client_id,
            component_name=f"DataClient-{client_id}",
            msgbus=msgbus,
            config=config,
        )

        self._cache = cache

        self.venue = venue

        # Subscriptions
        self._subscriptions_generic: set[DataType] = set()

        self.is_connected = False

    def __repr__(self) -> str:
        return f"{type(self).__name__}-{self.id.value}"

    cpdef void _set_connected(self, bint value=True):
        """
        Setter for Python implementations to change the readonly property.

        Parameters
        ----------
        value : bool
            The value to set for is_connected.

        """
        self.is_connected = value

# -- SUBSCRIPTIONS --------------------------------------------------------------------------------

    cpdef list subscribed_custom_data(self):
        """
        Return the custom data types subscribed to.

        Returns
        -------
        list[DataType]

        """
        return sorted(list(self._subscriptions_generic))

    cpdef void subscribe(self, SubscribeData command):
        """
        Subscribe to data for the given data type.

        Parameters
        ----------
        data_type : DataType
            The data type for the subscription.

        """
        self._log.error(
            f"Cannot subscribe to {command.data_type}: not implemented. "
            f"You can implement by overriding the `subscribe` method for this client",
        )

    cpdef void unsubscribe(self, UnsubscribeData command):
        """
        Unsubscribe from data for the given data type.

        Parameters
        ----------
        data_type : DataType
            The data type for the subscription.

        """
        self._log.error(
            f"Cannot unsubscribe from {command.data_type}: not implemented. "
            f"You can implement by overriding the `unsubscribe` method for this client",
        )

    cpdef void _add_subscription(self, DataType data_type):
        Condition.not_none(data_type, "data_type")

        self._subscriptions_generic.add(data_type)

    cpdef void _remove_subscription(self, DataType data_type):
        Condition.not_none(data_type, "data_type")

        self._subscriptions_generic.discard(data_type)

# -- REQUESTS -------------------------------------------------------------------------------------

    cpdef void request(self, RequestData request):
        """
        Request data for the given data type.

        Parameters
        ----------
        request : RequestData
            The message for the data request.

        """
        self._log.error(
            f"Cannot request {request.data_type}: not implemented. "
            f"You can implement by overriding the `request` method for this client",
        )

# -- PYTHON WRAPPERS ------------------------------------------------------------------------------

    def _handle_data_py(self, Data data):
        self._handle_data(data)

    def _handle_data_response_py(self, DataType data_type, data, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params):
        self._handle_data_response(data_type, data, correlation_id, start, end, params)

# -- DATA HANDLERS --------------------------------------------------------------------------------

    cpdef void _handle_data(self, Data data):
        self._msgbus.send(endpoint="DataEngine.process", msg=data)

    cpdef void _handle_data_response(self, DataType data_type, data, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params):
        cdef DataResponse response = DataResponse(
            client_id=self.id,
            venue=self.venue,
            data_type=data_type,
            data=data,
            correlation_id=correlation_id,
            response_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            start=start,
            end=end,
            params=params,
        )

        self._msgbus.send(endpoint="DataEngine.response", msg=response)


cdef class MarketDataClient(DataClient):
    """
    The base class for all market data clients.

    Parameters
    ----------
    client_id : ClientId
        The data client ID.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : Clock
        The clock for the client.
    venue : Venue, optional
        The client venue. If multi-venue then can be ``None``.
    config : NautilusConfig, optional
        The configuration for the instance.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        ClientId client_id not None,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
        Venue venue: Venue | None = None,
        config: NautilusConfig | None = None,
    ):
        super().__init__(
            client_id=client_id,
            venue=venue,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
            config=config,
        )

        # Subscriptions
        self._subscriptions_order_book_delta = set()     # type: set[InstrumentId]
        self._subscriptions_order_book_snapshot = set()  # type: set[InstrumentId]
        self._subscriptions_quote_tick = set()           # type: set[InstrumentId]
        self._subscriptions_trade_tick = set()           # type: set[InstrumentId]
        self._subscriptions_mark_price = set()           # type: set[InstrumentId]
        self._subscriptions_index_price = set()          # type: set[InstrumentId]
        self._subscriptions_funding_rate = set()         # type: set[InstrumentId]
        self._subscriptions_instrument_status = set()    # type: set[InstrumentId]
        self._subscriptions_instrument_close = set()     # type: set[InstrumentId]
        self._subscriptions_instrument = set()           # type: set[InstrumentId]
        self._subscriptions_bar = set()                  # type: set[BarType]

        # Tasks
        self._update_instruments_task = None

# -- SUBSCRIPTIONS --------------------------------------------------------------------------------

    cpdef list subscribed_custom_data(self):
        """
        Return the custom data types subscribed to.

        Returns
        -------
        list[DataType]

        """
        return sorted(list(self._subscriptions_generic))

    cpdef list subscribed_instruments(self):
        """
        Return the instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_instrument))

    cpdef list subscribed_order_book_deltas(self):
        """
        Return the order book delta instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_order_book_delta))

    cpdef list subscribed_order_book_snapshots(self):
        """
        Return the order book snapshot instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_order_book_snapshot))

    cpdef list subscribed_quote_ticks(self):
        """
        Return the quote tick instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_quote_tick))

    cpdef list subscribed_trade_ticks(self):
        """
        Return the trade tick instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_trade_tick))

    cpdef list subscribed_mark_prices(self):
        """
        Return the mark price update instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_mark_price))

    cpdef list subscribed_index_prices(self):
        """
        Return the index price update instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_index_price))

    cpdef list subscribed_funding_rates(self):
        """
        Return the funding rate update instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_funding_rate))

    cpdef list subscribed_bars(self):
        """
        Return the bar types subscribed to.

        Returns
        -------
        list[BarType]

        """
        return sorted(list(self._subscriptions_bar))

    cpdef list subscribed_instrument_status(self):
        """
        Return the status update instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_instrument_status))

    cpdef list subscribed_instrument_close(self):
        """
        Return the instrument closes subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscriptions_instrument_close))

    cpdef void subscribe(self, SubscribeData command):
        """
        Subscribe to data for the given data type.

        Parameters
        ----------
        data_type : DataType
            The data type for the subscription.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(
            f"Cannot subscribe to {command.data_type}: not implemented. "
            f"You can implement by overriding the `subscribe` method for this client",
        )
        raise NotImplementedError("method `subscribe` must be implemented in the subclass")

    cpdef void subscribe_instruments(self, SubscribeInstruments command):
        """
        Subscribe to all `Instrument` data.

        Parameters
        ----------
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(
            f"Cannot subscribe to all `Instrument` data: not implemented. "
            f"You can implement by overriding the `subscribe_instruments` method for this client",
        )
        raise NotImplementedError("method `subscribe_instruments` must be implemented in the subclass")

    cpdef void subscribe_instrument(self, SubscribeInstrument command):
        """
        Subscribe to the `Instrument` with the given instrument ID.

        Parameters
        ----------
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(
            f"Cannot subscribe to `Instrument` data for {command.instrument_id}: not implemented. "
            f"You can implement by overriding the `subscribe_instrument` method for this client",
        )
        raise NotImplementedError("method `subscribe_instrument` must be implemented in the subclass")

    cpdef void subscribe_order_book_deltas(self, SubscribeOrderBook command):
        """
        Subscribe to `OrderBookDeltas` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to subscribe to.
        book_type : BookType {``L1_MBP``, ``L2_MBP``, ``L3_MBO``}
            The order book type.
        depth : int, optional, default None
            The maximum depth for the subscription.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `OrderBookDeltas` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_order_book_deltas` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_order_book_deltas` must be implemented in the subclass")

    cpdef void subscribe_order_book_snapshots(self, SubscribeOrderBook command):
        """
        Subscribe to `OrderBook` snapshots data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to subscribe to.
        book_type : BookType {``L1_MBP``, ``L2_MBP``, ``L3_MBO``}
            The order book level.
        depth : int, optional
            The maximum depth for the order book. A depth of 0 is maximum depth.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `OrderBook` snapshots data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_order_book_snapshots` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_order_book_snapshots` must be implemented in the subclass")

    cpdef void subscribe_order_book_depth(self, SubscribeOrderBook command):
        """
        Subscribe to `OrderBookDepth10` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to subscribe to.
        depth : int, optional
            The maximum depth for the order book (defaults to 10).
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `OrderBookDepth10` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_order_book_depth` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_order_book_depth` must be implemented in the subclass")

    cpdef void subscribe_quote_ticks(self, SubscribeQuoteTicks command):
        """
        Subscribe to `QuoteTick` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `QuoteTick` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_quote_ticks` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_quote_ticks` must be implemented in the subclass")

    cpdef void subscribe_trade_ticks(self, SubscribeTradeTicks command):
        """
        Subscribe to `TradeTick` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `TradeTick` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_trade_ticks` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_trade_ticks` must be implemented in the subclass")

    cpdef void subscribe_mark_prices(self, SubscribeMarkPrices command):
        """
        Subscribe to `MarkPriceUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `MarkPriceUpdate` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_mark_prices` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_mark_prices` must be implemented in the subclass")

    cpdef void subscribe_index_prices(self, SubscribeIndexPrices command):
        """
        Subscribe to `IndexPriceUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `IndexPriceUpdate` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_index_prices` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_index_prices` must be implemented in the subclass")

    cpdef void subscribe_funding_rates(self, SubscribeFundingRates command):
        """
        Subscribe to `FundingRateUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `FundingRateUpdate` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_funding_rates` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_funding_rates` must be implemented in the subclass")

    cpdef void subscribe_instrument_status(self, SubscribeInstrumentStatus command):
        """
        Subscribe to `InstrumentStatus` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `InstrumentStatus` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_instrument_status` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_instrument_status` must be implemented in the subclass")

    cpdef void subscribe_instrument_close(self, SubscribeInstrumentClose command):
        """
        Subscribe to `InstrumentClose` updates for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `InstrumentClose` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_instrument_close` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_instrument_close` must be implemented in the subclass")

    cpdef void subscribe_bars(self, SubscribeBars command):
        """
        Subscribe to `Bar` data for the given bar type.

        Parameters
        ----------
        bar_type : BarType
            The bar type to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot subscribe to `Bar` data for {command.bar_type}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `subscribe_bars` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `subscribe_bars` must be implemented in the subclass")

    cpdef void unsubscribe(self, UnsubscribeData command):
        """
        Unsubscribe from data for the given data type.

        Parameters
        ----------
        data_type : DataType
            The data type for the subscription.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(
            f"Cannot unsubscribe from {command.data_type}: not implemented. "
            f"You can implement by overriding the `unsubscribe` method for this client",
        )

    cpdef void unsubscribe_instruments(self, UnsubscribeInstruments command):
        """
        Unsubscribe from all `Instrument` data.

        Parameters
        ----------
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from all `Instrument` data: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_instruments` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_instruments` must be implemented in the subclass")

    cpdef void unsubscribe_instrument(self, UnsubscribeInstrument command):
        """
        Unsubscribe from `Instrument` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `Instrument` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_instrument` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_instrument` must be implemented in the subclass")

    cpdef void unsubscribe_order_book_deltas(self, UnsubscribeOrderBook command):
        """
        Unsubscribe from `OrderBookDeltas` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `OrderBookDeltas` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_order_book_deltas` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_order_book_deltas` must be implemented in the subclass")

    cpdef void unsubscribe_order_book_snapshots(self, UnsubscribeOrderBook command):
        """
        Unsubscribe from `OrderBook` snapshots data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `OrderBook` snapshot data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_order_book_snapshots` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_order_book_snapshots` must be implemented in the subclass")

    cpdef void unsubscribe_order_book_depth(self, UnsubscribeOrderBook command):
        """
        Unsubscribe from `OrderBookDepth10` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The order book instrument to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `OrderBookDepth10` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_order_book_depth` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_order_book_depth` must be implemented in the subclass")

    cpdef void unsubscribe_quote_ticks(self, UnsubscribeQuoteTicks command):
        """
        Unsubscribe from `QuoteTick` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `QuoteTick` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_quote_ticks` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_quote_ticks` must be implemented in the subclass")

    cpdef void unsubscribe_trade_ticks(self, UnsubscribeTradeTicks command):
        """
        Unsubscribe from `TradeTick` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `TradeTick` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_trade_ticks` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_trade_ticks` must be implemented in the subclass")

    cpdef void unsubscribe_mark_prices(self, UnsubscribeMarkPrices command):
        """
        Unsubscribe from `MarkPriceUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `MarkPriceUpdate` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_mark_prices` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_mark_prices` must be implemented in the subclass")

    cpdef void unsubscribe_index_prices(self, UnsubscribeIndexPrices command):
        """
        Unsubscribe from `IndexPriceUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `IndexPriceUpdate` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_index_prices` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_index_prices` must be implemented in the subclass")

    cpdef void unsubscribe_funding_rates(self, UnsubscribeFundingRates command):
        """
        Unsubscribe from `FundingRateUpdate` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument to subscribe to.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `FundingRateUpdate` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_funding_rates` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_funding_rates` must be implemented in the subclass")

    cpdef void unsubscribe_bars(self, UnsubscribeBars command):
        """
        Unsubscribe from `Bar` data for the given bar type.

        Parameters
        ----------
        bar_type : BarType
            The bar type to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `Bar` data for {command.bar_type}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_bars` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_bars` must be implemented in the subclass")

    cpdef void unsubscribe_instrument_status(self, UnsubscribeInstrumentStatus command):
        """
        Unsubscribe from `InstrumentStatus` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument status updates to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `InstrumentStatus` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_instrument_status` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_instrument_status` must be implemented in the subclass")

    cpdef void unsubscribe_instrument_close(self, UnsubscribeInstrumentClose command):
        """
        Unsubscribe from `InstrumentClose` data for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The tick instrument to unsubscribe from.
        params : dict[str, Any], optional
            Additional params for the subscription.

        """
        self._log.error(  # pragma: no cover
            f"Cannot unsubscribe from `InstrumentClose` data for {command.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `unsubscribe_instrument_close` method for this client",  # pragma: no cover
        )
        raise NotImplementedError("method `unsubscribe_instrument_close` must be implemented in the subclass")

    cpdef void _add_subscription(self, DataType data_type):
        Condition.not_none(data_type, "data_type")

        self._subscriptions_generic.add(data_type)

    cpdef void _add_subscription_instrument(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_instrument.add(instrument_id)

    cpdef void _add_subscription_order_book_deltas(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_order_book_delta.add(instrument_id)

    cpdef void _add_subscription_order_book_snapshots(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_order_book_snapshot.add(instrument_id)

    cpdef void _add_subscription_quote_ticks(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_quote_tick.add(instrument_id)

    cpdef void _add_subscription_trade_ticks(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_trade_tick.add(instrument_id)

    cpdef void _add_subscription_mark_prices(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_mark_price.add(instrument_id)

    cpdef void _add_subscription_index_prices(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_index_price.add(instrument_id)

    cpdef void _add_subscription_funding_rates(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_funding_rate.add(instrument_id)

    cpdef void _add_subscription_bars(self, BarType bar_type):
        Condition.not_none(bar_type, "bar_type")

        self._subscriptions_bar.add(bar_type)

    cpdef void _add_subscription_instrument_status(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_instrument_status.add(instrument_id)

    cpdef void _add_subscription_instrument_close(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_instrument_close.add(instrument_id)

    cpdef void _remove_subscription(self, DataType data_type):
        Condition.not_none(data_type, "data_type")

        self._subscriptions_generic.discard(data_type)

    cpdef void _remove_subscription_instrument(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_instrument.discard(instrument_id)

    cpdef void _remove_subscription_order_book_deltas(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_order_book_delta.discard(instrument_id)

    cpdef void _remove_subscription_order_book_snapshots(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_order_book_snapshot.discard(instrument_id)

    cpdef void _remove_subscription_quote_ticks(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_quote_tick.discard(instrument_id)

    cpdef void _remove_subscription_trade_ticks(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_trade_tick.discard(instrument_id)

    cpdef void _remove_subscription_mark_prices(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_mark_price.discard(instrument_id)

    cpdef void _remove_subscription_index_prices(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_index_price.discard(instrument_id)

    cpdef void _remove_subscription_funding_rates(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_funding_rate.discard(instrument_id)

    cpdef void _remove_subscription_bars(self, BarType bar_type):
        Condition.not_none(bar_type, "bar_type")

        self._subscriptions_bar.discard(bar_type)

    cpdef void _remove_subscription_instrument_status(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_instrument_status.discard(instrument_id)

    cpdef void _remove_subscription_instrument_close(self, InstrumentId instrument_id):
        Condition.not_none(instrument_id, "instrument_id")

        self._subscriptions_instrument_close.discard(instrument_id)

# -- REQUESTS -------------------------------------------------------------------------------------

    cpdef void request_instrument(self, RequestInstrument request):
        """
        Request `Instrument` data for the given instrument ID.

        Parameters
        ----------
        request : RequestInstrument
            The message for the data request.

        """
        self._log.error(  # pragma: no cover
            f"Cannot request `Instrument` data for {request.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `request_instrument` method for this client",  # pragma: no cover  # noqa
        )

    cpdef void request_instruments(self, RequestInstruments request):
        """
        Request all `Instrument` data for the given venue.

        Parameters
        ----------
        request : RequestInstruments
            The message for the data request.

        """
        self._log.error(  # pragma: no cover
            f"Cannot request all `Instrument` data: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `request_instruments` method for this client",  # pragma: no cover  # noqa
        )

    cpdef void request_order_book_snapshot(self, RequestOrderBookSnapshot request):
        """
        Request order book snapshot data.

        Parameters
        ----------
        request : RequestOrderBookSnapshot
            The message for the data request.

        """
        self._log.error(
            f"Cannot request order book snapshot data for {request.instrument_id}: not implemented. "
            "You can implement by overriding the `request_order_book_snapshot` method for this client."
        )

    cpdef void request_quote_ticks(self, RequestQuoteTicks request):
        """
        Request historical `QuoteTick` data.

        Parameters
        ----------
        request : RequestQuoteTicks
            The message for the data request.

        """
        self._log.error(  # pragma: no cover
            f"Cannot request `QuoteTick` data for {request.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `request_quote_ticks` method for this client",  # pragma: no cover  # noqa
        )

    cpdef void request_trade_ticks(self, RequestTradeTicks request):
        """
        Request historical `TradeTick` data.

        Parameters
        ----------
        request : RequestTradeTicks
            The message for the data request.

        """
        self._log.error(  # pragma: no cover
            f"Cannot request `TradeTick` data for {request.instrument_id}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `request_trade_ticks` method for this client",  # pragma: no cover  # noqa
        )

    cpdef void request_bars(self, RequestBars request):
        """
        Request historical `Bar` data. To load historical data from a catalog, you can pass a list[DataCatalogConfig] to the TradingNodeConfig or the BacktestEngineConfig.

        Parameters
        ----------
        request : RequestBars
            The message for the data request.

        """
        self._log.error(  # pragma: no cover
            f"Cannot request `Bar` data for {request.bar_type}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `request_bars` method for this client",  # pragma: no cover  # noqa
        )


# -- PYTHON WRAPPERS ------------------------------------------------------------------------------

    # Convenient Python wrappers for the data handlers. Often Python methods
    # involving threads or the event loop don't work with `cpdef` methods.

    def _handle_data_py(self, Data data):
        self._handle_data(data)

    def _handle_instrument_py(self, Instrument instrument, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params = None):
        self._handle_instrument(instrument, correlation_id, start, end, params)

    def _handle_instruments_py(self, Venue venue, list instruments, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params = None):
        self._handle_instruments(venue, instruments, correlation_id, start, end, params)

    def _handle_quote_ticks_py(self, InstrumentId instrument_id, list ticks, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params = None):
        self._handle_quote_ticks(instrument_id, ticks, correlation_id, start, end, params)

    def _handle_trade_ticks_py(self, InstrumentId instrument_id, list ticks, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params = None):
        self._handle_trade_ticks(instrument_id, ticks, correlation_id, start, end, params)

    def _handle_bars_py(self, BarType bar_type, list bars, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params = None):
        self._handle_bars(bar_type, bars, correlation_id, start, end, params)

    def _handle_order_book_depths_py(self, InstrumentId instrument_id, list depths, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params = None):
        self._handle_order_book_depths(instrument_id, depths, correlation_id, start, end, params)

    def _handle_data_response_py(self, DataType data_type, data, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params = None):
        self._handle_data_response(data_type, data, correlation_id, start, end, params)

# -- DATA HANDLERS --------------------------------------------------------------------------------

    cpdef void _handle_data(self, Data data):
        self._msgbus.send(endpoint="DataEngine.process", msg=data)

    cpdef void _handle_instrument(self, Instrument instrument, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params):
        cdef DataResponse response = DataResponse(
            client_id=self.id,
            venue=instrument.venue,
            data_type=DataType(Instrument, metadata=({"instrument_id": instrument.id})),
            data=[instrument],
            correlation_id=correlation_id,
            response_id=UUID4(),
            start=start,
            end=end,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )

        self._msgbus.send(endpoint="DataEngine.response", msg=response)

    cpdef void _handle_instruments(self, Venue venue, list instruments, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params):
        cdef DataResponse response = DataResponse(
            client_id=self.id,
            venue=venue,
            data_type=DataType(Instrument, metadata=({"venue": venue})),
            data=instruments,
            correlation_id=correlation_id,
            response_id=UUID4(),
            start=start,
            end=end,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )

        self._msgbus.send(endpoint="DataEngine.response", msg=response)

    cpdef void _handle_quote_ticks(self, InstrumentId instrument_id, list ticks, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params):
        cdef DataResponse response = DataResponse(
            client_id=self.id,
            venue=instrument_id.venue,
            data_type=DataType(QuoteTick, metadata=({"instrument_id": instrument_id})),
            data=ticks,
            correlation_id=correlation_id,
            response_id=UUID4(),
            start=start,
            end=end,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )

        self._msgbus.send(endpoint="DataEngine.response", msg=response)

    cpdef void _handle_trade_ticks(self, InstrumentId instrument_id, list ticks, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params):
        cdef DataResponse response = DataResponse(
            client_id=self.id,
            venue=instrument_id.venue,
            data_type=DataType(TradeTick, metadata=({"instrument_id": instrument_id})),
            data=ticks,
            correlation_id=correlation_id,
            response_id=UUID4(),
            start=start,
            end=end,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )

        self._msgbus.send(endpoint="DataEngine.response", msg=response)

    cpdef void _handle_bars(self, BarType bar_type, list bars, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params):
        cdef DataResponse response = DataResponse(
            client_id=self.id,
            venue=bar_type.instrument_id.venue,
            data_type=DataType(Bar, metadata=(({"bar_type": bar_type}))),
            data=bars,
            correlation_id=correlation_id,
            response_id=UUID4(),
            start=start,
            end=end,
            params=params,
            ts_init=self._clock.timestamp_ns(),
        )

        self._msgbus.send(endpoint="DataEngine.response", msg=response)

    cpdef void _handle_order_book_depths(self, InstrumentId instrument_id, list depths, UUID4 correlation_id, datetime start, datetime end, dict[str, object] params):
        cdef DataResponse response = DataResponse(
            client_id=self.id,
            venue=instrument_id.venue,
            data_type=DataType(OrderBookDepth10, metadata=({"instrument_id": instrument_id})),
            data=depths,
            correlation_id=correlation_id,
            response_id=UUID4(),
            start=start,
            end=end,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )

        self._msgbus.send(endpoint="DataEngine.response", msg=response)

</document_content>
</document>
<document index="2307">
<source>nautilus_trader/data/engine.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
The `DataEngine` is the central component of the entire data stack.

The data engines primary responsibility is to orchestrate interactions between
the `DataClient` instances, and the rest of the platform. This includes sending
requests to, and receiving responses from, data endpoints via its registered
data clients.

The engine employs a simple fan-in fan-out messaging pattern to execute
`DataCommand` type messages, and process `DataResponse` messages or market data
objects.

Alternative implementations can be written on top of the generic engine - which
just need to override the `execute`, `process`, `send` and `receive` methods.
"""

from typing import Any
from typing import Callable
from typing import Generator

from nautilus_trader.common.enums import LogColor
from nautilus_trader.core.datetime import min_date
from nautilus_trader.core.datetime import time_object_to_dt
from nautilus_trader.data.config import DataEngineConfig
from nautilus_trader.model.enums import RecordFlag
from nautilus_trader.persistence.catalog import ParquetDataCatalog

from cpython.datetime cimport datetime
from libc.stdint cimport uint64_t

from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.component cimport CMD
from nautilus_trader.common.component cimport RECV
from nautilus_trader.common.component cimport REQ
from nautilus_trader.common.component cimport RES
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Component
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport TestClock
from nautilus_trader.common.data_topics cimport TopicCache
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.datetime cimport dt_to_unix_nanos
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.rust.core cimport NANOSECONDS_IN_MILLISECOND
from nautilus_trader.core.rust.core cimport NANOSECONDS_IN_SECOND
from nautilus_trader.core.rust.core cimport millis_to_nanos
from nautilus_trader.core.rust.model cimport BookType
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.data.aggregation cimport BarAggregator
from nautilus_trader.data.aggregation cimport RenkoBarAggregator
from nautilus_trader.data.aggregation cimport TickBarAggregator
from nautilus_trader.data.aggregation cimport TickImbalanceBarAggregator
from nautilus_trader.data.aggregation cimport TickRunsBarAggregator
from nautilus_trader.data.aggregation cimport TimeBarAggregator
from nautilus_trader.data.aggregation cimport ValueBarAggregator
from nautilus_trader.data.aggregation cimport ValueImbalanceBarAggregator
from nautilus_trader.data.aggregation cimport ValueRunsBarAggregator
from nautilus_trader.data.aggregation cimport VolumeBarAggregator
from nautilus_trader.data.aggregation cimport VolumeImbalanceBarAggregator
from nautilus_trader.data.aggregation cimport VolumeRunsBarAggregator
from nautilus_trader.data.client cimport DataClient
from nautilus_trader.data.client cimport MarketDataClient
from nautilus_trader.data.engine cimport SnapshotInfo
from nautilus_trader.data.messages cimport DataCommand
from nautilus_trader.data.messages cimport DataResponse
from nautilus_trader.data.messages cimport RequestBars
from nautilus_trader.data.messages cimport RequestData
from nautilus_trader.data.messages cimport RequestInstrument
from nautilus_trader.data.messages cimport RequestInstruments
from nautilus_trader.data.messages cimport RequestJoin
from nautilus_trader.data.messages cimport RequestOrderBookDepth
from nautilus_trader.data.messages cimport RequestOrderBookSnapshot
from nautilus_trader.data.messages cimport RequestQuoteTicks
from nautilus_trader.data.messages cimport RequestTradeTicks
from nautilus_trader.data.messages cimport SubscribeBars
from nautilus_trader.data.messages cimport SubscribeData
from nautilus_trader.data.messages cimport SubscribeFundingRates
from nautilus_trader.data.messages cimport SubscribeIndexPrices
from nautilus_trader.data.messages cimport SubscribeInstrument
from nautilus_trader.data.messages cimport SubscribeInstrumentClose
from nautilus_trader.data.messages cimport SubscribeInstruments
from nautilus_trader.data.messages cimport SubscribeInstrumentStatus
from nautilus_trader.data.messages cimport SubscribeMarkPrices
from nautilus_trader.data.messages cimport SubscribeOrderBook
from nautilus_trader.data.messages cimport SubscribeQuoteTicks
from nautilus_trader.data.messages cimport SubscribeTradeTicks
from nautilus_trader.data.messages cimport UnsubscribeBars
from nautilus_trader.data.messages cimport UnsubscribeData
from nautilus_trader.data.messages cimport UnsubscribeFundingRates
from nautilus_trader.data.messages cimport UnsubscribeIndexPrices
from nautilus_trader.data.messages cimport UnsubscribeInstrument
from nautilus_trader.data.messages cimport UnsubscribeInstrumentClose
from nautilus_trader.data.messages cimport UnsubscribeInstruments
from nautilus_trader.data.messages cimport UnsubscribeInstrumentStatus
from nautilus_trader.data.messages cimport UnsubscribeMarkPrices
from nautilus_trader.data.messages cimport UnsubscribeOrderBook
from nautilus_trader.data.messages cimport UnsubscribeQuoteTicks
from nautilus_trader.data.messages cimport UnsubscribeTradeTicks
from nautilus_trader.model.book cimport OrderBook
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarAggregation
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport CustomData
from nautilus_trader.model.data cimport DataType
from nautilus_trader.model.data cimport FundingRateUpdate
from nautilus_trader.model.data cimport IndexPriceUpdate
from nautilus_trader.model.data cimport InstrumentClose
from nautilus_trader.model.data cimport InstrumentStatus
from nautilus_trader.model.data cimport MarkPriceUpdate
from nautilus_trader.model.data cimport OrderBookDelta
from nautilus_trader.model.data cimport OrderBookDeltas
from nautilus_trader.model.data cimport OrderBookDepth10
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.data cimport bar_aggregation_not_implemented_message
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ComponentId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class DataEngine(Component):
    """
    Provides a high-performance data engine for managing many `DataClient`
    instances, for the asynchronous ingest of data.

    Parameters
    ----------
    msgbus : MessageBus
        The message bus for the engine.
    cache : Cache
        The cache for the engine.
    clock : Clock
        The clock for the engine.
    config : DataEngineConfig, optional
        The configuration for the instance.
    """

    def __init__(
        self,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
        config: DataEngineConfig | None = None,
    ) -> None:
        if config is None:
            config = DataEngineConfig()

        Condition.type(config, DataEngineConfig, "config")
        super().__init__(
            clock=clock,
            component_id=ComponentId("DataEngine"),
            msgbus=msgbus,
            config=config,
        )

        self._cache = cache

        self._clients: dict[ClientId, DataClient] = {}
        self._routing_map: dict[Venue, DataClient] = {}
        self._default_client: DataClient | None = None
        self._external_clients: set[ClientId] = set()
        self._catalogs: dict[str, ParquetDataCatalog] = {}
        self._order_book_intervals: dict[tuple[InstrumentId, int], list[Callable[[OrderBook], None]]] = {}
        self._bar_aggregators: dict[BarType, BarAggregator] = {}
        self._synthetic_quote_feeds: dict[InstrumentId, list[SyntheticInstrument]] = {}
        self._synthetic_trade_feeds: dict[InstrumentId, list[SyntheticInstrument]] = {}
        self._subscribed_synthetic_quotes: list[InstrumentId] = []
        self._subscribed_synthetic_trades: list[InstrumentId] = []
        self._buffered_deltas_map: dict[InstrumentId, list[OrderBookDelta]] = {}
        self._snapshot_info: dict[str, SnapshotInfo] = {}

        self._request_group_parent_request: dict[UUID4, RequestData] = {}
        self._request_group_n_components: dict[UUID4, int] = {}
        self._request_group_parent_request_id: dict[UUID4, UUID4] = {}
        self._request_group_responses: dict[UUID4, list] = {}
        self._long_request_generator: dict[UUID4, object] = {}
        self._requests: dict[UUID4, RequestData] = {}
        self._parent_long_request_id: dict[UUID4, UUID4] = {}
        self._parent_join_request_id: dict[UUID4, UUID4] = {}

        self._topic_cache = TopicCache()

        # Configuration
        self.debug = config.debug
        self._time_bars_interval_type = config.time_bars_interval_type
        self._time_bars_timestamp_on_close = config.time_bars_timestamp_on_close
        self._time_bars_skip_first_non_full_bar = config.time_bars_skip_first_non_full_bar
        self._time_bars_build_with_no_updates = config.time_bars_build_with_no_updates
        self._time_bars_origin_offset = config.time_bars_origin_offset or {}
        self._time_bars_build_delay = config.time_bars_build_delay
        self._validate_data_sequence = config.validate_data_sequence
        self._buffer_deltas = config.buffer_deltas
        self._emit_quotes_from_book = config.emit_quotes_from_book
        self._emit_quotes_from_book_depths = config.emit_quotes_from_book_depths

        if config.external_clients:
            self._external_clients = set(config.external_clients)

        # Counters
        self.command_count = 0
        self.data_count = 0
        self.request_count = 0
        self.response_count = 0

        # Register endpoints
        self._msgbus.register(endpoint="DataEngine.execute", handler=self.execute)
        self._msgbus.register(endpoint="DataEngine.process", handler=self.process)
        self._msgbus.register(endpoint="DataEngine.request", handler=self.request)
        self._msgbus.register(endpoint="DataEngine.response", handler=self.response)
        self._msgbus.register(endpoint="DataEngine.process_historical", handler=self.process_historical)

    @property
    def registered_clients(self) -> list[ClientId]:
        """
        Return the execution clients registered with the engine.

        Returns
        -------
        list[ClientId]

        """
        return sorted(list(self._clients.keys()))

    @property
    def default_client(self) -> ClientId | None:
        """
        Return the default data client registered with the engine.

        Returns
        -------
        ClientId or ``None``

        """
        return self._default_client.id if self._default_client is not None else None

    @property
    def routing_map(self) -> dict[Venue, DataClient]:
        """
        Return the default data client registered with the engine.

        Returns
        -------
        ClientId or ``None``

        """
        return self._routing_map

    def connect(self) -> None:
        """
        Connect the engine by calling connect on all registered clients.
        """
        self._log.info("Connecting all clients...")
        # Implement actual client connections for a live/sandbox context

    def disconnect(self) -> None:
        """
        Disconnect the engine by calling disconnect on all registered clients.
        """
        self._log.info("Disconnecting all clients...")
        # Implement actual client connections for a live/sandbox context

    cpdef bint check_connected(self):
        """
        Check all of the engines clients are connected.

        Returns
        -------
        bool
            True if all clients connected, else False.

        """
        cdef DataClient client
        for client in self._clients.values():
            if not client.is_connected:
                return False

        return True

    cpdef bint check_disconnected(self):
        """
        Check all of the engines clients are disconnected.

        Returns
        -------
        bool
            True if all clients disconnected, else False.

        """
        cdef DataClient client
        for client in self._clients.values():
            if client.is_connected:
                return False

        return True

    cpdef set[ClientId] get_external_client_ids(self):
        """
        Returns the configured external client order IDs.

        Returns
        -------
        set[ClientId]

        """
        return self._external_clients.copy()

    cpdef bint _is_backtest_client(self, DataClient client):
        """
        Check if we're in a backtest context by looking for the default backtest client.

        Returns
        -------
        bool
            True if in backtest context, else False.

        """
        # Avoid importing `BacktestMarketDataClient` from the `backtest` subpackage at
        # module import time – doing so creates a circular import between
        # `nautilus_trader.data` and `nautilus_trader.backtest`.
        from nautilus_trader.backtest.data_client import BacktestMarketDataClient

        return isinstance(client, BacktestMarketDataClient)

# --REGISTRATION ----------------------------------------------------------------------------------

    def register_catalog(self, catalog: ParquetDataCatalog, name: str = "catalog_0") -> None:
        """
        Register the given data catalog with the engine.

        Parameters
        ----------
        catalog : ParquetDataCatalog
            The data catalog to register.
        name : str, default 'catalog_0'
            The name of the catalog to register.

        """
        Condition.not_none(catalog, "catalog")

        self._catalogs[name] = catalog

    cpdef void register_client(self, DataClient client):
        """
        Register the given data client with the data engine.

        Parameters
        ----------
        client : DataClient
            The client to register.

        Raises
        ------
        ValueError
            If `client` is already registered.

        """
        Condition.not_none(client, "client")
        Condition.not_in(client.id, self._clients, "client", "_clients")

        self._clients[client.id] = client
        routing_log = ""

        if client.venue is None:
            if self._default_client is None:
                self._default_client = client
                routing_log = " for default routing"
        else:
            self._routing_map[client.venue] = client

        self._log.info(f"Registered {client}{routing_log}")

    cpdef void register_default_client(self, DataClient client):
        """
        Register the given client as the default routing client (when a specific
        venue routing cannot be found).

        Any existing default routing client will be overwritten.

        Parameters
        ----------
        client : DataClient
            The client to register.

        """
        Condition.not_none(client, "client")

        self._default_client = client
        self._log.info(f"Registered {client} for default routing")

    cpdef void register_venue_routing(self, DataClient client, Venue venue):
        """
        Register the given client to route messages to the given venue.

        Any existing client in the routing map for the given venue will be
        overwritten.

        Parameters
        ----------
        venue : Venue
            The venue to route messages to.
        client : DataClient
            The client for the venue routing.

        """
        Condition.not_none(client, "client")
        Condition.not_none(venue, "venue")

        if client.id not in self._clients:
            self._clients[client.id] = client

        self._routing_map[venue] = client
        self._log.info(f"Registered DataClient-{client} for routing to {venue}")

    cpdef void deregister_client(self, DataClient client):
        """
        Deregister the given data client from the data engine.

        Parameters
        ----------
        client : DataClient
            The data client to deregister.

        """
        Condition.not_none(client, "client")
        Condition.is_in(client.id, self._clients, "client.id", "self._clients")

        del self._clients[client.id]
        self._log.info(f"Deregistered {client}")

    cpdef bint is_live_mode(self):
        cdef ClientId backtest_client_id = ClientId("backtest_default_client")

        return backtest_client_id not in self._clients

# -- SUBSCRIPTIONS --------------------------------------------------------------------------------

    cpdef list subscribed_custom_data(self):
        """
        Return the custom data types subscribed to.

        Returns
        -------
        list[DataType]

        """
        cdef:
            list subscriptions = []
            DataClient client
        for client in self._clients.values():
            subscriptions += client.subscribed_custom_data()

        return subscriptions

    cpdef list subscribed_instruments(self):
        """
        Return the instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_instruments()

        return subscriptions

    cpdef list subscribed_order_book_deltas(self):
        """
        Return the order book delta instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_order_book_deltas()

        return subscriptions

    cpdef list subscribed_order_book_snapshots(self):
        """
        Return the order book snapshot instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_order_book_snapshots()

        return subscriptions

    cpdef list subscribed_quote_ticks(self):
        """
        Return the quote tick instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_quote_ticks()

        return subscriptions

    cpdef list subscribed_trade_ticks(self):
        """
        Return the trade tick instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_trade_ticks()

        return subscriptions

    cpdef list subscribed_mark_prices(self):
        """
        Return the mark price update instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_mark_prices()

        return subscriptions

    cpdef list subscribed_index_prices(self):
        """
        Return the index price update instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_index_prices()

        return subscriptions

    cpdef list subscribed_funding_rates(self):
        """
        Return the funding rate update instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_funding_rates()

        return subscriptions

    cpdef list subscribed_bars(self):
        """
        Return the bar types subscribed to.

        Returns
        -------
        list[BarType]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_bars()

        return subscriptions + list(self._bar_aggregators.keys())

    cpdef list subscribed_instrument_status(self):
        """
        Return the status update instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_instrument_status()

        return subscriptions

    cpdef list subscribed_instrument_close(self):
        """
        Return the close price instruments subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        cdef:
            list subscriptions = []
            MarketDataClient client
        for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
            subscriptions += client.subscribed_instrument_close()

        return subscriptions

    cpdef list subscribed_synthetic_quotes(self):
        """
        Return the synthetic instrument quotes subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return self._subscribed_synthetic_quotes.copy()

    cpdef list subscribed_synthetic_trades(self):
        """
        Return the synthetic instrument trades subscribed to.

        Returns
        -------
        list[InstrumentId]

        """
        return self._subscribed_synthetic_trades.copy()

# -- ABSTRACT METHODS -----------------------------------------------------------------------------

    cpdef void _on_start(self):
        pass  # Optionally override in subclass

    cpdef void _on_stop(self):
        pass  # Optionally override in subclass

# -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------

    cpdef void _start(self):
        for client in self._clients.values():
            client.start()

        self._on_start()

    cpdef void _stop(self):
        for client in self._clients.values():
            if client.is_running:
                client.stop()

        for aggregator in self._bar_aggregators.values():
            if isinstance(aggregator, TimeBarAggregator):
                aggregator.stop_timer()

        self._on_stop()

    cpdef void _reset(self):
        cdef DataClient client
        for client in self._clients.values():
            client.reset()

        self._order_book_intervals.clear()
        self._bar_aggregators.clear()
        self._synthetic_quote_feeds.clear()
        self._synthetic_trade_feeds.clear()
        self._subscribed_synthetic_quotes.clear()
        self._subscribed_synthetic_trades.clear()
        self._buffered_deltas_map.clear()
        self._snapshot_info.clear()

        self._request_group_parent_request.clear()
        self._request_group_n_components.clear()
        self._request_group_parent_request_id.clear()
        self._request_group_responses.clear()
        self._long_request_generator.clear()
        self._requests.clear()
        self._parent_long_request_id.clear()
        self._parent_join_request_id.clear()

        self._topic_cache.clear_cache()

        self._clock.cancel_timers()
        self.command_count = 0
        self.data_count = 0
        self.request_count = 0
        self.response_count = 0

    cpdef void _dispose(self):
        cdef DataClient client
        for client in self._clients.values():
            client.dispose()

        self._clock.cancel_timers()

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void stop_clients(self):
        """
        Stop the registered clients.
        """
        for client in self._clients.values():
            if client.is_running:
                client.stop()

    cpdef void execute(self, DataCommand command):
        """
        Execute the given data command.

        Parameters
        ----------
        command : DataCommand
            The command to execute.

        """
        Condition.not_none(command, "command")

        self._execute_command(command)

    cpdef void process(self, Data data, bint historical = False):
        """
        Process the given data.

        Parameters
        ----------
        data : Data
            The data to process.

        """
        Condition.not_none(data, "data")

        self._handle_data(data, historical)

    cpdef void process_historical(self, Data data):
        """
        Process historical data.

        Parameters
        ----------
        data : Data
            The historical data to process.
        """
        self._handle_data(data, historical=True)

    cpdef void request(self, RequestData request):
        """
        Handle the given request.

        Parameters
        ----------
        request : RequestData
            The request to handle.

        """
        Condition.not_none(request, "request")

        self._handle_request(request)

    cpdef void response(self, DataResponse response):
        """
        Handle the given response.

        Parameters
        ----------
        response : DataResponse
            The response to handle.

        """
        Condition.not_none(response, "response")

        self._handle_response(response)

# -- COMMAND HANDLERS -----------------------------------------------------------------------------

    cpdef void _execute_command(self, DataCommand command):
        if self.debug:
            self._log.debug(f"{RECV}{CMD} {command}", LogColor.MAGENTA)

        self.command_count += 1

        if command.client_id in self._external_clients:
            self._msgbus.add_streaming_type(command.data_type.type)
            self._log.debug(
                f"Skipping data command for external client {command.client_id}: {command}",
                LogColor.MAGENTA,
            )
            return

        # In a backtest context, we never want to subscribe to live data
        cdef:
            ClientId backtest_client_id = ClientId("backtest_default_client")
            DataClient client
        if backtest_client_id in self._clients:
            client = self._clients[backtest_client_id]
        else:
            client = self._clients.get(command.client_id)

        cdef Venue venue = command.venue
        if venue is not None and venue.is_synthetic():
            # No further check as no client needed
            pass
        elif client is None:
            client = self._routing_map.get(command.venue, self._default_client)
            if client is None:
                self._log.error(
                    f"Cannot execute command: "
                    f"no data client configured for {command.venue} or `client_id` {command.client_id}, "
                    f"{command}"
                )
                return  # No client to handle command

        if isinstance(command, SubscribeData):
            self._handle_subscribe(client, command)
        elif isinstance(command, UnsubscribeData):
            self._handle_unsubscribe(client, command)
        else:
            self._log.error(f"Cannot handle command: unrecognized {command}")

    cpdef void _handle_subscribe(self, DataClient client, SubscribeData command):
        if isinstance(command, SubscribeInstruments):
            self._handle_subscribe_instruments(client, command)
        elif isinstance(command, SubscribeInstrument):
            self._handle_subscribe_instrument(client, command)
        elif isinstance(command, SubscribeOrderBook):
            self._handle_subscribe_order_book(client, command)
        elif isinstance(command, SubscribeQuoteTicks):
            self._handle_subscribe_quote_ticks(client, command)
        elif isinstance(command, SubscribeTradeTicks):
            self._handle_subscribe_trade_ticks(client, command)
        elif isinstance(command, SubscribeMarkPrices):
            self._handle_subscribe_mark_prices(client, command)
        elif isinstance(command, SubscribeIndexPrices):
            self._handle_subscribe_index_prices(client, command)
        elif isinstance(command, SubscribeFundingRates):
            self._handle_subscribe_funding_rates(client, command)
        elif isinstance(command, SubscribeBars):
            self._handle_subscribe_bars(client, command)
        elif isinstance(command, SubscribeInstrumentStatus):
            self._handle_subscribe_instrument_status(client, command)
        elif isinstance(command, SubscribeInstrumentClose):
            self._handle_subscribe_instrument_close(client, command)
        else:
            self._handle_subscribe_data(client, command)

    cpdef void _handle_unsubscribe(self, DataClient client, UnsubscribeData command):
        if isinstance(command, UnsubscribeInstruments):
            self._handle_unsubscribe_instruments(client, command)
        elif isinstance(command, UnsubscribeInstrument):
            self._handle_unsubscribe_instrument(client, command)
        elif isinstance(command, UnsubscribeOrderBook):
            self._handle_unsubscribe_order_book(client, command)
        elif isinstance(command, UnsubscribeQuoteTicks):
            self._handle_unsubscribe_quote_ticks(client, command)
        elif isinstance(command, UnsubscribeTradeTicks):
            self._handle_unsubscribe_trade_ticks(client, command)
        elif isinstance(command, UnsubscribeMarkPrices):
            self._handle_unsubscribe_mark_prices(client, command)
        elif isinstance(command, UnsubscribeIndexPrices):
            self._handle_unsubscribe_index_prices(client, command)
        elif isinstance(command, UnsubscribeFundingRates):
            self._handle_unsubscribe_funding_rates(client, command)
        elif isinstance(command, UnsubscribeBars):
            self._handle_unsubscribe_bars(client, command)
        elif isinstance(command, UnsubscribeInstrumentStatus):
            self._handle_unsubscribe_instrument_status(client, command)
        elif isinstance(command, UnsubscribeInstrumentClose):
            self._handle_unsubscribe_instrument_status(client, command)
        else:
            self._handle_unsubscribe_data(client, command)

    cpdef void _handle_subscribe_instruments(self, MarketDataClient client, SubscribeInstruments command):
        Condition.not_none(client, "client")

        client.subscribe_instruments(command)

    cpdef void _handle_subscribe_instrument(self, MarketDataClient client, SubscribeInstrument command):
        Condition.not_none(client, "client")

        if command.instrument_id.is_synthetic():
            self._log.error("Cannot subscribe for synthetic instrument `Instrument` data")
            return

        if command.instrument_id not in client.subscribed_instruments():
            client.subscribe_instrument(command)

    cpdef void _handle_subscribe_order_book(self, MarketDataClient client, SubscribeOrderBook command):
        Condition.not_none(client, "client")

        if command.instrument_id.is_synthetic():
            self._log.error(f"Cannot subscribe for synthetic instrument `{command.data_type.type}` data")
            return

        if command.data_type.type == OrderBookDelta:
            if command.instrument_id not in client.subscribed_order_book_deltas():
                client.subscribe_order_book_deltas(command)
        elif command.data_type.type == OrderBookDepth10:
            if command.instrument_id not in client.subscribed_order_book_snapshots():
                client.subscribe_order_book_depth(command)
        else:  # pragma: no cover (design-time error)
            raise TypeError(f"Invalid book data type, was {command.data_type}")

        cdef:
            str topic
            uint64_t interval_ns
            uint64_t timestamp_ns
            SnapshotInfo snap_info
            tuple[InstrumentId, int] key

        if command.interval_ms > 0:
            key = (command.instrument_id, command.interval_ms)

            if key not in self._order_book_intervals:
                self._order_book_intervals[key] = []

                timer_name = f"OrderBook|{command.instrument_id}|{command.interval_ms}"
                interval_ns = millis_to_nanos(command.interval_ms)
                timestamp_ns = self._clock.timestamp_ns()
                start_time_ns = timestamp_ns - (timestamp_ns % interval_ns)

                topic = self._topic_cache.get_snapshots_topic(command.instrument_id, command.interval_ms)

                # Cache snapshot event info
                snap_info = SnapshotInfo.__new__(SnapshotInfo)
                snap_info.instrument_id = command.instrument_id
                snap_info.venue = command.instrument_id.venue
                snap_info.is_composite = command.instrument_id.symbol.is_composite()
                snap_info.root = command.instrument_id.symbol.root()
                snap_info.topic = topic
                snap_info.interval_ms = command.interval_ms

                self._snapshot_info[timer_name] = snap_info

                if start_time_ns - NANOSECONDS_IN_MILLISECOND <= self._clock.timestamp_ns():
                    start_time_ns += NANOSECONDS_IN_SECOND  # Add one second

                self._clock.set_timer_ns(
                    name=timer_name,
                    interval_ns=interval_ns,
                    start_time_ns=start_time_ns,
                    stop_time_ns=0,  # No stop
                    callback=self._snapshot_order_book,
                )
                self._log.debug(f"Set timer {timer_name}")

        if command.managed:
            self._setup_order_book(client, command)

    cpdef void _setup_order_book(self, MarketDataClient client, SubscribeOrderBook command):
        cdef Instrument instrument = self._cache.instrument(command.instrument_id)
        if instrument is None:
            self._log.warning(
                f"No instrument found for {command.instrument_id} on order book data subscription"
            )

        cdef:
            list[Instrument] instruments
            str root

        # Create order book(s)
        if command.instrument_id.symbol.is_composite():
            root = command.instrument_id.symbol.root()
            instruments = self._cache.instruments(venue=command.instrument_id.venue, underlying=root)

            for instrument in instruments:
                self._create_new_book(instrument.id, command.book_type)
        else:
            self._create_new_book(command.instrument_id, command.book_type)

        cdef str topic = self._topic_cache.get_book_topic(command.data_type.type, command.instrument_id)
        if not self._msgbus.is_subscribed(
            topic=topic,
            handler=self._update_order_book,
        ):
            self._msgbus.subscribe(
                topic=topic,
                handler=self._update_order_book,
                priority=10,
            )

    cpdef void _create_new_book(self, InstrumentId instrument_id, BookType book_type):
        order_book = OrderBook(
            instrument_id=instrument_id,
            book_type=book_type,
        )
        self._cache.add_order_book(order_book)
        self._log.debug(f"Created {type(order_book).__name__} for {instrument_id}")

    cpdef void _handle_subscribe_quote_ticks(self, MarketDataClient client, SubscribeQuoteTicks command):
        Condition.not_none(command.instrument_id, "instrument_id")

        if command.instrument_id.is_synthetic():
            self._handle_subscribe_synthetic_quote_ticks(command.instrument_id)
            return

        Condition.not_none(client, "client")

        if "start_ns" not in command.params:
            last_timestamp: datetime | None = self._catalog_last_timestamp(QuoteTick, str(command.instrument_id))[0]
            command.params["start_ns"] = last_timestamp.value + 1 if last_timestamp else None

        if command.instrument_id not in client.subscribed_quote_ticks():
            client.subscribe_quote_ticks(command)

    cpdef void _handle_subscribe_synthetic_quote_ticks(self, InstrumentId instrument_id):
        cdef SyntheticInstrument synthetic = self._cache.synthetic(instrument_id)
        if synthetic is None:
            self._log.error(
                f"Cannot subscribe to `QuoteTick` data for synthetic instrument {instrument_id}, "
                " not found"
            )
            return

        if instrument_id in self._subscribed_synthetic_quotes:
            return  # Already setup

        cdef:
            InstrumentId component_instrument_id
            list synthetics_for_feed
        for component_instrument_id in synthetic.components:
            synthetics_for_feed = self._synthetic_quote_feeds.get(component_instrument_id)
            if synthetics_for_feed is None:
                synthetics_for_feed = []

            if synthetic in synthetics_for_feed:
                continue

            synthetics_for_feed.append(synthetic)
            self._synthetic_quote_feeds[component_instrument_id] = synthetics_for_feed

        self._subscribed_synthetic_quotes.append(instrument_id)

    cpdef void _handle_subscribe_trade_ticks(self, MarketDataClient client, SubscribeTradeTicks command):
        if command.instrument_id.is_synthetic():
            self._handle_subscribe_synthetic_trade_ticks(command.instrument_id)
            return

        Condition.not_none(client, "client")

        if "start_ns" not in command.params:
            last_timestamp: datetime | None = self._catalog_last_timestamp(TradeTick, str(command.instrument_id))[0]
            command.params["start_ns"] = last_timestamp.value + 1 if last_timestamp else None

        if command.instrument_id not in client.subscribed_trade_ticks():
            client.subscribe_trade_ticks(command)

    cpdef void _handle_subscribe_synthetic_trade_ticks(self, InstrumentId instrument_id):
        cdef SyntheticInstrument synthetic = self._cache.synthetic(instrument_id)
        if synthetic is None:
            self._log.error(
                f"Cannot subscribe to `TradeTick` data for synthetic instrument {instrument_id}, "
                " not found"
            )
            return

        if instrument_id in self._subscribed_synthetic_trades:
            return  # Already setup

        cdef:
            InstrumentId component_instrument_id
            list synthetics_for_feed
        for component_instrument_id in synthetic.components:
            synthetics_for_feed = self._synthetic_trade_feeds.get(component_instrument_id)
            if synthetics_for_feed is None:
                synthetics_for_feed = []

            if synthetic in synthetics_for_feed:
                continue

            synthetics_for_feed.append(synthetic)
            self._synthetic_trade_feeds[component_instrument_id] = synthetics_for_feed

        self._subscribed_synthetic_trades.append(instrument_id)

    cpdef void _handle_subscribe_mark_prices(self, MarketDataClient client, SubscribeMarkPrices command):
        Condition.not_none(client, "client")
        Condition.not_none(command.instrument_id, "instrument_id")

        if command.instrument_id not in client.subscribed_mark_prices():
            client.subscribe_mark_prices(command)

    cpdef void _handle_subscribe_index_prices(self, MarketDataClient client, SubscribeIndexPrices command):
        Condition.not_none(client, "client")
        Condition.not_none(command.instrument_id, "instrument_id")

        if command.instrument_id not in client.subscribed_index_prices():
            client.subscribe_index_prices(command)

    cpdef void _handle_subscribe_funding_rates(self, MarketDataClient client, SubscribeFundingRates command):
        Condition.not_none(client, "client")
        Condition.not_none(command.instrument_id, "instrument_id")

        if command.instrument_id not in client.subscribed_funding_rates():
            client.subscribe_funding_rates(command)

    cpdef void _handle_subscribe_bars(self, MarketDataClient client, SubscribeBars command):
        Condition.not_none(client, "client")

        if command.bar_type.is_internally_aggregated():
            # Internal aggregation
            bar_type_standard = command.bar_type.standard()

            if bar_type_standard not in self._bar_aggregators:
                # Aggregator doesn't exist, create and start it
                self._start_bar_aggregator(client, command)
            elif not self._bar_aggregators[bar_type_standard].is_running:
                # Aggregator exists but not running, start it
                self._start_bar_aggregator(client, command)
            else:
                # Aggregator exists and is running
                self._log.warning(f"Aggregator for {bar_type_standard} is currently in use, subscription can't be started.")
        else:
            # External aggregation
            if command.bar_type.instrument_id.is_synthetic():
                self._log.error(
                    "Cannot subscribe for externally aggregated synthetic instrument bar data",
                )
                return

            if "start_ns" not in command.params:
                last_timestamp: datetime | None = self._catalog_last_timestamp(Bar, str(command.bar_type))[0]
                command.params["start_ns"] = last_timestamp.value + 1 if last_timestamp else None

            if command.bar_type not in client.subscribed_bars():
                client.subscribe_bars(command)

    cpdef void _handle_subscribe_data(self, DataClient client, SubscribeData command):
        Condition.not_none(client, "client")

        try:
            if command.data_type not in client.subscribed_custom_data():
                if "start_ns" not in command.params:
                    last_timestamp: datetime | None = self._catalog_last_timestamp(command.data_type.type, str(command.instrument_id))[0]
                    command.params["start_ns"] = last_timestamp.value + 1 if last_timestamp else None

                client.subscribe(command)
        except NotImplementedError:
            self._log.error(
                f"Cannot subscribe: {client.id.value} "
                f"has not implemented {command.data_type} subscriptions",
            )
            return

    cpdef void _handle_subscribe_instrument_status(self, MarketDataClient client, SubscribeInstrumentStatus command):
        Condition.not_none(client, "client")

        if command.instrument_id.is_synthetic():
            self._log.error(
                "Cannot subscribe for synthetic instrument `InstrumentStatus` data",
            )
            return

        if command.instrument_id not in client.subscribed_instrument_status():
            client.subscribe_instrument_status(command)

    cpdef void _handle_subscribe_instrument_close(self, MarketDataClient client, SubscribeInstrumentClose command):
        Condition.not_none(client, "client")

        if command.instrument_id.is_synthetic():
            self._log.error("Cannot subscribe for synthetic instrument `InstrumentClose` data")
            return

        if command.instrument_id not in client.subscribed_instrument_close():
            client.subscribe_instrument_close(command)

    cpdef void _handle_unsubscribe_instruments(self, MarketDataClient client, UnsubscribeInstruments command):
        Condition.not_none(client, "client")

        if not self._msgbus.has_subscribers(f"data.instrument.{client.id.value}.*"):
            if client.subscribed_instruments():
                client.unsubscribe_instruments(command)

    cpdef void _handle_unsubscribe_instrument(self, MarketDataClient client, UnsubscribeInstrument command):
        Condition.not_none(client, "client")

        if command.instrument_id.is_synthetic():
            self._log.error("Cannot unsubscribe from synthetic instrument `Instrument` data")
            return

        if not self._msgbus.has_subscribers(
            f"data.instrument"
            f".{command.instrument_id.venue}"
            f".{command.instrument_id.symbol}",
        ):
            if command.instrument_id in client.subscribed_instruments():
                client.unsubscribe_instrument(command)

    cpdef void _handle_unsubscribe_order_book(self, MarketDataClient client, UnsubscribeOrderBook command):
        Condition.not_none(client, "client")

        if command.instrument_id.is_synthetic():
            self._log.error(f"Cannot unsubscribe from synthetic instrument `{command.data_type.type}` data")
            return

        # If the internal order book is the last subscriber on this topic, remove it
        cdef str topic = self._topic_cache.get_book_topic(command.data_type.type, command.instrument_id)
        cdef int num_subscribers = len(self._msgbus.subscriptions(pattern=topic))
        cdef bint is_internal_book_subscriber = self._msgbus.is_subscribed(
            topic=topic,
            handler=self._update_order_book,
        )

        if num_subscribers == 1 and is_internal_book_subscriber:
            self._msgbus.unsubscribe(
                topic=topic,
                handler=self._update_order_book,
            )

        # If no more subscribers to the client-backed topic, unsubscribe the client
        if not self._msgbus.has_subscribers(topic):
            if command.data_type.type == OrderBookDelta:
                if command.instrument_id in client.subscribed_order_book_deltas():
                    client.unsubscribe_order_book_deltas(command)
            elif command.data_type.type == OrderBookDepth10:
                if command.instrument_id in client.subscribed_order_book_snapshots():
                    client.unsubscribe_order_book_depth(command)
            else:
                if command.instrument_id in client.subscribed_order_book_snapshots():
                    client.unsubscribe_order_book_snapshots(command)

        # Cancel any snapshot timers for this instrument that no longer have subscribers
        cdef:
            tuple[InstrumentId, int] key
            list[tuple[InstrumentId, int]] keys_to_remove = []
            str timer_name
            str snapshots_topic
        for key in list(self._order_book_intervals.keys()):
            if key[0] != command.instrument_id:
                continue

            snapshots_topic = self._topic_cache.get_snapshots_topic(key[0], key[1])

            if not self._msgbus.has_subscribers(snapshots_topic):
                timer_name = f"OrderBook|{key[0]}|{key[1]}"
                self._clock.cancel_timer(timer_name)
                keys_to_remove.append(key)

                if timer_name in self._snapshot_info:
                    del self._snapshot_info[timer_name]

        for key in keys_to_remove:
            del self._order_book_intervals[key]

    cpdef void _handle_unsubscribe_quote_ticks(self, MarketDataClient client, UnsubscribeQuoteTicks command):
        Condition.not_none(command.instrument_id, "instrument_id")
        Condition.not_none(client, "client")

        if not self._msgbus.has_subscribers(
            self._topic_cache.get_quotes_topic(command.instrument_id),
        ):
            if command.instrument_id in client.subscribed_quote_ticks():
                client.unsubscribe_quote_ticks(command)

    cpdef void _handle_unsubscribe_trade_ticks(self, MarketDataClient client, UnsubscribeTradeTicks command):
        Condition.not_none(client, "client")

        if not self._msgbus.has_subscribers(
            self._topic_cache.get_trades_topic(command.instrument_id),
        ):
            if command.instrument_id in client.subscribed_trade_ticks():
                client.unsubscribe_trade_ticks(command)

    cpdef void _handle_unsubscribe_mark_prices(self, MarketDataClient client, UnsubscribeMarkPrices command):
        Condition.not_none(client, "client")

        if not self._msgbus.has_subscribers(
            self._topic_cache.get_mark_prices_topic(command.instrument_id),
        ):
            if command.instrument_id in client.subscribed_mark_prices():
                client.unsubscribe_mark_prices(command)

    cpdef void _handle_unsubscribe_index_prices(self, MarketDataClient client, UnsubscribeIndexPrices command):
        Condition.not_none(client, "client")

        if not self._msgbus.has_subscribers(
            self._topic_cache.get_index_prices_topic(command.instrument_id),
        ):
            if command.instrument_id in client.subscribed_index_prices():
                client.unsubscribe_index_prices(command)

    cpdef void _handle_unsubscribe_funding_rates(self, MarketDataClient client, UnsubscribeFundingRates command):
        Condition.not_none(client, "client")

        if not self._msgbus.has_subscribers(
            self._topic_cache.get_funding_rates_topic(command.instrument_id),
        ):
            if command.instrument_id in client.subscribed_funding_rates():
                client.unsubscribe_funding_rates(command)

    cpdef void _handle_unsubscribe_bars(self, MarketDataClient client, UnsubscribeBars command):
        Condition.not_none(client, "client")

        if self._msgbus.has_subscribers(self._topic_cache.get_bars_topic(command.bar_type.standard())):
            return

        if command.bar_type.is_internally_aggregated():
            # Internal aggregation
            if command.bar_type.standard() in self._bar_aggregators:
                self._stop_bar_aggregator(client, command)
        else:
            # External aggregation
            if command.bar_type in client.subscribed_bars():
                client.unsubscribe_bars(command)

    cpdef void _handle_unsubscribe_data(self, DataClient client, UnsubscribeData command):
        Condition.not_none(client, "client")

        try:
            if not self._msgbus.has_subscribers(f"data.{command.data_type}"):
                if command.data_type in client.subscribed_custom_data():
                    client.unsubscribe(command)
        except NotImplementedError:
            self._log.error(
                f"Cannot unsubscribe: {client.id.value} "
                f"has not implemented data type {command.data_type} subscriptions",
            )
            return

    cpdef void _handle_unsubscribe_instrument_status(self, MarketDataClient client, UnsubscribeInstrumentStatus command):
        Condition.not_none(client, "client")

        if command.instrument_id.is_synthetic():
            self._log.error(
                "Cannot unsubscribe for synthetic instrument `InstrumentStatus` data",
            )
            return

        if command.instrument_id in client.subscribed_instrument_status():
            client.unsubscribe_instrument_status(command)

    cpdef void _handle_unsubscribe_instrument_close(self, MarketDataClient client, UnsubscribeInstrumentClose command):
        Condition.not_none(client, "client")

        if command.instrument_id.is_synthetic():
            self._log.error("Cannot unsubscribe for synthetic instrument `InstrumentClose` data")
            return

        # Only unsubscribe if currently subscribed
        if command.instrument_id in client.subscribed_instrument_close():
            client.unsubscribe_instrument_close(command)

# -- REQUEST HANDLERS -----------------------------------------------------------------------------

    cpdef void _handle_request(self, RequestData request):
        if self.debug:
            self._log.debug(f"{RECV}{REQ} {request}", LogColor.MAGENTA)

        self.request_count += 1

        if request.params.get("join_request", False):
            self._requests[request.id] = request
            return

        # Get data client
        cdef DataClient client = self._clients.get(request.client_id)
        if client is None:
            client = self._routing_map.get(
                request.venue,
                self._default_client,
            )

        if client is not None:
            Condition.is_true(isinstance(client, DataClient), "client was not a DataClient")

        request.start = time_object_to_dt(request.start)
        request.end = time_object_to_dt(request.end)

        if ("time_range_generator" in request.params
                and not (isinstance(request, RequestJoin) and request.correlation_id is None)):
            self._handle_long_request(client, request)
            return

        if isinstance(request, RequestJoin):
            self._handle_request_join(request)

        if request.params.get("bar_types"):
            self._init_historical_aggregators(request)

        if isinstance(request, RequestInstruments):
            self._handle_request_instruments(client, request)
        elif isinstance(request, RequestInstrument):
            self._handle_request_instrument(client, request)
        elif isinstance(request, RequestOrderBookSnapshot):
            self._handle_request_order_book_snapshot(client, request)
        elif isinstance(request, RequestOrderBookDepth):
            self._handle_request_order_book_depth(client, request)
        elif isinstance(request, RequestQuoteTicks):
            self._handle_request_quote_ticks(client, request)
        elif isinstance(request, RequestTradeTicks):
            self._handle_request_trade_ticks(client, request)
        elif isinstance(request, RequestBars):
            self._handle_request_bars(client, request)
        else:
            self._handle_request_data(client, request)

    cpdef void _handle_request_instruments(self, DataClient client, RequestInstruments request):
        update_catalog = request.params.get("update_catalog", False)
        force_instrument_update = request.params.get("force_instrument_update", False)

        if self._catalogs and not update_catalog and not force_instrument_update:
            self._query_catalog(request)
            return

        if client is None:
            self._log_request_warning(request)
            return  # No client to handle request

        client.request_instruments(request)

    cpdef void _handle_request_instrument(self, DataClient client, RequestInstrument request):
        last_timestamp = self._catalog_last_timestamp(Instrument, str(request.instrument_id))[0]
        force_instrument_update = request.params.get("force_instrument_update", False)

        if last_timestamp and not force_instrument_update:
            self._query_catalog(request)
            return

        if client is None:
            self._log_request_warning(request)
            return  # No client to handle request

        client.request_instrument(request)

    cpdef void _handle_request_order_book_snapshot(self, DataClient client, RequestOrderBookSnapshot request):
        if client is None:
            self._log_request_warning(request)
            return  # No client to handle request

        client.request_order_book_snapshot(request)

    cpdef void _handle_request_order_book_depth(self, DataClient client, RequestOrderBookDepth request):
        self._handle_date_range_request(client, request)

    cpdef void _handle_request_quote_ticks(self, DataClient client, RequestQuoteTicks request):
        self._handle_date_range_request(client, request)

    cpdef void _handle_request_trade_ticks(self, DataClient client, RequestTradeTicks request):
        self._handle_date_range_request(client, request)

    cpdef void _handle_request_bars(self, DataClient client, RequestBars request):
        self._handle_date_range_request(client, request)

    cpdef void _handle_request_data(self, DataClient client, RequestData request):
        self._handle_date_range_request(client, request)

    cpdef void _handle_date_range_request(self, DataClient client, RequestData request):
        cdef DataClient used_client = client
        if self._is_backtest_client(used_client):
            used_client = None

        # Capping dates to the now datetime
        start, end = self._bound_dates(request)
        cdef datetime now = self._clock.utc_now()

        if start > end:
            self._log.error(f"Cannot handle request: incompatible request dates for {request}")
            return

        cdef list query_interval = [(start.value, end.value)]
        cdef list missing_intervals = query_interval
        cdef bint has_catalog_data = False

        if isinstance(request, RequestBars):
            identifier = request.bar_type
        else:
            identifier = request.instrument_id

        # We assume each symbol is only in one catalog
        for catalog in self._catalogs.values():
            missing_intervals = catalog.get_missing_intervals_for_request(
                start.value,
                end.value,
                request.data_type.type,
                identifier,
            )
            has_catalog_data = missing_intervals != query_interval

            if has_catalog_data:
                break

        skip_catalog_data = request.params.get("skip_catalog_data", False)
        n_requests = (len(missing_intervals) if used_client else 0) + (1 if has_catalog_data and not skip_catalog_data else 0)
        request.params["identifier"] = identifier # Allows to update catalog file names when no data is returned

        # From here the parent request is split into subrequests
        if n_requests == 0:
            self._new_request_group(request, 1)
            self._request_group_parent_request_id[request.id] = request.id
            response = DataResponse(
                client_id=request.client_id,
                venue=request.venue,
                data_type=request.data_type,
                data=[],
                correlation_id=request.id,
                response_id=UUID4(),
                start=request.start,
                end=request.end,
                ts_init=self._clock.timestamp_ns(),
                params=request.params,
            )
            self._handle_response(response)
            return

        self._new_request_group(request, n_requests)

        # Catalog query
        if has_catalog_data and not skip_catalog_data:
            new_request = request.with_dates(start, end, now.value)
            self._request_group_parent_request_id[new_request.id] = new_request.correlation_id
            self._query_catalog(new_request)

        # Client requests
        if len(missing_intervals) > 0 and used_client:
            for request_start, request_end in missing_intervals:
                new_request = request.with_dates(time_object_to_dt(request_start), time_object_to_dt(request_end), now.value)
                self._request_group_parent_request_id[new_request.id] = new_request.correlation_id
                self._date_range_client_request(used_client, new_request)

    cpdef void _date_range_client_request(self, DataClient client, RequestData request):
        if isinstance(request, RequestBars):
            client.request_bars(request)
        elif isinstance(request, RequestQuoteTicks):
            client.request_quote_ticks(request)
        elif isinstance(request, RequestTradeTicks):
            client.request_trade_ticks(request)
        elif isinstance(request, RequestOrderBookDepth):
            client.request_order_book_depth(request)
        else:
            try:
                client.request(request)
            except:
                self._log.error(f"Cannot handle request: unrecognized data type {request.data_type}, {request}")

    def _log_request_warning(self, RequestData request):
        self._log.warning(f"Cannot handle request: no client registered for '{request.client_id}', {request}")

    cpdef void _query_catalog(self, RequestData request):
        cdef datetime start = request.start
        cdef datetime end = request.end
        cdef bint query_past_data = request.params.get("subscription_name") is None

        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef uint64_t ts_start = dt_to_unix_nanos(start) if start is not None else 0
        cdef uint64_t ts_end = dt_to_unix_nanos(end) if end is not None else ts_now

        # Validate request time range
        Condition.is_true(ts_start <= ts_end, f"{ts_start=} was greater than {ts_end=}")

        if end is not None and ts_end > ts_now and query_past_data:
            self._log.warning(
                "Cannot request data beyond current time. "
                f"Truncating `end` to current UNIX nanoseconds {unix_nanos_to_dt(ts_now)}",
            )
            ts_end = ts_now

        data = []

        # We assume each symbol is only in one catalog
        for catalog in self._catalogs.values():
            if isinstance(request, RequestInstruments):
                # We only use ts_end if end is passed as request argument
                data += catalog.instruments(
                    start=ts_start,
                    end=(ts_end if end is not None else None),
                )
            elif isinstance(request, RequestInstrument):
                # We only use ts_end if end is passed as request argument
                data = catalog.instruments(
                    instrument_ids=[str(request.instrument_id)],
                    start=ts_start,
                    end=(ts_end if end is not None else None),
                )
            elif isinstance(request, RequestQuoteTicks):
                data = catalog.quote_ticks(
                    instrument_ids=[str(request.instrument_id)],
                    start=ts_start,
                    end=ts_end,
                )
            elif isinstance(request, RequestTradeTicks):
                data = catalog.trade_ticks(
                    instrument_ids=[str(request.instrument_id)],
                    start=ts_start,
                    end=ts_end,
                )
            elif isinstance(request, RequestBars):
                bar_type = request.bar_type
                if bar_type is None:
                    self._log.error("No bar type provided for bars request")
                    return

                data = catalog.bars(
                    instrument_ids=[str(bar_type.instrument_id)],
                    bar_types=[str(bar_type)],
                    start=ts_start,
                    end=ts_end,
                )
            elif isinstance(request, RequestOrderBookDepth):
                data = catalog.order_book_depth10(
                    instrument_ids=[str(request.instrument_id)],
                    start=ts_start,
                    end=ts_end,
                )
            elif type(request) is RequestData:
                data = catalog.custom_data(
                    cls=request.data_type.type,
                    instrument_ids=[str(request.instrument_id)] if request.instrument_id else None,
                    metadata=request.data_type.metadata,
                    start=ts_start,
                    end=ts_end,
                )

            if data and not isinstance(request, RequestInstruments):
                break

        # Validate data is not from the future
        if data and data[-1].ts_init > ts_now and query_past_data:
            raise RuntimeError(
                "Invalid response: Historical data from the future: "
                f"data[-1].ts_init={data[-1].ts_init}, {ts_now=}",
            )

        if isinstance(request, RequestInstrument):
            if len(data) == 0:
                self._log.error(f"Cannot find instrument for {request.instrument_id}")
                return

        if isinstance(request, RequestInstruments) or isinstance(request, RequestInstrument):
            only_last = request.params.get("only_last", True)

            if only_last:
                # Retains only the latest instrument record per instrument_id, based on the most recent ts_init
                last_instrument = {}

                for instrument in data:
                    if instrument.id not in last_instrument:
                        last_instrument[instrument.id] = instrument
                    elif instrument.ts_init > last_instrument[instrument.id].ts_init:
                        last_instrument[instrument.id] = instrument

                data = list(last_instrument.values())

        params = request.params.copy()
        params["update_catalog"] = False

        response = DataResponse(
            client_id=request.client_id,
            venue=request.venue,
            data_type=request.data_type,
            data=data,
            correlation_id=request.id,
            response_id=UUID4(),
            start=request.start,
            end=request.end,
            ts_init=self._clock.timestamp_ns(),
            params=params,
        )
        self._handle_response(response)

    cpdef void _handle_long_request(self, DataClient client, RequestData request):
        start, end = self._bound_dates(request)
        request.start, request.end = start, end
        self._requests[request.id] = request

        time_range_generator = get_time_range_generator(
            request.params.get("time_range_generator", "")
        )(request)
        self._long_request_generator[request.id] = time_range_generator

        self._update_long_request_data(request.id, is_first_call=True)

    cpdef void _update_long_request_data(
        self,
        UUID4 parent_request_id,
        bint data_received = False,
        bint is_first_call = False
    ):
        time_range_generator = self._long_request_generator.get(parent_request_id)
        if time_range_generator is None:
            self._log.error(f"No time range generator found for request {parent_request_id}")
            return

        cdef RequestData parent_request = self._requests.get(parent_request_id)
        if parent_request is None:
            self._log.error(f"No parent request found for {parent_request_id}")
            return

        # Get next time range from generator
        cdef:
            uint64_t request_start_ns
            uint64_t request_end_ns
        try:
            if is_first_call:
                request_start_ns, request_end_ns = next(time_range_generator)
            else:
                request_start_ns, request_end_ns = time_range_generator.send(data_received)
        except StopIteration:
            # No more intervals, send final empty response
            self._finalize_long_request(parent_request_id)
            return

        if parent_request.end is not None and request_start_ns > parent_request.end.value:
            self._finalize_long_request(parent_request_id)
            return

        request_end_ns = min(request_end_ns, parent_request.end.value)

        # Create a sub-request for this interval
        cdef datetime now = self._clock.utc_now()
        cdef RequestData new_request = parent_request.with_dates(
            unix_nanos_to_dt(request_start_ns),
            unix_nanos_to_dt(request_end_ns),
            now.value,
            self._handle_long_request_response
        )

        # We remove time_range_generator from params to avoid an infinite recursion
        new_request.params.pop("time_range_generator", None)

        # Send the sub-request through the message bus to properly register the callback
        self._parent_long_request_id[new_request.id] = parent_request_id
        self._msgbus.request(endpoint="DataEngine.request", request=new_request)

    cpdef void _handle_long_request_response(self, DataResponse response):
        cdef:
            UUID4 sub_request_id = response.correlation_id
            UUID4 parent_request_id = self._parent_long_request_id.pop(sub_request_id, None)
        if parent_request_id is None:
            self._log.error(f"No parent request ID found for sub-request {sub_request_id}")
            return

        # Storing information about the data count received in the parent request's params
        cdef int data_count = response.params.get("data_count", 0)
        cdef RequestData parent_request = self._requests.get(parent_request_id)
        parent_request.params["data_count"] = parent_request.params.get("data_count", 0) + data_count

        # Process the next interval with feedback on if data was received
        cdef bint data_received = data_count > 0
        self._update_long_request_data(parent_request_id, data_received=data_received)

    cpdef void _finalize_long_request(self, UUID4 parent_request_id):
        cdef RequestData parent_request = self._requests.pop(parent_request_id, None)
        if parent_request is None:
            self._log.error(f"Cannot finalize long request: no parent request found for {parent_request_id}")
            return

        # Close the generator
        time_range_generator = self._long_request_generator.pop(parent_request_id, None)
        if time_range_generator is not None:
            try:
                time_range_generator.close()
            except (StopIteration, GeneratorExit):
                pass

        # Send response for the original request to trigger its callback
        response = DataResponse(
            client_id=parent_request.client_id,
            venue=parent_request.venue,
            data_type=parent_request.data_type,
            data=[],
            correlation_id=parent_request_id,
            response_id=UUID4(),
            start=parent_request.start,
            end=parent_request.end,
            ts_init=self._clock.timestamp_ns(),
            params=parent_request.params,
        )
        self._msgbus.response(response)

    cpdef void _handle_request_join(self, RequestJoin request):
        if not request.correlation_id:
            self._requests[request.id] = request
            start, end = self._bound_dates(request)
            new_request = request.with_dates(start, end, self._clock.timestamp_ns(), self._finalize_request_join)
            self._parent_join_request_id[new_request.id] = request.id
            self._msgbus.request(endpoint="DataEngine.request", request=new_request)
            return

        self._new_request_group(request, len(request.request_ids))

        for request_id in request.request_ids:
            joined_request = self._requests.get(request_id)
            new_request = joined_request.with_dates(request.start, request.end, self._clock.timestamp_ns())
            new_request.params["join_request"] = False
            self._request_group_parent_request_id[new_request.id] = request.id
            self._msgbus.request(endpoint="DataEngine.request", request=new_request)

    cpdef void _finalize_request_join(self, DataResponse response):
        parent_request_id = self._parent_join_request_id.pop(response.correlation_id, None)
        if not parent_request_id:
            self._log.error(f"parent_request_id for {response.correlation_id=} not found.")
            return

        parent_request = self._requests.pop(parent_request_id, None)
        if not parent_request:
            self._log.error(f"parent_request for {parent_request_id=} not found.")
            return

        # We send responses for the joined requests and the joining request to trigger callbacks
        for request_id in parent_request.request_ids:
            joined_request = self._requests.pop(request_id, None)
            if not joined_request:
                self._log.error(f"joined_request for {request_id=} not found.")
                continue

            response = DataResponse(
                client_id=joined_request.client_id,
                venue=joined_request.venue,
                data_type=joined_request.data_type,
                data=[],
                correlation_id=joined_request.id,
                response_id=UUID4(),
                start=None,
                end=None,
                ts_init=self._clock.timestamp_ns(),
                params=joined_request.params,
            )
            self._msgbus.response(response)

        response = DataResponse(
            client_id=parent_request.client_id,
            venue=parent_request.venue,
            data_type=parent_request.data_type,
            data=[],
            correlation_id=parent_request.id,
            response_id=UUID4(),
            start=parent_request.start,
            end=parent_request.end,
            ts_init=self._clock.timestamp_ns(),
            params=parent_request.params,
        )
        self._msgbus.response(response)

    cpdef tuple _bound_dates(self, RequestData request):
        # Capping dates to the now datetime
        cdef bint query_past_data = request.params.get("subscription_name") is None
        cdef datetime now = self._clock.utc_now()

        cdef datetime start = request.start if request.start is not None else time_object_to_dt(0)
        cdef datetime end = request.end if request.end is not None else now

        if query_past_data:
            start = min_date(start, now)
            end = min_date(end, now)

        return start, end

# -- DATA HANDLERS --------------------------------------------------------------------------------

    cpdef void _handle_data(self, Data data, bint historical = False):
        self.data_count += 1

        if isinstance(data, OrderBookDelta):
            self._handle_order_book_delta(data, historical)
        elif isinstance(data, OrderBookDeltas):
            self._handle_order_book_deltas(data, historical)
        elif isinstance(data, OrderBookDepth10):
            self._handle_order_book_depth(data, historical)
        elif isinstance(data, QuoteTick):
            self._handle_quote_tick(data, historical)
        elif isinstance(data, TradeTick):
            self._handle_trade_tick(data, historical)
        elif isinstance(data, MarkPriceUpdate):
            self._handle_mark_price(data, historical)
        elif isinstance(data, IndexPriceUpdate):
            self._handle_index_price(data, historical)
        elif isinstance(data, FundingRateUpdate):
            self._handle_funding_rate(data, historical)
        elif isinstance(data, Bar):
            self._handle_bar(data, historical)
        elif isinstance(data, Instrument):
            self._handle_instrument(data, historical)
        elif isinstance(data, InstrumentStatus):
            self._handle_instrument_status(data, historical)
        elif isinstance(data, InstrumentClose):
            self._handle_close_price(data, historical)
        elif isinstance(data, CustomData):
            self._handle_custom_data(data, historical)
        else:
            self._log.error(f"Cannot handle data: unrecognized type {type(data)} {data}")

    cpdef void _handle_instrument(
        self,
        Instrument instrument,
        bint historical = False,
        dict params = None,
    ):
        self._cache.add_instrument(instrument)

        if params is None:
            params = {}

        instrument_properties = params.get("instrument_properties")
        update_catalog = params.get("update_catalog", False)
        force_update_catalog = params.get("force_update_catalog", False)
        modified_instrument = self._modify_instrument_properties(instrument, instrument_properties)

        if update_catalog:
            self._update_catalog(
                [modified_instrument],
                Instrument,
                instrument.id,
                is_instrument=True,
                force_update_catalog=force_update_catalog,
            )

        self._msgbus.publish_c(
            topic=self._topic_cache.get_instrument_topic(modified_instrument.id, historical),
            msg=modified_instrument,
        )

    cpdef Instrument _modify_instrument_properties(self, Instrument instrument, dict instrument_properties):
        if instrument_properties is None:
            return instrument

        instrument_dict = type(instrument).to_dict(instrument)
        instrument_dict.update(instrument_properties)

        return type(instrument).from_dict(instrument_dict)

    cpdef void _handle_order_book_delta(
        self,
        OrderBookDelta delta,
        bint historical = False
    ):
        cdef:
            OrderBookDeltas deltas = None
            list[OrderBookDelta] buffer_deltas = None
            bint is_last_delta = False
            InstrumentId instrument_id = delta.instrument_id
        if self._buffer_deltas:
            buffer_deltas = self._buffered_deltas_map.get(instrument_id)
            if buffer_deltas is None:
                buffer_deltas = []
                self._buffered_deltas_map[instrument_id] = buffer_deltas

            buffer_deltas.append(delta)

            is_last_delta = delta.flags == RecordFlag.F_LAST
            if is_last_delta:
                deltas = OrderBookDeltas(
                    instrument_id=instrument_id,
                    deltas=buffer_deltas
                )
                self._msgbus.publish_c(
                    topic=self._topic_cache.get_deltas_topic(instrument_id, historical),
                    msg=deltas,
                )
                buffer_deltas.clear()
        else:
            deltas = OrderBookDeltas(
                instrument_id=instrument_id,
                deltas=[delta]
            )
            self._msgbus.publish_c(
                topic=self._topic_cache.get_deltas_topic(instrument_id, historical),
                msg=deltas,
            )

    cpdef void _handle_order_book_deltas(self, OrderBookDeltas deltas, bint historical = False):
        cdef:
            OrderBookDeltas deltas_to_publish = None
            list[OrderBookDelta] buffer_deltas = None
            bint is_last_delta = False
            InstrumentId instrument_id = deltas.instrument_id
        if self._buffer_deltas:
            buffer_deltas = self._buffered_deltas_map.get(instrument_id)
            if buffer_deltas is None:
                buffer_deltas = []
                self._buffered_deltas_map[instrument_id] = buffer_deltas

            for delta in deltas.deltas:
                buffer_deltas.append(delta)

                is_last_delta = delta.flags == RecordFlag.F_LAST
                if is_last_delta:
                    deltas_to_publish = OrderBookDeltas(
                        instrument_id=instrument_id,
                        deltas=buffer_deltas,
                    )
                    self._msgbus.publish_c(
                        topic=self._topic_cache.get_deltas_topic(instrument_id, historical),
                        msg=deltas_to_publish,
                    )
                    buffer_deltas.clear()
        else:
            self._msgbus.publish_c(
                topic=self._topic_cache.get_deltas_topic(instrument_id, historical),
                msg=deltas,
            )

    cpdef void _handle_order_book_depth(self, OrderBookDepth10 depth, bint historical = False):
        # Publish the depth data
        self._msgbus.publish_c(
            topic=self._topic_cache.get_depth_topic(depth.instrument_id, historical),
            msg=depth,
        )

        cdef:
            QuoteTick quote_tick
            QuoteTick last_quote
        if self._emit_quotes_from_book_depths:
            quote_tick = depth.to_quote_tick()
            if quote_tick is not None:
                # Check if top of book has changed
                last_quote = self._cache.quote_tick(depth.instrument_id)
                if last_quote is None or (
                    quote_tick.bid_price != last_quote.bid_price or
                    quote_tick.ask_price != last_quote.ask_price or
                    quote_tick.bid_size != last_quote.bid_size or
                    quote_tick.ask_size != last_quote.ask_size
                ):
                    self._handle_quote_tick(quote_tick)

    cpdef void _handle_quote_tick(self, QuoteTick tick, bint historical = False):
        self._cache.add_quote_tick(tick)

        # Handle synthetics update
        cdef:
            InstrumentId instrument_id = tick.instrument_id
            list synthetics = self._synthetic_quote_feeds.get(instrument_id)
        if synthetics is not None:
            self._update_synthetics_with_quote(synthetics, tick)

        self._msgbus.publish_c(
            topic=self._topic_cache.get_quotes_topic(instrument_id, historical),
            msg=tick,
        )

    cpdef void _handle_trade_tick(self, TradeTick tick, bint historical = False):
        self._cache.add_trade_tick(tick)

        # Handle synthetics update
        cdef:
            InstrumentId instrument_id = tick.instrument_id
            list synthetics = self._synthetic_trade_feeds.get(instrument_id)
        if synthetics is not None:
            self._update_synthetics_with_trade(synthetics, tick)

        self._msgbus.publish_c(
            topic=self._topic_cache.get_trades_topic(instrument_id, historical),
            msg=tick,
        )

    cpdef void _handle_mark_price(self, MarkPriceUpdate mark_price, bint historical = False):
        self._cache.add_mark_price(mark_price)

        self._msgbus.publish_c(
            topic=self._topic_cache.get_mark_prices_topic(mark_price.instrument_id, historical),
            msg=mark_price,
        )

    cpdef void _handle_index_price(self, IndexPriceUpdate index_price, bint historical = False):
        self._cache.add_index_price(index_price)

        self._msgbus.publish_c(
            topic=self._topic_cache.get_index_prices_topic(index_price.instrument_id, historical),
            msg=index_price,
        )

    cpdef void _handle_funding_rate(self, FundingRateUpdate funding_rate, bint historical = False):
        self._cache.add_funding_rate(funding_rate)

        self._msgbus.publish_c(
            topic=self._topic_cache.get_funding_rates_topic(funding_rate.instrument_id, historical),
            msg=funding_rate,
        )

    cpdef void _handle_bar(self, Bar bar, bint historical = False):
        cdef:
            BarType bar_type = bar.bar_type
            Bar cached_bar
            Bar last_bar
            list bars
            int i
        if self._validate_data_sequence:
            last_bar = self._cache.bar(bar_type)
            if last_bar is not None:
                if bar.ts_event < last_bar.ts_event:
                    self._log.warning(
                        f"Bar {bar} was prior to last bar `ts_event` {last_bar.ts_event}",
                    )
                    return  # `bar` is out of sequence

                if bar.ts_init < last_bar.ts_init:
                    self._log.warning(
                        f"Bar {bar} was prior to last bar `ts_init` {last_bar.ts_init}",
                    )
                    return  # `bar` is out of sequence

                if bar.is_revision:
                    if bar.ts_event == last_bar.ts_event:
                        # Replace `last_bar`, previously cached bar will fall out of scope
                        self._cache._bars.get(bar_type)[0] = bar  # noqa
                    elif bar.ts_event > last_bar.ts_event:
                        # Bar is latest, consider as new bar
                        self._cache.add_bar(bar)
                    else:
                        self._log.warning(
                            f"Bar revision {bar} was not at last bar `ts_event` {last_bar.ts_event}",
                        )
                        return  # Revision SHOULD be at `last_bar.ts_event`

        if not bar.is_revision:
            self._cache.add_bar(bar)

        self._msgbus.publish_c(topic=self._topic_cache.get_bars_topic(bar_type, historical), msg=bar)

    cpdef void _handle_instrument_status(self, InstrumentStatus data, bint historical = False):
        self._msgbus.publish_c(topic=self._topic_cache.get_status_topic(data.instrument_id, historical), msg=data)

    cpdef void _handle_close_price(self, InstrumentClose data, bint historical = False):
        self._msgbus.publish_c(topic=self._topic_cache.get_close_prices_topic(data.instrument_id, historical), msg=data)

    cpdef void _handle_custom_data(self, CustomData data, bint historical = False):
        cdef InstrumentId instrument_id = getattr(data.data, "instrument_id", None)
        cdef str topic = self._topic_cache.get_custom_data_topic(data.data_type, instrument_id, historical)
        self._msgbus.publish_c(topic=topic, msg=data.data)

# -- RESPONSE HANDLERS ----------------------------------------------------------------------------

    cpdef void _handle_response(self, DataResponse response):
        if self.debug:
            self._log.debug(f"{RECV}{RES} {response}", LogColor.MAGENTA)

        self.response_count += 1

        # We may need to join responses from a catalog and a client
        grouped_response = None
        if response.data_type.type == Instrument:
            grouped_response = response
        else:
            grouped_response = self._handle_request_group(response)

        if grouped_response is None:
            return

        # When a request group is part of another request group (RequestJoin case)
        if self._request_group_parent_request_id.get(grouped_response.correlation_id):
            self._handle_response(grouped_response)
            return

        cdef:
            bint query_past_data = response.params.get("subscription_name") is None
            Data data
        if query_past_data or grouped_response.data_type.type == Instrument:
            if grouped_response.data_type.type == Instrument:
                for data in grouped_response.data:
                    self._handle_instrument(data, params=grouped_response.params)

                grouped_response.data = []
            else:
                for data in grouped_response.data:
                    self.process_historical(data)

                if grouped_response.params.get("bar_types"):
                    self._handle_aggregated_bars(grouped_response)

                # We store the amount of data received to be used for long requests
                grouped_response.params["data_count"] = len(grouped_response.data)
                grouped_response.data = []

        self._msgbus.response(grouped_response)

    cpdef void _new_request_group(self, RequestData request, int n_components):
        # The parent request is stored so the grouped response can use its information
        self._request_group_n_components[request.id] = n_components
        self._request_group_parent_request[request.id] = request
        self._request_group_responses[request.id] = []

    cpdef DataResponse _handle_request_group(self, DataResponse response):
        # Closure is not allowed in cpdef functions so we call a cdef function
        return self._handle_request_group_aux(response)

    cdef DataResponse _handle_request_group_aux(self, DataResponse response):
        correlation_id = response.correlation_id

        # Look for parent request id using the mapping
        parent_request_id = self._request_group_parent_request_id.get(correlation_id)
        if parent_request_id is not None:
            self._request_group_parent_request_id.pop(correlation_id, None)

        if parent_request_id not in self._request_group_responses:
            self._log.error(f"_handle_request_group_aux: correlation_id {correlation_id} not found "
                            f"in _request_group_responses. Available keys: {list(self._request_group_responses.keys())}")
            return None

        self._request_group_responses[parent_request_id].append(response)

        if len(self._request_group_responses[parent_request_id]) != self._request_group_n_components[parent_request_id]:
            return None

        cdef list responses = self._request_group_responses[parent_request_id]
        cdef list data_result = []

        for response in responses:
            self._check_bounds(response)

            update_catalog = response.params.get("update_catalog", False)
            if update_catalog:
                start = response.start.value if response.start is not None else None
                end = response.end.value if response.end is not None else None
                identifier = response.params.get("identifier")
                self._update_catalog(
                    response.data,
                    response.data_type.type,
                    identifier,
                    start,
                    end
                )

            data_result += response.data

        data_result.sort(key=lambda x: x.ts_init)

        # Use the parent request to ensure the correct response parameters are returned to the caller.
        parent_request = self._request_group_parent_request[parent_request_id]
        response.data = data_result
        response.start = parent_request.start
        response.end = parent_request.end
        response.correlation_id = parent_request_id
        response.id = UUID4()
        response.params = parent_request.params

        del self._request_group_n_components[parent_request_id]
        del self._request_group_parent_request[parent_request_id]
        del self._request_group_responses[parent_request_id]

        return response

    cpdef void _check_bounds(self, DataResponse response):
        cdef int data_len = len(response.data)
        if data_len == 0:
            return

        cdef:
            uint64_t start = response.start.value if response.start is not None else 0
            cdef int first_index = 0
        if start:
            for i in range(data_len):
                if response.data[i].ts_init >= start:
                    first_index = i
                    break

        cdef:
            uint64_t end = response.end.value if response.end is not None else 0
            int last_index = data_len - 1
        if end:
            for i in range(data_len-1, -1, -1):
                if response.data[i].ts_init <= end:
                    last_index = i
                    break

        if first_index <= last_index:
            response.data = response.data[first_index:last_index + 1]

    def _update_catalog(
        self,
        data: list,
        data_cls: type,
        identifier: object,
        start: int | None = None,
        end: int | None = None,
        is_instrument: bool = False,
        force_update_catalog: bool = False,
    ) -> None:
        # Works with InstrumentId or BarType
        used_catalog = self._catalog_last_timestamp(data_cls, identifier)[1]

        # We don't want to write in the catalog several times the same instrument
        if used_catalog and is_instrument and not force_update_catalog:
            return

        # If more than one catalog exists, use the first declared one as default
        if used_catalog is None and len(self._catalogs) > 0:
            used_catalog = list(self._catalogs.values())[0]

        if used_catalog is None:
            self._log.warning("No catalog available for appending data.")
            return

        if len(data) == 0 and data_cls and start and end:
            # identifier can be None for custom data
            used_catalog.extend_file_name(data_cls, identifier, start, end)
        else:
            used_catalog.write_data(data, start, end)

    cpdef tuple[datetime, object] _catalog_last_timestamp(
        self,
        type data_cls,
        identifier = str | None,
    ):
        # We assume each symbol is only in one catalog
        for catalog in self._catalogs.values():
            last_timestamp = catalog.query_last_timestamp(data_cls, identifier)
            if last_timestamp:
                return last_timestamp, catalog

        return None, None

    # -- INTERNAL -------------------------------------------------------------------------------------

    # Python wrapper to enable callbacks
    cpdef void _internal_update_instruments(self, list instruments):
        # Handle all instruments individually
        cdef Instrument instrument
        for instrument in instruments:
            self._handle_instrument(instrument)

    cpdef void _update_order_book(self, Data data):
        cdef OrderBook order_book = self._cache.order_book(data.instrument_id)
        if order_book is None:
            return

        order_book.apply(data)

        cdef:
            QuoteTick quote_tick
            QuoteTick last_quote
        if self._emit_quotes_from_book:
            quote_tick = order_book.to_quote_tick()
            if quote_tick is not None:
                # Check if top of book has changed
                last_quote = self._cache.quote_tick(data.instrument_id)
                if last_quote is None or (
                    quote_tick.bid_price != last_quote.bid_price or
                    quote_tick.ask_price != last_quote.ask_price or
                    quote_tick.bid_size != last_quote.bid_size or
                    quote_tick.ask_size != last_quote.ask_size
                ):
                    self._handle_quote_tick(quote_tick)

    cpdef void _snapshot_order_book(self, TimeEvent snap_event):
        if self.debug:
            self._log.debug(f"Received snapshot event for {snap_event}", LogColor.MAGENTA)

        cdef SnapshotInfo snap_info = self._snapshot_info.get(snap_event.name)
        if snap_info is None:
            self._log.error(f"No `SnapshotInfo` found for snapshot event {snap_event}")
            return

        cdef:
            list[Instrument] instruments
            Instrument instrument
        if snap_info.is_composite:
            instruments = self._cache.instruments(venue=snap_info.venue, underlying=snap_info.root)
            for instrument in instruments:
                self._publish_order_book(instrument.id, snap_info.topic)
        else:
            self._publish_order_book(snap_info.instrument_id, snap_info.topic)

    cpdef void _publish_order_book(self, InstrumentId instrument_id, str topic):
        cdef OrderBook order_book = self._cache.order_book(instrument_id)
        if order_book is None:
            self._log.error(
                f"Cannot snapshot orderbook: "
                f"no order book found, {instrument_id}",
            )
            return

        if order_book.ts_last == 0:
            self._log.debug("OrderBook not yet updated, skipping snapshot")
            return

        self._msgbus.publish_c(
            topic=topic,
            msg=order_book,
        )

    cpdef void _update_synthetics_with_quote(self, list synthetics, QuoteTick update):
        cdef SyntheticInstrument synthetic
        for synthetic in synthetics:
            self._update_synthetic_with_quote(synthetic, update)

    cpdef void _update_synthetic_with_quote(self, SyntheticInstrument synthetic, QuoteTick update):
        cdef:
            list components = synthetic.components
            list[double] inputs_bid = []
            list[double] inputs_ask = []
            InstrumentId instrument_id
            QuoteTick component_quote
            Price update_bid
            Price update_ask
        for instrument_id in components:
            if instrument_id == update.instrument_id:
                update_bid = update.bid_price
                update_ask = update.ask_price
                inputs_bid.append(update_bid.as_f64_c())
                inputs_ask.append(update_ask.as_f64_c())
                continue

            component_quote = self._cache.quote_tick(instrument_id)
            if component_quote is None:
                self._log.warning(
                    f"Cannot calculate synthetic instrument {synthetic.id} price, "
                    f"no quotes for {instrument_id} yet",
                )
                return

            update_bid = component_quote.bid_price
            update_ask = component_quote.ask_price
            inputs_bid.append(update_bid.as_f64_c())
            inputs_ask.append(update_ask.as_f64_c())

        cdef Price bid_price = synthetic.calculate(inputs_bid)
        cdef Price ask_price = synthetic.calculate(inputs_ask)
        cdef Quantity size_one = Quantity(1, 0)  # Placeholder for now
        cdef InstrumentId synthetic_instrument_id = synthetic.id
        cdef QuoteTick synthetic_quote = QuoteTick(
            synthetic_instrument_id,
            bid_price,
            ask_price,
            size_one,
            size_one,
            update.ts_event,
            self._clock.timestamp_ns(),
        )

        self._msgbus.publish_c(
            topic=self._topic_cache.get_quotes_topic(synthetic_instrument_id),
            msg=synthetic_quote,
        )

    cpdef void _update_synthetics_with_trade(self, list synthetics, TradeTick update):
        cdef SyntheticInstrument synthetic
        for synthetic in synthetics:
            self._update_synthetic_with_trade(synthetic, update)

    cpdef void _update_synthetic_with_trade(self, SyntheticInstrument synthetic, TradeTick update):
        cdef:
            list components = synthetic.components
            list[double] inputs = []
            InstrumentId instrument_id
            TradeTick component_quote
            Price update_price
        for instrument_id in components:
            if instrument_id == update.instrument_id:
                update_price = update.price
                inputs.append(update_price.as_f64_c())
                continue

            component_trade = self._cache.trade_tick(instrument_id)
            if component_trade is None:
                self._log.warning(
                    f"Cannot calculate synthetic instrument {synthetic.id} price, "
                    f"no trades for {instrument_id} yet",
                )
                return

            update_price = component_trade.price
            inputs.append(update_price.as_f64_c())

        cdef Price price = synthetic.calculate(inputs)
        cdef Quantity size_one = Quantity(1, 0)  # Placeholder for now
        cdef InstrumentId synthetic_instrument_id = synthetic.id
        cdef TradeTick synthetic_trade = TradeTick(
            synthetic_instrument_id,
            price,
            size_one,
            update.aggressor_side,
            update.trade_id,
            update.ts_event,
            self._clock.timestamp_ns(),
        )

        self._msgbus.publish_c(
            topic=self._topic_cache.get_trades_topic(synthetic_instrument_id),
            msg=synthetic_trade,
        )

    # -- INTERNAL - Bar Aggregators -------------------------------------------------------------------

    cpdef void _init_historical_aggregators(self, RequestData request):
        bar_types = request.params.get("bar_types", ())
        for bar_type in bar_types:
            self._create_bar_aggregator(bar_type, request.params)
            aggregator = self._bar_aggregators.get(bar_type.standard())

            # No need to setup again an already existing aggregator (kept with update_subscriptions) in historical_mode
            if aggregator and not aggregator.historical_mode:
                self._setup_bar_aggregator(bar_type, historical=True)

    cpdef void _start_bar_aggregator(self, MarketDataClient client, SubscribeBars command):
        self._create_bar_aggregator(command.bar_type, command.params)
        self._setup_bar_aggregator(command.bar_type)
        self._subscribe_bar_aggregator(client, command)

    cpdef BarAggregator _create_bar_aggregator(self, BarType bar_type, dict params):
        aggregated_bar_type = bar_type.standard()
        if aggregated_bar_type in self._bar_aggregators:
            self._log.debug(f"BarAggregator for {aggregated_bar_type} already exists.")
            return

        instrument = self._cache.instrument(bar_type.instrument_id)
        if instrument is None:
            self._log.error(
                f"Cannot start bar aggregation: "
                f"no instrument found for {bar_type.instrument_id}",
            )
            return

        if bar_type.spec.is_time_aggregated():
            time_bars_origin_offset = self._time_bars_origin_offset.get(bar_type.spec.aggregation) or params.get("time_bars_origin_offset")
            aggregator = TimeBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
                clock=self._clock,
                interval_type=self._time_bars_interval_type,
                timestamp_on_close=self._time_bars_timestamp_on_close,
                skip_first_non_full_bar=self._time_bars_skip_first_non_full_bar,
                build_with_no_updates=self._time_bars_build_with_no_updates,
                time_bars_origin_offset=time_bars_origin_offset,
                bar_build_delay=self._time_bars_build_delay,
            )
        elif bar_type.spec.aggregation == BarAggregation.TICK:
            aggregator = TickBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.TICK_IMBALANCE:
            aggregator = TickImbalanceBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.TICK_RUNS:
            aggregator = TickRunsBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.VOLUME:
            aggregator = VolumeBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.VOLUME_IMBALANCE:
            aggregator = VolumeImbalanceBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.VOLUME_RUNS:
            aggregator = VolumeRunsBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.VALUE:
            aggregator = ValueBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.VALUE_IMBALANCE:
            aggregator = ValueImbalanceBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.VALUE_RUNS:
            aggregator = ValueRunsBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        elif bar_type.spec.aggregation == BarAggregation.RENKO:
            aggregator = RenkoBarAggregator(
                instrument=instrument,
                bar_type=aggregated_bar_type,
                handler=self.process,
            )
        else:
            raise NotImplementedError(  # pragma: no cover (design-time error)
                bar_aggregation_not_implemented_message(bar_type.spec.aggregation)
            )

        self._bar_aggregators[aggregated_bar_type] = aggregator

    cpdef void _setup_bar_aggregator(
            self,
            BarType bar_type,
            bint historical = False,
    ):
        aggregator = self._bar_aggregators.get(bar_type.standard())
        if aggregator is None:
            self._log.error(f"Cannot setup bar aggregator: no aggregator found for {bar_type}")
            return

        if historical:
            aggregator.set_historical_mode(historical, self.process_historical)
        else:
            if aggregator.historical_mode:
                # When switching from historical to live mode we unsubscribe from a historical topic
                self._dispose_bar_aggregator(bar_type, historical=True)

            aggregator.set_historical_mode(historical, self.process)

        # Subscribe aggregator to message bus to receive underlying data
        if bar_type.is_composite():
            self._msgbus.subscribe(
                topic=self._topic_cache.get_bars_topic(bar_type.composite(), historical),
                handler=aggregator.handle_bar,
            )
        elif bar_type.spec.price_type == PriceType.LAST:
            self._msgbus.subscribe(
                topic=self._topic_cache.get_trades_topic(bar_type.instrument_id, historical),
                handler=aggregator.handle_trade_tick,
                priority=5,
            )
        else:
            self._msgbus.subscribe(
                topic=self._topic_cache.get_quotes_topic(bar_type.instrument_id, historical),
                handler=aggregator.handle_quote_tick,
                priority=5,
            )

        if isinstance(aggregator, TimeBarAggregator):
            if historical:
                # Each aggregator gets its own independent clock
                test_clock = TestClock()
                aggregator.set_clock(test_clock)
            else:
                aggregator.set_clock(self._clock)
                aggregator.start_timer()

        aggregator.set_running(True)

    cpdef void _subscribe_bar_aggregator(self, MarketDataClient client, SubscribeBars command):
        # Subscribe to required market data
        if command.bar_type.is_composite():
            composite_bar_type = command.bar_type.composite()
            if composite_bar_type.is_externally_aggregated():
                subscribe = SubscribeBars(
                    bar_type=composite_bar_type,
                    client_id=command.client_id,
                    venue=command.venue,
                    command_id=UUID4(),
                    ts_init=command.ts_init,
                    params=command.params,
                    correlation_id=command.id,
                )
                self._handle_subscribe_bars(client, subscribe)
        elif command.bar_type.spec.price_type == PriceType.LAST:
            subscribe = SubscribeTradeTicks(
                instrument_id=command.bar_type.instrument_id,
                client_id=command.client_id,
                venue=command.venue,
                command_id=UUID4(),
                ts_init=command.ts_init,
                params=command.params,
                correlation_id=command.id,
            )
            self._handle_subscribe_trade_ticks(client, subscribe)
        else:
            subscribe = SubscribeQuoteTicks(
                instrument_id=command.bar_type.instrument_id,
                client_id=command.client_id,
                venue=command.venue,
                command_id=UUID4(),
                ts_init=command.ts_init,
                params=command.params,
                correlation_id=command.id,
            )
            self._handle_subscribe_quote_ticks(client, subscribe)

    cpdef void _handle_aggregated_bars(self, DataResponse response):
        # 1. Create aggregators (in _handle_request)
        # 2. Process underlying data through aggregators (in _handle_response)
        # 3. Handle aggregator lifecycle based on update_subscriptions
        update_subscriptions = response.params.get("update_subscriptions", False)

        bar_types = response.params.get("bar_types", ())
        for bar_type in bar_types:
            aggregator = self._bar_aggregators.get(bar_type.standard())
            if not aggregator:
                continue

            # Setting aggregator.is_running to False allows to start a live subscription
            # allowing the aggregator to still aggregate historical data if update_subscriptions is True
            aggregator.set_running(False)

            if not update_subscriptions:
                self._dispose_bar_aggregator(bar_type, historical=True)
                self._bar_aggregators.pop(bar_type.standard(), None)

    cpdef void _stop_bar_aggregator(self, MarketDataClient client, UnsubscribeBars command):
        aggregator = self._bar_aggregators.get(command.bar_type.standard())
        if aggregator is None:
            self._log.warning(
                f"Cannot stop bar aggregator: "
                f"no aggregator to stop for {command.bar_type}",
            )
            return

        if isinstance(aggregator, TimeBarAggregator):
            aggregator.stop_timer()

        self._dispose_bar_aggregator(command.bar_type)
        self._unsubscribe_aggregator(client, command)

        del self._bar_aggregators[command.bar_type.standard()]

    cpdef void _dispose_bar_aggregator(self, BarType bar_type, bint historical = False):
        aggregator = self._bar_aggregators.get(bar_type.standard())
        if aggregator is None:
            self._log.error(f"Cannot dispose bar aggregator: no aggregator found for {bar_type}")
            return

        if bar_type.is_composite():
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_bars_topic(bar_type.composite(), historical),
                handler=aggregator.handle_bar,
            )
        elif bar_type.spec.price_type == PriceType.LAST:
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_trades_topic(bar_type.instrument_id, historical),
                handler=aggregator.handle_trade_tick,
            )
        else:
            self._msgbus.unsubscribe(
                topic=self._topic_cache.get_quotes_topic(bar_type.instrument_id, historical=historical),
                handler=aggregator.handle_quote_tick,
            )

    cpdef void _unsubscribe_aggregator(self, MarketDataClient client, UnsubscribeBars command):
        # Unsubscribe from market data updates
        if command.bar_type.is_composite():
            composite_bar_type = command.bar_type.composite()
            if composite_bar_type.is_externally_aggregated():
                unsubscribe = UnsubscribeBars(
                    bar_type=composite_bar_type,
                    client_id=command.client_id,
                    venue=command.venue,
                    command_id=UUID4(),
                    ts_init=command.ts_init,
                    params=command.params,
                    correlation_id=command.id,
                )
                self._handle_unsubscribe_bars(client, unsubscribe)
        elif command.bar_type.spec.price_type == PriceType.LAST:
            unsubscribe = UnsubscribeTradeTicks(
                instrument_id=command.bar_type.instrument_id,
                client_id=command.client_id,
                venue=command.venue,
                command_id=UUID4(),
                ts_init=command.ts_init,
                params=command.params,
                correlation_id=command.id,
            )
            self._handle_unsubscribe_trade_ticks(client, unsubscribe)
        else:
            unsubscribe = UnsubscribeQuoteTicks(
                instrument_id=command.bar_type.instrument_id,
                client_id=command.client_id,
                venue=command.venue,
                command_id=UUID4(),
                ts_init=command.ts_init,
                params=command.params,
                correlation_id=command.id,
            )
            self._handle_unsubscribe_quote_ticks(client, unsubscribe)

TimeRangeGenerator = Callable[[int, dict[str, Any]], Generator[int, bool, None]]


cdef dict[str, TimeRangeGenerator] TIME_RANGE_GENERATORS = {}


def register_time_range_generator(name: str, function: TimeRangeGenerator):
    TIME_RANGE_GENERATORS[name] = function


def get_time_range_generator(name: str):
    return TIME_RANGE_GENERATORS.get(name, default_time_range_generator)


def default_time_range_generator(RequestData request):
    """
    Generator that yields (request_start_ns, request_end_ns) tuples for subrequests.

    This generator handles the duration logic and receives data_received feedback via .send().
    """
    cdef uint64_t prev_request_end_ns = request.start.value
    cdef uint64_t last_end_ns = request.end.value
    cdef uint64_t duration_ns = 0

    point_data = request.params.get("point_data", False)
    durations_seconds = request.params.get("durations_seconds", [None])

    iteration_index = 0
    while True:
        for duration_seconds in durations_seconds:
            # Possibility to use durations of various lengths to take into account weekends or market breaks
            # First iteration for [a, a + duration], then ]a + duration, a + 2 * duration], etc.
            # When point_data we do a query for [request_start_ns, request_start_ns] only
            offset = 1 if iteration_index > 0 and not point_data else 0
            request_start_ns = prev_request_end_ns + offset

            if request_start_ns > last_end_ns:
                return

            if duration_seconds is not None:
                duration_ns = duration_seconds * NANOSECONDS_IN_SECOND
                request_end_ns = min(request_start_ns + duration_ns - offset, last_end_ns)
            else:
                request_end_ns = last_end_ns

            prev_request_end_ns = request_end_ns

            if point_data:
                request_end_ns = request_start_ns

            # Yield the time range and wait for feedback
            data_received = yield (request_start_ns, request_end_ns)
            iteration_index += 1

            # When requesting a single point we exit the generator directly
            if duration_ns == 0:
                return

            # If we receive a success signal, break from the duration loop
            if data_received:
                break
        else:
            # If we complete the for loop without breaking (no success) we exit the generator
            return

</document_content>
</document>
<document index="2309">
<source>nautilus_trader/data/messages.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from typing import Any
from typing import Callable

from cpython.datetime cimport datetime
from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport DataType
from nautilus_trader.model.data cimport FundingRateUpdate
from nautilus_trader.model.data cimport IndexPriceUpdate
from nautilus_trader.model.data cimport InstrumentClose
from nautilus_trader.model.data cimport InstrumentStatus
from nautilus_trader.model.data cimport MarkPriceUpdate
from nautilus_trader.model.data cimport OrderBookDelta
from nautilus_trader.model.data cimport OrderBookDeltas
from nautilus_trader.model.data cimport OrderBookDepth10
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.base cimport Instrument


cdef class DataCommand(Command):
    """
    The base class for all data commands.

    Parameters
    ----------
    data_type : type
        The data type for the command.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the command.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        DataType data_type not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        Condition.is_true(client_id or venue, "Both `client_id` and `venue` were None")
        super().__init__(command_id, ts_init, correlation_id)

        self.data_type = data_type
        self.client_id = client_id
        self.venue = venue
        self.params = params or {}

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}{form_params_str(self.params)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class SubscribeData(DataCommand):
    """
    Represents a command to subscribe to data.

    Parameters
    ----------
    data_type : type
        The data type for the subscription.
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        DataType data_type not None,
        InstrumentId instrument_id: InstrumentId | None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        if instrument_id is not None:
            # for a unique type in such usage: self._add_subscription(command.data_type)
            metadata = data_type.metadata.copy()
            metadata["instrument_id"] = instrument_id
            data_type = DataType(data_type.type, metadata)

        super().__init__(
            data_type,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )
        self.instrument_id = instrument_id

    def to_request(
        self,
        datetime start: datetime | None,
        datetime end: datetime | None,
        callback: Callable[[Any], None] | None,
    ) -> RequestData:
        """
        Convert this subscribe message to a request message.

        Parameters
        ----------
        start : datetime
            The start datetime (UTC) of request time range (inclusive).
        end : datetime
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        callback : Callable[[Any], None]
            The delegate to call with the data.

        Returns
        -------
        RequestQuoteTicks
            The converted request message.
        """
        params = self.params.copy() if self.params else {}
        params["subscription_name"] = f"{self.data_type.type.__name__}.{self.instrument_id}"

        return RequestData(
            data_type=self.data_type,
            instrument_id=self.instrument_id,
            start=start,
            end=end,
            limit=0,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=self.ts_init,
            params=params,
            correlation_id=self.id,
        )


cdef class SubscribeInstruments(SubscribeData):
    """
    Represents a command to subscribe to all instruments of a venue.

    Parameters
    ----------
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Instrument),
            None,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )

    def to_request(
        self,
        datetime start: datetime | None,
        datetime end: datetime | None,
        callback: Callable[[Any], None] | None,
    ) -> RequestInstruments:
        """
        Convert this subscribe message to a request message.

        Parameters
        ----------
        start : datetime
            The start datetime (UTC) of request time range (inclusive).
        end : datetime
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        callback : Callable[[Any], None]
            The delegate to call with the data.

        Returns
        -------
        RequestInstruments
            The converted request message.
        """
        params = self.params.copy() if self.params else {}
        params["subscription_name"] = f"subscribe_instruments"

        return RequestInstruments(
            start=start,
            end=end,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=self.ts_init,
            params=params,
            correlation_id=self.id,
        )


cdef class SubscribeInstrument(SubscribeData):
    """
    Represents a command to subscribe to an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Instrument),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class SubscribeOrderBook(SubscribeData):
    """
    Represents a command to subscribe to order book deltas for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    data_type : DataType, {``OrderBookDeltas``, ``OrderBookDepth10``}
        The data type for book updates.
    book_type : BookType
        The order book type.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    depth : int, optional, default 0
        The maximum depth for the subscription.
    managed: bool, optional, default True
        If an order book should be managed by the data engine based on the subscribed feed.
    interval_ms : int, default 0 (no interval snapshots)
        The interval (milliseconds) between snapshots.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).
    ValueError
        If `interval_ms` is negative (< 0).
    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        type book_data_type,
        BookType book_type,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        int depth = 0,
        bint managed = True,
        int interval_ms = 0,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        Condition.is_true(
            book_data_type in (OrderBookDelta, OrderBookDepth10),
            f"`book_data_type` must be `OrderBookDelta` or `OrderBookDepth10`, was {book_data_type}",
        )
        Condition.not_negative_int(interval_ms, "interval_ms")
        super().__init__(
            DataType(book_data_type),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )
        self.book_type = book_type
        self.depth = depth
        self.managed = managed
        self.interval_ms = interval_ms

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"data_type={self.data_type}, "
            f"book_type={self.book_type}, "
            f"depth={self.depth}, "
            f"managed={self.managed}, "
            f"interval_ms={self.interval_ms}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"data_type={self.data_type}, "
            f"book_type={self.book_type}, "
            f"depth={self.depth}, "
            f"managed={self.managed}, "
            f"interval_ms={self.interval_ms}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )

    def to_request(
        self,
        datetime start: datetime | None,
        datetime end: datetime | None,
        callback: Callable[[Any], None] | None,
    ) -> RequestOrderBookDepth:
        """
        Convert this subscribe message to a request message.

        Parameters
        ----------
        start : datetime
            The start datetime (UTC) of request time range (inclusive).
        end : datetime
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        callback : Callable[[Any], None]
            The delegate to call with the data.

        Returns
        -------
        RequestOrderBookDepth
            The converted request message.
        """
        if self.data_type.type != OrderBookDepth10:
            raise ValueError(
                f"Cannot convert SubscribeOrderBook with data_type {self.data_type.type} to RequestOrderBookDepth. "
                f"Only OrderBookDepth10 subscriptions can be converted to historical requests."
            )

        params = self.params.copy() if self.params else {}
        params["subscription_name"] = f"{self.data_type.type.__name__}.{self.instrument_id}"

        return RequestOrderBookDepth(
            instrument_id=self.instrument_id,
            start=start,
            end=end,
            limit=0,
            depth=self.depth if self.depth > 0 else 10,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=self.ts_init,
            params=params,
            correlation_id=self.id,
        )


cdef class SubscribeQuoteTicks(SubscribeData):
    """
    Represents a command to subscribe to quote ticks.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(QuoteTick),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )

    def to_request(
        self,
        datetime start: datetime | None,
        datetime end: datetime | None,
        callback: Callable[[Any], None] | None,
    ) -> RequestQuoteTicks:
        """
        Convert this subscribe message to a request message.

        Parameters
        ----------
        start : datetime
            The start datetime (UTC) of request time range (inclusive).
        end : datetime
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        callback : Callable[[Any], None]
            The delegate to call with the data.

        Returns
        -------
        RequestQuoteTicks
            The converted request message.
        """
        params = self.params.copy() if self.params else {}
        params["subscription_name"] = f"{self.data_type.type.__name__}.{self.instrument_id}"

        return RequestQuoteTicks(
            instrument_id=self.instrument_id,
            start=start,
            end=end,
            limit=0,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=self.ts_init,
            params=params,
            correlation_id=self.id,
        )


cdef class SubscribeTradeTicks(SubscribeData):
    """
    Represents a command to subscribe to trade ticks.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(TradeTick),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )

    def to_request(
        self,
        datetime start: datetime | None,
        datetime end: datetime | None,
        callback: Callable[[Any], None] | None,
    ) -> RequestTradeTicks:
        """
        Convert this subscribe message to a request message.

        Parameters
        ----------
        start : datetime
            The start datetime (UTC) of request time range (inclusive).
        end : datetime
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        callback : Callable[[Any], None]
            The delegate to call with the data.

        Returns
        -------
        RequestTradeTicks
            The converted request message.
        """
        params = self.params.copy() if self.params else {}
        params["subscription_name"] = f"{self.data_type.type.__name__}.{self.instrument_id}"

        return RequestTradeTicks(
            instrument_id=self.instrument_id,
            start=start,
            end=end,
            limit=0,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=self.ts_init,
            params=params,
            correlation_id=self.id,
        )


cdef class SubscribeMarkPrices(SubscribeData):
    """
    Represents a command to subscribe to mark prices.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(MarkPriceUpdate),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class SubscribeIndexPrices(SubscribeData):
    """
    Represents a command to subscribe to index prices.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(IndexPriceUpdate),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class SubscribeFundingRates(SubscribeData):
    """
    Represents a command to subscribe to funding rates.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(FundingRateUpdate),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class SubscribeBars(SubscribeData):
    """
    Represents a command to subscribe to bars for an instrument.

    Parameters
    ----------
    bar_type : BarType
        The bar type for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        BarType bar_type not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Bar),
            None,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )
        self.bar_type = bar_type

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"bar_type={self.bar_type}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"bar_type={self.bar_type}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )

    def to_request(
        self,
        datetime start: datetime | None,
        datetime end: datetime | None,
        callback: Callable[[Any], None] | None,
    ) -> RequestBars:
        """
        Convert this subscribe message to a request message.

        Parameters
        ----------
        start : datetime
            The start datetime (UTC) of request time range (inclusive).
        end : datetime
            The end datetime (UTC) of request time range.
            The inclusiveness depends on individual data client implementation.
        callback : Callable[[Any], None]
            The delegate to call with the data.

        Returns
        -------
        RequestBars
            The converted request message.
        """
        params = self.params.copy() if self.params else {}
        params["subscription_name"] = f"{self.bar_type}"

        return RequestBars(
            bar_type=self.bar_type,
            start=start,
            end=end,
            limit=0,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=self.ts_init,
            params=params,
            correlation_id=self.id,
        )


cdef class SubscribeInstrumentStatus(SubscribeData):
    """
    Represents a command to subscribe to the status of an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(InstrumentStatus),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class SubscribeInstrumentClose(SubscribeData):
    """
    Represents a command to subscribe to the close of an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(InstrumentClose),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeData(DataCommand):
    """
    Represents a command to unsubscribe to data.

    Parameters
    ----------
    data_type : type
        The data type for the subscription.
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        DataType data_type not None,
        InstrumentId instrument_id: InstrumentId | None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        if instrument_id is not None:
            # for a unique type in such usage: self._add_subscription(command.data_type)
            metadata = data_type.metadata.copy()
            metadata["instrument_id"] = instrument_id
            data_type = DataType(data_type.type, metadata)

        super().__init__(
            data_type,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )
        self.instrument_id = instrument_id


cdef class UnsubscribeInstruments(UnsubscribeData):
    """
    Represents a command to unsubscribe to all instruments.

    Parameters
    ----------
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Instrument),
            None,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeInstrument(UnsubscribeData):
    """
    Represents a command to unsubscribe to an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Instrument),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeOrderBook(UnsubscribeData):
    """
    Represents a command to unsubscribe from order book updates for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    book_data_type : type, {``OrderBookDelta``, ``OrderBookDepth10``}
        The data type for book updates.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        type book_data_type,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        Condition.is_true(
            book_data_type in (OrderBookDelta, OrderBookDepth10),
            f"`book_data_type` must be `OrderBookDelta` or `OrderBookDepth10`, was {book_data_type}",
        )
        super().__init__(
            DataType(book_data_type),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"data_type={self.data_type}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"data_type={self.data_type}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeQuoteTicks(UnsubscribeData):
    """
    Represents a command to unsubscribe from quote ticks for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(QuoteTick),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeTradeTicks(UnsubscribeData):
    """
    Represents a command to unsubscribe from trade ticks for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(TradeTick),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeMarkPrices(UnsubscribeData):
    """
    Represents a command to unsubscribe from mark prices for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(MarkPriceUpdate),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeIndexPrices(UnsubscribeData):
    """
    Represents a command to unsubscribe from index prices for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(IndexPriceUpdate),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeFundingRates(UnsubscribeData):
    """
    Represents a command to unsubscribe from funding rates for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(FundingRateUpdate),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeBars(UnsubscribeData):
    """
    Represents a command to unsubscribe from bars for an instrument.

    Parameters
    ----------
    bar_type : BarType
        The bar type for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        BarType bar_type not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Bar),
            None,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )
        self.bar_type = bar_type

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"bar_type={self.bar_type}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"bar_type={self.bar_type}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeInstrumentStatus(UnsubscribeData):
    """
    Represents a command to unsubscribe from instrument status.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(InstrumentStatus),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class UnsubscribeInstrumentClose(UnsubscribeData):
    """
    Represents a command to unsubscribe from instrument close for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the subscription.
    client_id : ClientId or ``None``
        The data client ID for the command.
    venue : Venue or ``None``
        The venue for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the subscription.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(InstrumentClose),
            instrument_id,
            client_id,
            venue,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class RequestData(Request):
    """
    Represents a request for data.

    Parameters
    ----------
    data_type : type
        The data type for the request.
    instrument_id : InstrumentId
        The instrument ID for the request.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    limit : int
        The limit on the amount of data to return for the request.
    client_id : ClientId or ``None``
        The data client ID for the request.
    venue : Venue or ``None``
        The venue for the request.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        DataType data_type not None,
        InstrumentId instrument_id: InstrumentId | None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        int limit,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        Condition.is_true(client_id or venue, "Both `client_id` and `venue` were None")
        super().__init__(
            callback,
            request_id,
            ts_init,
            correlation_id,
        )
        self.data_type = data_type
        self.instrument_id = instrument_id
        self.start = start
        self.end = end
        self.limit = limit
        self.client_id = client_id
        self.venue = venue
        self.params = params or {}

    def with_dates(self, datetime start, datetime end, uint64_t ts_init, callback: Callable[[Any], None] | None = None):
        return RequestData(
            data_type=self.data_type,
            instrument_id=self.instrument_id,
            start=start,
            end=end,
            limit=self.limit,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=ts_init,
            params=self.params.copy(),
            correlation_id=self.id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"data_type={self.data_type}{form_params_str(self.params)}, "
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"data_type={self.data_type}{form_params_str(self.params)}, "
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id})"
        )


cdef class RequestInstrument(RequestData):
    """
    Represents a request for an instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the request.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    client_id : ClientId or ``None``
        The data client ID for the request.
    venue : Venue or ``None``
        The venue for the request.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Instrument),
            instrument_id,
            start,
            end,
            0,
            client_id,
            venue,
            callback,
            request_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}{form_params_str(self.params)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class RequestInstruments(RequestData):
    """
    Represents a request for instruments.

    Parameters
    ----------
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    client_id : ClientId or ``None``
        The data client ID for the request.
    venue : Venue or ``None``
        The venue for the request.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        datetime start : datetime | None,
        datetime end : datetime | None,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Instrument),
            None,
            start,
            end,
            0,
            client_id,
            venue,
            callback,
            request_id,
            ts_init,
            params,
            correlation_id,
        )

    def with_dates(self, datetime start, datetime end, uint64_t ts_init, callback: Callable[[Any], None] | None = None):
        return RequestInstruments(
            start=start,
            end=end,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=ts_init,
            params=self.params.copy(),
            correlation_id=self.id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"start={self.start}, "
            f"end={self.end}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}{form_params_str(self.params)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"start={self.start}, "
            f"end={self.end}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class RequestOrderBookSnapshot(RequestData):
    """
    Represents a request for an order book snapshot.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the request.
    limit : int
        The limit on the depth of the order book snapshot (default is None).
    client_id : ClientId or ``None``
        The data client ID for the request.
    venue : Venue or ``None``
        The venue for the request.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        int limit,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(OrderBookDeltas),
            instrument_id,
            None,
            None,
            limit,
            client_id,
            venue,
            callback,
            request_id,
            ts_init,
            params,
            correlation_id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}{form_params_str(self.params)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class RequestOrderBookDepth(RequestData):
    """
    Represents a request for historical `OrderBookDepth10` data.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the request.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    limit : int
        The limit on the amount of depth snapshots received.
    depth : int
        The maximum depth for the order book depth data (default is 10).
    client_id : ClientId or ``None``
        The data client ID for the request.
    venue : Venue or ``None``
        The venue for the request.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        int limit,
        int depth,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(OrderBookDepth10),
            instrument_id,
            start,
            end,
            limit,
            client_id,
            venue,
            callback,
            request_id,
            ts_init,
            params,
            correlation_id,
        )
        self.depth = depth

    def with_dates(self, datetime start, datetime end, uint64_t ts_init, callback: Callable[[Any], None] | None = None):
        return RequestOrderBookDepth(
            instrument_id=self.instrument_id,
            start=start,
            end=end,
            limit=self.limit,
            depth=self.depth,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=ts_init,
            params=self.params.copy(),
            correlation_id=self.id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"depth={self.depth}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}{form_params_str(self.params)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"depth={self.depth}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class RequestQuoteTicks(RequestData):
    """
    Represents a request for quote ticks.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the request.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    limit : int
        The limit on the amount of quote ticks received.
    client_id : ClientId or ``None``
        The data client ID for the request.
    venue : Venue or ``None``
        The venue for the request.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        int limit,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(QuoteTick),
            instrument_id,
            start,
            end,
            limit,
            client_id,
            venue,
            callback,
            request_id,
            ts_init,
            params,
            correlation_id,
        )

    def with_dates(self, datetime start, datetime end, uint64_t ts_init, callback: Callable[[Any], None] | None = None):
        return RequestQuoteTicks(
            instrument_id=self.instrument_id,
            start=start,
            end=end,
            limit=self.limit,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=ts_init,
            params=self.params.copy(),
            correlation_id=self.id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}{form_params_str(self.params)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )

cdef class RequestTradeTicks(RequestData):
    """
    Represents a request for trade ticks.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the request.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    limit : int
        The limit on the amount of trade ticks received.
    client_id : ClientId or ``None``
        The data client ID for the request.
    venue : Venue or ``None``
        The venue for the request.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        int limit,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(TradeTick),
            instrument_id,
            start,
            end,
            limit,
            client_id,
            venue,
            callback,
            request_id,
            ts_init,
            params,
            correlation_id,
        )

    def with_dates(self, datetime start, datetime end, uint64_t ts_init, callback: Callable[[Any], None] | None = None):
        return RequestTradeTicks(
            instrument_id=self.instrument_id,
            start=start,
            end=end,
            limit=self.limit,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=ts_init,
            params=self.params.copy(),
            correlation_id=self.id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}{form_params_str(self.params)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class RequestBars(RequestData):
    """
    Represents a request for bars.

    Parameters
    ----------
    bar_type : BarType
        The bar type for the request.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    limit : int
        The limit on the amount of bars received.
    client_id : ClientId or ``None``
        The data client ID for the request.
    venue : Venue or ``None``
        The venue for the request.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        BarType bar_type not None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        int limit,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            DataType(Bar),
            None,
            start,
            end,
            limit,
            client_id,
            venue,
            callback,
            request_id,
            ts_init,
            params,
            correlation_id,
        )
        self.bar_type = bar_type

    def with_dates(self, datetime start, datetime end, uint64_t ts_init, callback: Callable[[Any], None] | None = None):
        return RequestBars(
            bar_type=self.bar_type,
            start=start,
            end=end,
            limit=self.limit,
            client_id=self.client_id,
            venue=self.venue,
            callback=callback,
            request_id=UUID4(),
            ts_init=ts_init,
            params=self.params.copy(),
            correlation_id=self.id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"bar_type={self.bar_type}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}{form_params_str(self.params)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"bar_type={self.bar_type}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"limit={self.limit}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class RequestJoin(RequestData):
    """
    Represents a request to join multiple data requests.

    Parameters
    ----------
    request_ids : tuple[UUID4]
        The tuple of sub-request IDs to join.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    callback : Callable[[Any], None]
        The delegate to call with the data.
    request_id : UUID4
        The request ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object]
        Additional parameters for the request.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        tuple request_ids not None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        callback: Callable[[Any], None] | None,
        UUID4 request_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None,
        UUID4 correlation_id = None,
    ) -> None:
        Condition.not_none(request_ids, "request_ids")
        Condition.is_true(len(request_ids) > 0, "request_ids must not be empty")

        super().__init__(
            DataType(Data),  # Generic data type for join
            None,  # No specific instrument_id for join
            start,
            end,
            0,  # No limit for join
            ClientId("join_request"),
            None,
            callback,
            request_id,
            ts_init,
            params,
            correlation_id,
        )
        self.request_ids = request_ids

    def with_dates(self, datetime start, datetime end, uint64_t ts_init, callback: Callable[[Any], None] | None = None):
        return RequestJoin(
            request_ids=self.request_ids,
            start=start,
            end=end,
            callback=callback,
            request_id=UUID4(),
            ts_init=ts_init,
            params=self.params.copy(),
            correlation_id=self.id,
        )

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"request_ids={self.request_ids}, "
            f"start={self.start}, "
            f"end={self.end})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"request_ids={self.request_ids}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"callback={self.callback}, "
            f"id={self.id}, "
            f"correlation_id={self.correlation_id}{form_params_str(self.params)})"
        )


cdef class DataResponse(Response):
    """
    Represents a response with data.

    Parameters
    ----------
    client_id : ClientId or ``None``
        The data client ID of the response.
    venue : Venue or ``None``
        The venue for the response.
    data_type : type
        The data type of the response.
    data : object
        The data of the response.
    correlation_id : UUID4
        The correlation ID.
    response_id : UUID4
        The response ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    start : datetime
        The start datetime (UTC) of response time range (inclusive).
    end : datetime
        The end datetime (UTC) of response time range (inclusive).
    params : dict[str, object], optional
        Additional parameters for the response.

    Raises
    ------
    ValueError
        If both `client_id` and `venue` are both ``None`` (not enough routing info).

    """

    def __init__(
        self,
        ClientId client_id: ClientId | None,
        Venue venue: Venue | None,
        DataType data_type,
        data not None,
        UUID4 correlation_id not None,
        UUID4 response_id not None,
        uint64_t ts_init,
        datetime start,
        datetime end,
        dict[str, object] params: dict | None = None,
    ) -> None:
        Condition.is_true(client_id or venue, "Both `client_id` and `venue` were None")
        super().__init__(
            correlation_id,
            response_id,
            ts_init,
        )

        self.client_id = client_id
        self.venue = venue
        self.data_type = data_type
        self.data = data
        self.start = start
        self.end = end
        self.params = params or {}

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"data_type={self.data_type}, "
            f"correlation_id={self.correlation_id}, "
            f"id={self.id}{form_params_str(self.params)})"
        )

</document_content>
</document>
<document index="2336">
<source>nautilus_trader/execution/algorithm.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from typing import Any

from nautilus_trader.execution.config import ExecAlgorithmConfig
from nautilus_trader.execution.config import ImportableExecAlgorithmConfig

from cpython.datetime cimport datetime
from libc.stdint cimport uint8_t
from libc.stdint cimport uint64_t

from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.common.actor cimport Actor
from nautilus_trader.common.component cimport CMD
from nautilus_trader.common.component cimport RECV
from nautilus_trader.common.component cimport SENT
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport is_logging_initialized
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport dt_to_unix_nanos
from nautilus_trader.core.fsm cimport InvalidStateTrigger
from nautilus_trader.core.message cimport Command
from nautilus_trader.core.rust.common cimport ComponentState
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.execution.messages cimport TradingCommand
from nautilus_trader.model.events.order cimport OrderAccepted
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderCancelRejected
from nautilus_trader.model.events.order cimport OrderDenied
from nautilus_trader.model.events.order cimport OrderEmulated
from nautilus_trader.model.events.order cimport OrderEvent
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderModifyRejected
from nautilus_trader.model.events.order cimport OrderPendingCancel
from nautilus_trader.model.events.order cimport OrderPendingUpdate
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderReleased
from nautilus_trader.model.events.order cimport OrderSubmitted
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.events.position cimport PositionChanged
from nautilus_trader.model.events.position cimport PositionClosed
from nautilus_trader.model.events.position cimport PositionEvent
from nautilus_trader.model.events.position cimport PositionOpened
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport LIMIT_ORDER_TYPES
from nautilus_trader.model.orders.base cimport STOP_ORDER_TYPES
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.limit cimport LimitOrder
from nautilus_trader.model.orders.list cimport OrderList
from nautilus_trader.model.orders.market cimport MarketOrder
from nautilus_trader.model.orders.market_to_limit cimport MarketToLimitOrder
from nautilus_trader.portfolio.base cimport PortfolioFacade


cdef class ExecAlgorithm(Actor):
    """
    The base class for all execution algorithms.

    This class allows traders to implement their own customized execution algorithms.

    Parameters
    ----------
    config : ExecAlgorithmConfig, optional
        The execution algorithm configuration.

    Raises
    ------
    TypeError
        If `config` is not of type `ExecAlgorithmConfig`.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(self, config: ExecAlgorithmConfig | None = None):
        if config is None:
            config = ExecAlgorithmConfig()
        Condition.type(config, ExecAlgorithmConfig, "config")

        super().__init__()
        # Assign Execution Algorithm ID after base class initialized
        if isinstance(config.exec_algorithm_id, str):
            self.id = ExecAlgorithmId(config.exec_algorithm_id)
        else:
            self.id = config.exec_algorithm_id or ExecAlgorithmId(type(self).__name__)

        # Configuration
        self._log_events = config.log_events
        self._log_commands = config.log_commands
        self.config = config

        self._exec_spawn_ids: dict[ClientOrderId, int] = {}
        self._subscribed_strategies: set[StrategyId] = set()

        # Public components
        self.portfolio = None  # Initialized when registered

    def to_importable_config(self) -> ImportableExecAlgorithmConfig:
        """
        Returns an importable configuration for this execution algorithm.

        Returns
        -------
        ImportableExecAlgorithmConfig

        """
        return ImportableExecAlgorithmConfig(
            exec_algorithm_path=self.fully_qualified_name(),
            config_path=self.config.fully_qualified_name(),
            config=self.config.dict(),
        )

# -- REGISTRATION ---------------------------------------------------------------------------------

    cpdef void register(
        self,
        TraderId trader_id,
        PortfolioFacade portfolio,
        MessageBus msgbus,
        CacheFacade cache,
        Clock clock,
    ):
        """
        Register the execution algorithm with a trader.

        Parameters
        ----------
        trader_id : TraderId
            The trader ID for the execution algorithm.
        portfolio : PortfolioFacade
            The read-only portfolio for the execution algorithm.
        msgbus : MessageBus
            The message bus for the execution algorithm.
        cache : CacheFacade
            The read-only cache for the execution algorithm.
        clock : Clock
            The clock for the execution algorithm.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(trader_id, "trader_id")
        Condition.not_none(portfolio, "portfolio")
        Condition.not_none(msgbus, "msgbus")
        Condition.not_none(cache, "cache")
        Condition.not_none(clock, "clock")

        self.register_base(
            portfolio=portfolio,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
        )

        # Register endpoints
        self._msgbus.register(endpoint=f"{self.id}.execute", handler=self.execute)

# -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------

    cpdef void _reset(self):
        self._exec_spawn_ids.clear()
        self._subscribed_strategies.clear()

        self.on_reset()

# -- INTERNAL -------------------------------------------------------------------------------------

    cdef ClientOrderId _spawn_client_order_id(self, Order primary):
        cdef int spawn_sequence = self._exec_spawn_ids.get(primary.client_order_id, 0)
        spawn_sequence += 1
        self._exec_spawn_ids[primary.client_order_id] = spawn_sequence

        return ClientOrderId(f"{primary.client_order_id.to_str()}-E{spawn_sequence}")

    cdef void _reduce_primary_order(self, Order primary, Quantity spawn_qty):
        Condition.is_true(primary.quantity >= spawn_qty, "Spawn order quantity was greater than or equal to primary order")

        cdef Quantity new_qty = Quantity.from_raw_c(
            primary.quantity._mem.raw - spawn_qty._mem.raw,
            primary.quantity._mem.precision,
        )

        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()

        cdef OrderUpdated updated = OrderUpdated(
            trader_id=primary.trader_id,
            strategy_id=primary.strategy_id,
            instrument_id=primary.instrument_id,
            client_order_id=primary.client_order_id,
            venue_order_id=primary.venue_order_id,
            account_id=primary.account_id,
            quantity=new_qty,
            price=None,
            trigger_price=None,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

        primary.apply(updated)
        self.cache.update_order(primary)

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void execute(self, TradingCommand command):
        """
        Handle the given trading command by processing it with the execution algorithm.

        Parameters
        ----------
        command : SubmitOrder
            The command to handle.

        Raises
        ------
        ValueError
            If `command.exec_algorithm_id` is not equal to `self.id`.

        """
        Condition.not_none(command, "command")

        if self._log_commands:
            self._log.debug(f"{RECV}{CMD} {command}", LogColor.MAGENTA)

        if self._fsm.state != ComponentState.RUNNING:
            return

        if isinstance(command, SubmitOrder):
            self._handle_submit_order(command)
        elif isinstance(command, SubmitOrderList):
            self._handle_submit_order_list(command)
        elif isinstance(command, CancelOrder):
            self._handle_cancel_order(command)
        else:
            self._log.error(f"Cannot handle command: unrecognized {command}")

        if command.strategy_id in self._subscribed_strategies:
            return  # Already subscribed

        self._log.info(f"Subscribing to {command.strategy_id} order events", LogColor.BLUE)
        self._msgbus.subscribe(topic=f"events.order.{command.strategy_id.to_str()}", handler=self._handle_event)
        self._msgbus.subscribe(topic=f"events.position.{command.strategy_id.to_str()}", handler=self._handle_event)
        self._subscribed_strategies.add(command.strategy_id)

    cdef void _handle_submit_order(self, SubmitOrder command):
        Condition.equal(command.exec_algorithm_id, self.id, "command.exec_algorithm_id", "self.id")
        try:
            self.on_order(command.order)
        except Exception as e:  # pragma: no cover
            self.log.exception(f"Error on handling {repr(command.order)}", e)
            raise

    cdef void _handle_submit_order_list(self, SubmitOrderList command):
        Condition.equal(command.exec_algorithm_id, self.id, "command.exec_algorithm_id", "self.id")
        cdef Order order
        for order in command.order_list.orders:
            if order.exec_algorithm_id is not None:
                Condition.equal(order.exec_algorithm_id, self.id, "order.exec_algorithm_id", "self.id")
        try:
            self.on_order_list(command.order_list)
        except Exception as e:  # pragma: no cover
            self.log.exception(f"Error on handling {repr(command.order_list)}", e)
            raise

    cdef void _handle_cancel_order(self, CancelOrder command):
        cdef Order order = self.cache.order(command.client_order_id)
        if order is None:  # pragma: no cover (design-time error)
            self._log.error(
                f"Cannot cancel order: {repr(command.client_order_id)} not found",
            )
            return

        if self.cache.is_order_pending_cancel_local(command.client_order_id):
            return  # Already pending cancel locally

        if order.is_closed_c():
            self._log.warning(f"Order already canceled for {command}")
            return

        # Generate event
        cdef OrderCanceled event = self._generate_order_canceled(order)

        try:
            order.apply(event)
        except InvalidStateTrigger as e:  # pragma: no cover
            self._log.warning(f"InvalidStateTrigger: {e}, did not apply {event}")
            return

        self.cache.update_order(order)

        # Publish canceled event
        self._msgbus.publish_c(
            topic=f"events.order.{order.strategy_id.to_str()}",
            msg=event,
        )

# -- EVENT HANDLERS -------------------------------------------------------------------------------

    cdef void _handle_event(self, Event event):
        cdef Order order

        if isinstance(event, OrderEvent):
            order = self.cache.order(event.client_order_id)
            if order is None:
                return
            if order.exec_algorithm_id is None or order.exec_algorithm_id != self.id:
                return  # Not for this algorithm

        if self._fsm.state != ComponentState.RUNNING:
            return

        try:
            # Send to specific event handler
            if isinstance(event, OrderInitialized):
                self.on_order_initialized(event)
                self.on_order_event(event)
            elif isinstance(event, OrderDenied):
                self.on_order_denied(event)
                self.on_order_event(event)
            elif isinstance(event, OrderEmulated):
                self.on_order_emulated(event)
                self.on_order_event(event)
            elif isinstance(event, OrderReleased):
                self.on_order_released(event)
                self.on_order_event(event)
            elif isinstance(event, OrderSubmitted):
                self.on_order_submitted(event)
                self.on_order_event(event)
            elif isinstance(event, OrderRejected):
                self.on_order_rejected(event)
                self.on_order_event(event)
            elif isinstance(event, OrderAccepted):
                self.on_order_accepted(event)
                self.on_order_event(event)
            elif isinstance(event, OrderCanceled):
                self.on_order_canceled(event)
                self.on_order_event(event)
            elif isinstance(event, OrderExpired):
                self.on_order_expired(event)
                self.on_order_event(event)
            elif isinstance(event, OrderTriggered):
                self.on_order_triggered(event)
                self.on_order_event(event)
            elif isinstance(event, OrderPendingUpdate):
                self.on_order_pending_update(event)
                self.on_order_event(event)
            elif isinstance(event, OrderPendingCancel):
                self.on_order_pending_cancel(event)
                self.on_order_event(event)
            elif isinstance(event, OrderModifyRejected):
                self.on_order_modify_rejected(event)
                self.on_order_event(event)
            elif isinstance(event, OrderCancelRejected):
                self.on_order_cancel_rejected(event)
                self.on_order_event(event)
            elif isinstance(event, OrderUpdated):
                self.on_order_updated(event)
                self.on_order_event(event)
            elif isinstance(event, OrderFilled):
                self.on_order_filled(event)
                self.on_order_event(event)
            elif isinstance(event, PositionOpened):
                self.on_position_opened(event)
                self.on_position_event(event)
            elif isinstance(event, PositionChanged):
                self.on_position_changed(event)
                self.on_position_event(event)
            elif isinstance(event, PositionClosed):
                self.on_position_closed(event)
                self.on_position_event(event)

            # Always send to general event handler
            self.on_event(event)
        except Exception as e:  # pragma: no cover
            self.log.exception(f"Error on handling {repr(event)}", e)
            raise

    cpdef void on_order(self, Order order):
        """
        Actions to be performed when running and receives an order.

        Parameters
        ----------
        order : Order
            The order to be handled.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_list(self, OrderList order_list):
        """
        Actions to be performed when running and receives an order list.

        Parameters
        ----------
        order_list : OrderList
            The order list to be handled.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_event(self, OrderEvent event):
        """
        Actions to be performed when running and receives an order event.

        Parameters
        ----------
        event : OrderEvent
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_initialized(self, OrderInitialized event):
        """
        Actions to be performed when running and receives an order initialized event.

        Parameters
        ----------
        event : OrderInitialized
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_denied(self, OrderDenied event):
        """
        Actions to be performed when running and receives an order denied event.

        Parameters
        ----------
        event : OrderDenied
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_emulated(self, OrderEmulated event):
        """
        Actions to be performed when running and receives an order initialized event.

        Parameters
        ----------
        event : OrderEmulated
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_released(self, OrderReleased event):
        """
        Actions to be performed when running and receives an order released event.

        Parameters
        ----------
        event : OrderReleased
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_submitted(self, OrderSubmitted event):
        """
        Actions to be performed when running and receives an order submitted event.

        Parameters
        ----------
        event : OrderSubmitted
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_rejected(self, OrderRejected event):
        """
        Actions to be performed when running and receives an order rejected event.

        Parameters
        ----------
        event : OrderRejected
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_accepted(self, OrderAccepted event):
        """
        Actions to be performed when running and receives an order accepted event.

        Parameters
        ----------
        event : OrderAccepted
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_canceled(self, OrderCanceled event):
        """
        Actions to be performed when running and receives an order canceled event.

        Parameters
        ----------
        event : OrderCanceled
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_expired(self, OrderExpired event):
        """
        Actions to be performed when running and receives an order expired event.

        Parameters
        ----------
        event : OrderExpired
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_triggered(self, OrderTriggered event):
        """
        Actions to be performed when running and receives an order triggered event.

        Parameters
        ----------
        event : OrderTriggered
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_pending_update(self, OrderPendingUpdate event):
        """
        Actions to be performed when running and receives an order pending update event.

        Parameters
        ----------
        event : OrderPendingUpdate
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_pending_cancel(self, OrderPendingCancel event):
        """
        Actions to be performed when running and receives an order pending cancel event.

        Parameters
        ----------
        event : OrderPendingCancel
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_modify_rejected(self, OrderModifyRejected event):
        """
        Actions to be performed when running and receives an order modify rejected event.

        Parameters
        ----------
        event : OrderModifyRejected
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_cancel_rejected(self, OrderCancelRejected event):
        """
        Actions to be performed when running and receives an order cancel rejected event.

        Parameters
        ----------
        event : OrderCancelRejected
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_updated(self, OrderUpdated event):
        """
        Actions to be performed when running and receives an order updated event.

        Parameters
        ----------
        event : OrderUpdated
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_filled(self, OrderFilled event):
        """
        Actions to be performed when running and receives an order filled event.

        Parameters
        ----------
        event : OrderFilled
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_position_event(self, PositionEvent event):
        """
        Actions to be performed when running and receives a position event.

        Parameters
        ----------
        event : PositionEvent
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_position_opened(self, PositionOpened event):
        """
        Actions to be performed when running and receives a position opened event.

        Parameters
        ----------
        event : PositionOpened
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_position_changed(self, PositionChanged event):
        """
        Actions to be performed when running and receives a position changed event.

        Parameters
        ----------
        event : PositionChanged
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_position_closed(self, PositionClosed event):
        """
        Actions to be performed when running and receives a position closed event.

        Parameters
        ----------
        event : PositionClosed
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass


# -- TRADING COMMANDS -----------------------------------------------------------------------------

    cpdef MarketOrder spawn_market(
        self,
        Order primary,
        Quantity quantity,
        TimeInForce time_in_force = TimeInForce.GTC,
        bint reduce_only = False,
        list[str] tags = None,
        bint reduce_primary = True,
    ):
        """
        Spawn a new ``MARKET`` order from the given primary order.

        Parameters
        ----------
        primary : Order
            The primary order from which this order will spawn.
        quantity : Quantity
            The spawned orders quantity (> 0).
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
            The spawned orders time in force. Often not applicable for market orders.
        reduce_only : bool, default False
            If the spawned order carries the 'reduce-only' execution instruction.
        tags : list[str], optional
            The custom user tags for the order.
        reduce_primary : bool, default True
            If the primary order quantity should be reduced by the given `quantity`.

        Returns
        -------
        MarketOrder

        Raises
        ------
        ValueError
            If `primary.exec_algorithm_id` is not equal to `self.id`.
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `time_in_force` is ``GTD``.

        """
        Condition.not_none(primary, "primary")
        Condition.not_none(quantity, "quantity")
        Condition.equal(primary.exec_algorithm_id, self.id, "primary.exec_algorithm_id", "id")

        if reduce_primary:
            self._reduce_primary_order(primary, spawn_qty=quantity)

        return MarketOrder(
            trader_id=primary.trader_id,
            strategy_id=primary.strategy_id,
            instrument_id=primary.instrument_id,
            client_order_id=self._spawn_client_order_id(primary),
            order_side=primary.side,
            quantity=quantity,
            time_in_force=time_in_force,
            reduce_only=reduce_only,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            contingency_type=primary.contingency_type,
            order_list_id=primary.order_list_id,
            linked_order_ids=primary.linked_order_ids,
            parent_order_id=primary.parent_order_id,
            exec_algorithm_id=self.id,
            exec_spawn_id=primary.client_order_id,
            tags=tags,
        )

    cpdef LimitOrder spawn_limit(
        self,
        Order primary,
        Quantity quantity,
        Price price,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint post_only = False,
        bint reduce_only = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        list[str] tags = None,
        bint reduce_primary = True,
    ):
        """
        Spawn a new ``LIMIT`` order from the given primary order.

        Parameters
        ----------
        primary : Order
            The primary order from which this order will spawn.
        quantity : Quantity
            The spawned orders quantity (> 0). Must be less than `primary.quantity`.
        price : Price
            The spawned orders price.
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
            The spawned orders time in force.
        expire_time : datetime, optional
            The spawned order expiration (for ``GTD`` orders).
        post_only : bool, default False
            If the spawned order will only provide liquidity (make a market).
        reduce_only : bool, default False
            If the spawned order carries the 'reduce-only' execution instruction.
        display_qty : Quantity, optional
            The quantity of the spawned order to display on the public book (iceberg).
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        tags : list[str], optional
            The custom user tags for the order.
        reduce_primary : bool, default True
            If the primary order quantity should be reduced by the given `quantity`.

        Returns
        -------
        LimitOrder

        Raises
        ------
        ValueError
            If `primary.exec_algorithm_id` is not equal to `self.id`.
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.
        ValueError
            If `display_qty` is negative (< 0) or greater than `quantity`.

        """
        Condition.not_none(primary, "primary")
        Condition.not_none(quantity, "quantity")
        Condition.equal(primary.exec_algorithm_id, self.id, "primary.exec_algorithm_id", "id")

        if reduce_primary:
            self._reduce_primary_order(primary, spawn_qty=quantity)

        return LimitOrder(
            trader_id=primary.trader_id,
            strategy_id=primary.strategy_id,
            instrument_id=primary.instrument_id,
            client_order_id=self._spawn_client_order_id(primary),
            order_side=primary.side,
            quantity=quantity,
            price=price,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            post_only=post_only,
            reduce_only=reduce_only,
            display_qty=display_qty,
            emulation_trigger=emulation_trigger,
            contingency_type=primary.contingency_type,
            order_list_id=primary.order_list_id,
            linked_order_ids=primary.linked_order_ids,
            parent_order_id=primary.parent_order_id,
            exec_algorithm_id=self.id,
            exec_spawn_id=primary.client_order_id,
            tags=tags,
        )

    cpdef MarketToLimitOrder spawn_market_to_limit(
        self,
        Order primary,
        Quantity quantity,
        TimeInForce time_in_force = TimeInForce.GTC,
        datetime expire_time = None,
        bint reduce_only = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        list[str] tags = None,
        bint reduce_primary = True,
    ):
        """
        Spawn a new ``MARKET_TO_LIMIT`` order from the given primary order.

        Parameters
        ----------
        primary : Order
            The primary order from which this order will spawn.
        quantity : Quantity
            The spawned orders quantity (> 0). Must be less than `primary.quantity`.
        time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
            The spawned orders time in force.
        expire_time : datetime, optional
            The spawned order expiration (for ``GTD`` orders).
        reduce_only : bool, default False
            If the spawned order carries the 'reduce-only' execution instruction.
        display_qty : Quantity, optional
            The quantity of the spawned order to display on the public book (iceberg).
        emulation_trigger : TriggerType, default ``NO_TRIGGER``
            The type of market price trigger to use for local order emulation.
            - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
            - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
            Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
        tags : list[str], optional
            The custom user tags for the order.
        reduce_primary : bool, default True
            If the primary order quantity should be reduced by the given `quantity`.

        Returns
        -------
        MarketToLimitOrder

        Raises
        ------
        ValueError
            If `primary.exec_algorithm_id` is not equal to `self.id`.
        ValueError
            If `quantity` is not positive (> 0).
        ValueError
            If `time_in_force` is ``GTD`` and `expire_time` <= UNIX epoch.
        ValueError
            If `display_qty` is negative (< 0) or greater than `quantity`.

        """
        Condition.not_none(primary, "primary")
        Condition.not_none(quantity, "quantity")
        Condition.equal(primary.exec_algorithm_id, self.id, "primary.exec_algorithm_id", "id")

        if reduce_primary:
            self._reduce_primary_order(primary, spawn_qty=quantity)

        return MarketToLimitOrder(
            trader_id=primary.trader_id,
            strategy_id=primary.strategy_id,
            instrument_id=primary.instrument_id,
            client_order_id=self._spawn_client_order_id(primary),
            order_side=primary.side,
            quantity=quantity,
            reduce_only=reduce_only,
            display_qty=display_qty,
            init_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
            time_in_force=time_in_force,
            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
            contingency_type=primary.contingency_type,
            order_list_id=primary.order_list_id,
            linked_order_ids=primary.linked_order_ids,
            parent_order_id=primary.parent_order_id,
            exec_algorithm_id=self.id,
            exec_spawn_id=primary.client_order_id,
            tags=tags,
        )

    cpdef void submit_order(self, Order order):
        """
        Submit the given order (may be the primary or spawned order).

        A `SubmitOrder` command will be created and sent to the `RiskEngine`.

        If the client order ID is duplicate, then the order will be denied.

        Parameters
        ----------
        order : Order
            The order to submit.
        parent_order_id : ClientOrderId, optional
            The parent client order identifier. If provided then will be considered a child order
            of the parent.

        Raises
        ------
        ValueError
            If `order.status` is not ``INITIALIZED`` or ``RELEASED``.
        ValueError
            If `order.emulation_trigger` is not ``NO_TRIGGER``.

        Warning
        -------
        If a `position_id` is passed and a position does not yet exist, then any
        position opened by the order will have this position ID assigned. This may
        not be what you intended.

        Emulated orders cannot be sent from execution algorithms (intentionally constraining complexity).

        """
        Condition.is_true(self.trader_id is not None, "The execution algorithm has not been registered")
        Condition.not_none(order, "order")
        Condition.equal(order.emulation_trigger, TriggerType.NO_TRIGGER, "order.emulation_trigger", "NO_TRIGGER")
        Condition.is_true(
            order.status_c() in (OrderStatus.INITIALIZED, OrderStatus.RELEASED),
            "order",
            "order status was not either ``INITIALIZED`` or ``RELEASED``",
        )

        cdef Order primary = None
        cdef PositionId position_id = None
        cdef ClientId client_id = None
        cdef SubmitOrder command = None

        if order.is_spawned_c():
            # Handle new spawned order
            primary = self.cache.order(order.exec_spawn_id)
            Condition.equal(order.strategy_id, primary.strategy_id, "order.strategy_id", "primary.strategy_id")
            if primary is None:
                self._log.error(
                    f"Cannot submit order: cannot find primary order for {order.exec_spawn_id!r}"
                )
                return

            position_id = self.cache.position_id(primary.client_order_id)
            client_id = self.cache.client_id(primary.client_order_id)

            if self.cache.order_exists(order.client_order_id):
                self._log.error(
                    f"Cannot submit order: order already exists for {order.client_order_id!r}",
                )
                return

            # Publish initialized event
            self._msgbus.publish_c(
                topic=f"events.order.{order.strategy_id.to_str()}",
                msg=order.init_event_c(),
            )

            self.cache.add_order(order, position_id, client_id)

            command = SubmitOrder(
                trader_id=self.trader_id,
                strategy_id=primary.strategy_id,
                order=order,
                command_id=UUID4(),
                ts_init=self.clock.timestamp_ns(),
                position_id=primary.position_id,
                client_id=client_id,
            )

            self._send_risk_command(command)
            return

        # Handle primary (original) order
        position_id = self.cache.position_id(order.client_order_id)
        client_id = self.cache.client_id(order.client_order_id)
        cdef Order cached_order = self.cache.order(order.client_order_id)
        if cached_order.order_type != order.order_type:
            self.cache.add_order(order, position_id, client_id, overwrite=True)

        command = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=order.strategy_id,
            order=order,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            position_id=position_id,
            client_id=client_id,
        )

        self._send_risk_command(command)

    cpdef void modify_order(
        self,
        Order order,
        Quantity quantity = None,
        Price price = None,
        Price trigger_price = None,
        ClientId client_id = None,
    ):
        """
        Modify the given order with optional parameters and routing instructions.

        An `ModifyOrder` command will be created and then sent to the `RiskEngine`.

        At least one value must differ from the original order for the command to be valid.

        Will use an Order Cancel/Replace Request (a.k.a Order Modification)
        for FIX protocols, otherwise if order update is not available for
        the API, then will cancel and replace with a new order using the
        original `ClientOrderId`.

        Parameters
        ----------
        order : Order
            The order to update.
        quantity : Quantity, optional
            The updated quantity for the given order.
        price : Price, optional
            The updated price for the given order (if applicable).
        trigger_price : Price, optional
            The updated trigger price for the given order (if applicable).
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.

        Raises
        ------
        ValueError
            If `price` is not ``None`` and order does not have a `price`.
        ValueError
            If `trigger` is not ``None`` and order does not have a `trigger_price`.

        Warnings
        --------
        If the order is already closed or at `PENDING_CANCEL` status
        then the command will not be generated, and a warning will be logged.

        References
        ----------
        https://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_G_71.html

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(order, "order")

        cdef bint updating = False  # Set validation flag (must become true)

        if quantity is not None and quantity != order.quantity:
            updating = True

        if price is not None:
            Condition.is_true(
                order.order_type in LIMIT_ORDER_TYPES,
                fail_msg=f"{order.type_string_c()} orders do not have a LIMIT price",
            )
            if price != order.price:
                updating = True

        if trigger_price is not None:
            Condition.is_true(
                order.order_type in STOP_ORDER_TYPES,
                fail_msg=f"{order.type_string_c()} orders do not have a STOP trigger price",
            )
            if trigger_price != order.trigger_price:
                updating = True

        if not updating:
            self.log.error(
                "Cannot create command ModifyOrder: "
                "quantity, price and trigger were either None "
                "or the same as existing values.",
            )
            return

        if order.is_closed_c() or order.is_pending_cancel_c():
            self.log.warning(
                f"Cannot create command ModifyOrder: "
                f"state is {order.status_string_c()}, {order}.",
            )
            return  # Cannot send command

        cdef OrderPendingUpdate event
        if not order.is_active_local_c():
            # Generate and apply event
            event = self._generate_order_pending_update(order)
            try:
                order.apply(event)
            except InvalidStateTrigger as e:  # pragma: no cover
                self._log.warning(f"InvalidStateTrigger: {e}, did not apply {event}")
                return

            self.cache.update_order(order)

            # Publish event
            self._msgbus.publish_c(
                topic=f"events.order.{order.strategy_id.to_str()}",
                msg=event,
            )

        cdef ModifyOrder command = ModifyOrder(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            quantity=quantity,
            price=price,
            trigger_price=trigger_price,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            client_id=client_id,
        )

        self._send_risk_command(command)

    cpdef void modify_order_in_place(
        self,
        Order order,
        Quantity quantity = None,
        Price price = None,
        Price trigger_price = None,
    ):
        """
        Modify the given ``INITIALIZED`` order in place (immediately) with optional parameters.

        At least one value must differ from the original order for the command to be valid.

        Parameters
        ----------
        order : Order
            The order to update.
        quantity : Quantity, optional
            The updated quantity for the given order.
        price : Price, optional
            The updated price for the given order (if applicable).
        trigger_price : Price, optional
            The updated trigger price for the given order (if applicable).

        Raises
        ------
        ValueError
            If `order.status` is not ``INITIALIZED`` or ``RELEASED``.
        ValueError
            If `price` is not ``None`` and order does not have a `price`.
        ValueError
            If `trigger` is not ``None`` and order does not have a `trigger_price`.

        Warnings
        --------
        If the order is already closed or at `PENDING_CANCEL` status
        then the command will not be generated, and a warning will be logged.

        References
        ----------
        https://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_G_71.html

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(order, "order")
        Condition.is_true(
            order.status_c() in (OrderStatus.INITIALIZED, OrderStatus.RELEASED),
            "order",
            "order status was not either ``INITIALIZED`` or ``RELEASED``",
        )

        cdef bint updating = False  # Set validation flag (must become true)

        if quantity is not None and quantity != order.quantity:
            updating = True

        if price is not None:
            Condition.is_true(
                order.order_type in LIMIT_ORDER_TYPES,
                fail_msg=f"{order.type_string_c()} orders do not have a LIMIT price",
            )
            if price != order.price:
                updating = True

        if trigger_price is not None:
            Condition.is_true(
                order.order_type in STOP_ORDER_TYPES,
                fail_msg=f"{order.type_string_c()} orders do not have a STOP trigger price",
            )
            if trigger_price != order.trigger_price:
                updating = True

        if not updating:
            self.log.error(
                "Cannot create command ModifyOrder: "
                "quantity, price and trigger were either None "
                "or the same as existing values.",
            )
            return

        if order.is_closed_c() or order.is_pending_cancel_c():
            self.log.warning(
                f"Cannot create command ModifyOrder: "
                f"state is {order.status_string_c()}, {order}.",
            )
            return  # Cannot send command

        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()

        cdef OrderUpdated updated = OrderUpdated(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id,
            quantity=quantity or order.quantity,
            price=price,
            trigger_price=trigger_price,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

        order.apply(updated)
        self.cache.update_order(order)

    cpdef void cancel_order(self, Order order, ClientId client_id = None):
        """
        Cancel the given order with optional routing instructions.

        A `CancelOrder` command will be created and then sent to **either** the
        `OrderEmulator` or the `ExecutionEngine` (depending on whether the order is emulated).

        Logs an error if no `VenueOrderId` has been assigned to the order.

        Parameters
        ----------
        order : Order
            The order to cancel.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(order, "order")

        if order.is_closed_c() or order.is_pending_cancel_c():
            self.log.warning(
                f"Cannot cancel order: state is {order.status_string_c()}, {order}.",
            )
            return  # Cannot send command

        cdef OrderPendingCancel event
        if not order.is_active_local_c():
            # Generate and apply event
            event = self._generate_order_pending_cancel(order)
            try:
                order.apply(event)
            except InvalidStateTrigger as e:  # pragma: no cover
                self._log.warning(f"InvalidStateTrigger: {e}, did not apply {event}")
                return

            self.cache.update_order(order)

            # Publish event
            self._msgbus.publish_c(
                topic=f"events.order.{order.strategy_id.to_str()}",
                msg=event,
            )

        cdef CancelOrder command = CancelOrder(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            client_id=client_id,
        )

        if order.is_emulated_c() or order.status_c() == OrderStatus.RELEASED:
            self._send_emulator_command(command)
        else:
            self._send_exec_command(command)

# -- EVENTS ---------------------------------------------------------------------------------------

    cdef OrderPendingUpdate _generate_order_pending_update(self, Order order):
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        return OrderPendingUpdate(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

    cdef OrderPendingCancel _generate_order_pending_cancel(self, Order order):
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        return OrderPendingCancel(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

    cdef OrderCanceled _generate_order_canceled(self, Order order):
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        return OrderCanceled(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

# -- EGRESS ---------------------------------------------------------------------------------------

    cdef void _send_emulator_command(self, TradingCommand command):
        if self._log_commands and is_logging_initialized():
            self.log.info(f"{CMD}{SENT} {command}.")
        self._msgbus.send(endpoint="OrderEmulator.execute", msg=command)

    cdef void _send_risk_command(self, TradingCommand command):
        if self._log_commands and is_logging_initialized():
            self.log.info(f"{CMD}{SENT} {command}.")
        self._msgbus.send(endpoint="RiskEngine.execute", msg=command)

    cdef void _send_exec_command(self, Command command):
        if self._log_commands and is_logging_initialized():
            self.log.info(f"{CMD}{SENT} {command}.")
        self._msgbus.send(endpoint="ExecEngine.execute", msg=command)

</document_content>
</document>
<document index="2338">
<source>nautilus_trader/execution/client.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.common.config import NautilusConfig
from nautilus_trader.execution.reports import ExecutionMassStatus
from nautilus_trader.execution.reports import FillReport
from nautilus_trader.execution.reports import OrderStatusReport
from nautilus_trader.execution.reports import PositionStatusReport

from libc.stdint cimport uint64_t

from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Component
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport QueryAccount
from nautilus_trader.execution.messages cimport QueryOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.model.events.account cimport AccountState
from nautilus_trader.model.events.order cimport OrderAccepted
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderCancelRejected
from nautilus_trader.model.events.order cimport OrderDenied
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderModifyRejected
from nautilus_trader.model.events.order cimport OrderPendingCancel
from nautilus_trader.model.events.order cimport OrderPendingUpdate
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderSubmitted
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TradeId
from nautilus_trader.model.identifiers cimport VenueOrderId
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class ExecutionClient(Component):
    """
    The base class for all execution clients.

    Parameters
    ----------
    client_id : ClientId
        The client ID.
    venue : Venue or ``None``
        The client venue. If multi-venue then can be ``None``.
    oms_type : OmsType
        The venues order management system type.
    account_type : AccountType
        The account type for the client.
    base_currency : Currency or ``None``
        The account base currency. Use ``None`` for multi-currency accounts.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : Clock
        The clock for the client.
    config : NautilusConfig, optional
        The configuration for the instance.

    Raises
    ------
    ValueError
        If `client_id` is not equal to `account_id.get_issuer()`.
    ValueError
        If `oms_type` is ``UNSPECIFIED`` (must be specified).

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        ClientId client_id not None,
        Venue venue: Venue | None,
        OmsType oms_type,
        AccountType account_type,
        Currency base_currency: Currency | None,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
        config: NautilusConfig | None = None,
    ):
        Condition.not_equal(oms_type, OmsType.UNSPECIFIED, "oms_type", "UNSPECIFIED")

        super().__init__(
            clock=clock,
            component_id=client_id,
            component_name=f"ExecClient-{client_id}",
            msgbus=msgbus,
            config=config,
        )

        self._cache = cache

        self.trader_id = msgbus.trader_id
        self.venue = venue
        self.oms_type = oms_type
        self.account_id = None  # Initialized on connection
        self.account_type = account_type
        self.base_currency = base_currency

        self.is_connected = False

    def __repr__(self) -> str:
        return f"{type(self).__name__}-{self.id.value}"

    cpdef void _set_connected(self, bint value=True):
        # Setter for Python implementations to change the readonly property
        self.is_connected = value

    cpdef void _set_account_id(self, AccountId account_id):
        Condition.not_none(account_id, "account_id")
        Condition.equal(self.id.to_str(), account_id.get_issuer(), "id.value", "account_id.get_issuer()")

        self.account_id = account_id

    cpdef Account get_account(self):
        """
        Return the account for the client (if registered).

        Returns
        -------
        Account or ``None``

        """
        return self._cache.account(self.account_id)

# -- COMMAND HANDLERS -----------------------------------------------------------------------------

    cpdef void submit_order(self, SubmitOrder command):
        """
        Submit the order contained in the given command for execution.

        Parameters
        ----------
        command : SubmitOrder
            The command to execute.

        """
        self._log.error(  # pragma: no cover
            f"Cannot execute command {command}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `submit_order` method for this client",  # pragma: no cover  # noqa
        )
        raise NotImplementedError("method `submit_order` must be implemented in the subclass")

    cpdef void submit_order_list(self, SubmitOrderList command):
        """
        Submit the order list contained in the given command for execution.

        Parameters
        ----------
        command : SubmitOrderList
            The command to execute.

        """
        self._log.error(  # pragma: no cover
            f"Cannot execute command {command}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `submit_order_list` method for this client",  # pragma: no cover   # noqa
        )
        raise NotImplementedError("method `submit_order_list` must be implemented in the subclass")

    cpdef void modify_order(self, ModifyOrder command):
        """
        Modify the order with parameters contained in the command.

        Parameters
        ----------
        command : ModifyOrder
            The command to execute.

        """
        self._log.error(  # pragma: no cover
            f"Cannot execute command {command}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `modify_order` method for this client",  # pragma: no cover  # noqa
        )
        raise NotImplementedError("method `modify_order` must be implemented in the subclass")

    cpdef void cancel_order(self, CancelOrder command):
        """
        Cancel the order with the client order ID contained in the given command.

        Parameters
        ----------
        command : CancelOrder
            The command to execute.

        """
        self._log.error(  # pragma: no cover
            f"Cannot execute command {command}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `cancel_order` method for this client",  # pragma: no cover  # noqa
        )
        raise NotImplementedError("method `cancel_order` must be implemented in the subclass")

    cpdef void cancel_all_orders(self, CancelAllOrders command):
        """
        Cancel all orders for the instrument ID contained in the given command.

        Parameters
        ----------
        command : CancelAllOrders
            The command to execute.

        """
        self._log.error(  # pragma: no cover
            f"Cannot execute command {command}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `cancel_all_orders` method for this client",  # pragma: no cover  # noqa
        )
        raise NotImplementedError("method `cancel_all_orders` must be implemented in the subclass")

    cpdef void batch_cancel_orders(self, BatchCancelOrders command):
        """
        Batch cancel orders for the instrument ID contained in the given command.

        Parameters
        ----------
        command : BatchCancelOrders
            The command to execute.

        """
        self._log.error(  # pragma: no cover
            f"Cannot execute command {command}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `batch_cancel_orders` method for this client",  # pragma: no cover  # noqa
        )
        raise NotImplementedError("method `batch_cancel_orders` must be implemented in the subclass")

    cpdef void query_account(self, QueryAccount command):
        """
        Query the account specified by the command which will generate an `AccountState` event.

        Parameters
        ----------
        command : QueryAccount
            The command to execute.

        """
        self._log.error(  # pragma: no cover
            f"Cannot execute command {command}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `query_account` method for this client",  # pragma: no cover  # noqa
        )
        raise NotImplementedError("method `query_account` must be implemented in the subclass")

    cpdef void query_order(self, QueryOrder command):
        """
        Initiate a reconciliation for the queried order which will generate an
        `OrderStatusReport`.

        Parameters
        ----------
        command : QueryOrder
            The command to execute.

        """
        self._log.error(  # pragma: no cover
            f"Cannot execute command {command}: not implemented. "  # pragma: no cover
            f"You can implement by overriding the `query_order` method for this client",  # pragma: no cover  # noqa
        )
        raise NotImplementedError("method `query_order` must be implemented in the subclass")

# -- EVENT HANDLERS -------------------------------------------------------------------------------

    cpdef void generate_account_state(
        self,
        list balances,
        list margins,
        bint reported,
        uint64_t ts_event,
        dict info = None,
    ):
        """
        Generate an `AccountState` event and publish on the message bus.

        Parameters
        ----------
        balances : list[AccountBalance]
            The account balances.
        margins : list[MarginBalance]
            The margin balances.
        reported : bool
            If the balances are reported directly from the exchange.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the account state event occurred.
        info : dict [str, object]
            The additional implementation specific account information.

        """
        # Generate event
        cdef AccountState account_state = AccountState(
            account_id=self.account_id,
            account_type=self.account_type,
            base_currency=self.base_currency,
            reported=reported,
            balances=balances,
            margins=margins,
            info=info or {},
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_account_state(account_state)

    cpdef void generate_order_denied(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        str reason,
        uint64_t ts_event,
    ):
        """
        Generate an `OrderDenied` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        reason : str
            The order denied reason.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order denied event occurred.

        """
        Condition.not_none(instrument_id, "instrument_id")

        # Generate event
        cdef OrderDenied denied = OrderDenied(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            reason=reason,
            event_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
        )
        denied._mem.ts_event = ts_event

        self._send_order_event(denied)

    cpdef void generate_order_submitted(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        uint64_t ts_event,
    ):
        """
        Generate an `OrderSubmitted` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order submitted event occurred.

        """
        # Generate event
        cdef OrderSubmitted submitted = OrderSubmitted(
            trader_id=self._msgbus.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            account_id=self.account_id,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_order_event(submitted)

    cpdef void generate_order_rejected(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        str reason,
        uint64_t ts_event,
        bint due_post_only=False,
    ):
        """
        Generate an `OrderRejected` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        reason : datetime
            The order rejected reason.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order rejected event occurred.
        due_post_only : bool, default False
            If the order was rejected because it was post-only and would execute immediately as a taker.

        """
        # Generate event
        cdef OrderRejected rejected = OrderRejected(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            account_id=self.account_id,
            reason=reason,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
            due_post_only=due_post_only,
        )

        self._send_order_event(rejected)

    cpdef void generate_order_accepted(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        uint64_t ts_event,
    ):
        """
        Generate an `OrderAccepted` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        venue_order_id : VenueOrderId
            The venue order ID (assigned by the venue).
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order accepted event occurred.

        """
        # Generate event
        cdef OrderAccepted accepted = OrderAccepted(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=self.account_id,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_order_event(accepted)

    cpdef void generate_order_modify_rejected(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        str reason,
        uint64_t ts_event,
    ):
        """
        Generate an `OrderModifyRejected` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        venue_order_id : VenueOrderId
            The venue order ID (assigned by the venue).
        reason : str
            The order update rejected reason.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order update rejection event occurred.

        """
        # Generate event
        cdef OrderModifyRejected modify_rejected = OrderModifyRejected(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=self.account_id,
            reason=reason,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_order_event(modify_rejected)

    cpdef void generate_order_cancel_rejected(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        str reason,
        uint64_t ts_event,
    ):
        """
        Generate an `OrderCancelRejected` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        venue_order_id : VenueOrderId
            The venue order ID (assigned by the venue).
        reason : str
            The order cancel rejected reason.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order cancel rejected event occurred.

        """
        # Generate event
        cdef OrderCancelRejected cancel_rejected = OrderCancelRejected(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=self.account_id,
            reason=reason,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_order_event(cancel_rejected)

    cpdef void generate_order_updated(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        Quantity quantity,
        Price price,
        Price trigger_price,
        uint64_t ts_event,
        bint venue_order_id_modified=False,
    ):
        """
        Generate an `OrderUpdated` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        venue_order_id : VenueOrderId
            The venue order ID (assigned by the venue).
        quantity : Quantity
            The orders current quantity.
        price : Price
            The orders current price.
        trigger_price : Price or ``None``
            The orders current trigger price.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order update event occurred.
        venue_order_id_modified : bool
            If the ID was modified for this event.

        """
        Condition.not_none(client_order_id, "client_order_id")
        Condition.not_none(venue_order_id, "venue_order_id")

        # Check venue_order_id against cache, only allow modification when `venue_order_id_modified=True`
        if not venue_order_id_modified:
            existing = self._cache.venue_order_id(client_order_id)
            if existing is not None:
                Condition.equal(existing, venue_order_id, "existing", "order.venue_order_id")
            else:
                self._log.warning(f"{venue_order_id} does not match existing {repr(existing)}")

        # Generate event
        cdef OrderUpdated updated = OrderUpdated(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=self.account_id,
            quantity=quantity,
            price=price,
            trigger_price=trigger_price,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_order_event(updated)

    cpdef void generate_order_canceled(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        uint64_t ts_event,
    ):
        """
        Generate an `OrderCanceled` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        venue_order_id : VenueOrderId
            The venue order ID (assigned by the venue).
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when order canceled event occurred.

        """
        # Generate event
        cdef OrderCanceled canceled = OrderCanceled(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=self.account_id,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_order_event(canceled)

    cpdef void generate_order_triggered(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        uint64_t ts_event,
    ):
        """
        Generate an `OrderTriggered` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        venue_order_id : VenueOrderId
            The venue order ID (assigned by the venue).
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order triggered event occurred.

        """
        # Generate event
        cdef OrderTriggered triggered = OrderTriggered(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=self.account_id,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_order_event(triggered)

    cpdef void generate_order_expired(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        uint64_t ts_event,
    ):
        """
        Generate an `OrderExpired` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        venue_order_id : VenueOrderId
            The venue order ID (assigned by the venue).
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order expired event occurred.

        """
        # Generate event
        cdef OrderExpired expired = OrderExpired(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=self.account_id,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
        )

        self._send_order_event(expired)

    cpdef void generate_order_filled(
        self,
        StrategyId strategy_id,
        InstrumentId instrument_id,
        ClientOrderId client_order_id,
        VenueOrderId venue_order_id,
        PositionId venue_position_id: PositionId | None,
        TradeId trade_id,
        OrderSide order_side,
        OrderType order_type,
        Quantity last_qty,
        Price last_px,
        Currency quote_currency,
        Money commission,
        LiquiditySide liquidity_side,
        uint64_t ts_event,
        dict info = None,
    ):
        """
        Generate an `OrderFilled` event and send it to the `ExecutionEngine`.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID associated with the event.
        instrument_id : InstrumentId
            The instrument ID.
        client_order_id : ClientOrderId
            The client order ID.
        venue_order_id : VenueOrderId
            The venue order ID (assigned by the venue).
        trade_id : TradeId
            The trade ID.
        venue_position_id : PositionId or ``None``
            The venue position ID associated with the order. If the trading
            venue has assigned a position ID / ticket then pass that here,
            otherwise pass ``None`` and the execution engine OMS will handle
            position ID resolution.
        order_side : OrderSide {``BUY``, ``SELL``}
            The execution order side.
        order_type : OrderType
            The execution order type.
        last_qty : Quantity
            The fill quantity for this execution.
        last_px : Price
            The fill price for this execution (not average price).
        quote_currency : Currency
            The currency of the price.
        commission : Money
            The fill commission.
        liquidity_side : LiquiditySide {``NO_LIQUIDITY_SIDE``, ``MAKER``, ``TAKER``}
            The execution liquidity side.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the order filled event occurred.
        info : dict[str, object], optional
            The additional fill information.

        """
        Condition.not_none(instrument_id, "instrument_id")

        # Generate event
        cdef OrderFilled fill = OrderFilled(
            trader_id=self.trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            account_id=self.account_id,
            trade_id=trade_id,
            position_id=venue_position_id,
            order_side=order_side,
            order_type=order_type,
            last_qty=last_qty,
            last_px=last_px,
            currency=quote_currency,
            commission=commission,
            liquidity_side=liquidity_side,
            event_id=UUID4(),
            ts_event=ts_event,
            ts_init=self._clock.timestamp_ns(),
            info=info,
        )

        self._send_order_event(fill)

# --------------------------------------------------------------------------------------------------

    cpdef void _send_account_state(self, account_state: AccountState):
        self._msgbus.send(
            endpoint=f"Portfolio.update_account",
            msg=account_state,
        )

    cpdef void _send_order_event(self, event: OrderEvent):
        self._msgbus.send(
            endpoint="ExecEngine.process",
            msg=event,
        )

    cpdef void _send_mass_status_report(self, report: ExecutionMassStatus):
        self._msgbus.send(
            endpoint="ExecEngine.reconcile_execution_mass_status",
            msg=report,
        )

    cpdef void _send_order_status_report(self, report: OrderStatusReport):
        self._msgbus.send(
            endpoint="ExecEngine.reconcile_execution_report",
            msg=report,
        )

    cpdef void _send_fill_report(self, report: FillReport):
        self._msgbus.send(
            endpoint="ExecEngine.reconcile_execution_report",
            msg=report,
        )

    cpdef void _send_position_status_report(self, report: PositionStatusReport):
        self._msgbus.send(
            endpoint="ExecEngine.reconcile_execution_report",
            msg=report,
        )

</document_content>
</document>
<document index="2341">
<source>nautilus_trader/execution/emulator.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.common.config import OrderEmulatorConfig

from libc.stdint cimport uint8_t
from libc.stdint cimport uint64_t

from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.actor cimport Actor
from nautilus_trader.common.component cimport CMD
from nautilus_trader.common.component cimport EVT
from nautilus_trader.common.component cimport RECV
from nautilus_trader.common.component cimport SENT
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport is_logging_initialized
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.execution.manager cimport OrderManager
from nautilus_trader.execution.matching_core cimport MatchingCore
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport TradingCommand
from nautilus_trader.execution.trailing cimport TrailingStopCalculator
from nautilus_trader.model.book cimport OrderBook
from nautilus_trader.model.data cimport OrderBookDeltas
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderEmulated
from nautilus_trader.model.events.order cimport OrderEvent
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderReleased
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.limit cimport LimitOrder
from nautilus_trader.model.orders.market cimport MarketOrder
from nautilus_trader.portfolio.base cimport PortfolioFacade


cdef set SUPPORTED_TRIGGERS = {TriggerType.DEFAULT, TriggerType.BID_ASK, TriggerType.LAST_PRICE}


cdef class OrderEmulator(Actor):
    """
    Provides order emulation for specified trigger types.

    Parameters
    ----------
    portfolio : PortfolioFacade
        The read-only portfolio for the order emulator.
    msgbus : MessageBus
        The message bus for the order emulator.
    cache : Cache
        The cache for the order emulator.
    clock : Clock
        The clock for the order emulator.
    config : OrderEmulatorConfig, optional
        The configuration for the order emulator.

    """

    def __init__(
        self,
        PortfolioFacade portfolio,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
        config: OrderEmulatorConfig | None = None,
    ):
        if config is None:
            config = OrderEmulatorConfig()
        Condition.type(config, OrderEmulatorConfig, "config")
        super().__init__()

        self.register_base(
            portfolio=portfolio,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
        )

        self._manager = OrderManager(
            clock=clock,
            msgbus=msgbus,
            cache=cache,
            component_name=type(self).__name__,
            active_local=True,
            submit_order_handler=self._handle_submit_order,
            cancel_order_handler=self._cancel_order,
            modify_order_handler=self._update_order,
            debug=config.debug,
        )

        self._matching_cores: dict[InstrumentId, MatchingCore]  = {}

        self._subscribed_quotes: set[InstrumentId] = set()
        self._subscribed_trades: set[InstrumentId] = set()
        self._subscribed_strategies: set[StrategyId] = set()
        self._monitored_positions: set[PositionId] = set()

        # Configuration
        self.debug: bool = config.debug

        # Counters
        self.command_count: int = 0
        self.event_count: int = 0

        # Register endpoints
        self._msgbus.register(endpoint="OrderEmulator.execute", handler=self.execute)

    @property
    def subscribed_quotes(self) -> list[InstrumentId]:
        """
        Return the subscribed quote feeds for the emulator.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscribed_quotes))

    @property
    def subscribed_trades(self) -> list[InstrumentId]:
        """
        Return the subscribed trade feeds for the emulator.

        Returns
        -------
        list[InstrumentId]

        """
        return sorted(list(self._subscribed_trades))

    def get_submit_order_commands(self) -> dict[ClientOrderId, SubmitOrder]:
        """
        Return the emulators cached submit order commands.

        Returns
        -------
        dict[ClientOrderId, SubmitOrder]

        """
        return self._manager.get_submit_order_commands()

    def get_matching_core(self, InstrumentId instrument_id) -> MatchingCore | None:
        """
        Return the emulators matching core for the given instrument ID.

        Returns
        -------
        MatchingCore or ``None``

        """
        return self._matching_cores.get(instrument_id)

# -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------

    cpdef void on_start(self):
        cdef list emulated_orders = self.cache.orders_emulated()
        if not emulated_orders:
            self._log.info("No emulated orders to reactivate")
            return

        cdef:
            Order order
            SubmitOrder command
            PositionId position_id
            ClientId client_id
        for order in emulated_orders:
            if order.status_c() not in (OrderStatus.INITIALIZED, OrderStatus.EMULATED):
                continue  # No longer emulated

            if order.parent_order_id is not None:
                parent_order = self.cache.order(order.parent_order_id)
                if parent_order is None:
                    self._log.error("Cannot handle order: parent {order.parent_order_id!r} not found")
                    continue
                position_id = parent_order.position_id
                if parent_order.is_closed_c() and (position_id is None or self.cache.is_position_closed(position_id)):
                    self._manager.cancel_order(order=order)
                    continue  # Parent already closed
                if parent_order.contingency_type == ContingencyType.OTO:
                    if parent_order.is_active_local_c() or parent_order.filled_qty == 0:
                        continue  # Process contingency order later once parent triggered

            position_id = self.cache.position_id(order.client_order_id)
            client_id = self.cache.client_id(order.client_order_id)
            command = SubmitOrder(
                trader_id=self.trader_id,
                strategy_id=order.strategy_id,
                order=order,
                command_id=UUID4(),
                ts_init=self.clock.timestamp_ns(),
                position_id=position_id,
                client_id=client_id,
            )

            self._handle_submit_order(command)

    cpdef void on_event(self, Event event):
        """
        Handle the given `event`.

        Parameters
        ----------
        event : Event
            The received event to handle.

        """
        Condition.not_none(event, "event")

        if self.debug:
            self._log.info(f"{RECV}{EVT} {event}.", LogColor.MAGENTA)
        self.event_count += 1

        self._manager.handle_event(event)

        if not isinstance(event, OrderEvent):
            return

        cdef Order order = self.cache.order(event.client_order_id)
        if order is None:
            return  # Order not in cache yet

        cdef MatchingCore matching_core = None
        if order.is_closed_c():
            matching_core = self._matching_cores.get(order.instrument_id)
            if matching_core is not None:
                matching_core.delete_order(order)

    cpdef void on_stop(self):
        pass

    cpdef void on_reset(self):
        self._manager.reset()
        self._matching_cores.clear()

        self.command_count = 0
        self.event_count = 0

    cpdef void on_dispose(self):
        pass

# -------------------------------------------------------------------------------------------------

    cpdef void execute(self, TradingCommand command):
        """
        Execute the given command.

        Parameters
        ----------
        command : TradingCommand
            The command to execute.

        """
        Condition.not_none(command, "command")

        if self.debug:
            self._log.info(f"{RECV}{CMD} {command}", LogColor.MAGENTA)
        self.command_count += 1

        if isinstance(command, SubmitOrder):
            self._handle_submit_order(command)
        elif isinstance(command, SubmitOrderList):
            self._handle_submit_order_list(command)
        elif isinstance(command, ModifyOrder):
            self._handle_modify_order(command)
        elif isinstance(command, CancelOrder):
            self._handle_cancel_order(command)
        elif isinstance(command, CancelAllOrders):
            self._handle_cancel_all_orders(command)
        else:
            self._log.error(f"Cannot handle command: unrecognized {command}")

    cpdef MatchingCore create_matching_core(
        self,
        InstrumentId instrument_id,
        Price price_increment,
    ):
        """
        Create an internal matching core for the given `instrument`.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the matching core.
        price_increment : Price
            The minimum price increment (tick size) for the matching core.

        Returns
        -------
        MatchingCore

        Raises
        ------
        KeyError
            If a matching core for the given `instrument_id` already exists.

        """
        Condition.not_in(instrument_id, self._matching_cores, "instrument_id", "self._matching_cores")

        matching_core = MatchingCore(
            instrument_id=instrument_id,
            price_increment=price_increment,
            trigger_stop_order=self._trigger_stop_order,
            fill_market_order=self._fill_market_order,
            fill_limit_order=self._fill_limit_order,
        )

        self._matching_cores[instrument_id] = matching_core

        if self.debug:
            self._log.info(f"Created matching core for {instrument_id}", LogColor.MAGENTA)

        return matching_core

    cdef void _handle_submit_order(self, SubmitOrder command):
        cdef Order order = command.order
        cdef TriggerType emulation_trigger = command.order.emulation_trigger
        Condition.not_equal(emulation_trigger, TriggerType.NO_TRIGGER, "command.order.emulation_trigger", "TriggerType.NO_TRIGGER")
        Condition.not_in(command.order.client_order_id, self._manager.get_submit_order_commands(), "command.order.client_order_id", "manager.submit_order_commands")

        if emulation_trigger not in SUPPORTED_TRIGGERS:
            self._log.error(
                f"Cannot emulate order: `TriggerType` {trigger_type_to_str(emulation_trigger)} not supported")
            self._manager.cancel_order(order=order)
            return

        self._check_monitoring(command.strategy_id, command.position_id)

        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
        if matching_core is None:
            if trigger_instrument_id.is_synthetic():
                synthetic = self.cache.synthetic(trigger_instrument_id)
                if synthetic is None:
                    self._log.error(
                        f"Cannot emulate order: no synthetic instrument {trigger_instrument_id} for trigger",
                    )
                    self._manager.cancel_order(order=order)
                    return
                matching_core = self.create_matching_core(synthetic.id, synthetic.price_increment)
            else:
                instrument = self.cache.instrument(trigger_instrument_id)
                if instrument is None:
                    self._log.error(
                        f"Cannot emulate order: no instrument {trigger_instrument_id} for trigger",
                    )
                    self._manager.cancel_order(order=order)
                    return
                matching_core = self.create_matching_core(instrument.id, instrument.price_increment)

        # Update trailing stop
        if order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
            self._trail_stop_order(matching_core, order)

        # Cache command
        self._manager.cache_submit_order_command(command)

        # Check if immediately marketable (initial match)
        matching_core.match_order(order, initial=True)

        # Check data subscription
        if emulation_trigger == TriggerType.DEFAULT or emulation_trigger == TriggerType.BID_ASK:
            if trigger_instrument_id not in self._subscribed_quotes:
                if not trigger_instrument_id.is_synthetic():
                    self.subscribe_order_book_deltas(trigger_instrument_id)
                self.subscribe_quote_ticks(trigger_instrument_id)
                self._subscribed_quotes.add(trigger_instrument_id)
        elif emulation_trigger == TriggerType.LAST_PRICE:
            if trigger_instrument_id not in self._subscribed_trades:
                self.subscribe_trade_ticks(trigger_instrument_id)
                self._subscribed_trades.add(trigger_instrument_id)
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `TriggerType`, was {emulation_trigger}",  # pragma: no cover (design-time error)
            )

        if order.client_order_id not in self._manager.get_submit_order_commands():
            return  # Already released

        # Hold in matching core
        matching_core.add_order(order)

        cdef OrderEmulated event
        if order.status_c() == OrderStatus.INITIALIZED:
            # Generate event
            event = OrderEmulated(
                trader_id=order.trader_id,
                strategy_id=order.strategy_id,
                instrument_id=order.instrument_id,
                client_order_id=order.client_order_id,
                event_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
            )
            order.apply(event)
            self.cache.update_order(order)

            self._manager.send_risk_event(event)

            # Publish event
            self._msgbus.publish_c(
                topic=f"events.order.{order.strategy_id.to_str()}",
                msg=event,
            )

        self._log.info(f"Emulating {command.order}", LogColor.MAGENTA)

    cdef void _handle_submit_order_list(self, SubmitOrderList command):
        self._check_monitoring(command.strategy_id, command.position_id)

        cdef Order order
        for order in command.order_list.orders:
            if order.parent_order_id is not None:
                parent_order = self.cache.order(order.parent_order_id)
                assert parent_order, f"Parent order for {repr(order.client_order_id)} not found"
                if parent_order.contingency_type == ContingencyType.OTO:
                    continue  # Process contingency order later once parent triggered
            self._manager.create_new_submit_order(
                order=order,
                position_id=command.position_id,
                client_id=command.client_id,
            )

    cdef void _handle_modify_order(self, ModifyOrder command):
        cdef Order order = self.cache.order(command.client_order_id)
        if order is None:
            self._log.error(
                f"Cannot modify order: {repr(order.client_order_id)} not found",
            )
            return

        cdef Price price = command.price
        if price is None and order.has_price_c():
            price = order.price

        cdef Price trigger_price = command.trigger_price
        if trigger_price is None and order.has_trigger_price_c():
            trigger_price = order.trigger_price

        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderUpdated event = OrderUpdated(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,  # Could be None
            account_id=order.account_id,  # Could be None
            quantity=command.quantity or order.quantity,
            price=price,
            trigger_price=trigger_price,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self._manager.send_exec_event(event)

        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
        if matching_core is None:
            self._log.error(
                f"Cannot handle `ModifyOrder`: no matching core for trigger instrument {trigger_instrument_id}",
            )
            return

        matching_core.match_order(order)
        if order.side == OrderSide.BUY:
            matching_core.sort_bid_orders()
        elif order.side == OrderSide.SELL:
            matching_core.sort_ask_orders()
        else:
            raise RuntimeError("invalid `OrderSide`")  # pragma: no cover (design-time error)

    cdef void _handle_cancel_order(self, CancelOrder command):
        cdef Order order = self.cache.order(command.client_order_id)
        if order is None:
            self._log.error(
                f"Cannot cancel order: {repr(command.client_order_id)} not found",
            )
            return

        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
        if matching_core is None:
            self._manager.cancel_order(order)
            return

        if not matching_core.order_exists(order.client_order_id) and order.is_open_c() and not order.is_pending_cancel_c():
            # Order not held in the emulator
            self._manager.send_exec_command(command)
        else:
            self._manager.cancel_order(order)

    cdef void _handle_cancel_all_orders(self, CancelAllOrders command):
        cdef MatchingCore matching_core = self._matching_cores.get(command.instrument_id)
        if matching_core is None:
            # No orders to cancel
            return

        cdef list orders
        if command.order_side == OrderSide.NO_ORDER_SIDE:
            orders = matching_core.get_orders()
        elif command.order_side == OrderSide.BUY:
            orders = matching_core.get_orders_bid()
        elif command.order_side == OrderSide.SELL:
            orders = matching_core.get_orders_ask()
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `OrderSide`, was {command.order_side}",  # pragma: no cover (design-time error)
            )

        cdef Order order
        for order in orders:
            self._manager.cancel_order(order)

    cpdef void _check_monitoring(self, StrategyId strategy_id, PositionId position_id):
        if strategy_id not in self._subscribed_strategies:
            # Subscribe to all strategy events
            self._msgbus.subscribe(topic=f"events.order.{strategy_id.to_str()}", handler=self.on_event)
            self._msgbus.subscribe(topic=f"events.position.{strategy_id.to_str()}", handler=self.on_event)
            self._subscribed_strategies.add(strategy_id)
            self._log.info(f"Subscribed to strategy {strategy_id.to_str()} order and position events", LogColor.BLUE)

        if position_id is not None and position_id not in self._monitored_positions:
            self._monitored_positions.add(position_id)

    cpdef void _cancel_order(self, Order order):
        if order is None:
            self._log.error(
                f"Cannot cancel order: order for {repr(order.client_order_id)} not found",
            )
            return

        if self.debug:
            self._log.info(f"Canceling order {order.client_order_id!r}", LogColor.MAGENTA)

        # Remove emulation trigger
        order.emulation_trigger = TriggerType.NO_TRIGGER

        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
        if matching_core is not None:
            matching_core.delete_order(order)

        self.cache.update_order_pending_cancel_local(order)

        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderCanceled event = OrderCanceled(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,  # Probably None
            account_id=order.account_id,  # Probably None
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        self._manager.send_exec_event(event)

    cpdef void _update_order(self, Order order, Quantity new_quantity):
        if order is None:
            self._log.error(
                f"Cannot update order: order for {repr(order.client_order_id)} not found",
            )
            return

        if self.debug:
            self._log.info(
                f"Updating order {order.client_order_id} quantity to {new_quantity}",
                LogColor.MAGENTA,
            )

        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderUpdated event = OrderUpdated(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=None,  # Not yet assigned by any venue
            account_id=order.account_id,  # Probably None
            quantity=new_quantity,
            price=None,
            trigger_price=None,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        order.apply(event)
        self.cache.update_order(order)

        self._manager.send_risk_event(event)

# -------------------------------------------------------------------------------------------------

    cpdef Price _validate_release(
        self,
        Order order,
        MatchingCore matching_core,
        InstrumentId trigger_instrument_id,
    ):
        # Returns the released price if market data is available, None otherwise.
        # Logs appropriate warnings when market data is not yet available.
        #
        # Does NOT pop the submit order command - caller must do that and handle
        # missing command according to their contract (raise for market orders,
        # return for limit orders).

        cdef Price released_price = None

        if order.side == OrderSide.BUY:
            released_price = matching_core.ask
        elif order.side == OrderSide.SELL:
            released_price = matching_core.bid
        else:  # pragma: no cover (design-time error)
            raise RuntimeError("invalid `OrderSide`")  # pragma: no cover (design-time error)

        if released_price is None:
            self._log.warning(
                f"Cannot release order {order.client_order_id} yet: no market data available for {trigger_instrument_id}, will retry on next update",
            )
            return None

        return released_price

# -------------------------------------------------------------------------------------------------

    cpdef void _trigger_stop_order(self, Order order):
        if (
            order.order_type == OrderType.STOP_LIMIT
            or order.order_type == OrderType.LIMIT_IF_TOUCHED
            or order.order_type == OrderType.TRAILING_STOP_LIMIT
        ):
            self._fill_limit_order(order)
        elif (
            order.order_type == OrderType.STOP_MARKET
            or order.order_type == OrderType.MARKET_IF_TOUCHED
            or order.order_type == OrderType.TRAILING_STOP_MARKET
        ):
            self._fill_market_order(order)
        else:
            raise RuntimeError(f"invalid `OrderType`, was {order.type_string_c()}")  # pragma: no cover (design-time error)

    cpdef void _fill_market_order(self, Order order):
        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id

        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
        if matching_core is None:
            self._log.error(
                f"Cannot fill market order: no matching core for instrument {trigger_instrument_id}",
            )
            return  # Order stays queued for retry

        cdef Price released_price = self._validate_release(order, matching_core, trigger_instrument_id)
        if released_price is None:
            return  # Order stays queued for retry

        cdef SubmitOrder command = self._manager.pop_submit_order_command(order.client_order_id)
        if command is None:
            raise RuntimeError("invalid operation `_fill_market_order` with no command")  # pragma: no cover (design-time error)

        matching_core.delete_order(order)

        order.emulation_trigger = TriggerType.NO_TRIGGER
        cdef MarketOrder transformed = MarketOrder.transform(order, self.clock.timestamp_ns())

        # Cast to writable cache
        cdef Cache cache = <Cache>self.cache
        cache.add_order(
            transformed,
            command.position_id,
            command.client_id,
            overwrite=True,
        )

        # Replace commands order with transformed order
        command.order = transformed

        # Publish initialized event
        self._msgbus.publish_c(
            topic=f"events.order.{order.strategy_id.to_str()}",
            msg=transformed.last_event_c(),
        )

        # Generate event
        cdef OrderReleased event = OrderReleased(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            released_price=released_price,
            event_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
        )
        transformed.apply(event)
        self.cache.update_order(transformed)

        self._manager.send_risk_event(event)

        self._log.info(f"Releasing {transformed}", LogColor.MAGENTA)

        # Publish event
        self._msgbus.publish_c(
            topic=f"events.order.{transformed.strategy_id.to_str()}",
            msg=event,
        )

        if order.exec_algorithm_id is not None:
            self._manager.send_algo_command(command, order.exec_algorithm_id)
        else:
            self._manager.send_exec_command(command)

    cpdef void _fill_limit_order(self, Order order):
        if order.order_type == OrderType.LIMIT:
            self._fill_market_order(order)
            return

        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id

        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
        if matching_core is None:
            self._log.error(
                f"Cannot fill limit order: no matching core for instrument {trigger_instrument_id}",
            )
            return  # Order stays queued for retry

        # Validate market data availability
        cdef Price released_price = self._validate_release(order, matching_core, trigger_instrument_id)
        if released_price is None:
            return  # Order stays queued for retry

        # Fetch command (only after confirming market data exists)
        cdef SubmitOrder command = self._manager.pop_submit_order_command(order.client_order_id)
        if command is None:
            return  # Order already released

        matching_core.delete_order(order)

        order.emulation_trigger = TriggerType.NO_TRIGGER
        cdef LimitOrder transformed = LimitOrder.transform(order, self.clock.timestamp_ns())

        # Cast to writable cache
        cdef Cache cache = <Cache>self.cache
        cache.add_order(
            transformed,
            command.position_id,
            command.client_id,
            overwrite=True,
        )

        # Replace commands order with transformed order
        command.order = transformed

        # Publish initialized event
        self._msgbus.publish_c(
            topic=f"events.order.{order.strategy_id.to_str()}",
            msg=transformed.last_event_c(),
        )

        # Generate event
        cdef OrderReleased event = OrderReleased(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            released_price=released_price,
            event_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
        )
        transformed.apply(event)
        self.cache.update_order(transformed)

        self._manager.send_risk_event(event)

        self._log.info(f"Releasing {transformed}", LogColor.MAGENTA)

        # Publish event
        self._msgbus.publish_c(
            topic=f"events.order.{transformed.strategy_id.to_str()}",
            msg=event,
        )

        if order.exec_algorithm_id is not None:
            self._manager.send_algo_command(command, order.exec_algorithm_id)
        else:
            self._manager.send_exec_command(command)

    cpdef void on_order_book_deltas(self, deltas):
        cdef OrderBookDeltas _deltas = deltas  # C typing to optimize performance

        if is_logging_initialized():
            self._log.debug(f"Processing {repr(_deltas)}", LogColor.CYAN)


        cdef MatchingCore matching_core = self._matching_cores.get(_deltas.instrument_id)
        if matching_core is None:
            self._log.error(f"Cannot handle `OrderBookDeltas`: no matching core for instrument {_deltas.instrument_id}")
            return

        cdef OrderBook book = self.cache.order_book(_deltas.instrument_id)
        if book is None:
            self.log.error(f"Cannot handle `OrderBookDeltas`: no book being maintained for {_deltas.instrument_id}")
            return

        cdef Price best_bid = book.best_bid_price()
        cdef Price best_ask = book.best_ask_price()

        if best_bid is not None:
            matching_core.set_bid_raw(best_bid._mem.raw)

        if best_ask is not None:
            matching_core.set_ask_raw(best_ask._mem.raw)

        self._iterate_orders(matching_core)

    cpdef void on_quote_tick(self, QuoteTick tick):
        if is_logging_initialized():
            self._log.debug(f"Processing {repr(tick)}", LogColor.CYAN)

        cdef MatchingCore matching_core = self._matching_cores.get(tick.instrument_id)
        if matching_core is None:
            self._log.error(f"Cannot handle `QuoteTick`: no matching core for instrument {tick.instrument_id}")
            return

        matching_core.set_bid_raw(tick._mem.bid_price.raw)
        matching_core.set_ask_raw(tick._mem.ask_price.raw)

        self._iterate_orders(matching_core)

    cpdef void on_trade_tick(self, TradeTick tick):
        if is_logging_initialized():
            self._log.debug(f"Processing {repr(tick)}...", LogColor.CYAN)

        cdef MatchingCore matching_core = self._matching_cores.get(tick.instrument_id)
        if matching_core is None:
            self._log.error(f"Cannot handle `TradeTick`: no matching core for instrument {tick.instrument_id}")
            return

        matching_core.set_last_raw(tick._mem.price.raw)
        if tick.instrument_id not in self._subscribed_quotes:
            matching_core.set_bid_raw(tick._mem.price.raw)
            matching_core.set_ask_raw(tick._mem.price.raw)

        self._iterate_orders(matching_core)

    cdef void _iterate_orders(self, MatchingCore matching_core):
        matching_core.iterate(self._clock.timestamp_ns())

        cdef list orders = matching_core.get_orders()
        cdef Order order
        for order in orders:
            if order.is_closed_c():
                continue

            # Manage trailing stop
            if order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
                self._trail_stop_order(matching_core, order)

    cdef void _trail_stop_order(self, MatchingCore matching_core, Order order):
        # TODO: Improve efficiency of this ---------------------------------
        cdef Price bid = None
        cdef Price ask = None
        cdef Price last = None
        if matching_core.is_bid_initialized:
            bid = Price.from_raw_c(matching_core.bid_raw, matching_core.price_precision)
        if matching_core.is_ask_initialized:
            ask = Price.from_raw_c(matching_core.ask_raw, matching_core.price_precision)
        if matching_core.is_last_initialized:
            last = Price.from_raw_c(matching_core.last_raw, matching_core.price_precision)

        cdef QuoteTick quote_tick = self.cache.quote_tick(matching_core.instrument_id)
        cdef TradeTick trade_tick = self.cache.trade_tick(matching_core.instrument_id)
        if bid is None and quote_tick is not None:
            bid = quote_tick.bid_price
        if ask is None and quote_tick is not None:
            ask = quote_tick.ask_price
        if last is None and trade_tick is not None:
            last = trade_tick.price
        # TODO: ------------------------------------------------------------

        cdef Price market_price = None

        if not order.is_activated:
            if order.activation_price is None:
                # NOTE
                # The activation price should have been set in OrderMatchingEngine._process_trailing_stop_order()
                # However, the implementation of the emulator bypass this step, and directly call this method through match_order().
                market_price = ask if order.side == OrderSide.BUY else bid
                if market_price is None:
                    # If there is no market price, we cannot process the order
                    raise RuntimeError(  # pragma: no cover (design-time error)
                        f"cannot process trailing stop, "
                        f"no BID or ASK price for {order.instrument_id} "
                        f"(add quotes or use bars)",
                    )
                order.set_activated_c(market_price)
            elif matching_core.is_touch_triggered(order.side, order.activation_price):
                order.set_activated_c(None)
            else:
                return  # Do nothing

        cdef tuple output
        try:
            output = TrailingStopCalculator.calculate(
                price_increment=matching_core.price_increment,
                order=order,
                bid=bid,
                ask=ask,
                last=last,
            )
        except RuntimeError as e:  # pragma: no cover (design-time error)
            self._log.warning(f"Cannot calculate trailing stop order: {e}")
            return

        cdef Price new_trigger_price = output[0]
        cdef Price new_price = output[1]
        if new_trigger_price is None and new_price is None:
            return  # No updates

        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderUpdated event = OrderUpdated(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=None,  # Not yet assigned by any venue
            account_id=order.account_id,  # Probably None
            quantity=order.quantity,
            price=new_price,
            trigger_price=new_trigger_price,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )
        order.apply(event)
        self.cache.update_order(order)

        self._manager.send_risk_event(event)

</document_content>
</document>
<document index="2343">
<source>nautilus_trader/execution/engine.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
The `ExecutionEngine` is the central component of the entire execution stack.

The execution engines primary responsibility is to orchestrate interactions
between the `ExecutionClient` instances, and the rest of the platform. This
includes sending commands to, and receiving events from, the trading venue
endpoints via its registered execution clients.

The engine employs a simple fan-in fan-out messaging pattern to execute
`TradingCommand` messages and `OrderEvent` messages.

Alternative implementations can be written on top of the generic engine - which
just need to override the `execute` and `process` methods.
"""

import time
from decimal import Decimal

from nautilus_trader.common.config import InvalidConfiguration
from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.execution.config import ExecEngineConfig
from nautilus_trader.execution.reports import ExecutionMassStatus
from nautilus_trader.execution.reports import ExecutionReport

from libc.stdint cimport uint64_t

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.component cimport CMD
from nautilus_trader.common.component cimport EVT
from nautilus_trader.common.component cimport RECV
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Component
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport TimeEvent
from nautilus_trader.common.generators cimport PositionIdGenerator
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.fsm cimport InvalidStateTrigger
from nautilus_trader.core.message cimport Command
from nautilus_trader.core.rust.core cimport secs_to_nanos
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OmsType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.execution.client cimport ExecutionClient
from nautilus_trader.execution.messages cimport BatchCancelOrders
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport QueryAccount
from nautilus_trader.execution.messages cimport QueryOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.execution.messages cimport TradingCommand
from nautilus_trader.model.book cimport should_handle_own_book_order
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.events.order cimport OrderAccepted
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderDenied
from nautilus_trader.model.events.order cimport OrderEvent
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.position cimport PositionChanged
from nautilus_trader.model.events.position cimport PositionClosed
from nautilus_trader.model.events.position cimport PositionEvent
from nautilus_trader.model.events.position cimport PositionOpened
from nautilus_trader.model.functions cimport oms_type_to_str
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ComponentId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.position cimport Position
from nautilus_trader.trading.strategy cimport Strategy


cdef class ExecutionEngine(Component):
    """
    Provides a high-performance execution engine for the management of many
    `ExecutionClient` instances, and the asynchronous ingest and distribution of
    trading commands and events.

    Parameters
    ----------
    msgbus : MessageBus
        The message bus for the engine.
    cache : Cache
        The cache for the engine.
    clock : Clock
        The clock for the engine.
    config : ExecEngineConfig, optional
        The configuration for the instance.

    Raises
    ------
    TypeError
        If `config` is not of type `ExecEngineConfig`.
    """

    def __init__(
        self,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
        config: ExecEngineConfig | None = None,
    ) -> None:
        if config is None:
            config = ExecEngineConfig()
        Condition.type(config, ExecEngineConfig, "config")
        super().__init__(
            clock=clock,
            component_id=ComponentId("ExecEngine"),
            msgbus=msgbus,
            config=config,
        )

        self._cache: Cache = cache

        self._clients: dict[ClientId, ExecutionClient] = {}
        self._routing_map: dict[Venue, ExecutionClient] = {}
        self._default_client: ExecutionClient | None = None
        self._external_clients: set[ClientId] = set((config.external_clients or []))
        self._oms_overrides: dict[StrategyId, OmsType] = {}
        self._external_order_claims: dict[InstrumentId, StrategyId] = {}

        self._pos_id_generator: PositionIdGenerator = PositionIdGenerator(
            trader_id=msgbus.trader_id,
            clock=clock,
        )

        self._pending_position_events: list[PositionEvent] = []

        self._topic_cache_order_events: dict[StrategyId, str] = {}
        self._topic_cache_position_events: dict[StrategyId, str] = {}
        self._topic_cache_fill_events: dict[InstrumentId, str] = {}
        self._topic_cache_commands: dict[ClientId, str] = {}

        # Configuration
        self.debug: bool = config.debug
        self.allow_overfills = config.allow_overfills
        self.convert_quote_qty_to_base = config.convert_quote_qty_to_base
        self.manage_own_order_books = config.manage_own_order_books
        self.snapshot_orders = config.snapshot_orders
        self.snapshot_positions = config.snapshot_positions
        self.snapshot_positions_interval_secs = config.snapshot_positions_interval_secs or 0
        self.snapshot_positions_timer_name = "ExecEngine_SNAPSHOT_POSITIONS"

        self._log.info(f"{config.snapshot_orders=}", LogColor.BLUE)
        self._log.info(f"{config.snapshot_positions=}", LogColor.BLUE)
        self._log.info(f"{config.snapshot_positions_interval_secs=}", LogColor.BLUE)
        self._log.info(f"{config.allow_overfills=}", LogColor.BLUE)

        # Counters
        self.command_count: int = 0
        self.event_count: int = 0
        self.report_count: int = 0

        # Register endpoints
        self._msgbus.register(endpoint="ExecEngine.execute", handler=self.execute)
        self._msgbus.register(endpoint="ExecEngine.process", handler=self.process)

    @property
    def reconciliation(self) -> bool:
        """
        Return whether the reconciliation process will be run on start.

        Returns
        -------
        bool

        """
        # Temporary to push down common logic, the `LiveExecutionEngine` will override this
        return False

    @property
    def registered_clients(self) -> list[ClientId]:
        """
        Return the execution clients registered with the engine.

        Returns
        -------
        list[ClientId]

        """
        return sorted(list(self._clients.keys()))

    @property
    def default_client(self) -> ClientId | None:
        """
        Return the default execution client registered with the engine.

        Returns
        -------
        ClientId or ``None``

        """
        return self._default_client.id if self._default_client is not None else None

    def connect(self) -> None:
        """
        Connect the engine by calling connect on all registered clients.
        """
        self._log.info("Connecting all clients...")
        # Implement actual client connections for a live/sandbox context

    def disconnect(self) -> None:
        """
        Disconnect the engine by calling disconnect on all registered clients.
        """
        self._log.info("Disconnecting all clients...")
        # Implement actual client connections for a live/sandbox context

    cpdef int position_id_count(self, StrategyId strategy_id):
        """
        The position ID count for the given strategy ID.

        Parameters
        ----------
        strategy_id : StrategyId
            The strategy ID for the position count.

        Returns
        -------
        int

        """
        return self._pos_id_generator.get_count(strategy_id)

    cpdef bint check_integrity(self):
        """
        Check integrity of data within the cache and clients.

        Returns
        -------
        bool
            True if checks pass, else False.
        """
        return self._cache.check_integrity()

    cpdef bint check_connected(self):
        """
        Check all of the engines clients are connected.

        Returns
        -------
        bool
            True if all clients connected, else False.

        """
        cdef ExecutionClient client
        for client in self._clients.values():
            if not client.is_connected:
                return False
        return True

    cpdef bint check_disconnected(self):
        """
        Check all of the engines clients are disconnected.

        Returns
        -------
        bool
            True if all clients disconnected, else False.

        """
        cdef ExecutionClient client
        for client in self._clients.values():
            if client.is_connected:
                return False
        return True

    cpdef bint check_residuals(self):
        """
        Check for any residual open state and log warnings if found.

        'Open state' is considered to be open orders and open positions.

        Returns
        -------
        bool
            True if residuals exist, else False.

        """
        return self._cache.check_residuals()

    cpdef set[ClientId] get_external_client_ids(self):
        """
        Returns the configured external client order IDs.

        Returns
        -------
        set[ClientId]

        """
        return self._external_clients.copy()

    cpdef StrategyId get_external_order_claim(self, InstrumentId instrument_id):
        """
        Get any external order claim for the given instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the claim.

        Returns
        -------
        StrategyId or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._external_order_claims.get(instrument_id)

    cpdef set[InstrumentId] get_external_order_claims_instruments(self):
        """
        Get all instrument IDs registered for external order claims.

        Returns
        -------
        set[InstrumentId]

        """
        return set(self._external_order_claims.keys())

    cpdef set[ExecutionClient] get_clients_for_orders(self, list[Order] orders):
        """
        Get all execution clients corresponding to the given orders.

        Parameters
        ----------
        orders : list[Order]
            The orders to locate associated execution clients for.

        Returns
        -------
        set[ExecutionClient]

        """
        Condition.not_none(orders, "orders")

        cdef set[ClientId] client_ids = set()
        cdef set[Venue] venues = set()

        cdef:
            Order order
            ClientId client_id
            Venue venue
            ExecutionClient client
        for order in orders:
            venues.add(order.venue)
            client_id = self._cache.client_id(order.client_order_id)
            if client_id is None:
                continue
            client_ids.add(client_id)

        cdef set[ExecutionClient] clients = set()

        for client_id in client_ids:
            clients.add(self._clients[client_id])

        for venue in venues:
            client = self._routing_map.get(venue, self._default_client)
            if client is not None:
                clients.add(client)

        return clients

    cpdef void set_manage_own_order_books(self, bint value):
        """
        Set the `manage_own_order_books` setting with the given `value`.

        Parameters
        ----------
        value : bool
            The value to set.

        """
        self.manage_own_order_books = value

    cpdef void set_convert_quote_qty_to_base(self, bint value):
        """
        Set the `convert_quote_qty_to_base` flag with the given `value`.

        Parameters
        ----------
        value : bool
            The value to set.
        """
        self.convert_quote_qty_to_base = value

# -- REGISTRATION ---------------------------------------------------------------------------------

    cpdef void register_client(self, ExecutionClient client):
        """
        Register the given execution client with the execution engine.

        If the `client.venue` is ``None`` and a default routing client has not
        been previously registered then will be registered as such.

        Parameters
        ----------
        client : ExecutionClient
            The execution client to register.

        Raises
        ------
        ValueError
            If `client` is already registered with the execution engine.

        """
        Condition.not_none(client, "client")
        Condition.not_in(client.id, self._clients, "client.id", "_clients")

        cdef str routing_log = ""

        # Default routing client
        if client.venue is None:
            if self._default_client is not None:
                raise ValueError(
                    f"Default execution client already registered ("
                    f"{self._default_client.id!r}); use register_default_client to override"
                )
            self._default_client = client
            routing_log = " for default routing"
        # Venue-specific routing
        else:
            if client.venue in self._routing_map:
                existing = self._routing_map[client.venue]
                raise ValueError(
                    f"Execution client for venue {client.venue!r} "
                    f"already registered ({existing.id!r})"
                )
            self._routing_map[client.venue] = client

        # Finally register in client registry
        self._clients[client.id] = client

        self._log.info(f"Registered ExecutionClient-{client}{routing_log}")

    cpdef void register_default_client(self, ExecutionClient client):
        """
        Register the given client as the default routing client (when a specific
        venue routing cannot be found).

        Any existing default routing client will be overwritten.

        Parameters
        ----------
        client : ExecutionClient
            The client to register.

        """
        Condition.not_none(client, "client")

        self._default_client = client

        self._log.info(f"Registered {client} for default routing")

    cpdef void register_venue_routing(self, ExecutionClient client, Venue venue):
        """
        Register the given client to route orders to the given venue.

        Any existing client in the routing map for the given venue will be
        overwritten.

        Parameters
        ----------
        venue : Venue
            The venue to route orders to.
        client : ExecutionClient
            The client for the venue routing.

        """
        Condition.not_none(client, "client")
        Condition.not_none(venue, "venue")

        if client.id not in self._clients:
            self._clients[client.id] = client

        self._routing_map[venue] = client

        self._log.info(f"Registered ExecutionClient-{client} for routing to {venue}")

    cpdef void register_oms_type(self, Strategy strategy):
        """
        Register the given trading strategies OMS (Order Management System) type.

        Parameters
        ----------
        strategy : Strategy
            The strategy for the registration.

        """
        Condition.not_none(strategy, "strategy")

        self._oms_overrides[strategy.id] = strategy.oms_type

        self._log.info(
            f"Registered OMS.{oms_type_to_str(strategy.oms_type)} "
            f"for Strategy {strategy}",
        )

    cpdef void register_external_order_claims(self, Strategy strategy):
        """
        Register the given strategies external order claim instrument IDs (if any)

        Parameters
        ----------
        strategy : Strategy
            The strategy for the registration.

        Raises
        ------
        InvalidConfiguration
            If a strategy is already registered to claim external orders for an instrument ID.

        """
        Condition.not_none(strategy, "strategy")

        cdef:
            InstrumentId instrument_id
            StrategyId existing
        for instrument_id in strategy.external_order_claims:
            existing = self._external_order_claims.get(instrument_id)
            if existing:
                raise InvalidConfiguration(
                    f"External order claim for {instrument_id} already exists for {existing}",
                )
            # Register strategy to claim external orders for this instrument
            self._external_order_claims[instrument_id] = strategy.id

        if strategy.external_order_claims:
            self._log.info(
                f"Registered external order claims for {strategy}: {strategy.external_order_claims}",
            )

    cpdef void deregister_client(self, ExecutionClient client):
        """
        Deregister the given execution client from the execution engine.

        Parameters
        ----------
        client : ExecutionClient
            The execution client to deregister.

        Raises
        ------
        ValueError
            If `client` is not registered with the execution engine.

        """
        Condition.not_none(client, "client")
        Condition.is_in(client.id, self._clients, "client.id", "self._clients")

        # Remove client from registry
        del self._clients[client.id]

        # Clear default routing client if it matches
        if self._default_client is not None and self._default_client == client:
            self._default_client = None

        # Remove any venue-specific routing entries for this client
        cdef list to_remove = []
        for venue, mapped_client in self._routing_map.items():
            if mapped_client == client:
                to_remove.append(venue)
        for venue in to_remove:
            del self._routing_map[venue]

        self._log.info(f"Deregistered {client}")

    # -- RECONCILIATION -------------------------------------------------------------------------------

    async def reconcile_execution_state(self, timeout_secs: float = 10.0) -> bool:
        """
        Reconcile the internal execution state with all execution clients (external state).

        Parameters
        ----------
        timeout_secs : double, default 10.0
            The timeout (seconds) for reconciliation to complete.

        Returns
        -------
        bool
            True if states reconcile within timeout, else False.

        Raises
        ------
        ValueError
            If `timeout_secs` is not positive (> 0).

        """
        return True  # Should be overridden for live execution engines

    def reconcile_execution_report(self, report: ExecutionReport) -> bool:
        """
        Check the given execution report.

        Parameters
        ----------
        report : ExecutionReport
            The execution report to check.

        Returns
        -------
        bool
            True if reconciliation successful, else False.

        """
        return True  # Should be overridden for live execution engines

    def reconcile_execution_mass_status(self, report: ExecutionMassStatus) -> None:
        """
        Reconcile the given execution mass status report.

        Parameters
        ----------
        report : ExecutionMassStatus
            The execution mass status report to reconcile.

        """
        # Should be overridden for live execution engines

# -- ABSTRACT METHODS -----------------------------------------------------------------------------

    cpdef void _on_start(self):
        pass  # Optionally override in subclass

    cpdef void _on_stop(self):
        pass  # Optionally override in subclass

# -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------

    cpdef void _start(self):
        for client in self._clients.values():
            client.start()

        if self.snapshot_positions_interval_secs and self.snapshot_positions_timer_name not in self._clock.timer_names:
            self._log.info(
                f"Starting position snapshots timer at {self.snapshot_positions_interval_secs} second intervals",
            )
            interval_ns = secs_to_nanos(self.snapshot_positions_interval_secs)
            self._clock.set_timer_ns(
                name=self.snapshot_positions_timer_name,
                interval_ns=interval_ns,
                start_time_ns=0,  # TBD if should align to nearest second boundary
                stop_time_ns=0,  # Run as long as execution engine is running
                callback=self._snapshot_open_position_states,
            )

        self._on_start()

    cpdef void _stop(self):
        for client in self._clients.values():
            if client.is_running:
                client.stop()

        if self.snapshot_positions_interval_secs and self.snapshot_positions_timer_name in self._clock.timer_names:
            self._log.info(f"Canceling position snapshots timer")
            self._clock.cancel_timer(self.snapshot_positions_timer_name)

        self._on_stop()

    cpdef void _reset(self):
        for client in self._clients.values():
            client.reset()

        self._cache.reset()
        self._pos_id_generator.reset()

        self.command_count = 0
        self.event_count = 0
        self.report_count = 0

    cpdef void _dispose(self):
        for client in self._clients.values():
            client.dispose()

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void stop_clients(self):
        """
        Stop the registered clients.
        """
        for client in self._clients.values():
            if client.is_running:
                client.stop()

    cpdef void load_cache(self):
        """
        Load the cache up from the execution database.
        """
        # Manually measuring timestamps in case the engine is using a test clock
        cdef uint64_t ts = int(time.time() * 1000)
        cdef uint64_t ts_func_start
        cdef uint64_t ts_func_end

        # Clear index
        ts_func_start = int(time.time() * 1000)
        self._cache.clear_index()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"clear_index took {ts_func_end - ts_func_start}ms")

        # Cache general
        ts_func_start = int(time.time() * 1000)
        self._cache.cache_general()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"cache_general took {ts_func_end - ts_func_start}ms")

        # Cache currencies
        ts_func_start = int(time.time() * 1000)
        self._cache.cache_currencies()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"cache_currencies took {ts_func_end - ts_func_start}ms")

        # Cache instruments
        ts_func_start = int(time.time() * 1000)
        self._cache.cache_instruments()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"cache_instruments took {ts_func_end - ts_func_start}ms")

        # Cache accounts
        ts_func_start = int(time.time() * 1000)
        self._cache.cache_accounts()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"cache_accounts took {ts_func_end - ts_func_start}ms")

        # Cache orders
        ts_func_start = int(time.time() * 1000)
        self._cache.cache_orders()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"cache_orders took {ts_func_end - ts_func_start}ms")

        # Cache order lists
        ts_func_start = int(time.time() * 1000)
        self._cache.cache_order_lists()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"cache_order_lists took {ts_func_end - ts_func_start}ms")

        # Cache positions
        ts_func_start = int(time.time() * 1000)
        self._cache.cache_positions()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"cache_positions took {ts_func_end - ts_func_start}ms")

        # TODO: Uncomment and replace above individual caching methods once implemented
        # self._cache.cache_all()

        # Build index
        ts_func_start = int(time.time() * 1000)
        self._cache.build_index()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"build_index took {ts_func_end - ts_func_start}ms")

        # Check integrity
        ts_func_start = int(time.time() * 1000)
        self._cache.check_integrity()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"check_integrity took {ts_func_end - ts_func_start}ms")

        # Set position ID counts
        ts_func_start = int(time.time() * 1000)
        self._set_position_id_counts()
        ts_func_end = int(time.time() * 1000)
        self._log.debug(f"_set_position_id_counts took {ts_func_end - ts_func_start}ms")

        cdef Order order
        if self.manage_own_order_books:
            ts_func_start = int(time.time() * 1000)
            for order in self._cache.orders():
                if order.is_closed_c() or not should_handle_own_book_order(order):
                    continue
                self._add_own_book_order(order)
            ts_func_end = int(time.time() * 1000)
            self._log.debug(f"manage_own_order_books processing took {ts_func_end - ts_func_start}ms")

        self._log.info(f"Loaded cache in {(int(time.time() * 1000) - ts)}ms")

    cpdef void execute(self, Command command):
        """
        Execute the given command.

        Parameters
        ----------
        command : Command
            The command to execute.

        """
        Condition.not_none(command, "command")

        self._execute_command(command)

    cpdef void process(self, OrderEvent event):
        """
        Process the given order event.

        Parameters
        ----------
        event : OrderEvent
            The order event to process.

        """
        Condition.not_none(event, "event")

        self._handle_event(event)

    cpdef void flush_db(self):
        """
        Flush the execution database which permanently removes all persisted data.

        Warnings
        --------
        Permanent data loss.

        """
        self._cache.flush_db()

# -- INTERNAL -------------------------------------------------------------------------------------

    cdef str _get_order_events_topic(self, StrategyId strategy_id):
        cdef str topic = self._topic_cache_order_events.get(strategy_id)
        if topic is None:
            topic = f"events.order.{strategy_id}"
            self._topic_cache_order_events[strategy_id] = topic

        return topic

    cdef str _get_position_events_topic(self, StrategyId strategy_id):
        cdef str topic = self._topic_cache_position_events.get(strategy_id)
        if topic is None:
            topic = f"events.position.{strategy_id}"
            self._topic_cache_position_events[strategy_id] = topic

        return topic

    cdef str _get_fill_events_topic(self, InstrumentId instrument_id):
        cdef str topic = self._topic_cache_fill_events.get(instrument_id)
        if topic is None:
            topic = f"events.fills.{instrument_id}"
            self._topic_cache_fill_events[instrument_id] = topic

        return topic

    cdef str _get_commands_topic(self, ClientId client_id):
        cdef str topic = self._topic_cache_commands.get(client_id)
        if topic is None:
            topic = f"commands.trading.{client_id}"
            self._topic_cache_commands[client_id] = topic

        return topic

    cpdef void _set_position_id_counts(self):
        # For the internal position ID generator
        cdef list positions = self._cache.positions()

        # Count positions per instrument_id
        cdef dict counts = {}  # type: dict[StrategyId, int]
        cdef int count
        cdef Position position
        for position in positions:
            count = counts.get(position.strategy_id, 0)
            count += 1
            counts[position.strategy_id] = count

        # Reset position ID generator
        self._pos_id_generator.reset()

        # Set counts
        cdef StrategyId strategy_id
        for strategy_id, count in counts.items():
            self._pos_id_generator.set_count(strategy_id, count)
            self._log.info(f"Set PositionId count for {strategy_id!r} to {count}")

    cpdef Price _last_px_for_conversion(self, InstrumentId instrument_id, OrderSide order_side):
        cdef Price last_px = None
        cdef QuoteTick last_quote = self._cache.quote_tick(instrument_id)
        cdef TradeTick last_trade = self._cache.trade_tick(instrument_id)
        if last_quote is not None:
            last_px = last_quote.ask_price if order_side == OrderSide.BUY else last_quote.bid_price
        else:
            if last_trade is not None:
                last_px = last_trade.price

        return last_px

    cpdef void _set_order_base_qty(self, Order order, Quantity base_qty):
        self._log.info(
            f"Setting {order.instrument_id} order quote quantity {order.quantity} to base quantity {base_qty}",
        )
        cdef Quantity original_qty = order.quantity
        order.quantity = base_qty
        order.leaves_qty = base_qty
        order.is_quote_quantity = False

        if order.contingency_type != ContingencyType.OTO:
            return

        # Set base quantity for all OTO contingent orders
        cdef ClientOrderId client_order_id
        cdef Order contingent_order
        for client_order_id in order.linked_order_ids or []:
            contingent_order = self._cache.order(client_order_id)
            if contingent_order is None:
                self._log.error(f"Contingency order {client_order_id!r} not found")
                continue
            if not contingent_order.is_quote_quantity:
                continue  # Already base quantity
            if contingent_order.quantity != original_qty:
                self._log.warning(
                    f"Contingent order quantity {contingent_order.quantity} "
                    f"was not equal to the OTO parent original quantity {original_qty} "
                    f"when setting to base quantity of {base_qty}"
                )
            self._log.info(
                f"Setting {contingent_order.instrument_id} order quote quantity "
                f"{contingent_order.quantity} to base quantity {base_qty}",
            )
            contingent_order.quantity = base_qty
            contingent_order.leaves_qty = base_qty
            contingent_order.is_quote_quantity = False

    cpdef void _deny_order(self, Order order, str reason):
        # Generate event
        cdef OrderDenied denied = OrderDenied(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            reason=reason,
            event_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
        )
        order.apply(denied)
        self._cache.update_order(order)

        self._msgbus.publish_c(
            topic=self._get_order_events_topic(order.strategy_id),
            msg=denied,
        )
        if self.snapshot_orders:
            self._create_order_state_snapshot(order)

    cpdef object _get_or_init_own_order_book(self, InstrumentId instrument_id):
        own_book = self._cache.own_order_book(instrument_id)
        if own_book is None:
            pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(instrument_id.value)
            own_book = nautilus_pyo3.OwnOrderBook(pyo3_instrument_id)
            self._cache.add_own_order_book(own_book)
            self._log.debug(f"Initialized {own_book!r}", LogColor.MAGENTA)
        return own_book

    cpdef void _add_own_book_order(self, Order order):
        own_book = self._get_or_init_own_order_book(order.instrument_id)
        own_book_order = order.to_own_book_order()
        own_book.add(own_book_order)

        if self.debug:
            self._log.debug(f"Added: {own_book_order!r}", LogColor.MAGENTA)

# -- COMMAND HANDLERS -----------------------------------------------------------------------------

    cpdef void _execute_command(self, Command command):
        if self.debug:
            self._log.debug(f"{RECV}{CMD} {command}", LogColor.MAGENTA)

        self.command_count += 1

        if command.client_id in self._external_clients:
            self._msgbus.publish_c(
                topic=self._get_commands_topic(command.client_id),
                msg=command,
            )

            if self.debug:
                self._log.debug(
                    f"Skipping execution command for external client {command.client_id}: {command}",
                    LogColor.MAGENTA,
                )
            return

        cdef ExecutionClient client = self._clients.get(command.client_id)
        cdef Venue venue

        if client is None:
            if isinstance(command, QueryAccount):
                venue = Venue(command.account_id.get_issuer())
            elif isinstance(command, TradingCommand):
                venue = command.instrument_id.venue
            else:
                self._log.error(  # pragma: no cover (design-time error)
                    f"Cannot handle command: unrecognized {command}",  # pragma: no cover (design-time error)
                )
                return

            client = self._routing_map.get(venue, self._default_client)
            if client is None:
                self._log.error(
                    f"Cannot execute command: "
                    f"no execution client configured for {venue} or `client_id` {command.client_id}, "
                    f"{command}"
                )
                return  # No client to handle command

        if isinstance(command, SubmitOrder):
            self._handle_submit_order(client, command)
        elif isinstance(command, SubmitOrderList):
            self._handle_submit_order_list(client, command)
        elif isinstance(command, ModifyOrder):
            self._handle_modify_order(client, command)
        elif isinstance(command, CancelOrder):
            self._handle_cancel_order(client, command)
        elif isinstance(command, CancelAllOrders):
            self._handle_cancel_all_orders(client, command)
        elif isinstance(command, BatchCancelOrders):
            self._handle_batch_cancel_orders(client, command)
        elif isinstance(command, QueryAccount):
            self._handle_query_account(client, command)
        elif isinstance(command, QueryOrder):
            self._handle_query_order(client, command)
        else:
            self._log.error(  # pragma: no cover (design-time error)
                f"Cannot handle command: unrecognized {command}",  # pragma: no cover (design-time error)
            )

    cpdef void _handle_submit_order(self, ExecutionClient client, SubmitOrder command):
        cdef Order order = command.order
        if not self._cache.order_exists(order.client_order_id):
            # Cache order
            self._cache.add_order(order, command.position_id, command.client_id)
            if self.snapshot_orders:
                self._create_order_state_snapshot(order)

        cdef Instrument instrument = self._cache.instrument(order.instrument_id)
        if instrument is None:
            self._log.error(
                f"Cannot handle submit order: "
                f"no instrument found for {order.instrument_id}, {command}"
            )
            return

        # Check if converting quote quantity
        cdef Price last_px = None
        cdef Quantity base_qty = None
        if self.convert_quote_qty_to_base and not instrument.is_inverse and order.is_quote_quantity:
            self._log.warning(
                "`convert_quote_qty_to_base is deprecated`; set `convert_quote_qty_to_base=False` to maintain consistent behavior.",
                LogColor.YELLOW,
            )
            last_px = self._last_px_for_conversion(order.instrument_id, order.side)
            if last_px is None:
                self._deny_order(order, f"no-price-to-convert-quote-qty {order.instrument_id}")
                return  # Denied
            base_qty = instrument.calculate_base_quantity(order.quantity, last_px)
            self._set_order_base_qty(order, base_qty)

        if self.manage_own_order_books and should_handle_own_book_order(order):
            self._add_own_book_order(order)

        # Send to execution client
        client.submit_order(command)

    cpdef void _handle_submit_order_list(self, ExecutionClient client, SubmitOrderList command):
        cdef Order order
        for order in command.order_list.orders:
            if not self._cache.order_exists(order.client_order_id):
                # Cache order
                self._cache.add_order(order, command.position_id, command.client_id)
                if self.snapshot_orders:
                    self._create_order_state_snapshot(order)

        cdef Instrument instrument = self._cache.instrument(command.instrument_id)
        if instrument is None:
            self._log.error(
                f"Cannot handle submit order list: "
                f"no instrument found for {command.instrument_id}, {command}"
            )
            return

        # Check if converting quote quantity
        cdef Price last_px = None
        cdef Quantity base_qty = None
        if self.convert_quote_qty_to_base and not instrument.is_inverse:
            for order in command.order_list.orders:
                if not order.is_quote_quantity:
                    continue  # Base quantity already set

                self._log.warning(
                    "`convert_quote_qty_to_base` is deprecated; set `convert_quote_qty_to_base=False` to maintain consistent behavior",
                    LogColor.YELLOW,
                )

                last_px = self._last_px_for_conversion(order.instrument_id, order.side)
                if last_px is None:
                    for order in command.order_list.orders:
                        self._deny_order(order, f"no-price-to-convert-quote-qty {order.instrument_id}")
                    return  # Denied

                base_qty = instrument.calculate_base_quantity(order.quantity, last_px)
                self._set_order_base_qty(order, base_qty)

        if self.manage_own_order_books:
            for order in command.order_list.orders:
                if should_handle_own_book_order(order):
                    self._add_own_book_order(order)

        # Send to execution client
        client.submit_order_list(command)

    cpdef void _handle_modify_order(self, ExecutionClient client, ModifyOrder command):
        client.modify_order(command)

    cpdef void _handle_cancel_order(self, ExecutionClient client, CancelOrder command):
        client.cancel_order(command)

    cpdef void _handle_cancel_all_orders(self, ExecutionClient client, CancelAllOrders command):
        client.cancel_all_orders(command)

    cpdef void _handle_batch_cancel_orders(self, ExecutionClient client, BatchCancelOrders command):
        client.batch_cancel_orders(command)

    cpdef void _handle_query_account(self, ExecutionClient client, QueryAccount command):
        client.query_account(command)

    cpdef void _handle_query_order(self, ExecutionClient client, QueryOrder command):
        client.query_order(command)

# -- EVENT HANDLERS -------------------------------------------------------------------------------

    cpdef void _handle_event(self, OrderEvent event):
        if self.debug:
            self._log.debug(f"{RECV}{EVT} {event}", LogColor.MAGENTA)
        self.event_count += 1

        # Fetch Order from cache
        cdef ClientOrderId client_order_id = event.client_order_id
        cdef Order order = self._cache.order(event.client_order_id)
        if order is None:
            self._log.warning(
                f"Order with {event.client_order_id!r} "
                f"not found in the cache to apply {event}"
            )

            if event.venue_order_id is None:
                self._log.error(
                    f"Cannot apply event to any order: "
                    f"{event.client_order_id!r} not found in the cache "
                    f"with no `VenueOrderId`"
                )
                return  # Cannot process event further

            # Search cache for ClientOrderId matching the VenueOrderId
            client_order_id = self._cache.client_order_id(event.venue_order_id)
            if client_order_id is None:
                # Check if this is a leg fill (individual instrument from spread order)
                if isinstance(event, OrderFilled) and self._is_leg_fill(event):
                    self._log.info(
                        f"Processing leg fill without corresponding order: {event.client_order_id!r} "
                        f"for instrument {event.instrument_id}"
                    )
                    # Handle leg fill directly without order
                    self._handle_leg_fill_without_order(event)
                    return

                self._log.error(
                    f"Cannot apply event to any order: "
                    f"{event.client_order_id!r} and {event.venue_order_id!r} "
                    f"not found in the cache"
                )
                return  # Cannot process event further

            # Search cache for Order matching the found ClientOrderId
            order = self._cache.order(client_order_id)
            if order is None:
                # Check if this is a leg fill (individual instrument from spread order)
                if isinstance(event, OrderFilled) and self._is_leg_fill(event):
                    self._log.info(
                        f"Processing leg fill without corresponding order: {event.client_order_id!r} "
                        f"for instrument {event.instrument_id}"
                    )
                    # Handle leg fill directly without order
                    self._handle_leg_fill_without_order(event)
                    return

                self._log.error(
                    f"Cannot apply event to any order: "
                    f"{event.client_order_id!r} and {event.venue_order_id!r} "
                    f"not found in the cache"
                )
                return  # Cannot process event further

            # Set the correct ClientOrderId for the event
            event.set_client_order_id(client_order_id)
            self._log.info(
                f"Order with {client_order_id!r} was found in the cache",
                color=LogColor.GREEN,
            )

        cdef OmsType oms_type
        if isinstance(event, OrderFilled):
            if order.is_duplicate_fill_c(event):
                self._log.warning(
                    f"Duplicate fill: {order.client_order_id!r} trade_id={event.trade_id} already applied",
                )
                return  # Reject duplicate fill, skip all processing

            if not self._check_overfill(order, event):
                return  # Reject overfill, skip all processing

            oms_type = self._determine_oms_type(event)
            self._determine_position_id(event, oms_type, order)
            if not self._apply_event_to_order(order, event):
                return  # Event rejected, skip downstream handling
            self._handle_order_fill(order, event, oms_type)
        else:
            self._apply_event_to_order(order, event)

        # Pop position events which are pending publishing to prevent recursion issues
        cdef list[PositionEvent] to_publish = self._pending_position_events
        self._pending_position_events = []

        self._msgbus.publish_c(
            topic=self._get_order_events_topic(event.strategy_id),
            msg=event,
        )

        cdef:
            PositionEvent pos_event
            Position position
        for pos_event in to_publish:
            self._msgbus.publish_c(
                topic=self._get_position_events_topic(pos_event.strategy_id),
                msg=pos_event,
            )

    cdef bint _is_leg_fill(self, OrderFilled fill):
        cdef str client_order_id_str = fill.client_order_id.value
        cdef str venue_order_id_str = fill.venue_order_id.value if fill.venue_order_id else ""

        if not ("-LEG-" in client_order_id_str or "-LEG-" in venue_order_id_str):
            return False

        cdef Instrument instrument = self._cache.load_instrument(fill.instrument_id)
        if instrument is None:
            return False

        return not instrument.is_spread()

    cpdef void _handle_leg_fill_without_order(self, OrderFilled fill):
        """
        Handle leg fills that don't have corresponding orders in the cache.

        This occurs when a spread order is executed and generates individual leg fills.
        The leg fills need to create positions for portfolio tracking, even though
        there's no direct order for the individual leg instruments.
        """
        cdef Instrument instrument = self._cache.load_instrument(fill.instrument_id)
        if instrument is None:
            self._log.error(
                f"Cannot handle leg fill: "
                f"no instrument found for {fill.instrument_id}, {fill}"
            )
            return

        cdef Account account = self._cache.account(fill.account_id)
        if account is None:
            self._log.error(
                f"Cannot handle leg fill: "
                f"no account found for {fill.instrument_id.venue}, {fill}"
            )
            return

        # Determine OMS type for leg fill
        cdef OmsType oms_type = self._determine_oms_type(fill)

        # Determine position ID for leg fill without requiring an order in cache
        cdef PositionId position_id

        if oms_type == OmsType.HEDGING:
            position_id = self._determine_hedging_position_id(fill)
        elif oms_type == OmsType.NETTING:
            # Assign netted position ID
            position_id = self._determine_netting_position_id(fill)
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `OmsType`, was {oms_type}",  # pragma: no cover (design-time error)
            )

        fill.position_id = position_id

        # Handle position update
        self._handle_position_update(instrument, fill, oms_type)

        self._msgbus.publish_c(
            topic=self._get_order_events_topic(fill.strategy_id),
            msg=fill,
        )

    cpdef OmsType _determine_oms_type(self, OrderFilled fill):
        cdef ExecutionClient client
        # Check for strategy OMS override
        cdef OmsType oms_type = self._oms_overrides.get(fill.strategy_id, OmsType.UNSPECIFIED)
        if oms_type == OmsType.UNSPECIFIED:
            # Use native venue OMS
            client = self._routing_map.get(fill.instrument_id.venue, self._default_client)
            if client is None:
                return OmsType.NETTING
            else:
                return client.oms_type

        return oms_type

    cpdef void _determine_position_id(self, OrderFilled fill, OmsType oms_type, Order order=None):
        # Fetch ID from cache
        cdef PositionId position_id = self._cache.position_id(fill.client_order_id)

        if self.debug:
            self._log.debug(
                f"Determining position ID for {fill.client_order_id!r}, "
                f"position_id={position_id!r}",
                LogColor.MAGENTA,
            )

        if position_id is not None:
            if fill.position_id is not None and fill.position_id != position_id:
                self._log.warning(
                    "Incorrect position ID assigned to fill: "
                    f"cached={position_id!r}, assigned={fill.position_id!r}; "
                    "re-assigning from cache",
                )
            # Assign position ID to fill
            fill.position_id = position_id

            if self.debug:
                self._log.debug(f"Assigned {position_id!r} to {fill}", LogColor.MAGENTA)

            return

        if oms_type == OmsType.HEDGING:
            position_id = self._determine_hedging_position_id(fill, order)
        elif oms_type == OmsType.NETTING:
            # Assign netted position ID
            position_id = self._determine_netting_position_id(fill)
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `OmsType`, was {oms_type}",  # pragma: no cover (design-time error)
            )

        fill.position_id = position_id

        if order is None:
            order = self._cache.order(fill.client_order_id)
            if order is None:
                raise RuntimeError(
                    f"Order for {fill.client_order_id!r} not found to determine position ID",
                )

        # Check execution algorithm position ID
        if order.exec_algorithm_id is None or order.exec_spawn_id is None:
            return

        cdef Order primary = self._cache.order(order.exec_spawn_id)
        assert primary is not None
        if primary.position_id is None:
            primary.position_id = position_id
            self._cache.add_position_id(
                position_id,
                primary.instrument_id.venue,
                primary.client_order_id,
                primary.strategy_id,
            )
            self._log.debug(f"Assigned primary order {position_id!r}", LogColor.MAGENTA)

    cpdef PositionId _determine_hedging_position_id(self, OrderFilled fill, Order order=None):
        if fill.position_id is not None:
            if self.debug:
                self._log.debug(f"Already had a position ID of: {fill.position_id!r}", LogColor.MAGENTA)
            # Already assigned
            return fill.position_id

        if order is None:
            order = self._cache.order(fill.client_order_id)
            if order is None:
                raise RuntimeError(
                    f"Order for {fill.client_order_id!r} not found to determine position ID",
                )

        cdef:
            list exec_spawn_orders
            Order spawned_order
        if order.exec_spawn_id is not None:
            exec_spawn_orders = self._cache.orders_for_exec_spawn(order.exec_spawn_id)
            for spawned_order in exec_spawn_orders:
                if spawned_order.position_id is not None:
                    if self.debug:
                        self._log.debug(f"Found spawned {spawned_order.position_id!r} for {fill}", LogColor.MAGENTA)
                    # Use position ID for execution spawn
                    return spawned_order.position_id

        # Assign new position ID
        position_id = self._pos_id_generator.generate(fill.strategy_id)

        if self.debug:
            self._log.debug(f"Generated {position_id!r} for {fill}", LogColor.MAGENTA)

        return position_id

    cpdef PositionId _determine_netting_position_id(self, OrderFilled fill):
        return PositionId(f"{fill.instrument_id}-{fill.strategy_id}")

    cdef bint _check_overfill(self, Order order, OrderFilled fill):
        cdef Quantity potential_overfill = order.calculate_overfill_c(fill.last_qty)

        if potential_overfill._mem.raw > 0:
            if self.allow_overfills:
                self._log.warning(
                    f"Order overfill detected: {order.client_order_id!r} "
                    f"potential_overfill={potential_overfill}, "
                    f"current_filled={order.filled_qty}, last_qty={fill.last_qty}, quantity={order.quantity}",
                    LogColor.YELLOW,
                )
                return True  # Allow overfill
            else:
                self._log.error(
                    f"Order overfill rejected: {order.client_order_id!r} "
                    f"potential_overfill={potential_overfill}, "
                    f"current_filled={order.filled_qty}, last_qty={fill.last_qty}, quantity={order.quantity}. "
                    f"Set `allow_overfills=True` in ExecEngineConfig to allow overfills.",
                )
                return False  # Reject overfill

        return True  # No overfill

    cpdef bint _apply_event_to_order(self, Order order, OrderEvent event):
        try:
            order.apply(event)
        except InvalidStateTrigger as e:
            log_msg = f"InvalidStateTrigger: {e}, did not apply {event}"

            if order.status_c() == OrderStatus.ACCEPTED and isinstance(event, OrderAccepted):
                self._log.debug(log_msg)
            else:
                self._log.warning(log_msg)
            return True  # Continue processing for idempotent state transitions
        except (ValueError, KeyError) as e:
            # ValueError: Protection against invalid IDs
            # KeyError: Protection against duplicate fills (same trade_id, different data)
            self._log.exception(f"Error on applying {event!r} to {order!r}", e)

            if isinstance(event, (OrderRejected, OrderCanceled, OrderExpired, OrderDenied)):
                self._log.warning(
                    f"Terminal event {event!r} failed to apply to {order.client_order_id!r}, "
                    f"forcing cleanup from own book",
                    LogColor.YELLOW,
                )
                self._cache.force_remove_from_own_order_book(order.client_order_id)
            else:
                own_book = self._cache.own_order_book(order.instrument_id)
                # Only bypass should_handle check for closed orders (to ensure cleanup)
                if (own_book is not None and order.is_closed_c()) or should_handle_own_book_order(order):
                    self._cache.update_own_order_book(order)
            return False  # Event rejected, skip downstream handling

        self._cache.update_order(order)

        if self.snapshot_orders:
            self._create_order_state_snapshot(order)

        self._msgbus.send(
            endpoint="Portfolio.update_order",
            msg=event,
        )
        return True

    cpdef void _handle_order_fill(self, Order order, OrderFilled fill, OmsType oms_type):
        cdef Instrument instrument = self._cache.load_instrument(fill.instrument_id)
        if instrument is None:
            self._log.error(
                f"Cannot handle order fill: "
                f"no instrument found for {fill.instrument_id}, {fill}"
            )
            return

        cdef Account account = self._cache.account(fill.account_id)
        if account is None:
            self._log.error(
                f"Cannot handle order fill: "
                f"no account found for {fill.instrument_id.venue}, {fill}"
            )
            return

        # Skip portfolio position updates for combo fills (spread instruments)
        # Combo fills are only used for order management, not portfolio updates
        cdef:
            Position position = None
            ClientOrderId client_order_id
            Order contingent_order

        if not instrument.is_spread():
            self._handle_position_update(instrument, fill, oms_type)
            position = self._cache.position(fill.position_id)

        # Handle contingent orders for both spread and non-spread instruments
        # For spread instruments, contingent orders work without position linkage
        if order.contingency_type == ContingencyType.OTO:
            # For non-spread instruments, link to position if available
            if not instrument.is_spread() and position is not None and position.is_open_c():
                for client_order_id in order.linked_order_ids or []:
                    contingent_order = self._cache.order(client_order_id)
                    if contingent_order is not None and contingent_order.position_id is None:
                        contingent_order.position_id = position.id
                        self._cache.add_position_id(
                            position.id,
                            contingent_order.instrument_id.venue,
                            contingent_order.client_order_id,
                            contingent_order.strategy_id,
                        )
            # For spread instruments, contingent orders can still be triggered
            # but without position linkage (since no position is created for spreads)

        self._msgbus.publish_c(
            topic=self._get_fill_events_topic(fill.instrument_id),
            msg=fill,
        )

    cdef void _handle_position_update(self, Instrument instrument, OrderFilled fill, OmsType oms_type):
        cdef Position position = self._cache.position(fill.position_id)

        if position is None or position.is_closed_c():
            self._open_position(instrument, position, fill, oms_type)
        elif self._will_flip_position(position, fill):
            self._flip_position(instrument, position, fill, oms_type)
        else:
            self._update_position(instrument, position, fill, oms_type)

    cpdef void _open_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type):
        if position is not None:
            try:
                position._check_duplicate_trade_id(fill)
            except KeyError:
                self._log.warning(
                    f"Ignoring duplicate fill {fill.trade_id} for closed position {position.id}; "
                    "no position reopened",
                )
                return

            self._reopen_position(position, oms_type)

        position = Position(instrument, fill)
        self._cache.add_position(position, oms_type)

        cdef PositionOpened event = PositionOpened.create_c(
            position=position,
            fill=fill,
            event_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
        )

        self._pending_position_events.append(event)

        if self.snapshot_positions:
            self._create_position_state_snapshot(position, open_only=True)

        self._msgbus.send(
            endpoint="Portfolio.update_position",
            msg=event,
        )

    cpdef void _reopen_position(self, Position position, OmsType oms_type):
        if oms_type == OmsType.NETTING:
            if position.is_open_c():
                raise RuntimeError(
                    f"Cannot reopen position {position.info()} (oms_type={oms_type_to_str(oms_type)}: "
                    "reopening is only valid for closed positions in NETTING mode"
                )
            # Snapshot closed position if reopening (NETTING mode)
            self._cache.snapshot_position(position)
        else:  # HEDGING
            self._log.warning(
                f"Received fill for closed position {position.id} in HEDGING mode; "
                "creating new position and ignoring previous state"
            )

    cpdef void _update_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type):
        try:
            position.apply(fill)
        except KeyError as e:
            # Protected against duplicate OrderFilled
            self._log.exception(f"Error on applying {fill!r} to {position!r}", e)
            return  # Not re-raising to avoid crashing engine

        self._cache.update_position(position)

        cdef PositionEvent event
        if position.is_closed_c():
            event = PositionClosed.create_c(
                position=position,
                fill=fill,
                event_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
            )
        else:
            event = PositionChanged.create_c(
                position=position,
                fill=fill,
                event_id=UUID4(),
                ts_init=self._clock.timestamp_ns(),
            )

        self._pending_position_events.append(event)

        if self.snapshot_positions:
            self._create_position_state_snapshot(position, open_only=False)

        self._msgbus.send(
            endpoint="Portfolio.update_position",
            msg=event,
        )

    cpdef bint _will_flip_position(self, Position position, OrderFilled fill):
        return (
            # Check for flip (last_qty guaranteed to be positive)
            position.is_opposite_side(fill.order_side)
            and fill.last_qty._mem.raw > position.quantity._mem.raw
        )

    cpdef void _flip_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type):
        cdef Quantity difference = None
        if position.side == PositionSide.LONG:
            difference = Quantity(fill.last_qty - position.quantity, position.size_precision)
        elif position.side == PositionSide.SHORT:
            difference = Quantity(abs(position.quantity - fill.last_qty), position.size_precision)
        else:
            difference = fill.last_qty

        # Split commission between two positions
        fill_percent: Decimal = position.quantity / fill.last_qty
        cdef Money commission1 = Money(fill.commission * fill_percent, fill.commission.currency)
        cdef Money commission2 = Money(fill.commission - commission1, fill.commission.currency)

        cdef OrderFilled fill_split1 = None
        if position.is_open_c():
            # Split fill to close original position
            fill_split1 = OrderFilled(
                trader_id=fill.trader_id,
                strategy_id=fill.strategy_id,
                instrument_id=fill.instrument_id,
                client_order_id=fill.client_order_id,
                venue_order_id=fill.venue_order_id,
                account_id=fill.account_id,
                trade_id=fill.trade_id,
                position_id=fill.position_id,
                order_side=fill.order_side,
                order_type=fill.order_type,
                last_qty=position.quantity,  # Fill original position quantity remaining
                last_px=fill.last_px,
                currency=fill.currency,
                commission=commission1,
                liquidity_side=fill.liquidity_side,
                event_id=fill.id,
                ts_event=fill.ts_event,
                ts_init=fill.ts_init,
            )

            # Close original position
            self._update_position(instrument, position, fill_split1, oms_type)

            # Snapshot closed position before reusing ID (NETTING mode)
            if oms_type == OmsType.NETTING:
                self._cache.snapshot_position(position)

        # Guard against flipping a position with a zero fill size
        if difference._mem.raw == 0:
            self._log.warning(
                "Zero fill size during position flip calculation, this could be caused by"
                "a mismatch between instrument `size_precision` and a quantity `size_precision`"
            )
            return

        cdef PositionId position_id_flip = fill.position_id
        if oms_type == OmsType.HEDGING and fill.position_id.is_virtual_c():
            # Generate new position ID for flipped virtual position
            position_id_flip = self._pos_id_generator.generate(
                strategy_id=fill.strategy_id,
                flipped=True,
            )

        # Generate order fill for flipped position
        cdef OrderFilled fill_split2 = OrderFilled(
            trader_id=fill.trader_id,
            strategy_id=fill.strategy_id,
            instrument_id=fill.instrument_id,
            client_order_id=fill.client_order_id,
            venue_order_id=fill.venue_order_id,
            account_id=fill.account_id,
            trade_id=fill.trade_id,
            position_id=position_id_flip,
            order_side=fill.order_side,
            order_type=fill.order_type,
            last_qty=difference,  # Fill difference from original as above
            last_px=fill.last_px,
            currency=fill.currency,
            commission=commission2,
            liquidity_side=fill.liquidity_side,
            event_id=UUID4(),  # New event ID
            ts_event=fill.ts_event,
            ts_init=fill.ts_init,
        )

        if oms_type == OmsType.HEDGING and fill.position_id.is_virtual_c():
            self._log.warning(f"Closing position {fill_split1}")
            self._log.warning(f"Flipping position {fill_split2}")

        # Open flipped position
        self._open_position(instrument, None, fill_split2, oms_type)

    cpdef void _create_order_state_snapshot(self, Order order):
        if self.debug:
            self._log.debug(f"Creating order state snapshot for {order}", LogColor.MAGENTA)

        if self._cache.has_backing:
            self._cache.snapshot_order_state(order)

        if self._msgbus.has_backing and self._msgbus.serializer is not None:
            self._msgbus.publish_c(
                topic=f"snapshots:orders:{order.client_order_id.to_str()}",
                msg=self._msgbus.serializer.serialize(order.to_dict())
            )

    cpdef void _create_position_state_snapshot(self, Position position, bint open_only):
        if self.debug:
            self._log.debug(f"Creating position state snapshot for {position}", LogColor.MAGENTA)

        cdef uint64_t ts_snapshot = self._clock.timestamp_ns()

        cdef Money unrealized_pnl = self._cache.calculate_unrealized_pnl(position)
        cdef dict[str, object] position_state = position.to_dict()
        if unrealized_pnl is not None:
            position_state["unrealized_pnl"] = str(unrealized_pnl)

        position_state["ts_snapshot"] = ts_snapshot

        self._msgbus.publish_c(
            topic=f"snapshots.positions.{position.id}",
            msg=position_state,
            external_pub=False,
        )

        if self._cache.has_backing:
            self._cache.snapshot_position_state(
                position,
                ts_snapshot,
                unrealized_pnl,
                open_only,
            )

        if self._msgbus.has_backing and self._msgbus.serializer is not None:
            self._msgbus.publish_c(
                topic=f"snapshots:positions:{position.id}",
                msg=self._msgbus.serializer.serialize(position_state),
            )

    cpdef void _snapshot_open_position_states(self, TimeEvent event):
        cdef Position position
        for position in self._cache.positions_open():
            self._create_position_state_snapshot(position, open_only=True)

</document_content>
</document>
<document index="2345">
<source>nautilus_trader/execution/manager.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint8_t
from libc.stdint cimport uint64_t

from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.component cimport CMD
from nautilus_trader.common.component cimport EVT
from nautilus_trader.common.component cimport SENT
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport Logger
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport is_logging_initialized
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.message cimport Command
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.execution.messages cimport TradingCommand
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderEvent
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.events.position cimport PositionEvent
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class OrderManager:
    """
    Provides a generic order execution manager.

    Parameters
    ----------
    clock : Clock
        The clock for the order manager.
    msgbus : MessageBus
        The message bus for the order manager.
    cache : Cache
        The cache for the order manager.
    component_name : str
        The component name for the order manager.
    active_local : str
        If the manager is for active local orders.
    submit_order_handler : Callable[[SubmitOrder], None], optional
        The handler to call when submitting orders.
    cancel_order_handler : Callable[[Order], None], optional
        The handler to call when canceling orders.
    modify_order_handler : Callable[[Order, Quantity], None], optional
        The handler to call when modifying orders (limited to modifying quantity).
    debug : bool, default False
        If debug mode is active (will provide extra debug logging).

    Raises
    ------
    TypeError
        If `submit_order_handler` is not ``None`` and not of type `Callable`.
    TypeError
        If `cancel_order_handler` is not ``None`` and not of type `Callable`.
    TypeError
        If `modify_order_handler` is not ``None`` and not of type `Callable`.
    """

    def __init__(
        self,
        Clock clock not None,
        MessageBus msgbus,
        Cache cache not None,
        str component_name not None,
        bint active_local,
        submit_order_handler: Callable[[SubmitOrder], None] = None,
        cancel_order_handler: Callable[[Order], None] = None,
        modify_order_handler: Callable[[Order, Quantity], None] = None,
        bint debug = False,
        bint log_events = True,
        bint log_commands = True,
    ):
        Condition.valid_string(component_name, "component_name")
        Condition.callable_or_none(submit_order_handler, "submit_order_handler")
        Condition.callable_or_none(cancel_order_handler, "cancel_order_handler")
        Condition.callable_or_none(modify_order_handler, "modify_order_handler")

        self._clock = clock
        self._log = Logger(name=component_name)
        self._msgbus = msgbus
        self._cache = cache

        self.active_local = active_local
        self.debug = debug
        self.log_events = log_events
        self.log_commands = log_commands
        self._submit_order_handler = submit_order_handler
        self._cancel_order_handler = cancel_order_handler
        self._modify_order_handler = modify_order_handler

        self._submit_order_commands: dict[ClientOrderId, SubmitOrder] = {}

    cpdef dict get_submit_order_commands(self):
        """
        Return the managers cached submit order commands.

        Returns
        -------
        dict[ClientOrderId, SubmitOrder]

        """
        return self._submit_order_commands.copy()

    cpdef void cache_submit_order_command(self, SubmitOrder command):
        """
        Cache the given submit order `command` with the manager.

        Parameters
        ----------
        command : SubmitOrder
            The submit order command to cache.

        """
        Condition.not_none(command, "command")

        self._submit_order_commands[command.order.client_order_id] = command

    cpdef SubmitOrder pop_submit_order_command(self, ClientOrderId client_order_id):
        """
        Pop the submit order command for the given `client_order_id` out of the managers
        cache (if found).

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID for the command to pop.

        Returns
        -------
        SubmitOrder or ``None``

        """
        Condition.not_none(client_order_id, "client_order_id")

        return self._submit_order_commands.pop(client_order_id, None)

    cpdef void reset(self):
        """
        Reset the manager, clearing all stateful values.
        """
        self._submit_order_commands.clear()

    cpdef void cancel_order(self, Order order):
        """
        Cancel the given `order` with the manager.

        Parameters
        ----------
        order : Order
            The order to cancel.

        """
        Condition.not_none(order, "order")

        if self._cache.is_order_pending_cancel_local(order.client_order_id):
            return  # Already pending cancel locally

        if order.is_closed_c():
            self._log.warning("Cannot cancel order: already closed")
            return

        if self.debug:
            self._log.info(f"Canceling order {order}", LogColor.MAGENTA)

        self._submit_order_commands.pop(order.client_order_id, None)

        if self._cancel_order_handler is not None:
            self._cancel_order_handler(order)

    cpdef void modify_order_quantity(self, Order order, Quantity new_quantity):
        """
        Modify the given `order` with the manager.

        Parameters
        ----------
        order : Order
            The order to modify.

        """
        Condition.not_none(order, "order")
        Condition.not_none(new_quantity, "new_quantity")

        if self._modify_order_handler is not None:
            self._modify_order_handler(order, new_quantity)

    cpdef void create_new_submit_order(
        self,
        Order order,
        PositionId position_id = None,
        ClientId client_id = None,
    ):
        """
        Create a new submit order command for the given `order`.

        Parameters
        ----------
        order : Order
            The order for the command.
        position_id : PositionId, optional
            The position ID for the command.
        client_id : ClientId, optional
            The client ID for the command.

        """
        Condition.not_none(order, "order")

        if self.debug:
            self._log.info(
                f"Creating new `SubmitOrder` command for {order}, {position_id=}, {client_id=}",
                LogColor.MAGENTA,
            )

        cdef SubmitOrder submit = SubmitOrder(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            order=order,
            position_id=position_id,
            client_id=client_id,
            command_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
        )

        if order.emulation_trigger == TriggerType.NO_TRIGGER:
            # Cache command
            self.cache_submit_order_command(submit)

            if order.exec_algorithm_id is not None:
                self.send_algo_command(submit, order.exec_algorithm_id)
            else:
                self.send_risk_command(submit)
        else:
            self._submit_order_handler(submit)

    cpdef bint should_manage_order(self, Order order):
        """
        Check if the given order should be managed.

        Parameters
        ----------
        order : Order
            The order to check.

        Returns
        -------
        bool
            True if the order should be managed, else False.

        """
        Condition.not_none(order, "order")

        if self.active_local:
            return order.is_active_local_c()
        else:
            return not order.is_active_local_c()

# -- EVENT HANDLERS -------------------------------------------------------------------------------

    cpdef void handle_event(self, Event event):
        """
        Handle the given `event`.

        If a handler for the given event is not implemented then this will simply be a no-op.

        Parameters
        ----------
        event : Event
            The event to handle

        """
        if isinstance(event, OrderRejected):
            self.handle_order_rejected(event)
        elif isinstance(event, OrderCanceled):
            self.handle_order_canceled(event)
        elif isinstance(event, OrderExpired):
            self.handle_order_expired(event)
        elif isinstance(event, OrderUpdated):
            self.handle_order_updated(event)
        elif isinstance(event, OrderFilled):
            self.handle_order_filled(event)
        elif isinstance(event, PositionEvent):
            self.handle_position_event(event)

    cpdef void handle_order_rejected(self, OrderRejected rejected):
        Condition.not_none(rejected, "rejected")

        cdef Order order = self._cache.order(rejected.client_order_id)
        if order is None:
            self._log.error(  # pragma: no cover (design-time error)
                "Cannot handle `OrderRejected`: "
                f"order for {repr(rejected.client_order_id)} not found, {rejected}",
                )
            return

        if order.contingency_type != ContingencyType.NO_CONTINGENCY:
            self.handle_contingencies(order)

    cpdef void handle_order_canceled(self, OrderCanceled canceled):
        Condition.not_none(canceled, "canceled")

        cdef Order order = self._cache.order(canceled.client_order_id)
        if order is None:
            self._log.error(  # pragma: no cover (design-time error)
                "Cannot handle `OrderCanceled`: "
                f"order for {repr(canceled.client_order_id)} not found, {canceled}",
                )
            return

        if order.contingency_type != ContingencyType.NO_CONTINGENCY:
            self.handle_contingencies(order)

    cpdef void handle_order_expired(self, OrderExpired expired):
        Condition.not_none(expired, "expired")

        cdef Order order = self._cache.order(expired.client_order_id)
        if order is None:
            self._log.error(  # pragma: no cover (design-time error)
                "Cannot handle `OrderExpired`: "
                f"order for {repr(expired.client_order_id)} not found, {expired}",
                )
            return

        if order.contingency_type != ContingencyType.NO_CONTINGENCY:
            self.handle_contingencies(order)

    cpdef void handle_order_updated(self, OrderUpdated updated):
        Condition.not_none(updated, "updated")

        cdef Order order = self._cache.order(updated.client_order_id)
        if order is None:
            self._log.error(  # pragma: no cover (design-time error)
                "Cannot handle `OrderUpdated`: "
                f"order for {repr(updated.client_order_id)} not found, {updated}",
                )
            return

        if order.contingency_type != ContingencyType.NO_CONTINGENCY:
            self.handle_contingencies_update(order)

    cpdef void handle_order_filled(self, OrderFilled filled):
        Condition.not_none(filled, "filled")

        if self.debug:
            self._log.info(f"Handling fill for {filled.client_order_id}", LogColor.MAGENTA)

        cdef Order order = self._cache.order(filled.client_order_id)
        if order is None:  # pragma: no cover (design-time error)
            self._log.error(
                "Cannot handle `OrderFilled`: "
                f"order for {repr(filled.client_order_id)} not found, {filled}",
            )
            return

        cdef:
            PositionId position_id
            ClientId client_id
            ClientOrderId client_order_id
            Order child_order
            Order primary_order
            Order spawn_order
            Quantity parent_filled_qty
        if order.contingency_type == ContingencyType.OTO:
            Condition.not_empty(order.linked_order_ids, "order.linked_order_ids")

            position_id = self._cache.position_id(order.client_order_id)
            client_id = self._cache.client_id(order.client_order_id)

            if order.exec_spawn_id is not None:
                # Determine total filled of execution spawn sequence
                parent_filled_qty = self._cache.exec_spawn_total_filled_qty(order.exec_spawn_id)
            else:
                parent_filled_qty = order.filled_qty

            for client_order_id in order.linked_order_ids:
                child_order = self._cache.order(client_order_id)
                if child_order is None:
                    raise RuntimeError(f"Cannot find OTO child order for {repr(client_order_id)}")  # pragma: no cover

                if not self.should_manage_order(child_order):
                    continue  # Not being managed

                if self.debug:
                    self._log.info(f"Processing OTO child order {child_order}", LogColor.MAGENTA)
                    self._log.info(f"{parent_filled_qty=}", LogColor.MAGENTA)

                if child_order.position_id is None:
                    child_order.position_id = position_id

                if parent_filled_qty._mem.raw != child_order.leaves_qty._mem.raw:
                    self.modify_order_quantity(child_order, parent_filled_qty)

                if self._submit_order_handler is None:
                    return  # No handler to submit

                if not child_order.client_order_id in self._submit_order_commands:
                    self.create_new_submit_order(
                        order=child_order,
                        position_id=position_id,
                        client_id=client_id,
                    )
        elif order.contingency_type == ContingencyType.OCO:
            # Cancel all OCO orders
            for client_order_id in order.linked_order_ids:
                contingent_order = self._cache.order(client_order_id)
                if contingent_order is None:
                    raise RuntimeError(f"Cannot find OCO contingent order for {repr(client_order_id)}")  # pragma: no cover

                if self.debug:
                    self._log.info(f"Processing OCO contingent order {contingent_order}", LogColor.MAGENTA)

                if not self.should_manage_order(contingent_order):
                    continue  # Not being managed
                if contingent_order.is_closed_c():
                    continue  # Already completed
                if contingent_order.client_order_id != order.client_order_id:
                    self.cancel_order(contingent_order)
        elif order.contingency_type == ContingencyType.OUO:
            self.handle_contingencies(order)

    cpdef void handle_contingencies(self, Order order):
        Condition.not_none(order, "order")
        Condition.not_empty(order.linked_order_ids, "order.linked_order_ids")

        if self.debug:
            self._log.info(
                f"Handling contingencies for {order.client_order_id}", LogColor.MAGENTA,
            )

        cdef:
            Quantity filled_qty
            Quantity leaves_qty
            bint is_spawn_active = False
        if order.exec_spawn_id is not None:
            # Determine total quantities of execution spawn sequence
            filled_qty = self._cache.exec_spawn_total_filled_qty(order.exec_spawn_id)
            leaves_qty = self._cache.exec_spawn_total_leaves_qty(order.exec_spawn_id, active_only=True)
            is_spawn_active = leaves_qty._mem.raw > 0
        else:
            filled_qty = order.filled_qty
            leaves_qty = order.leaves_qty

        cdef ClientOrderId client_order_id
        cdef Order contingent_order
        for client_order_id in order.linked_order_ids:
            contingent_order = self._cache.order(client_order_id)
            if contingent_order is None:
                raise RuntimeError(f"Cannot find contingent order for {repr(client_order_id)}")  # pragma: no cover
            if not self.should_manage_order(contingent_order):
                continue  # Not being managed
            if client_order_id == order.client_order_id:
                continue  # Already being handled
            if contingent_order.is_closed_c():
                self._submit_order_commands.pop(order.client_order_id, None)
                continue  # Already completed

            if order.contingency_type == ContingencyType.OTO:
                if self.debug:
                    self._log.info(f"Processing OTO child order {contingent_order}", LogColor.MAGENTA)
                    self._log.info(f"{filled_qty=}, {contingent_order.quantity=}", LogColor.YELLOW)
                if order.is_closed_c() and filled_qty._mem.raw == 0 and (order.exec_spawn_id is None or not is_spawn_active):
                    self.cancel_order(contingent_order)
                elif filled_qty._mem.raw > 0 and filled_qty._mem.raw != contingent_order.quantity._mem.raw:
                    self.modify_order_quantity(contingent_order, filled_qty)
            elif order.contingency_type == ContingencyType.OCO:
                if self.debug:
                    self._log.info(f"Processing OCO contingent order {client_order_id}", LogColor.MAGENTA)
                if order.is_closed_c() and (order.exec_spawn_id is None or not is_spawn_active):
                    self.cancel_order(contingent_order)
            elif order.contingency_type == ContingencyType.OUO:
                if self.debug:
                    self._log.info(f"Processing OUO contingent order {client_order_id}, {leaves_qty=}, {contingent_order.leaves_qty=}", LogColor.MAGENTA)
                if leaves_qty._mem.raw == 0 and order.exec_spawn_id is not None:
                    self.cancel_order(contingent_order)
                elif order.is_closed_c() and (order.exec_spawn_id is None or not is_spawn_active):
                    self.cancel_order(contingent_order)
                elif leaves_qty._mem.raw != contingent_order.leaves_qty._mem.raw:
                    self.modify_order_quantity(contingent_order, leaves_qty)

    cpdef void handle_contingencies_update(self, Order order):
        Condition.not_none(order, "order")

        if self.debug:
            self._log.info(
                f"Handling contingencies update for {order.client_order_id}", LogColor.MAGENTA,
            )

        cdef:
            Quantity quantity
        if order.exec_spawn_id is not None:
            # Determine total quantity of execution spawn sequence
            quantity = self._cache.exec_spawn_total_quantity(order.exec_spawn_id, active_only=True)
        else:
            quantity = order.quantity

        if quantity._mem.raw == 0:
            return

        cdef ClientOrderId client_order_id
        cdef Order contingent_order
        for client_order_id in order.linked_order_ids:
            contingent_order = self._cache.order(client_order_id)
            if contingent_order is None:
                raise RuntimeError(f"Cannot find OCO contingent order for {repr(client_order_id)}")  # pragma: no cover

            if not self.should_manage_order(contingent_order):
                continue  # Not being managed
            if client_order_id == order.client_order_id:
                continue  # Already being handled  # pragma: no cover
            if contingent_order.is_closed_c():
                continue  # Already completed  # pragma: no cover

            if order.contingency_type == ContingencyType.OTO:
                if quantity._mem.raw != contingent_order.quantity._mem.raw:
                    self.modify_order_quantity(contingent_order, quantity)
            elif order.contingency_type == ContingencyType.OUO:
                if quantity._mem.raw != contingent_order.quantity._mem.raw:
                    self.modify_order_quantity(contingent_order, quantity)

    cpdef void handle_position_event(self, PositionEvent event):
        Condition.not_none(event, "event")
        # TBC

# -- EGRESS ---------------------------------------------------------------------------------------

    cpdef void send_emulator_command(self, TradingCommand command):
        Condition.not_none(command, "command")

        if self.log_commands and is_logging_initialized():
            self._log.info(f"{CMD}{SENT} [Emulator] {command}")  # pragma: no cover  (no logging in tests)
        self._msgbus.send(endpoint="OrderEmulator.execute", msg=command)

    cpdef void send_algo_command(self, TradingCommand command, ExecAlgorithmId exec_algorithm_id):
        Condition.not_none(command, "command")
        Condition.not_none(exec_algorithm_id, "exec_algorithm_id")

        if self.log_commands and is_logging_initialized():
            self._log.info(f"{CMD}{SENT} [Algorithm] {command}")  # pragma: no cover  (no logging in tests)
        self._msgbus.send(endpoint=f"{exec_algorithm_id}.execute", msg=command)

    cpdef void send_risk_command(self, TradingCommand command):
        Condition.not_none(command, "command")

        if self.log_commands and is_logging_initialized():
            self._log.info(f"{CMD}{SENT} [Risk] {command}")  # pragma: no cover  (no logging in tests)
        self._msgbus.send(endpoint="RiskEngine.execute", msg=command)

    cpdef void send_exec_command(self, Command command):
        Condition.not_none(command, "command")

        if self.log_commands and is_logging_initialized():
            self._log.info(f"{CMD}{SENT} [Execution] {command}")  # pragma: no cover  (no logging in tests)
        self._msgbus.send(endpoint="ExecEngine.execute", msg=command)

    cpdef void send_risk_event(self, OrderEvent event):
        Condition.not_none(event, "event")

        if self.log_events and is_logging_initialized():
            self._log.info(f"{EVT}{SENT} {event}")  # pragma: no cover  (no logging in tests)
        self._msgbus.send(endpoint="RiskEngine.process", msg=event)

    cpdef void send_exec_event(self, OrderEvent event):
        Condition.not_none(event, "event")

        if self.log_events and is_logging_initialized():
            self._log.info(f"{EVT}{SENT} {event}")  # pragma: no cover (no logging in tests)
        self._msgbus.send(endpoint="ExecEngine.process", msg=event)

</document_content>
</document>
<document index="2347">
<source>nautilus_trader/execution/matching_core.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from typing import Callable

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport PriceRaw
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.orders.base cimport Order


cdef class MatchingCore:
    """
    Provides a generic order matching core.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the matching core.
    price_increment : Price
        The minimum price increment (tick size) for the matching core.
    trigger_stop_order : Callable[[Order], None]
        The callable when a stop order is triggered.
    fill_market_order : Callable[[Order], None]
        The callable when a market order is filled.
    fill_limit_order : Callable[[Order], None]
        The callable when a limit order is filled.
    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Price price_increment not None,
        trigger_stop_order not None: Callable,
        fill_market_order not None: Callable,
        fill_limit_order not None: Callable,
    ):
        self._instrument_id = instrument_id
        self._price_increment = price_increment
        self._price_precision = price_increment.precision

        # Market
        self.bid_raw = 0
        self.ask_raw = 0
        self.last_raw = 0
        self.is_bid_initialized = False
        self.is_ask_initialized = False
        self.is_last_initialized = False

        # Event handlers
        self._trigger_stop_order = trigger_stop_order
        self._fill_market_order = fill_market_order
        self._fill_limit_order = fill_limit_order

        # Orders
        self._orders: dict[ClientOrderId, Order] = {}
        self._orders_bid: list[Order] = []
        self._orders_ask: list[Order] = []

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the instrument ID for the matching core.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def price_precision(self) -> int:
        """
        Return the instruments price precision for the matching core.

        Returns
        -------
        int

        """
        return self._price_increment.precision

    @property
    def price_increment(self) -> Price:
        """
        Return the instruments minimum price increment (tick size) for the matching core.

        Returns
        -------
        Price

        """
        return self._price_increment

    @property
    def bid(self) -> Price | None:
        """
        Return the current bid price for the matching core.

        Returns
        -------
        Price or ``None``

        """
        if not self.is_bid_initialized:
            return None
        else:
            return Price.from_raw_c(self.bid_raw, self._price_precision)

    @property
    def ask(self) -> Price | None:
        """
        Return the current ask price for the matching core.

        Returns
        -------
        Price or ``None``

        """
        if not self.is_ask_initialized:
            return None
        else:
            return Price.from_raw_c(self.ask_raw, self._price_precision)

    @property
    def last(self) -> Price | None:
        """
        Return the current last price for the matching core.

        Returns
        -------
        Price or ``None``

        """
        if not self.is_last_initialized:
            return None
        else:
            return Price.from_raw_c(self.last_raw, self._price_precision)

# -- QUERIES --------------------------------------------------------------------------------------

    cpdef Order get_order(self, ClientOrderId client_order_id):
        Condition.not_none(client_order_id, "client_order_id")
        return self._orders.get(client_order_id)

    cpdef bint order_exists(self, ClientOrderId client_order_id):
        Condition.not_none(client_order_id, "client_order_id")
        return client_order_id in self._orders

    cpdef list get_orders(self):
        return self._orders_bid + self._orders_ask

    cpdef list get_orders_bid(self):
        return self._orders_bid

    cpdef list get_orders_ask(self):
        return self._orders_ask

# -- COMMANDS -------------------------------------------------------------------------------------

    cdef void set_bid_raw(self, PriceRaw bid_raw):
        self.is_bid_initialized = True
        self.bid_raw = bid_raw

    cdef void set_ask_raw(self, PriceRaw ask_raw):
        self.is_ask_initialized = True
        self.ask_raw = ask_raw

    cdef void set_last_raw(self, PriceRaw last_raw):
        self.is_last_initialized = True
        self.last_raw = last_raw

    cpdef void reset(self):
        self._orders.clear()
        self._orders_bid.clear()
        self._orders_ask.clear()
        self.bid_raw = 0
        self.ask_raw = 0
        self.last_raw = 0
        self.is_bid_initialized = False
        self.is_ask_initialized = False
        self.is_last_initialized = False

    cpdef void add_order(self, Order order):
        Condition.not_none(order, "order")

        # Needed as closures not supported in cpdef functions
        self._add_order(order)

    cdef void _add_order(self, Order order):
        # Index order
        self._orders[order.client_order_id] = order

        if order.side == OrderSide.BUY:
            self._orders_bid.append(order)
            self.sort_bid_orders()
        elif order.side == OrderSide.SELL:
            self._orders_ask.append(order)
            self.sort_ask_orders()
        else:
            raise RuntimeError(f"invalid `OrderSide`, was {order.side}")  # pragma: no cover (design-time error)

    cdef void sort_bid_orders(self):
        self._orders_bid.sort(key=order_sort_key, reverse=True)

    cdef void sort_ask_orders(self):
        self._orders_ask.sort(key=order_sort_key)

    cpdef void delete_order(self, Order order):
        Condition.not_none(order, "order")

        self._orders.pop(order.client_order_id, None)

        if order.side == OrderSide.BUY:
            if order in self._orders_bid:
                self._orders_bid.remove(order)
        elif order.side == OrderSide.SELL:
            if order in self._orders_ask:
                self._orders_ask.remove(order)
        else:
            raise RuntimeError(f"invalid `OrderSide`, was {order.side}")  # pragma: no cover (design-time error)

    cpdef void iterate(self, uint64_t timestamp_ns):
        cdef Order order
        for order in self._orders_bid + self._orders_ask:  # Lists implicitly copied
            if order.is_closed_c():
                continue  # Orders state has changed since iteration started  # pragma: no cover
            self.match_order(order)

# -- MATCHING -------------------------------------------------------------------------------------

    cpdef void match_order(self, Order order, bint initial = False):
        """
        Match the given order.

        Parameters
        ----------
        order : Order
            The order to match.
        initial : bool, default False
            If this is an initial match.

        Raises
        ------
        TypeError
            If the `order.order_type` is an invalid type for the core (e.g. `MARKET`).

        """
        Condition.not_none(order, "order")

        if (
            order.order_type == OrderType.LIMIT
            or order.order_type == OrderType.MARKET_TO_LIMIT
        ):
            self.match_limit_order(order)
        elif order.order_type == OrderType.STOP_LIMIT:
            self.match_stop_limit_order(order, initial)
        elif order.order_type == OrderType.STOP_MARKET:
            self.match_stop_market_order(order)
        elif order.order_type == OrderType.LIMIT_IF_TOUCHED:
            self.match_limit_if_touched_order(order, initial)
        elif order.order_type == OrderType.MARKET_IF_TOUCHED:
            self.match_market_if_touched_order(order)
        elif order.order_type == OrderType.TRAILING_STOP_LIMIT:
            self.match_trailing_stop_limit_order(order, initial)
        elif order.order_type == OrderType.TRAILING_STOP_MARKET:
            self.match_trailing_stop_market_order(order)
        else:
            raise TypeError(f"invalid `OrderType` was {order.order_type}")  # pragma: no cover (design-time error)

    cpdef void match_limit_order(self, Order order):
        Condition.not_none(order, "order")

        if self.is_limit_matched(order.side, order.price):
            order.liquidity_side = LiquiditySide.MAKER
            self._fill_limit_order(order)

    cpdef void match_stop_market_order(self, Order order):
        Condition.not_none(order, "order")

        if self.is_stop_triggered(order.side, order.trigger_price):
            order.set_triggered_price_c(order.trigger_price)
            # Triggered stop places market order
            self._fill_market_order(order)

    cpdef void match_stop_limit_order(self, Order order, bint initial):
        Condition.not_none(order, "order")

        if order.is_triggered:
            if self.is_limit_matched(order.side, order.price):
                order.liquidity_side = LiquiditySide.MAKER
                self._fill_limit_order(order)
            return

        cdef LiquiditySide liquidity_side
        if self.is_stop_triggered(order.side, order.trigger_price):
            order.set_triggered_price_c(order.trigger_price)
            order.liquidity_side = self._determine_order_liquidity(
                initial,
                order.side,
                order.price,
                order.trigger_price,
            )
            # Check if immediately marketable
            self._trigger_stop_order(order)

    cpdef void match_market_if_touched_order(self, Order order):
        Condition.not_none(order, "order")

        if self.is_touch_triggered(order.side, order.trigger_price):
            order.set_triggered_price_c(order.trigger_price)
            # Triggered stop places market order
            self._fill_market_order(order)

    cpdef void match_limit_if_touched_order(self, Order order, bint initial):
        Condition.not_none(order, "order")

        if order.is_triggered:
            if self.is_limit_matched(order.side, order.price):
                order.liquidity_side = LiquiditySide.MAKER
                self._fill_limit_order(order)
            return

        cdef LiquiditySide liquidity_side
        if self.is_touch_triggered(order.side, order.trigger_price):
            if not initial:
                order.set_triggered_price_c(order.trigger_price)
            order.liquidity_side = self._determine_order_liquidity(
                initial,
                order.side,
                order.price,
                order.trigger_price,
            )
            # Check if immediately marketable
            self._trigger_stop_order(order)

    cpdef void match_trailing_stop_limit_order(self, Order order, bint initial):
        if order.is_activated:
            self.match_stop_limit_order(order, initial)

    cpdef void match_trailing_stop_market_order(self, Order order):
        if order.is_activated:
            self.match_stop_market_order(order)

    cpdef bint is_limit_matched(self, OrderSide side, Price price):
        Condition.not_none(price, "price")

        if side == OrderSide.BUY:
            if not self.is_ask_initialized:
                return False  # No market
            return self.ask_raw <= price._mem.raw
        elif side == OrderSide.SELL:
            if not self.is_bid_initialized:
                return False  # No market
            return self.bid_raw >= price._mem.raw
        else:
            raise ValueError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)

    cpdef bint is_stop_triggered(self, OrderSide side, Price trigger_price):
        Condition.not_none(trigger_price, "trigger_price")

        if side == OrderSide.BUY:
            if not self.is_ask_initialized:
                return False  # No market
            return self.ask_raw >= trigger_price._mem.raw
        elif side == OrderSide.SELL:
            if not self.is_bid_initialized:
                return False  # No market
            return self.bid_raw <= trigger_price._mem.raw
        else:
            raise ValueError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)

    cpdef bint is_touch_triggered(self, OrderSide side, Price trigger_price):
        Condition.not_none(trigger_price, "trigger_price")

        if side == OrderSide.BUY:
            if not self.is_ask_initialized:
                return False  # No market
            return self.ask_raw <= trigger_price._mem.raw
        elif side == OrderSide.SELL:
            if not self.is_bid_initialized:
                return False  # No market
            return self.bid_raw >= trigger_price._mem.raw
        else:
            raise ValueError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)

    cdef LiquiditySide _determine_order_liquidity(
        self,
        bint initial,
        OrderSide side,
        Price price,
        Price trigger_price,
    ):
        if initial:
            return LiquiditySide.TAKER

        if side == OrderSide.BUY and trigger_price._mem.raw > price._mem.raw:
            return LiquiditySide.MAKER
        elif side == OrderSide.SELL and trigger_price._mem.raw < price._mem.raw:
            return LiquiditySide.MAKER

        return LiquiditySide.TAKER


cdef inline int64_t order_sort_key(Order order):
    cdef Price trigger_price
    cdef Price price
    if order.order_type == OrderType.LIMIT:
        price = order.price
        return price._mem.raw
    elif order.order_type == OrderType.MARKET_TO_LIMIT:
        price = order.price
        return price._mem.raw
    elif order.order_type == OrderType.STOP_MARKET:
        trigger_price = order.trigger_price
        return trigger_price._mem.raw
    elif order.order_type == OrderType.STOP_LIMIT:
        trigger_price = order.trigger_price
        price = order.price
        return price._mem.raw if order.is_triggered else trigger_price._mem.raw
    elif order.order_type == OrderType.MARKET_IF_TOUCHED:
        trigger_price = order.trigger_price
        return trigger_price._mem.raw
    elif order.order_type == OrderType.LIMIT_IF_TOUCHED:
        trigger_price = order.trigger_price
        price = order.price
        return price._mem.raw if order.is_triggered else trigger_price._mem.raw
    elif order.order_type == OrderType.TRAILING_STOP_MARKET:
        trigger_price = order.trigger_price or order.activation_price
        return trigger_price._mem.raw
    elif order.order_type == OrderType.TRAILING_STOP_LIMIT:
        trigger_price = order.trigger_price or order.activation_price
        price = order.price
        return price._mem.raw if order.is_triggered else trigger_price._mem.raw
    else:
        raise RuntimeError(  # pragma: no cover (design-time error)
            f"invalid order type to sort in book, "  # pragma: no cover (design-time error)
            f"was {order_type_to_str(order.order_type)}",  # pragma: no cover (design-time error)
        )

</document_content>
</document>
<document index="2349">
<source>nautilus_trader/execution/messages.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from datetime import datetime as py_datetime
from datetime import timezone
from typing import Any

from cpython.datetime cimport datetime
from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.message cimport Command
from nautilus_trader.core.rust.common cimport LogLevel
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.functions cimport order_side_from_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.identifiers cimport VenueOrderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.list cimport OrderList
from nautilus_trader.model.orders.unpacker cimport OrderUnpacker


cpdef datetime _ns_to_datetime(object value):
    if isinstance(value, datetime):
        return value
    if isinstance(value, (int, float)):
        return py_datetime.fromtimestamp(value / 1_000_000_000, tz=timezone.utc)
    return value


cdef class ExecutionReportCommand(Command):
    """
    The base class for all execution report commands.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the command.
    start : datetime, optional
        The start datetime (UTC) of request time range (inclusive).
    end : datetime, optional
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    command_id : UUID4
        The commands ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the command.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        InstrumentId instrument_id : InstrumentId | None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(command_id, ts_init, correlation_id)

        self.instrument_id = instrument_id
        self.start = start
        self.end = end
        self.params = params or {}


cdef class GenerateOrderStatusReport(ExecutionReportCommand):
    """
    Command to generate an order status report.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the command.
    client_order_id : ClientOrderId
        The client order ID to update.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue) to query.
    command_id : UUID4
        The commands ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the command.
    """

    def __init__(
        self,
        InstrumentId instrument_id : InstrumentId | None,
        ClientOrderId client_order_id : ClientOrderId | None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            instrument_id,
            None,
            None,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

        self.client_order_id = client_order_id
        self.venue_order_id = venue_order_id

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef GenerateOrderStatusReport from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str i = values["instrument_id"]
        cdef str c = values["client_order_id"]
        cdef str v = values["venue_order_id"]
        return GenerateOrderStatusReport(
            instrument_id=InstrumentId.from_str_c(i) if i is not None else None,
            client_order_id=ClientOrderId(c) if c is not None else None,
            venue_order_id=VenueOrderId(v) if v is not None else None,
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
            params=values.get("params"),
        )

    @staticmethod
    cdef dict to_dict_c(GenerateOrderStatusReport obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "GenerateOrderStatusReport",
            "instrument_id": obj.instrument_id.to_str() if obj.instrument_id is not None else None,
            "client_order_id": obj.client_order_id.to_str() if obj.client_order_id is not None else None,
            "venue_order_id": obj.venue_order_id.to_str() if obj.venue_order_id is not None else None,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
            "params": obj.params,
        }

    @staticmethod
    def from_dict(dict values) -> GenerateOrderStatusReport:
        """
        Return a generate order status report command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        GenerateOrderStatusReport

        """
        return GenerateOrderStatusReport.from_dict_c(values)

    @staticmethod
    def to_dict(GenerateOrderStatusReport obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return GenerateOrderStatusReport.to_dict_c(obj)


cdef class GenerateOrderStatusReports(ExecutionReportCommand):
    """
    Command to generate order status reports.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the command.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    open_only : bool
        If True then only open orders will be requested.
    command_id : UUID4
        The commands ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the command.
    log_receipt_level : LogLevel, default 'INFO'
        The log level for logging received reports. Must be either `LogLevel.DEBUG` or `LogLevel.INFO`.
    """

    def __init__(
        self,
        InstrumentId instrument_id : InstrumentId | None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        bint open_only,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        LogLevel log_receipt_level = LogLevel.INFO,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            instrument_id,
            start,
            end,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

        self.open_only = open_only
        self.log_receipt_level = log_receipt_level

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"open_only={self.open_only}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef GenerateOrderStatusReports from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str i = values["instrument_id"]
        return GenerateOrderStatusReports(
            instrument_id=InstrumentId.from_str_c(i) if i is not None else None,
            start=_ns_to_datetime(values["start"]),
            end=_ns_to_datetime(values["end"]),
            open_only=values["open_only"],
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
            params=values.get("params"),
        )

    @staticmethod
    cdef dict to_dict_c(GenerateOrderStatusReports obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "GenerateOrderStatusReports",
            "instrument_id": obj.instrument_id.to_str() if obj.instrument_id is not None else None,
            "start": obj.start,
            "end": obj.end,
            "open_only": obj.open_only,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
            "params": obj.params,
        }

    @staticmethod
    def from_dict(dict values) -> GenerateOrderStatusReports:
        """
        Return a generate order status reports command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        GenerateOrderStatusReports

        """
        return GenerateOrderStatusReports.from_dict_c(values)

    @staticmethod
    def to_dict(GenerateOrderStatusReports obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return GenerateOrderStatusReports.to_dict_c(obj)


cdef class GenerateFillReports(ExecutionReportCommand):
    """
    Command to generate fill reports.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the command.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue) to query.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    command_id : UUID4
        The commands ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the command.
    """

    def __init__(
        self,
        InstrumentId instrument_id : InstrumentId | None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            instrument_id,
            start,
            end,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

        self.venue_order_id = venue_order_id

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef GenerateFillReports from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str i = values["instrument_id"]
        cdef str v = values["venue_order_id"]
        return GenerateFillReports(
            instrument_id=InstrumentId.from_str_c(i) if i is not None else None,
            venue_order_id=VenueOrderId(v) if v is not None else None,
            start=_ns_to_datetime(values["start"]),
            end=_ns_to_datetime(values["end"]),
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
            params=values.get("params"),
        )

    @staticmethod
    cdef dict to_dict_c(GenerateFillReports obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "GenerateFillReports",
            "instrument_id": obj.instrument_id.to_str() if obj.instrument_id is not None else None,
            "venue_order_id": obj.venue_order_id.to_str() if obj.venue_order_id is not None else None,
            "start": obj.start,
            "end": obj.end,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
            "params": obj.params,
        }

    @staticmethod
    def from_dict(dict values) -> GenerateFillReports:
        """
        Return a generate fill reports command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        GenerateFillReports

        """
        return GenerateFillReports.from_dict_c(values)

    @staticmethod
    def to_dict(GenerateFillReports obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return GenerateFillReports.to_dict_c(obj)


cdef class GeneratePositionStatusReports(ExecutionReportCommand):
    """
    Command to generate position status reports.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the command.
    start : datetime
        The start datetime (UTC) of request time range (inclusive).
    end : datetime
        The end datetime (UTC) of request time range.
        The inclusiveness depends on individual data client implementation.
    command_id : UUID4
        The commands ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the command.
    log_receipt_level : LogLevel, default 'INFO'
        The log level for logging received reports. Must be either `LogLevel.DEBUG` or `LogLevel.INFO`.
    """

    def __init__(
        self,
        InstrumentId instrument_id : InstrumentId | None,
        datetime start : datetime | None,
        datetime end : datetime | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        LogLevel log_receipt_level = LogLevel.INFO,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            instrument_id,
            start,
            end,
            command_id,
            ts_init,
            params,
            correlation_id,
        )

        self.log_receipt_level = log_receipt_level

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"start={self.start}, "
            f"end={self.end}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef GeneratePositionStatusReports from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str i = values["instrument_id"]
        return GeneratePositionStatusReports(
            instrument_id=InstrumentId.from_str_c(i) if i is not None else None,
            start=_ns_to_datetime(values["start"]),
            end=_ns_to_datetime(values["end"]),
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
            params=values.get("params"),
        )

    @staticmethod
    cdef dict to_dict_c(GeneratePositionStatusReports obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "GeneratePositionStatusReports",
            "instrument_id": obj.instrument_id.to_str() if obj.instrument_id is not None else None,
            "start": obj.start,
            "end": obj.end,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
            "params": obj.params,
        }

    @staticmethod
    def from_dict(dict values) -> GeneratePositionStatusReports:
        """
        Return a generate position status reports command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        GeneratePositionStatusReports

        """
        return GeneratePositionStatusReports.from_dict_c(values)

    @staticmethod
    def to_dict(GeneratePositionStatusReports obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return GeneratePositionStatusReports.to_dict_c(obj)


cdef class GenerateExecutionMassStatus(ExecutionReportCommand):
    """
    Command to generate an execution mass status report.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    client_id : ClientId
        The client ID for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    venue : Venue, optional
        The venue for the command.
    params : dict[str, object], optional
        Additional parameters for the command.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        ClientId client_id not None,
        UUID4 command_id not None,
        uint64_t ts_init,
        Venue venue: Venue | None = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            instrument_id=None,
            start=None,
            end=None,
            command_id=command_id,
            ts_init=ts_init,
            params=params,
            correlation_id=correlation_id,
        )

        self.trader_id = trader_id
        self.client_id = client_id
        self.venue = venue

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"client_id={self.client_id}, "
            f"venue={self.venue}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef GenerateExecutionMassStatus from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str venue = values["venue"]
        return GenerateExecutionMassStatus(
            trader_id=TraderId(values["trader_id"]),
            client_id=ClientId(values["client_id"]),
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
            venue=Venue(venue) if venue else None,
            params=values.get("params"),
        )

    @staticmethod
    cdef dict to_dict_c(GenerateExecutionMassStatus obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "GenerateExecutionMassStatus",
            "trader_id": obj.trader_id.to_str(),
            "client_id": obj.client_id.to_str(),
            "venue": obj.venue.to_str() if obj.venue is not None else None,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
            "params": obj.params,
        }

    @staticmethod
    def from_dict(dict values) -> GenerateExecutionMassStatus:
        """
        Return a generate execution mass status command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        GenerateExecutionMassStatus

        """
        return GenerateExecutionMassStatus.from_dict_c(values)

    @staticmethod
    def to_dict(GenerateExecutionMassStatus obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return GenerateExecutionMassStatus.to_dict_c(obj)


cdef class TradingCommand(Command):
    """
    The base class for all trading related commands.

    Parameters
    ----------
    client_id : ClientId or ``None``
        The execution client ID for the command.
    trader_id : TraderId
        The trader ID for the command.
    strategy_id : StrategyId
        The strategy ID for the command.
    instrument_id : InstrumentId
        The instrument ID for the command.
    command_id : UUID4
        The commands ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    params : dict[str, object], optional
        Additional parameters for the command.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        ClientId client_id: ClientId | None,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        UUID4 command_id not None,
        uint64_t ts_init,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(command_id, ts_init, correlation_id)

        self.client_id = client_id
        self.trader_id = trader_id
        self.strategy_id = strategy_id
        self.instrument_id = instrument_id
        self.params = params or {}


cdef class SubmitOrder(TradingCommand):
    """
    Represents a command to submit the given order.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    strategy_id : StrategyId
        The strategy ID for the command.
    order : Order
        The order to submit.
    command_id : UUID4
        The commands ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    position_id : PositionId, optional
        The position ID for the command.
    client_id : ClientId, optional
        The execution client ID for the command.
    params : dict[str, object], optional
        Additional parameters for the command.

    References
    ----------
    https://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_D_68.html
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        Order order not None,
        UUID4 command_id not None,
        uint64_t ts_init,
        PositionId position_id: PositionId | None = None,
        ClientId client_id = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            client_id=client_id,
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=order.instrument_id,
            command_id=command_id,
            ts_init=ts_init,
            params=params,
            correlation_id=correlation_id,
        )

        self.order = order
        self.exec_algorithm_id = order.exec_algorithm_id
        self.position_id = position_id

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"order={self.order}, "
            f"position_id={self.position_id})" # Can be None
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "  # Can be None
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"client_order_id={self.order.client_order_id.to_str()}, "
            f"order={self.order}, "
            f"position_id={self.position_id}, "  # Can be None
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef SubmitOrder from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str c = values["client_id"]
        cdef str p = values["position_id"]
        cdef Order order = OrderUnpacker.unpack_c(values["order"]),
        return SubmitOrder(
            client_id=ClientId(c) if c is not None else None,
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            order=order,
            position_id=PositionId(p) if p is not None else None,
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(SubmitOrder obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "SubmitOrder",
            "client_id": obj.client_id.to_str() if obj.client_id is not None else None,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "order": OrderInitialized.to_dict_c(obj.order.init_event_c()),
            "position_id": obj.position_id.to_str() if obj.position_id is not None else None,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> SubmitOrder:
        """
        Return a submit order command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        SubmitOrder

        """
        return SubmitOrder.from_dict_c(values)

    @staticmethod
    def to_dict(SubmitOrder obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return SubmitOrder.to_dict_c(obj)


cdef class SubmitOrderList(TradingCommand):
    """
    Represents a command to submit an order list consisting of an order batch/bulk
    of related parent-child contingent orders.

    This command can correspond to a `NewOrderList <E> message` for the FIX
    protocol.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    strategy_id : StrategyId
        The strategy ID for the command.
    order_list : OrderList
        The order list to submit.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    position_id : PositionId, optional
        The position ID for the command.
    client_id : ClientId, optional
        The execution client ID for the command.
    params : dict[str, object], optional
        Additional parameters for the command.

    References
    ----------
    https://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_E_69.html
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        OrderList order_list not None,
        UUID4 command_id not None,
        uint64_t ts_init,
        PositionId position_id: PositionId | None = None,
        ClientId client_id = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            client_id=client_id,
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=order_list.instrument_id,
            command_id=command_id,
            ts_init=ts_init,
            params=params,
            correlation_id=correlation_id,
        )

        self.order_list = order_list
        self.exec_algorithm_id = order_list.first.exec_algorithm_id
        self.position_id = position_id
        self.has_emulated_order = True if any(o.emulation_trigger != TriggerType.NO_TRIGGER for o in order_list.orders) else False

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"order_list={self.order_list}, "
            f"position_id={self.position_id})" # Can be None
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "  # Can be None
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"order_list={self.order_list}, "
            f"position_id={self.position_id}, " # Can be None
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef SubmitOrderList from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str c = values["client_id"]
        cdef str p = values["position_id"]
        cdef OrderList order_list = OrderList(
            order_list_id=OrderListId(values["order_list_id"]),
            orders=[OrderUnpacker.unpack_c(o_dict) for o_dict in values["orders"]],
        )
        return SubmitOrderList(
            client_id=ClientId(c) if c is not None else None,
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            order_list=order_list,
            position_id=PositionId(p) if p is not None else None,
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(SubmitOrderList obj):
        Condition.not_none(obj, "obj")
        cdef Order o
        return {
            "type": "SubmitOrderList",
            "client_id": obj.client_id.to_str() if obj.client_id is not None else None,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "order_list_id": str(obj.order_list.id),
            "orders": [OrderInitialized.to_dict_c(o.init_event_c()) for o in obj.order_list.orders],
            "position_id": obj.position_id.to_str() if obj.position_id is not None else None,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> SubmitOrderList:
        """
        Return a submit order list command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        SubmitOrderList

        """
        return SubmitOrderList.from_dict_c(values)

    @staticmethod
    def to_dict(SubmitOrderList obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return SubmitOrderList.to_dict_c(obj)


cdef class ModifyOrder(TradingCommand):
    """
    Represents a command to modify the properties of an existing order.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    strategy_id : StrategyId
        The strategy ID for the command.
    instrument_id : InstrumentId
        The instrument ID for the command.
    client_order_id : ClientOrderId
        The client order ID to update.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue) to update.
    quantity : Quantity or ``None``
        The quantity for the order update.
    price : Price or ``None``
        The price for the order update.
    trigger_price : Price or ``None``
        The trigger price for the order update.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    client_id : ClientId, optional
        The execution client ID for the command.
    params : dict[str, object], optional
        Additional parameters for the command.

    References
    ----------
    https://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_G_71.html
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        Quantity quantity: Quantity | None,
        Price price: Price | None,
        Price trigger_price: Price | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        ClientId client_id = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            client_id=client_id,
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            command_id=command_id,
            ts_init=ts_init,
            params=params,
            correlation_id=correlation_id,
        )

        self.client_order_id = client_order_id
        self.venue_order_id = venue_order_id
        self.quantity = quantity
        self.price = price
        self.trigger_price = trigger_price

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id.to_str()}, "
            f"client_order_id={self.client_order_id.to_str()}, "
            f"venue_order_id={self.venue_order_id}, "  # Can be None
            f"quantity={self.quantity.to_formatted_str() if self.quantity is not None else None}, "
            f"price={self.price.to_formatted_str() if self.price is not None else None}, "
            f"trigger_price={self.trigger_price.to_formatted_str() if self.trigger_price is not None else None})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "  # Can be None
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"client_order_id={self.client_order_id.to_str()}, "
            f"venue_order_id={self.venue_order_id}, "  # Can be None
            f"quantity={self.quantity.to_formatted_str() if self.quantity is not None else None}, "
            f"price={self.price.to_formatted_str() if self.price is not None else None}, "
            f"trigger_price={self.trigger_price.to_formatted_str() if self.trigger_price is not None else None}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef ModifyOrder from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str c = values["client_id"]
        cdef str v = values["venue_order_id"]
        cdef str q = values["quantity"]
        cdef str p = values["price"]
        cdef str t = values["trigger_price"]
        return ModifyOrder(
            client_id=ClientId(c) if c is not None else None,
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            quantity=Quantity.from_str_c(q) if q is not None else None,
            price=Price.from_str_c(p) if p is not None else None,
            trigger_price=Price.from_str_c(t) if t is not None else None,
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(ModifyOrder obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "ModifyOrder",
            "client_id": obj.client_id.to_str() if obj.client_id is not None else None,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "client_order_id": obj.client_order_id.to_str(),
            "venue_order_id": obj.venue_order_id.to_str() if obj.venue_order_id is not None else None,
            "quantity": str(obj.quantity) if obj.quantity is not None else None,
            "price": str(obj.price) if obj.price is not None else None,
            "trigger_price": str(obj.trigger_price) if obj.trigger_price is not None else None,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> ModifyOrder:
        """
        Return a modify order command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        ModifyOrder

        """
        return ModifyOrder.from_dict_c(values)

    @staticmethod
    def to_dict(ModifyOrder obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return ModifyOrder.to_dict_c(obj)


cdef class CancelOrder(TradingCommand):
    """
    Represents a command to cancel an order.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    strategy_id : StrategyId
        The strategy ID for the command.
    instrument_id : InstrumentId
        The instrument ID for the command.
    client_order_id : ClientOrderId
        The client order ID to cancel.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue) to cancel.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    client_id : ClientId, optional
        The execution client ID for the command.
    params : dict[str, object], optional
        Additional parameters for the command.

    References
    ----------
    https://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_F_70.html
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        ClientId client_id = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        if client_id is None:
            client_id = ClientId(instrument_id.venue.value)
        super().__init__(
            client_id=client_id,
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            command_id=command_id,
            ts_init=ts_init,
            params=params,
            correlation_id=correlation_id,
        )

        self.client_order_id = client_order_id
        self.venue_order_id = venue_order_id

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id.to_str()}, "
            f"client_order_id={self.client_order_id.to_str()}, "
            f"venue_order_id={self.venue_order_id})"  # Can be None
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "  # Can be None
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"client_order_id={self.client_order_id.to_str()}, "
            f"venue_order_id={self.venue_order_id}, "  # Can be None
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef CancelOrder from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str c = values["client_id"]
        cdef str v = values["venue_order_id"]
        return CancelOrder(
            client_id=ClientId(c) if c is not None else None,
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(CancelOrder obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "CancelOrder",
            "client_id": obj.client_id.to_str() if obj.client_id is not None else None,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "client_order_id": obj.client_order_id.to_str(),
            "venue_order_id": obj.venue_order_id.to_str() if obj.venue_order_id is not None else None,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> CancelOrder:
        """
        Return a cancel order command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        CancelOrder

        """
        return CancelOrder.from_dict_c(values)

    @staticmethod
    def to_dict(CancelOrder obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return CancelOrder.to_dict_c(obj)


cdef class CancelAllOrders(TradingCommand):
    """
    Represents a command to cancel all orders for an instrument.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    strategy_id : StrategyId
        The strategy ID for the command.
    instrument_id : InstrumentId
        The instrument ID for the command.
    order_side : OrderSide
        The order side for the command.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    client_id : ClientId, optional
        The execution client ID for the command.
    params : dict[str, object], optional
        Additional parameters for the command.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        OrderSide order_side,
        UUID4 command_id not None,
        uint64_t ts_init,
        ClientId client_id = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(
            client_id=client_id,
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            command_id=command_id,
            ts_init=ts_init,
            params=params,
            correlation_id=correlation_id,
        )

        self.order_side = order_side

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id.to_str()}, "
            f"order_side={order_side_to_str(self.order_side)})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "  # Can be None
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"order_side={order_side_to_str(self.order_side)}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef CancelAllOrders from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str c = values["client_id"]
        return CancelAllOrders(
            client_id=ClientId(c) if c is not None else None,
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            order_side=order_side_from_str(values["order_side"]),
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(CancelAllOrders obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "CancelAllOrders",
            "client_id": obj.client_id.to_str() if obj.client_id is not None else None,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "order_side": order_side_to_str(obj.order_side),
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> CancelAllOrders:
        """
        Return a cancel order command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        CancelAllOrders

        """
        return CancelAllOrders.from_dict_c(values)

    @staticmethod
    def to_dict(CancelAllOrders obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return CancelAllOrders.to_dict_c(obj)


cdef class BatchCancelOrders(TradingCommand):
    """
    Represents a command to batch cancel orders working on a venue for an instrument.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    strategy_id : StrategyId
        The strategy ID for the command.
    instrument_id : InstrumentId
        The instrument ID for the command.
    cancels : list[CancelOrder]
        The inner list of cancel order commands.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    client_id : ClientId, optional
        The execution client ID for the command.
    params : dict[str, object], optional
        Additional parameters for the command.

    Raises
    ------
    ValueError
        If `cancels` is empty.
    ValueError
        If `cancels` contains a type other than `CancelOrder`.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        list cancels,
        UUID4 command_id not None,
        uint64_t ts_init,
        ClientId client_id = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        Condition.not_empty(cancels, "cancels")
        Condition.list_type(cancels, CancelOrder, "cancels")
        super().__init__(
            client_id=client_id,
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            command_id=command_id,
            ts_init=ts_init,
            params=params,
            correlation_id=correlation_id,
        )

        self.cancels = cancels

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id.to_str()}, "
            f"cancels={self.cancels})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "  # Can be None
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"cancels={self.cancels}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef BatchCancelOrders from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str client_id = values["client_id"]
        return BatchCancelOrders(
            client_id=ClientId(client_id) if client_id is not None else None,
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            cancels=[CancelOrder.from_dict_c(cancel) for cancel in values["cancels"]],
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(BatchCancelOrders obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "BatchCancelOrders",
            "client_id": obj.client_id.to_str() if obj.client_id is not None else None,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "cancels": [CancelOrder.to_dict_c(cancel) for cancel in obj.cancels],
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> BatchCancelOrders:
        """
        Return a batch cancel order command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        BatchCancelOrders

        """
        return BatchCancelOrders.from_dict_c(values)

    @staticmethod
    def to_dict(BatchCancelOrders obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return BatchCancelOrders.to_dict_c(obj)


cdef class QueryOrder(TradingCommand):
    """
    Represents a command to query an order.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    strategy_id : StrategyId
        The strategy ID for the command.
    instrument_id : InstrumentId
        The instrument ID for the command.
    client_order_id : ClientOrderId
        The client order ID for the order to query.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue) to query.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    client_id : ClientId, optional
        The execution client ID for the command.
    params : dict[str, object], optional
        Additional parameters for the command.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        UUID4 command_id not None,
        uint64_t ts_init,
        ClientId client_id = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        if client_id is None:
            client_id = ClientId(instrument_id.venue.value)
        super().__init__(
            client_id=client_id,
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            command_id=command_id,
            ts_init=ts_init,
            params=params,
            correlation_id=correlation_id,
        )

        self.client_order_id = client_order_id
        self.venue_order_id = venue_order_id

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id.to_str()}, "
            f"client_order_id={self.client_order_id.to_str()}, "
            f"venue_order_id={self.venue_order_id})"  # Can be None
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"client_order_id={self.client_order_id.to_str()}, "
            f"venue_order_id={self.venue_order_id}, "  # Can be None
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef QueryOrder from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str c = values["client_id"]
        cdef str v = values["venue_order_id"]
        return QueryOrder(
            client_id=ClientId(c) if c is not None else None,
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(QueryOrder obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "QueryOrder",
            "client_id": obj.client_id.to_str() if obj.client_id is not None else None,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "client_order_id": obj.client_order_id.to_str(),
            "venue_order_id": obj.venue_order_id.to_str() if obj.venue_order_id is not None else None,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> QueryOrder:
        """
        Return a query order command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        QueryOrder

        """
        return QueryOrder.from_dict_c(values)

    @staticmethod
    def to_dict(QueryOrder obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return QueryOrder.to_dict_c(obj)


cdef class QueryAccount(Command):
    """
    Represents a command to query an account.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID for the command.
    account_id : AccountId
        The account ID to query.
    command_id : UUID4
        The command ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    client_id : ClientId, optional
        The execution client ID for the command.
    params : dict[str, object], optional
        Additional parameters for the command.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        AccountId account_id not None,
        UUID4 command_id not None,
        uint64_t ts_init,
        ClientId client_id = None,
        dict[str, object] params: dict | None = None,
        UUID4 correlation_id = None,
    ) -> None:
        super().__init__(command_id, ts_init, correlation_id)

        self.client_id = client_id
        self.trader_id = trader_id
        self.account_id = account_id
        self.params = params or {}

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"client_id={self.client_id}, "  # Can be None
            f"trader_id={self.trader_id.to_str()}, "
            f"account_id={self.account_id.to_str()}, "
            f"command_id={self.id.to_str()}, "
            f"correlation_id={self.correlation_id.to_str() if self.correlation_id is not None else None}, "
            f"ts_init={self.ts_init})"
        )

    @staticmethod
    cdef QueryAccount from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str c = values["client_id"]
        return QueryAccount(
            client_id=ClientId(c) if c is not None else None,
            trader_id=TraderId(values["trader_id"]),
            account_id=AccountId(values["account_id"]),
            command_id=UUID4.from_str_c(values["command_id"]),
            ts_init=values["ts_init"],
            params=values.get("params"),
        )

    @staticmethod
    cdef dict to_dict_c(QueryAccount obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "QueryAccount",
            "client_id": obj.client_id.to_str() if obj.client_id is not None else None,
            "trader_id": obj.trader_id.to_str(),
            "account_id": obj.account_id.to_str() if obj.account_id is not None else None,
            "command_id": obj.id.to_str(),
            "ts_init": obj.ts_init,
            "params": obj.params if obj.params else None,
        }

    @staticmethod
    def from_dict(dict values) -> QueryAccount:
        """
        Return a query account command from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        QueryAccount

        """
        return QueryAccount.from_dict_c(values)

    @staticmethod
    def to_dict(QueryAccount obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return QueryAccount.to_dict_c(obj)

</document_content>
</document>
<document index="2352">
<source>nautilus_trader/execution/trailing.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TrailingOffsetType
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.model.functions cimport trailing_offset_type_to_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.orders.base cimport Order


cdef class TrailingStopCalculator:
    """
    Provides trailing stop calculation functionality
    """

    @staticmethod
    cdef tuple calculate(
        Price price_increment,
        Order order,
        Price bid,
        Price ask,
        Price last,
    ):
        Condition.not_none(price_increment, "price_increment")
        if order.order_type not in (OrderType.TRAILING_STOP_MARKET, OrderType.TRAILING_STOP_LIMIT):
            raise TypeError(f"invalid `OrderType` for calculation, was {order.type_string_c()}")  # pragma: no cover (design-time error)

        cdef Price trigger_price = order.trigger_price
        cdef Price price = None
        cdef Price new_trigger_price = None
        cdef Price new_price = None

        if order.order_type == OrderType.TRAILING_STOP_LIMIT:
            price = order.price

        cdef:
            Price temp_trigger_price
            Price temp_price
        if (
            order.trigger_type == TriggerType.DEFAULT
            or order.trigger_type == TriggerType.LAST_PRICE
            or order.trigger_type == TriggerType.MARK_PRICE
        ):
            if last is None:
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"cannot process trailing stop, "
                    f"no LAST price for {order.instrument_id} "
                    f"(add trades or use bars)",
                )
            if order.side == OrderSide.BUY:
                temp_trigger_price = TrailingStopCalculator.calculate_with_last(
                    price_increment=price_increment,
                    trailing_offset_type=order.trailing_offset_type,
                    side=order.side,
                    offset=float(order.trailing_offset),
                    last=last,
                )
                if trigger_price is None or trigger_price._mem.raw > temp_trigger_price._mem.raw:
                    new_trigger_price = temp_trigger_price
                if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                    temp_price = TrailingStopCalculator.calculate_with_last(
                        price_increment=price_increment,
                        trailing_offset_type=order.trailing_offset_type,
                        side=order.side,
                        offset=float(order.limit_offset),
                        last=last,
                    )
                    if price is None or price._mem.raw > temp_price._mem.raw:
                        new_price = temp_price
            elif order.side == OrderSide.SELL:
                temp_trigger_price = TrailingStopCalculator.calculate_with_last(
                    price_increment=price_increment,
                    trailing_offset_type=order.trailing_offset_type,
                    side=order.side,
                    offset=float(order.trailing_offset),
                    last=last,
                )
                if trigger_price is None or trigger_price._mem.raw < temp_trigger_price._mem.raw:
                    new_trigger_price = temp_trigger_price
                if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                    temp_price = TrailingStopCalculator.calculate_with_last(
                        price_increment=price_increment,
                        trailing_offset_type=order.trailing_offset_type,
                        side=order.side,
                        offset=float(order.limit_offset),
                        last=last,
                    )
                    if price is None or price._mem.raw < temp_price._mem.raw:
                        new_price = temp_price
        elif order.trigger_type == TriggerType.BID_ASK:
            if bid is None:
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"cannot process trailing stop, "
                    f"no BID price for {order.instrument_id} "
                    f"(add quotes or use bars)",
                )
            if ask is None:
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"cannot process trailing stop, "
                    f"no ASK price for {order.instrument_id} "
                    f"(add quotes or use bars)",
                )

            if order.side == OrderSide.BUY:
                temp_trigger_price = TrailingStopCalculator.calculate_with_bid_ask(
                    price_increment=price_increment,
                    trailing_offset_type=order.trailing_offset_type,
                    side=order.side,
                    offset=float(order.trailing_offset),
                    bid=bid,
                    ask=ask,
                )
                if trigger_price is None or trigger_price._mem.raw > temp_trigger_price._mem.raw:
                    new_trigger_price = temp_trigger_price
                if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                    temp_price = TrailingStopCalculator.calculate_with_bid_ask(
                        price_increment=price_increment,
                        trailing_offset_type=order.trailing_offset_type,
                        side=order.side,
                        offset=float(order.limit_offset),
                        bid=bid,
                        ask=ask,
                    )
                    if price is None or price._mem.raw > temp_price._mem.raw:
                        new_price = temp_price
            elif order.side == OrderSide.SELL:
                temp_trigger_price = TrailingStopCalculator.calculate_with_bid_ask(
                    price_increment=price_increment,
                    trailing_offset_type=order.trailing_offset_type,
                    side=order.side,
                    offset=float(order.trailing_offset),
                    bid=bid,
                    ask=ask,
                )
                if trigger_price is None or trigger_price._mem.raw < temp_trigger_price._mem.raw:
                    new_trigger_price = temp_trigger_price
                if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                    temp_price = TrailingStopCalculator.calculate_with_bid_ask(
                        price_increment=price_increment,
                        trailing_offset_type=order.trailing_offset_type,
                        side=order.side,
                        offset=float(order.limit_offset),
                        bid=bid,
                        ask=ask,
                    )
                    if price is None or price._mem.raw < temp_price._mem.raw:
                        new_price = temp_price
        elif order.trigger_type == TriggerType.LAST_OR_BID_ASK:
            if last is None:
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"cannot process trailing stop, "
                    f"no LAST price for {order.instrument_id} "
                    f"(add trades or use bars)",
                )
            if bid is None:
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"cannot process trailing stop, "
                    f"no BID price for {order.instrument_id} "
                    f"(add quotes or use bars)",
                )
            if ask is None:
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"cannot process trailing stop, "
                    f"no ASK price for {order.instrument_id} "
                    f"(add quotes or use bars)",
                )

            if order.side == OrderSide.BUY:
                temp_trigger_price = TrailingStopCalculator.calculate_with_last(
                    price_increment=price_increment,
                    trailing_offset_type=order.trailing_offset_type,
                    side=order.side,
                    offset=float(order.trailing_offset),
                    last=last,
                )
                if trigger_price is None or trigger_price._mem.raw > temp_trigger_price._mem.raw:
                    new_trigger_price = temp_trigger_price
                    trigger_price = new_trigger_price  # Set trigger to new trigger
                if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                    temp_price = TrailingStopCalculator.calculate_with_last(
                        price_increment=price_increment,
                        trailing_offset_type=order.trailing_offset_type,
                        side=order.side,
                        offset=float(order.limit_offset),
                        last=last,
                    )
                    if price is None or price._mem.raw > temp_price._mem.raw:
                        new_price = temp_price
                        price = new_price  # Set price to new price

                temp_trigger_price = TrailingStopCalculator.calculate_with_bid_ask(
                    price_increment=price_increment,
                    trailing_offset_type=order.trailing_offset_type,
                    side=order.side,
                    offset=float(order.trailing_offset),
                    bid=bid,
                    ask=ask,
                )
                if trigger_price._mem.raw > temp_trigger_price._mem.raw:
                    new_trigger_price = temp_trigger_price
                if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                    temp_price = TrailingStopCalculator.calculate_with_bid_ask(
                        price_increment=price_increment,
                        trailing_offset_type=order.trailing_offset_type,
                        side=order.side,
                        offset=float(order.limit_offset),
                        bid=bid,
                        ask=ask,
                    )
                    if price is None or price._mem.raw > temp_price._mem.raw:
                        new_price = temp_price
            elif order.side == OrderSide.SELL:
                temp_trigger_price = TrailingStopCalculator.calculate_with_last(
                    price_increment=price_increment,
                    trailing_offset_type=order.trailing_offset_type,
                    side=order.side,
                    offset=float(order.trailing_offset),
                    last=last,
                )
                if trigger_price is None or trigger_price._mem.raw < temp_trigger_price._mem.raw:
                    new_trigger_price = temp_trigger_price
                    trigger_price = new_trigger_price  # Set trigger to new trigger
                if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                    temp_price = TrailingStopCalculator.calculate_with_last(
                        price_increment=price_increment,
                        trailing_offset_type=order.trailing_offset_type,
                        side=order.side,
                        offset=float(order.limit_offset),
                        last=last,
                    )
                    if price is None or price._mem.raw < temp_price._mem.raw:
                        new_price = temp_price
                        price = new_price  # Set price to new price

                temp_trigger_price = TrailingStopCalculator.calculate_with_bid_ask(
                    price_increment=price_increment,
                    trailing_offset_type=order.trailing_offset_type,
                    side=order.side,
                    offset=float(order.trailing_offset),
                    bid=bid,
                    ask=ask,
                )
                if trigger_price._mem.raw < temp_trigger_price._mem.raw:
                    new_trigger_price = temp_trigger_price
                if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                    temp_price = TrailingStopCalculator.calculate_with_bid_ask(
                        price_increment=price_increment,
                        trailing_offset_type=order.trailing_offset_type,
                        side=order.side,
                        offset=float(order.limit_offset),
                        bid=bid,
                        ask=ask,
                    )
                    if price is None or price._mem.raw < temp_price._mem.raw:
                        new_price = temp_price
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"cannot process trailing stop, "
                f"`TriggerType.{trigger_type_to_str(order.trigger_type)}` "
                f"not currently supported",
            )

        return new_trigger_price, new_price

    @staticmethod
    cdef Price calculate_with_last(
        Price price_increment,
        TrailingOffsetType trailing_offset_type,
        OrderSide side,
        double offset,
        Price last,
    ):
        cdef double last_f64 = last.as_f64_c()

        if trailing_offset_type == TrailingOffsetType.PRICE:
            pass  # Offset already calculated
        elif trailing_offset_type == TrailingOffsetType.BASIS_POINTS:
            offset = last_f64 * (offset / 100) / 100
        elif trailing_offset_type == TrailingOffsetType.TICKS:
            offset *= price_increment.as_f64_c()
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"cannot process trailing stop, "
                f"`TrailingOffsetType` {trailing_offset_type_to_str(trailing_offset_type)} "
                f"not currently supported",
            )

        if side == OrderSide.BUY:
            return Price(last_f64 + offset, precision=price_increment.precision)
        elif side == OrderSide.SELL:
            return Price(last_f64 - offset, precision=price_increment.precision)
        else:
            raise RuntimeError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)

    @staticmethod
    cdef Price calculate_with_bid_ask(
        Price price_increment,
        TrailingOffsetType trailing_offset_type,
        OrderSide side,
        double offset,
        Price bid,
        Price ask,
    ):
        cdef double ask_f64 = ask.as_f64_c()
        cdef double bid_f64 = bid.as_f64_c()

        if trailing_offset_type == TrailingOffsetType.PRICE:
            pass  # Offset already calculated
        elif trailing_offset_type == TrailingOffsetType.BASIS_POINTS:
            if side == OrderSide.BUY:
                offset = ask_f64 * (offset / 100) / 100
            elif side == OrderSide.SELL:
                offset = bid_f64 * (offset / 100) / 100
        elif trailing_offset_type == TrailingOffsetType.TICKS:
            offset *= price_increment.as_f64_c()
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"cannot process trailing stop, "  # pragma: no cover (design-time error)
                f"`TrailingOffsetType` {trailing_offset_type_to_str(trailing_offset_type)} "  # pragma: no cover (design-time error)  # noqa
                f"not currently supported",  # pragma: no cover (design-time error)
            )

        if side == OrderSide.BUY:
            return Price(ask_f64 + offset, precision=price_increment.precision)
        elif side == OrderSide.SELL:
            return Price(bid_f64 - offset, precision=price_increment.precision)
        else:
            raise RuntimeError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)

</document_content>
</document>
<document index="2355">
<source>nautilus_trader/indicators/averages.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from collections import deque

import numpy as np

cimport numpy as np
from libc.math cimport pow

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.core.stats cimport fast_mean
from nautilus_trader.indicators.base cimport Indicator
from nautilus_trader.indicators.momentum cimport EfficiencyRatio
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.objects cimport Price


cdef class MovingAverage(Indicator):
    """
    The base class for all moving average type indicators.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    params : list
        The initialization parameters for the indicator.
    price_type : PriceType, optional
        The specified price type for extracting values from quotes.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        int period,
        list params not None,
        PriceType price_type,
    ):
        Condition.positive_int(period, "period")
        super().__init__(params)

        self.period = period
        self.price_type = price_type
        self.value = 0
        self.count = 0

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        raise NotImplementedError("method `update_raw` must be implemented in the subclass")  # pragma: no cover

    cpdef void _increment_count(self):
        self.count += 1

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self.count >= self.period:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._reset_ma()
        self.count = 0
        self.value = 0

    cpdef void _reset_ma(self):
        pass  # Optionally override if additional values to reset


cdef class SimpleMovingAverage(MovingAverage):
    """
    An indicator which calculates a simple moving average across a rolling window.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    price_type : PriceType
        The specified price type for extracting values from quotes.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    """

    def __init__(self, int period, PriceType price_type=PriceType.LAST):
        Condition.positive_int(period, "period")
        super().__init__(period, params=[period], price_type=price_type)

        self._inputs = deque(maxlen=period)
        self.value = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        self._inputs.append(value)

        self.value = fast_mean(np.asarray(self._inputs, dtype=np.float64))
        self._increment_count()

    cpdef void _reset_ma(self):
        self._inputs.clear()


cdef class ExponentialMovingAverage(MovingAverage):
    """
    An indicator which calculates an exponential moving average across a
    rolling window.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    price_type : PriceType
        The specified price type for extracting values from quotes.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    """

    def __init__(self, int period, PriceType price_type=PriceType.LAST):
        Condition.positive_int(period, "period")
        super().__init__(period, params=[period], price_type=price_type)

        self.alpha = 2.0 / (period + 1.0)
        self.value = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        # Check if this is the initial input
        if not self.has_inputs:
            self.value = value

        self.value = self.alpha * value + ((1.0 - self.alpha) * self.value)
        self._increment_count()


cdef class DoubleExponentialMovingAverage(MovingAverage):
    """
    The Double Exponential Moving Average attempts to a smoother average with less
    lag than the normal Exponential Moving Average (EMA).

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    price_type : PriceType
        The specified price type for extracting values from quotes.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    """

    def __init__(self, int period, PriceType price_type=PriceType.LAST):
        Condition.positive_int(period, "period")
        super().__init__(period, params=[period], price_type=price_type)

        self._ma1 = ExponentialMovingAverage(period)
        self._ma2 = ExponentialMovingAverage(period)

        self.value = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        self._ma1.update_raw(value)
        self._ma2.update_raw(self._ma1.value)

        self.value = 2.0 * self._ma1.value - self._ma2.value

        if not self.initialized:
            self._set_has_inputs(True)
            if self._ma2.initialized:
                self._set_initialized(True)

    cpdef void _reset_ma(self):
        self._ma1.reset()
        self._ma2.reset()
        self.value = 0


cdef class WeightedMovingAverage(MovingAverage):
    """
    An indicator which calculates a weighted moving average across a rolling window.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    weights : iterable
        The weights for the moving average calculation (if not ``None`` then = period).
    price_type : PriceType
        The specified price type for extracting values from quotes.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    """

    def __init__(
        self,
        int period,
        weights = None,
        PriceType price_type = PriceType.LAST,
    ):
        Condition.positive_int(period, "period")
        if weights is not None:
            if not isinstance(weights, np.ndarray):
                # convert weights to the np.ndarray if it's possible
                weights = np.asarray(weights, dtype=np.float64)
                # to avoid the case when weights = [[1.0, 2.0, 3,0], [1.0, 2.0, 3,0]] ...
            if weights.ndim != 1:
                raise ValueError("weights must be iterable with ndim == 1.")
            else:
                Condition.is_true(weights.dtype == np.float64, "weights ndarray.dtype must be 'float64'")
                Condition.is_true(weights.ndim == 1, "weights ndarray.ndim must be 1")
            Condition.equal(len(weights), period, "len(weights)", "period")
            eps = np.finfo(np.float64).eps
            Condition.is_true(eps < weights.sum(), f"sum of weights must be positive > {eps}")
        super().__init__(period, params=[period, weights], price_type=price_type)

        self._inputs = deque(maxlen=period)
        self.weights = weights
        self.value = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        self._inputs.append(value)

        if self.initialized or self.weights is None:
            self.value = np.average(self._inputs, weights=self.weights, axis=0)
        else:
            self.value = np.average(self._inputs, weights=self.weights[-len(self._inputs):], axis=0)

        self._increment_count()

    cpdef void _reset_ma(self):
        self._inputs.clear()


cdef class HullMovingAverage(MovingAverage):
    """
    An indicator which calculates a Hull Moving Average (HMA) across a rolling
    window. The HMA, developed by Alan Hull, is an extremely fast and smooth
    moving average.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    price_type : PriceType
        The specified price type for extracting values from quotes.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    """

    def __init__(self, int period, PriceType price_type=PriceType.LAST):
        Condition.positive_int(period, "period")
        super().__init__(period, params=[period], price_type=price_type)

        cdef int period_halved = int(self.period / 2)
        cdef int period_sqrt = int(np.sqrt(self.period))

        self._w1 = self._get_weights(period_halved)
        self._w2 = self._get_weights(period)
        self._w3 = self._get_weights(period_sqrt)

        self._ma1 = WeightedMovingAverage(period_halved, weights=self._w1)
        self._ma2 = WeightedMovingAverage(period, weights=self._w2)
        self._ma3 = WeightedMovingAverage(period_sqrt, weights=self._w3)

        self.value = 0

    cdef np.ndarray _get_weights(self, int size):
        cdef np.ndarray w = np.arange(1, size + 1, dtype=np.float64)
        w /= w.sum()
        return w

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        self._ma1.update_raw(value)
        self._ma2.update_raw(value)
        self._ma3.update_raw(self._ma1.value * 2.0 - self._ma2.value)

        self.value = self._ma3.value
        self._increment_count()

    cpdef void _reset_ma(self):
        self._ma1.reset()
        self._ma2.reset()
        self._ma3.reset()


cdef class AdaptiveMovingAverage(MovingAverage):
    """
    An indicator which calculates an adaptive moving average (AMA) across a
    rolling window. Developed by Perry Kaufman, the AMA is a moving average
    designed to account for market noise and volatility. The AMA will closely
    follow prices when the price swings are relatively small and the noise is
    low. The AMA will increase lag when the price swings increase.

    Parameters
    ----------
    period_er : int
        The period for the internal `EfficiencyRatio` indicator (> 0).
    period_alpha_fast : int
        The period for the fast smoothing constant (> 0).
    period_alpha_slow : int
        The period for the slow smoothing constant (> 0 < alpha_fast).
    price_type : PriceType
        The specified price type for extracting values from quotes.
    """

    def __init__(
        self,
        int period_er,
        int period_alpha_fast,
        int period_alpha_slow,
        PriceType price_type=PriceType.LAST,
    ):
        Condition.positive_int(period_er, "period_er")
        Condition.positive_int(period_alpha_fast, "period_alpha_fast")
        Condition.positive_int(period_alpha_slow, "period_alpha_slow")
        Condition.is_true(period_alpha_slow > period_alpha_fast, "period_alpha_slow was <= period_alpha_fast")

        params = [
            period_er,
            period_alpha_fast,
            period_alpha_slow
        ]
        super().__init__(period_er, params=params, price_type=price_type)

        self.period_er = period_er
        self.period_alpha_fast = period_alpha_fast
        self.period_alpha_slow = period_alpha_slow
        self.alpha_fast = 2.0 / (float(period_alpha_fast) + 1.0)
        self.alpha_slow = 2.0 / (float(period_alpha_slow) + 1.0)
        self.alpha_diff = self.alpha_fast - self.alpha_slow
        self._efficiency_ratio = EfficiencyRatio(self.period_er)
        self._prior_value = 0
        self.value = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        # Check if this is the initial input (then initialize variables)
        if not self.has_inputs:
            self.value = value

        self._efficiency_ratio.update_raw(value)
        self._prior_value = self.value

        # Calculate smoothing constant (sc)
        cdef double sc = pow(self._efficiency_ratio.value * self.alpha_diff + self.alpha_slow, 2)

        # Calculate AMA
        self.value = self._prior_value + sc * (value - self._prior_value)

        self._increment_count()

    cpdef void _reset_ma(self):
        self._efficiency_ratio.reset()
        self._prior_value = 0


cdef class WilderMovingAverage(MovingAverage):
    """
    The Wilder's Moving Average is simply an Exponential Moving Average (EMA) with
    a modified alpha = 1 / period.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    price_type : PriceType
        The specified price type for extracting values from quotes.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    """

    def __init__(self, int period, PriceType price_type=PriceType.LAST):
        Condition.positive_int(period, "period")
        super().__init__(period, params=[period], price_type=price_type)

        self.alpha = 1.0 / period
        self.value = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        # Check if this is the initial input
        if not self.has_inputs:
            self.value = value

        self.value = self.alpha * value + ((1.0 - self.alpha) * self.value)
        self._increment_count()


cdef class VariableIndexDynamicAverage(MovingAverage):
    """
    Variable Index Dynamic Average (VIDYA) was developed by Tushar Chande. It is
    similar to an Exponential Moving Average, but it has a dynamically adjusted
    lookback period dependent on relative price volatility as measured by Chande
    Momentum Oscillator (CMO). When volatility is high, VIDYA reacts faster to
    price changes. It is often used as moving average or trend identifier.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    price_type : PriceType
        The specified price type for extracting values from quotes.
    cmo_ma_type : int
        The moving average type for CMO indicator.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
        If `cmo_ma_type` is ``VARIABLE_INDEX_DYNAMIC``.
    """

    def __init__(
        self,
        int period,
        PriceType price_type=PriceType.LAST,
        MovingAverageType cmo_ma_type=MovingAverageType.SIMPLE,
    ):
        Condition.positive_int(period, "period")
        Condition.is_true(cmo_ma_type != MovingAverageType.VARIABLE_INDEX_DYNAMIC, "cmo_ma_type was invalid (VARIABLE_INDEX_DYNAMIC)")
        super().__init__(period, params=[period], price_type=price_type)

        from nautilus_trader.indicators.momentum import ChandeMomentumOscillator
        self.cmo = ChandeMomentumOscillator(period, cmo_ma_type)
        self.cmo_pct = 0
        self.alpha = 2.0 / (period + 1.0)
        self.value = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar to handle.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        value : double
            The update value.

        """
        # Check if this is the initial input
        self.cmo.update_raw(value)
        self.cmo_pct = abs(self.cmo.value / 100)

        if self.initialized:
            self.value = self.alpha * self.cmo_pct * value + (1.0 - self.alpha *  self.cmo_pct) * self.value

        # Initialization logic
        if not self.initialized:
            if self.cmo.initialized:
                self._set_initialized(True)

        self._increment_count()


cdef class MovingAverageFactory:
    """
    Provides a factory to construct different moving average indicators.
    """

    @staticmethod
    def create(
        int period,
        ma_type: MovingAverageType,
        **kwargs,
    ) -> MovingAverage:
        """
        Create a moving average indicator corresponding to the given ma_type.

        Parameters
        ----------
        period : int
            The period of the moving average (> 0).
        ma_type : MovingAverageType
            The moving average type.

        Returns
        -------
        MovingAverage

        Raises
        ------
        ValueError
            If `period` is not positive (> 0).

        """
        Condition.positive_int(period, "period")

        if ma_type == MovingAverageType.SIMPLE:
            return SimpleMovingAverage(period)

        elif ma_type == MovingAverageType.EXPONENTIAL:
            return ExponentialMovingAverage(period)

        elif ma_type == MovingAverageType.WEIGHTED:
            return WeightedMovingAverage(period, **kwargs)

        elif ma_type == MovingAverageType.HULL:
            return HullMovingAverage(period)

        elif ma_type == MovingAverageType.WILDER:
            return WilderMovingAverage(period)

        elif ma_type == MovingAverageType.DOUBLE_EXPONENTIAL:
            return DoubleExponentialMovingAverage(period)

        elif ma_type == MovingAverageType.VARIABLE_INDEX_DYNAMIC:
            return VariableIndexDynamicAverage(period, **kwargs)

</document_content>
</document>
<document index="2357">
<source>nautilus_trader/indicators/base.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick


cdef class Indicator:
    """
    The base class for all indicators.

    Parameters
    ----------
    params : list
        The initialization parameters for the indicator.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(self, list params not None):
        self._params = params.copy()

        self.name = type(self).__name__
        self.has_inputs = False
        self.initialized = False

    def __repr__(self) -> str:
        return f"{self.name}({self._params_str()})"

    cdef str _params_str(self):
        return str(self._params)[1:-1].replace("'", '') if self._params else ''

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError(f"Cannot handle {repr(tick)}: method `handle_quote_tick` not implemented in subclass")  # pragma: no cover

    cpdef void handle_trade_tick(self, TradeTick tick):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError(f"Cannot handle {repr(tick)}: method `handle_trade_tick` not implemented in subclass")  # pragma: no cover

    cpdef void handle_bar(self, Bar bar):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError(f"Cannot handle {repr(bar)}: method `handle_bar` not implemented in subclass")  # pragma: no cover

    cpdef void reset(self):
        """
        Reset the indicator.

        All stateful fields are reset to their initial value.
        """
        self._reset()
        self.has_inputs = False
        self.initialized = False

    cpdef void _set_has_inputs(self, bint setting):
        self.has_inputs = setting

    cpdef void _set_initialized(self, bint setting):
        self.initialized = setting

    cpdef void _reset(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `_reset` must be implemented in the subclass")  # pragma: no cover

</document_content>
</document>
<document index="2359">
<source>nautilus_trader/indicators/fuzzy_candlesticks.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from collections import deque

import numpy as np

cimport numpy as np
from libc.math cimport fabs

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.stats cimport fast_mean
from nautilus_trader.core.stats cimport fast_std_with_mean
from nautilus_trader.indicators.base cimport Indicator
from nautilus_trader.indicators.fuzzy_enums cimport CandleBodySize
from nautilus_trader.indicators.fuzzy_enums cimport CandleDirection
from nautilus_trader.indicators.fuzzy_enums cimport CandleSize
from nautilus_trader.indicators.fuzzy_enums cimport CandleWickSize
from nautilus_trader.model.data cimport Bar


cdef class FuzzyCandle:
    """
    Represents a fuzzy candle.

    Parameters
    ----------
    direction : CandleDirection
        The candle direction.
    size : CandleSize
        The candle fuzzy size.
    body_size : CandleBodySize
        The candle fuzzy body size.
    upper_wick_size : CandleWickSize
        The candle fuzzy upper wick size.
    lower_wick_size : CandleWickSize
        The candle fuzzy lower wick size.
    """

    def __init__(
        self,
        CandleDirection direction,
        CandleSize size,
        CandleBodySize body_size,
        CandleWickSize upper_wick_size,
        CandleWickSize lower_wick_size,
    ):
        self.direction = direction
        self.size = size
        self.body_size = body_size
        self.upper_wick_size = upper_wick_size
        self.lower_wick_size = lower_wick_size

    def __eq__(self, FuzzyCandle other) -> bool:
        if other is None:
            return False
        return self.direction == other.direction \
            and self.size == other.size \
            and self.body_size == other.body_size \
            and self.upper_wick_size == other.upper_wick_size \
            and self.lower_wick_size == other.lower_wick_size

    def __str__(self) -> str:
        return f"({self.direction}, {self.size}, {self.body_size}, {self.lower_wick_size}, {self.upper_wick_size})"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}{self}"


cdef class FuzzyCandlesticks(Indicator):
    """
    An indicator which fuzzifies bar data to produce fuzzy candlesticks.
    Bar data is dimensionally reduced via fuzzy feature extraction.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    threshold1 : float
        The membership function x threshold1 (>= 0).
    threshold2 : float
        The membership function x threshold2 (> threshold1).
    threshold3 : float
        The membership function x threshold3 (> threshold2).
    threshold4 : float
        The membership function x threshold4 (> threshold3).
    """

    def __init__(
        self,
        int period,
        double threshold1=0.5,
        double threshold2=1.0,
        double threshold3=2.0,
        double threshold4=3.0,
    ):
        Condition.positive_int(period, "period")
        Condition.positive(threshold1, "threshold1")
        Condition.is_true(threshold2 > threshold1, "threshold2 was <= threshold1")
        Condition.is_true(threshold3 > threshold2, "threshold3 was <= threshold2")
        Condition.is_true(threshold4 > threshold3, "threshold4 was <= threshold3")
        super().__init__(
            params=[
                period,
                threshold1,
                threshold2,
                threshold3,
                threshold4,
            ]
        )

        self.period = period
        self._threshold1 = threshold1
        self._threshold2 = threshold2
        self._threshold3 = threshold3
        self._threshold4 = threshold4
        self._lengths = deque(maxlen=self.period)
        self._body_percents = deque(maxlen=self.period)
        self._upper_wick_percents = deque(maxlen=self.period)
        self._lower_wick_percents = deque(maxlen=self.period)
        self._last_open = 0.0
        self._last_high = 0.0
        self._last_low = 0.0
        self._last_close = 0.0

        self.vector = None
        self.value = None

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.open.as_double(),
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double(),
        )

    cpdef void update_raw(
        self,
        double open,
        double high,
        double low,
        double close,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        open : double
            The open price.
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.

        """

        # Update last prices
        self._last_open = open
        self._last_high = high
        self._last_low = low
        self._last_close = close

        # Update measurements
        cdef double length = fabs(high - low)
        self._lengths.append(length)

        if length == 0.0:
            self._body_percents.append(0.0)
            self._upper_wick_percents.append(0.0)
            self._lower_wick_percents.append(0.0)
        else:
            self._body_percents.append(fabs(open - close) / length)
            self._upper_wick_percents.append((high - max(open, close)) / length)
            self._lower_wick_percents.append((min(open, close) - low) / length)

        cdef np.ndarray lengths = np.asarray(self._lengths, dtype=np.float64)
        cdef np.ndarray body_percents = np.asarray(self._body_percents, dtype=np.float64)
        cdef np.ndarray upper_wick_percents = np.asarray(self._upper_wick_percents, dtype=np.float64)
        cdef np.ndarray lower_wick_percents = np.asarray(self._lower_wick_percents, dtype=np.float64)

        # Calculate statistics for bars
        cdef double mean_length = fast_mean(lengths)
        cdef double mean_body_percent = fast_mean(body_percents)
        cdef double mean_upper_wick = fast_mean(upper_wick_percents)
        cdef double mean_lower_wick = fast_mean(lower_wick_percents)

        cdef double sd_lengths = fast_std_with_mean(lengths, mean_length)
        cdef double sd_body_percents = fast_std_with_mean(body_percents, mean_body_percent)
        cdef double sd_upper_wick_percents = fast_std_with_mean(upper_wick_percents, mean_upper_wick)
        cdef double sd_lower_wick_percents = fast_std_with_mean(lower_wick_percents, mean_lower_wick)

        # Create fuzzy candle
        self.value = FuzzyCandle(
            direction=self._fuzzify_direction(open, close),
            size=self._fuzzify_size(
                length,
                mean_length,
                sd_lengths),
            body_size=self._fuzzify_body_size(
                self._body_percents[-1],
                mean_body_percent,
                sd_body_percents),
            upper_wick_size=self._fuzzify_wick_size(
                self._upper_wick_percents[-1],
                mean_upper_wick,
                sd_upper_wick_percents),
            lower_wick_size=self._fuzzify_wick_size(
                self._lower_wick_percents[-1],
                mean_lower_wick,
                sd_lower_wick_percents),
        )

        # Create fuzzy candle as np array
        self.vector = [
            self.value.direction,
            self.value.size,
            self.value.body_size,
            self.value.upper_wick_size,
            self.value.lower_wick_size
        ]

        # Initialization logic
        if self.initialized is False:
            self._set_has_inputs(True)
            if len(self._lengths) >= self.period:
                self._set_initialized(True)

    cdef CandleDirection _fuzzify_direction(self, double open, double close):
        # Fuzzify the candle entry from the given inputs
        if close > open:
            return CandleDirection.DIRECTION_BULL
        if close < open:
            return CandleDirection.DIRECTION_BEAR
        else:
            return CandleDirection.DIRECTION_NONE

    cdef CandleSize _fuzzify_size(
            self,
            double length,
            double mean_length,
            double sd_lengths):
        # Fuzzify the candle size from the given inputs
        if length == 0:
            return CandleSize.SIZE_NONE

        cdef double x

        # Determine CandleSize fuzzy membership
        # -------------------------------------
        # CandleSize.VERY_SMALL
        x = mean_length - (sd_lengths * self._threshold2)
        if length <= x:
            return CandleSize.SIZE_VERY_SMALL

        # CandleSize.SMALL
        x = mean_length + (sd_lengths * self._threshold1)
        if length <= x:
            return CandleSize.SIZE_SMALL

        # CandleSize.MEDIUM
        x = mean_length + sd_lengths * self._threshold2
        if length <= x:
            return CandleSize.SIZE_MEDIUM

        # CandleSize.LARGE
        x = mean_length + (sd_lengths * self._threshold3)
        if length <= x:
            return CandleSize.SIZE_LARGE

        # CandleSize.VERY_LARGE
        x = mean_length + (sd_lengths * self._threshold4)
        if length <= x:
            return CandleSize.SIZE_VERY_LARGE

        return CandleSize.SIZE_EXTREMELY_LARGE

    cdef CandleBodySize _fuzzify_body_size(
            self,
            double body_percent,
            double mean_body_percent,
            double sd_body_percents):
        # Fuzzify the candle body size from the given inputs
        if body_percent == 0:
            return CandleBodySize.BODY_NONE

        cdef double x

        # Determine CandleBodySize fuzzy membership
        # -----------------------------------------
        # CandleBodySize.SMALL
        x = mean_body_percent - (sd_body_percents * self._threshold1)
        if body_percent <= x:
            return CandleBodySize.BODY_SMALL

        # CandleBodySize.MEDIUM
        x = mean_body_percent + (sd_body_percents * self._threshold1)
        if body_percent <= x:
            return CandleBodySize.BODY_MEDIUM

        # CandleBodySize.LARGE
        x = mean_body_percent + (sd_body_percents * self._threshold2)
        if body_percent <= x:
            return CandleBodySize.BODY_LARGE

        return CandleBodySize.BODY_TREND

    cdef CandleWickSize _fuzzify_wick_size(
            self,
            double wick_percent,
            double mean_wick_percent,
            double sd_wick_percents):
        # Fuzzify the candle wick size from the given inputs
        if wick_percent == 0:
            return CandleWickSize.WICK_NONE

        cdef double x

        # Determine CandleWickSize fuzzy membership
        # -----------------------------------------
        # CandleWickSize.SMALL
        x = mean_wick_percent - (sd_wick_percents * self._threshold1)
        if wick_percent <= x:
            return CandleWickSize.WICK_SMALL

        # CandleWickSize.MEDIUM
        x = mean_wick_percent + (sd_wick_percents * self._threshold2)
        if wick_percent <= x:
            return CandleWickSize.WICK_MEDIUM

        return CandleWickSize.WICK_LARGE

    cpdef void _reset(self):
        self._lengths.clear()
        self._body_percents.clear()
        self._upper_wick_percents.clear()
        self._lower_wick_percents.clear()
        self._last_open = 0
        self._last_high = 0
        self._last_low = 0
        self._last_close = 0
        self.vector = None
        self.value = None

</document_content>
</document>
<document index="2361">
<source>nautilus_trader/indicators/fuzzy_enums.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
This module exports the fuzzy candle enums for use from Python.

The enums are defined in the .pxd file for use in Cython code,
and this .pyx file makes them available to Python code.
"""

__all__ = [
    "CandleDirection",
    "CandleSize",
    "CandleBodySize",
    "CandleWickSize",
]

</document_content>
</document>
<document index="2363">
<source>nautilus_trader/indicators/momentum.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from collections import deque
from math import log

import numpy as np

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.stats cimport fast_mad_with_mean
from nautilus_trader.core.stats cimport fast_std_with_mean
from nautilus_trader.indicators.base cimport Indicator
from nautilus_trader.model.data cimport Bar


cdef str get_ma_type_name(ma_type):
    """Helper function to get MovingAverageType name for params."""
    from nautilus_trader.indicators.averages import MovingAverageType

    if ma_type == MovingAverageType.SIMPLE:
        return "SIMPLE"
    elif ma_type == MovingAverageType.EXPONENTIAL:
        return "EXPONENTIAL"
    elif ma_type == MovingAverageType.DOUBLE_EXPONENTIAL:
        return "DOUBLE_EXPONENTIAL"
    elif ma_type == MovingAverageType.WILDER:
        return "WILDER"
    elif ma_type == MovingAverageType.HULL:
        return "HULL"
    elif ma_type == MovingAverageType.ADAPTIVE:
        return "ADAPTIVE"
    elif ma_type == MovingAverageType.WEIGHTED:
        return "WEIGHTED"
    elif ma_type == MovingAverageType.VARIABLE_INDEX_DYNAMIC:
        return "VARIABLE_INDEX_DYNAMIC"
    else:
        return "UNKNOWN"


cdef class RelativeStrengthIndex(Indicator):
    """
    An indicator which calculates a relative strength index (RSI) across a rolling window.

    Parameters
    ----------
    ma_type : int
        The moving average type for average gain/loss.
    period : MovingAverageType
        The rolling window period for the indicator.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    """

    def __init__(
        self,
        int period,
        ma_type=None,
    ):
        from nautilus_trader.indicators.averages import MovingAverageFactory
        from nautilus_trader.indicators.averages import MovingAverageType

        if ma_type is None:
            ma_type = MovingAverageType.EXPONENTIAL
        Condition.positive_int(period, "period")
        super().__init__(params=[period, get_ma_type_name(ma_type)])

        self.period = period
        self._rsi_max = 1
        self._average_gain = MovingAverageFactory.create(period, ma_type)
        self._average_loss = MovingAverageFactory.create(period, ma_type)
        self._last_value = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double value):
        """
        Update the indicator with the given value.

        Parameters
        ----------
        value : double
            The update value.

        """
        # Check if first input
        if not self.has_inputs:
            self._last_value = value
            self._set_has_inputs(True)

        cdef double gain = value - self._last_value

        if gain > 0:
            self._average_gain.update_raw(gain)
            self._average_loss.update_raw(0)
        elif gain < 0:
            self._average_loss.update_raw(-gain)
            self._average_gain.update_raw(0)
        else:
            self._average_gain.update_raw(0)
            self._average_loss.update_raw(0)

        # Initialization logic
        if not self.initialized:
            if self._average_gain.initialized and self._average_loss.initialized:
                self._set_initialized(True)

        if self._average_loss.value == 0:
            self.value = self._rsi_max
            self._last_value = value
            return

        cdef double rs = self._average_gain.value / self._average_loss.value

        self.value = self._rsi_max - (self._rsi_max / (1 + rs))
        self._last_value = value

    cpdef void _reset(self):
        self._average_gain.reset()
        self._average_loss.reset()
        self._last_value = 0
        self.value = 0


cdef class RateOfChange(Indicator):
    """
    An indicator which calculates the rate of change of price over a defined period.
    The return output can be simple or log.

    Parameters
    ----------
    period : int
        The period for the indicator.
    use_log : bool
        Use log returns for value calculation.

    Raises
    ------
    ValueError
        If `period` is not > 1.
    """

    def __init__(self, int period, bint use_log=False):
        Condition.is_true(period > 1, "period was <= 1")
        super().__init__(params=[period])

        self.period = period
        self._use_log = use_log
        self._prices = deque(maxlen=period)
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double price):
        """
        Update the indicator with the given price.

        Parameters
        ----------
        price : double
            The update price.

        """
        self._prices.append(price)

        if not self.initialized:
            self._set_has_inputs(True)
            if len(self._prices) >= self.period:
                self._set_initialized(True)

        if self._use_log:
            self.value = log(price / self._prices[0])
        else:
            self.value = (price - self._prices[0]) / self._prices[0]

    cpdef void _reset(self):
        self._prices.clear()
        self.value = 0


cdef class ChandeMomentumOscillator(Indicator):
    """
    Attempts to capture the momentum of an asset with overbought at 50 and
    oversold at -50.

    Parameters
    ----------
    ma_type : int
        The moving average type for average gain/loss.
    period : MovingAverageType
        The rolling window period for the indicator.
    """

    def __init__(
        self,
        int period,
        ma_type=None,
    ):
        from nautilus_trader.indicators.averages import MovingAverageFactory
        from nautilus_trader.indicators.averages import MovingAverageType

        if ma_type is None:
            ma_type = MovingAverageType.WILDER
        params = [
            period,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params = params)

        self.period = period
        self._average_gain = MovingAverageFactory.create(period, ma_type)
        self._average_loss = MovingAverageFactory.create(period, ma_type)
        self._previous_close = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double close):
        """
        Update the indicator with the given value.

        Parameters
        ----------
        value : double
            The update value.

        """
        # Check if first input
        if not self.has_inputs:
            self._set_has_inputs(True)
            self._previous_close = close

        cdef double gain = close - self._previous_close

        if gain > 0:
            self._average_gain.update_raw(gain)
            self._average_loss.update_raw(0)
        elif gain < 0:
            self._average_gain.update_raw(0)
            self._average_loss.update_raw(-gain)
        else:
            self._average_gain.update_raw(0)
            self._average_loss.update_raw(0)
        # Initialization logic
        if not self.initialized:
            if self._average_gain.initialized and self._average_loss.initialized:
                self._set_initialized(True)

        cdef double divisor
        if self.initialized:
            divisor = self._average_gain.value + self._average_loss.value
            if divisor == 0.0:
                self.value = 0.0
            else:
                self.value = 100.0 * (self._average_gain.value - self._average_loss.value) / divisor

        self._previous_close = close

    cpdef void _reset(self):
        self._average_gain.reset()
        self._average_loss.reset()
        self._previous_close = 0
        self.value = 0


cdef class Stochastics(Indicator):
    """
    An oscillator which can indicate when an asset may be over bought or over
    sold.

    Parameters
    ----------
    period_k : int
        The period for the K line.
    period_d : int
        The period for the D line.

    Raises
    ------
    ValueError
        If `period_k` is not positive (> 0).
    ValueError
        If `period_d` is not positive (> 0).

    References
    ----------
    https://www.forextraders.com/forex-education/forex-indicators/stochastics-indicator-explained/
    """

    def __init__(self, int period_k, int period_d):
        Condition.positive_int(period_k, "period_k")
        Condition.positive_int(period_d, "period_d")
        super().__init__(params=[period_k, period_d])

        self.period_k = period_k
        self.period_d = period_d
        self._highs = deque(maxlen=period_k)
        self._lows = deque(maxlen=period_k)
        self._c_sub_l = deque(maxlen=period_d)
        self._h_sub_l = deque(maxlen=period_d)

        self.value_k = 0
        self.value_d = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double(),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
        double close,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.

        """
        # Check if first input
        if not self.has_inputs:
            self._set_has_inputs(True)

        self._highs.append(high)
        self._lows.append(low)

        # Initialization logic
        if not self.initialized:
            if len(self._highs) == self.period_k and len(self._lows) == self.period_k:
                self._set_initialized(True)

        cdef double k_max_high = max(self._highs)
        cdef double k_min_low = min(self._lows)

        self._c_sub_l.append(close - k_min_low)
        self._h_sub_l.append(k_max_high - k_min_low)

        if k_max_high == k_min_low:
            return  # Divide by zero guard

        self.value_k = 100 * ((close - k_min_low) / (k_max_high - k_min_low))
        self.value_d = 100 * (sum(self._c_sub_l) / sum(self._h_sub_l))

    cpdef void _reset(self):
        self._highs.clear()
        self._lows.clear()
        self._c_sub_l.clear()
        self._h_sub_l.clear()

        self.value_k = 0
        self.value_d = 0


cdef class CommodityChannelIndex(Indicator):
    """
    Commodity Channel Index is a momentum oscillator used to primarily identify
    overbought and oversold levels relative to a mean.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    scalar : double
        A positive float to scale the bands
    ma_type : MovingAverageType
        The moving average type for prices.

    References
    ----------
    https://www.tradingview.com/support/solutions/43000502001-commodity-channel-index-cci/
    """

    def __init__(
        self,
        int period,
        double scalar = 0.015,
        ma_type=None,
    ):
        from nautilus_trader.indicators.averages import MovingAverageFactory
        from nautilus_trader.indicators.averages import MovingAverageType

        if ma_type is None:
            ma_type = MovingAverageType.SIMPLE
        Condition.positive_int(period, "period")

        params = [
            period,
            scalar,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params=params)

        self.period = period
        self.scalar = scalar
        self._prices = deque(maxlen=period)
        self._ma = MovingAverageFactory.create(period, ma_type)
        self._mad = 0.0
        self.value = 0.0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double(),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
        double close,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.

        """
        cdef double typical_price = (high + low + close) / 3.0
        self._prices.append(typical_price)
        self._ma.update_raw(typical_price)
        self._mad = fast_mad_with_mean(
            values=np.asarray(self._prices, dtype=np.float64),
            mean=self._ma.value,
        )
        if self._ma.initialized:
            self.value = (typical_price - self._ma.value) / (self.scalar * self._mad)

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self._ma.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        """
        Reset the indicator.

        All stateful fields are reset to their initial value.
        """
        self._prices.clear()
        self._ma.reset()
        self._mad = 0.0
        self.value = 0.0


cdef class EfficiencyRatio(Indicator):
    """
    An indicator which calculates the efficiency ratio across a rolling window.
    The Kaufman Efficiency measures the ratio of the relative market speed in
    relation to the volatility, this could be thought of as a proxy for noise.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (>= 2).

    Raises
    ------
    ValueError
        If `period` is not >= 2.
    """

    def __init__(self, int period):
        Condition.is_true(period >= 2, "period was < 2")
        super().__init__(params=[period])

        self.period = period
        self._inputs = deque(maxlen=period)
        self._deltas = deque(maxlen=period)
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double price):
        """
        Update the indicator with the given price.

        Parameters
        ----------
        price : double
            The update price.

        """
        self._inputs.append(price)

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if len(self._inputs) < 2:
                return  # Not enough data
            elif len(self._inputs) >= self.period:
                self._set_initialized(True)

        # Add data to queues
        self._deltas.append(abs(self._inputs[-1] - self._inputs[-2]))

        # Calculate efficiency ratio
        cdef double net_diff = abs(self._inputs[0] - self._inputs[-1])
        cdef double sum_deltas = sum(self._deltas)

        if sum_deltas > 0:
            self.value = net_diff / sum_deltas
        else:
            self.value = 0

    cpdef void _reset(self):
        self._inputs.clear()
        self._deltas.clear()
        self.value = 0


cdef class RelativeVolatilityIndex(Indicator):
    """
    The Relative Volatility Index (RVI) was created in 1993 and revised in 1995.
    Instead of adding up price changes like RSI based on price direction, the RVI
    adds up standard deviations based on price direction.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    scalar : double
        A positive float to scale the bands.
    ma_type : MovingAverageType
        The moving average type for the vip and vim (cannot be None).
    """

    def __init__(
        self,
        int period,
        double scalar = 100.0,
        ma_type=None,
    ):
        from nautilus_trader.indicators.averages import MovingAverageFactory
        from nautilus_trader.indicators.averages import MovingAverageType

        if ma_type is None:
            ma_type = MovingAverageType.EXPONENTIAL
        Condition.positive_int(period, "period")

        params = [
            period,
            scalar,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params=params)

        self.period = period
        self.scalar = scalar
        self._prices = deque(maxlen=period)
        self._ma = MovingAverageFactory.create(period, MovingAverageType.SIMPLE)
        self._pos_ma = MovingAverageFactory.create(period, ma_type)
        self._neg_ma = MovingAverageFactory.create(period, ma_type)
        self._previous_close = 0
        self._std = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double close):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        close : double
            The close price.

        """
        self._prices.append(close)
        self._ma.update_raw(close)

        self._std = fast_std_with_mean(
            values=np.asarray(self._prices, dtype=np.float64),
            mean=self._ma.value,
        )

        self._std = self._std * np.sqrt(self.period) / np.sqrt(self.period - 1)

        if self._ma.initialized:
            if close > self._previous_close:
                self._pos_ma.update_raw(self._std)
                self._neg_ma.update_raw(0)
            elif close < self._previous_close:
                self._pos_ma.update_raw(0)
                self._neg_ma.update_raw(self._std)
            else:
                self._pos_ma.update_raw(0)
                self._neg_ma.update_raw(0)

            self.value = self.scalar * self._pos_ma.value
            self.value = self.value / (self._pos_ma.value + self._neg_ma.value)


        self._previous_close = close

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if  self._pos_ma.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        """
        Reset the indicator.

        All stateful fields are reset to their initial value.
        """
        self._prices.clear()
        self._ma.reset()
        self._pos_ma.reset()
        self._neg_ma.reset()
        self._previous_close = 0
        self._std = 0
        self.value = 0


cdef class PsychologicalLine(Indicator):
    """
    The Psychological Line is an oscillator-type indicator that compares the
    number of the rising periods to the total number of periods. In other
    words, it is the percentage of bars that close above the previous
    bar over a given period.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    ma_type : MovingAverageType
        The moving average type for the indicator (cannot be None).
    """

    def __init__(
        self,
        int period,
        ma_type=None,
    ):
        from nautilus_trader.indicators.averages import MovingAverageFactory
        from nautilus_trader.indicators.averages import MovingAverageType

        if ma_type is None:
            ma_type = MovingAverageType.SIMPLE
        Condition.positive_int(period, "period")
        params = [
            period,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params=params)

        self.period = period
        self._ma = MovingAverageFactory.create(period, ma_type)
        self._diff = 0
        self._previous_close = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double close):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        close : double
            The close price.

        """
        # Update inputs
        if not self.has_inputs:
            self._previous_close = close

        self._diff = close - self._previous_close
        if self._diff <= 0:
            self._ma.update_raw(0)
        else:
            self._ma.update_raw(1)
        self.value = 100.0 * self._ma.value

        if not self.initialized:
            self._set_has_inputs(True)
            if self._ma.initialized:
                self._set_initialized(True)
        self._previous_close = close

    cpdef void _reset(self):
        self._ma.reset()
        self._diff = 0
        self._previous_close = 0
        self.value = 0

</document_content>
</document>
<document index="2365">
<source>nautilus_trader/indicators/spread_analyzer.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from collections import deque

import numpy as np

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.stats cimport fast_mean_iterated
from nautilus_trader.indicators.base cimport Indicator
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.objects cimport Price


cdef class SpreadAnalyzer(Indicator):
    """
    Provides various spread analysis metrics.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the tick updates.
    capacity : int
        The max length for the internal `QuoteTick` deque (determines averages).

    Raises
    ------
    ValueError
        If `capacity` is not positive (> 0).
    """

    def __init__(self, InstrumentId instrument_id not None, int capacity) -> None:
        Condition.positive_int(capacity, "capacity")
        super().__init__(params=[instrument_id, capacity])

        self.instrument_id = instrument_id
        self.capacity = capacity
        self._spreads = deque(maxlen=capacity)

        self.current = 0
        self.average = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the analyzer with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The tick for the update.

        Raises
        ------
        ValueError
            If `tick.instrument_id` does not equal the analyzers instrument ID.

        """
        Condition.not_none(tick, "tick")
        Condition.equal(self.instrument_id, tick.instrument_id, "instrument_id", "tick.instrument_id")

        # Check initialization
        if not self.initialized:
            self._set_has_inputs(True)
            if len(self._spreads) == self.capacity:
                self._set_initialized(True)

        cdef double bid = Price.raw_to_f64_c(tick._mem.bid_price.raw)
        cdef double ask = Price.raw_to_f64_c(tick._mem.ask_price.raw)
        cdef double spread = ask - bid

        self.current = spread
        self._spreads.append(spread)

        # Update average spread
        self.average = fast_mean_iterated(
            values=np.asarray(self._spreads, dtype=np.float64),
            next_value=spread,
            current_value=self.average,
            expected_length=self.capacity,
            drop_left=False,
        )

    cpdef void _reset(self):
        self._spreads.clear()
        self.current = 0
        self.average = 0

</document_content>
</document>
<document index="2367">
<source>nautilus_trader/indicators/trend.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from collections import deque
from statistics import mean

import numpy as np
import pandas as pd

from nautilus_trader.indicators.averages import MovingAverageFactory

cimport numpy as np
from cpython.datetime cimport datetime

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.indicators.averages cimport MovingAverageType


cdef str get_ma_type_name(MovingAverageType ma_type):
    if ma_type == MovingAverageType.SIMPLE:
        return "SIMPLE"
    elif ma_type == MovingAverageType.EXPONENTIAL:
        return "EXPONENTIAL"
    elif ma_type == MovingAverageType.DOUBLE_EXPONENTIAL:
        return "DOUBLE_EXPONENTIAL"
    elif ma_type == MovingAverageType.WILDER:
        return "WILDER"
    elif ma_type == MovingAverageType.HULL:
        return "HULL"
    elif ma_type == MovingAverageType.ADAPTIVE:
        return "ADAPTIVE"
    elif ma_type == MovingAverageType.WEIGHTED:
        return "WEIGHTED"
    elif ma_type == MovingAverageType.VARIABLE_INDEX_DYNAMIC:
        return "VARIABLE_INDEX_DYNAMIC"
    else:
        return "UNKNOWN"
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.indicators.base cimport Indicator
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.objects cimport Price


cdef class ArcherMovingAveragesTrends(Indicator):
    """
    Archer Moving Averages Trends indicator.

    Parameters
    ----------
    fast_period : int
        The period for the fast moving average (> 0).
    slow_period : int
        The period for the slow moving average (> 0 & > fast_sma).
    signal_period : int
        The period for lookback price array (> 0).
    ma_type : MovingAverageType
        The moving average type for the calculations.

    References
    ----------
    https://github.com/twopirllc/pandas-ta/blob/bc3b292bf1cc1d5f2aba50bb750a75209d655b37/pandas_ta/trend/amat.py
    """

    def __init__(
        self,
        int fast_period,
        int slow_period,
        int signal_period,
        MovingAverageType ma_type=MovingAverageType.EXPONENTIAL,
    ):
        Condition.positive_int(fast_period, "fast_period")
        Condition.positive_int(slow_period, "slow_period")
        Condition.is_true(slow_period > fast_period, "fast_period was >= slow_period")
        Condition.positive_int(signal_period, "signal_period")
        params = [
            fast_period,
            slow_period,
            signal_period,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params=params)

        self.fast_period = fast_period
        self.slow_period = slow_period
        self.signal_period = signal_period
        self._fast_ma = MovingAverageFactory.create(fast_period, ma_type)
        self._slow_ma = MovingAverageFactory.create(slow_period, ma_type)
        self._fast_ma_price = deque(maxlen = signal_period + 1)
        self._slow_ma_price = deque(maxlen = signal_period + 1)
        self.long_run = 0
        self.short_run = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.close.as_double(),
        )

    cpdef void update_raw(self, double close):
        """
        Update the indicator with the given close price value.

        Parameters
        ----------
        close : double
            The close price.

        """
        self._fast_ma.update_raw(close)
        self._slow_ma.update_raw(close)
        if self._slow_ma.initialized:
            self._fast_ma_price.append(self._fast_ma.value)
            self._slow_ma_price.append(self._slow_ma.value)

            self.long_run = (self._fast_ma_price[-1] - self._fast_ma_price[0] > 0 and \
                self._slow_ma_price[-1] - self._slow_ma_price[0] < 0 )
            self.long_run = (self._fast_ma_price[-1] - self._fast_ma_price[0] > 0 and \
                self._slow_ma_price[-1] - self._slow_ma_price[0] > 0 ) or self.long_run

            self.short_run = (self._fast_ma_price[-1] - self._fast_ma_price[0] < 0 and \
                self._slow_ma_price[-1] - self._slow_ma_price[0] > 0 )
            self.short_run = (self._fast_ma_price[-1] - self._fast_ma_price[0] < 0 and \
                self._slow_ma_price[-1] - self._slow_ma_price[0] < 0 ) or self.short_run

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if len(self._slow_ma_price) >= self.signal_period + 1 and self._slow_ma.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._fast_ma.reset()
        self._slow_ma.reset()
        self._fast_ma_price.clear()
        self._slow_ma_price.clear()
        self.long_run = 0
        self.short_run = 0


cdef class AroonOscillator(Indicator):
    """
    The Aroon (AR) indicator developed by Tushar Chande attempts to
    determine whether an instrument is trending, and how strong the trend is.
    AroonUp and AroonDown lines make up the indicator with their formulas below.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    """

    def __init__(self, int period):
        Condition.positive_int(period, "period")
        params = [
            period,
        ]
        super().__init__(params = params)

        self.period = period
        self._high_inputs = deque(maxlen = self.period + 1)
        self._low_inputs = deque(maxlen = self.period + 1)
        self.aroon_up = 0
        self.aroon_down = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        """
        # Update inputs
        self._high_inputs.appendleft(high)
        self._low_inputs.appendleft(low)

        # Convert to double to compute values
        cdef double periods_from_hh = np.argmax(self._high_inputs)
        cdef double periods_from_ll = np.argmin(self._low_inputs)

        self.aroon_up = 100.0 * (1.0 - periods_from_hh / self.period)
        self.aroon_down = 100.0 * (1.0 - periods_from_ll / self.period)
        self.value = self.aroon_up - self.aroon_down

        self._check_initialized()

    cdef void _check_initialized(self):
        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if len(self._high_inputs) >= self.period + 1:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._high_inputs.clear()
        self._low_inputs.clear()
        self.aroon_up = 0
        self.aroon_down = 0
        self.value = 0


cdef class DirectionalMovement(Indicator):
    """
    Two oscillators that capture positive and negative trend movement.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    ma_type : MovingAverageType
        The moving average type for the indicator (cannot be None).
    """

    def __init__(
        self,
        int period,
        MovingAverageType ma_type=MovingAverageType.EXPONENTIAL,
    ):
        Condition.positive_int(period, "period")
        params = [
            period,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params=params)

        self.period = period
        self._pos_ma = MovingAverageFactory.create(period, ma_type)
        self._neg_ma = MovingAverageFactory.create(period, ma_type)
        self._previous_high = 0
        self._previous_low = 0
        self.pos = 0
        self.neg = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.

        """
        if not self.has_inputs:
            self._previous_high = high
            self._previous_low = low

        cdef double up = high - self._previous_high
        cdef double dn = self._previous_low - low

        self._pos_ma.update_raw(((up > dn) and (up > 0)) * up)
        self._neg_ma.update_raw(((dn > up) and (dn > 0)) * dn)
        self.pos = self._pos_ma.value
        self.neg = self._neg_ma.value

        self._previous_high = high
        self._previous_low = low

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self._neg_ma.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        """
        Reset the indicator.

        All stateful fields are reset to their initial value.
        """
        self._pos_ma.reset()
        self._neg_ma.reset()
        self._previous_high = 0
        self._previous_low = 0
        self.pos = 0
        self.neg = 0


cdef class MovingAverageConvergenceDivergence(Indicator):
    """
    An indicator which calculates the difference between two moving averages.
    Different moving average types can be selected for the inner calculation.

    Parameters
    ----------
    fast_period : int
        The period for the fast moving average (> 0).
    slow_period : int
        The period for the slow moving average (> 0 & > fast_sma).
    ma_type : MovingAverageType
        The moving average type for the calculations.
    price_type : PriceType
        The specified price type for extracting values from quotes.

    Raises
    ------
    ValueError
        If `fast_period` is not positive (> 0).
    ValueError
        If `slow_period` is not positive (> 0).
    ValueError
        If `fast_period` is not < `slow_period`.
    """

    def __init__(
        self,
        int fast_period,
        int slow_period,
        MovingAverageType ma_type=MovingAverageType.EXPONENTIAL,
        PriceType price_type=PriceType.LAST,
    ):
        Condition.positive_int(fast_period, "fast_period")
        Condition.positive_int(slow_period, "slow_period")
        Condition.is_true(slow_period > fast_period, "slow_period was <= fast_period")

        params=[
            fast_period,
            slow_period,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params=params)

        self.fast_period = fast_period
        self.slow_period = slow_period
        self._fast_ma = MovingAverageFactory.create(fast_period, ma_type)
        self._slow_ma = MovingAverageFactory.create(slow_period, ma_type)
        self.price_type = price_type
        self.value = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given quote tick.

        Parameters
        ----------
        tick : QuoteTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        cdef Price price = tick.extract_price(self.price_type)
        self.update_raw(Price.raw_to_f64_c(price._mem.raw))

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The update tick to handle.

        """
        Condition.not_none(tick, "tick")

        self.update_raw(Price.raw_to_f64_c(tick._mem.price.raw))

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double close):
        """
        Update the indicator with the given close price.

        Parameters
        ----------
        close : double
            The close price.

        """
        self._fast_ma.update_raw(close)
        self._slow_ma.update_raw(close)
        self.value = self._fast_ma.value - self._slow_ma.value

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self._fast_ma.initialized and self._slow_ma.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._fast_ma.reset()
        self._slow_ma.reset()
        self.value = 0


cdef class LinearRegression(Indicator):
    """
    An indicator that calculates a simple linear regression.

    Parameters
    ----------
    period : int
        The period for the indicator.

    Raises
    ------
    ValueError
        If `period` is not greater than zero.
    """

    def __init__(self, int period=0):
        Condition.positive_int(period, "period")
        super().__init__(params=[period])

        self.period = period
        self._inputs = deque(maxlen=self.period)
        self.slope = 0.0
        self.intercept = 0.0
        self.degree = 0.0
        self.cfo = 0.0
        self.R2 = 0.0
        self.value = 0.0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.close.as_double())

    cpdef void update_raw(self, double close):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        close_price : double
            The close price.

        """
        self._inputs.append(close)

        # Warmup indicator logic
        if not self.initialized:
            self._set_has_inputs(True)
            if len(self._inputs) >= self.period:
                self._set_initialized(True)
            else:
                return

        cdef np.ndarray x_arr = np.arange(1, self.period + 1, dtype=np.float64)
        cdef np.ndarray y_arr = np.asarray(self._inputs, dtype=np.float64)
        cdef double x_sum = 0.5 * self.period * (self.period + 1)
        cdef double x2_sum = x_sum * (2 * self.period + 1) / 3
        cdef double divisor = self.period * x2_sum - x_sum * x_sum
        cdef double y_sum = sum(y_arr)
        cdef double xy_sum = sum(x_arr * y_arr)
        self.slope = (self.period * xy_sum - x_sum * y_sum) / divisor
        self.intercept = (y_sum * x2_sum - x_sum * xy_sum) / divisor

        cdef np.ndarray residuals = np.zeros(self.period, dtype=np.float64)
        cdef int i
        for i in np.arange(self.period):
            residuals[i] = self.slope * x_arr[i] + self.intercept - y_arr[i]

        self.value = residuals[-1] + y_arr[-1]
        self.degree = 180.0 / np.pi * np.arctan(self.slope)
        self.cfo = 100.0 * residuals[-1] / y_arr[-1]

        # Compute R2 with handling for zero variance in y_arr
        cdef double ssr = sum(residuals * residuals)
        cdef double sst = sum((y_arr - mean(y_arr)) * (y_arr - mean(y_arr)))
        if sst == 0.0:
            self.R2 = -np.inf
        else:
            self.R2 = 1.0 - ssr / sst

    cpdef void _reset(self):
        self._inputs.clear()
        self.slope = 0.0
        self.intercept = 0.0
        self.degree = 0.0
        self.cfo = 0.0
        self.R2 = 0.0
        self.value = 0.0


cdef class Bias(Indicator):
    """
    Rate of change between the source and a moving average.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    ma_type : MovingAverageType
        The moving average type for the indicator (cannot be None).
    """

    def __init__(
        self,
        int period,
        MovingAverageType ma_type=MovingAverageType.SIMPLE,
    ):
        Condition.positive_int(period, "period")
        params = [
            period,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params=params)

        self.period = period
        self._ma = MovingAverageFactory.create(period, ma_type)
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.close.as_double(),
        )

    cpdef void update_raw(self, double close):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        close : double
            The close price.

        """
        # Calculate average
        self._ma.update_raw(close)
        self.value = (close / self._ma.value) - 1.0
        self._check_initialized()

    cdef void _check_initialized(self):
        if not self.initialized:
            self._set_has_inputs(True)
            if self._ma.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._ma.reset()
        self.value = 0


cdef class Swings(Indicator):
    """
    A swing indicator which calculates and stores various swing metrics.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    """

    def __init__(self, int period):
        Condition.positive_int(period, "period")
        super().__init__(params=[period])

        self.period = period
        self._high_inputs = deque(maxlen=self.period)
        self._low_inputs = deque(maxlen=self.period)

        self.direction = 0
        self.changed = False
        self.high_datetime = None
        self.low_datetime = None
        self.high_price = 0
        self.low_price = 0
        self.length = 0
        self.duration = 0
        self.since_high = 0
        self.since_low = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            pd.Timestamp(bar.ts_init, tz="UTC"),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
        datetime timestamp,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        timestamp : datetime
            The current timestamp.

        """
        # Update inputs
        self._high_inputs.append(high)
        self._low_inputs.append(low)

        # Update max high and min low
        cdef double max_high = max(self._high_inputs)
        cdef double min_low = min(self._low_inputs)

        # Calculate if swings
        cdef bint is_swing_high = high >= max_high and low >= min_low
        cdef bint is_swing_low = low <= min_low and high <= max_high

        # Swing logic
        self.changed = False

        if is_swing_high and not is_swing_low:
            if self.direction == -1:
                self.changed = True
            self.high_price = high
            self.high_datetime = timestamp
            self.direction = 1
            self.since_high = 0
            self.since_low += 1
        elif is_swing_low and not is_swing_high:
            if self.direction == 1:
                self.changed = True
            self.low_price = low
            self.low_datetime = timestamp
            self.direction = -1
            self.since_low = 0
            self.since_high += 1
        else:
            self.since_high += 1
            self.since_low += 1

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self.high_price != 0. and self.low_price != 0.0:
                self._set_initialized(True)
        # Calculate current values
        else:
            self.length = self.high_price - self.low_price
            if self.direction == 1:
                self.duration = self.since_low
            else:
                self.duration = self.since_high

    cpdef void _reset(self):
        self._high_inputs.clear()
        self._low_inputs.clear()

        self.direction = 0
        self.changed = False
        self.high_datetime = None
        self.low_datetime = None
        self.high_price = 0
        self.low_price = 0
        self.length = 0
        self.duration = 0
        self.since_high = 0
        self.since_low = 0

</document_content>
</document>
<document index="2369">
<source>nautilus_trader/indicators/volatility.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from collections import deque

import numpy as np

from nautilus_trader.indicators.averages import MovingAverageFactory

from libc.math cimport fabs

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.indicators.averages cimport MovingAverageType


cdef str get_ma_type_name(MovingAverageType ma_type):
    if ma_type == MovingAverageType.SIMPLE:
        return "SIMPLE"
    elif ma_type == MovingAverageType.EXPONENTIAL:
        return "EXPONENTIAL"
    elif ma_type == MovingAverageType.DOUBLE_EXPONENTIAL:
        return "DOUBLE_EXPONENTIAL"
    elif ma_type == MovingAverageType.WILDER:
        return "WILDER"
    elif ma_type == MovingAverageType.HULL:
        return "HULL"
    elif ma_type == MovingAverageType.ADAPTIVE:
        return "ADAPTIVE"
    elif ma_type == MovingAverageType.WEIGHTED:
        return "WEIGHTED"
    elif ma_type == MovingAverageType.VARIABLE_INDEX_DYNAMIC:
        return "VARIABLE_INDEX_DYNAMIC"
    else:
        return "UNKNOWN"


from nautilus_trader.core.stats cimport fast_std_with_mean
from nautilus_trader.indicators.base cimport Indicator
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.objects cimport Price


cdef class AverageTrueRange(Indicator):
    """
    An indicator which calculates the average true range across a rolling window.
    Different moving average types can be selected for the inner calculation.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    ma_type : MovingAverageType
        The moving average type for the indicator (cannot be None).
    use_previous : bool
        The boolean flag indicating whether previous price values should be used.
        (note: only applicable for `update()`. `update_mid()` will need to
        use previous price.
    value_floor : double
        The floor (minimum) output value for the indicator (>= 0).
    """

    def __init__(
        self,
        int period,
        MovingAverageType ma_type=MovingAverageType.SIMPLE,
        bint use_previous=True,
        double value_floor=0,
    ):
        Condition.positive_int(period, "period")
        Condition.not_negative(value_floor, "value_floor")
        params = [
            period,
            get_ma_type_name(ma_type),
            use_previous,
            value_floor,
        ]
        super().__init__(params=params)

        self.period = period
        self._ma = MovingAverageFactory.create(period, ma_type)
        self._use_previous = use_previous
        self._value_floor = value_floor
        self._previous_close = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.high.as_double(), bar.low.as_double(), bar.close.as_double())

    cpdef void update_raw(
        self,
        double high,
        double low,
        double close,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.

        """
        # Calculate average
        if self._use_previous:
            if not self.has_inputs:
                self._previous_close = close
            self._ma.update_raw(max(self._previous_close, high) - min(low, self._previous_close))
            self._previous_close = close
        else:
            self._ma.update_raw(high - low)

        self._floor_value()
        self._check_initialized()

    cdef void _floor_value(self):
        if self._value_floor == 0:
            self.value = self._ma.value
        elif self._value_floor < self._ma.value:
            self.value = self._ma.value
        else:
            # Floor the value
            self.value = self._value_floor

    cdef void _check_initialized(self):
        if not self.initialized:
            self._set_has_inputs(True)
            if self._ma.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._ma.reset()
        self._previous_close = 0
        self.value = 0


cdef class BollingerBands(Indicator):
    """
    A Bollinger Band® is a technical analysis tool defined by a set of
    trend lines plotted two standard deviations (positively and negatively) away
    from a simple moving average (SMA) of an instruments price, which can be
    adjusted to user preferences.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    k : double
        The standard deviation multiple for the indicator (> 0).
    ma_type : MovingAverageType
        The moving average type for the indicator.

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    ValueError
        If `k` is not positive (> 0).
    """

    def __init__(
        self,
        int period,
        double k,
        MovingAverageType ma_type=MovingAverageType.SIMPLE,
    ):
        Condition.positive_int(period, "period")
        Condition.positive(k, "k")
        super().__init__(params=[period, k, get_ma_type_name(ma_type)])

        self.period = period
        self.k = k
        self._ma = MovingAverageFactory.create(period, ma_type)
        self._prices = deque(maxlen=period)

        self.upper = 0.0
        self.middle = 0.0
        self.lower = 0.0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given tick.

        Parameters
        ----------
        tick : TradeTick
            The tick for the update.

        """
        Condition.not_none(tick, "tick")

        cdef double bid = Price.raw_to_f64_c(tick._mem.bid_price.raw)
        cdef double ask = Price.raw_to_f64_c(tick._mem.ask_price.raw)
        cdef double mid = (ask + bid) / 2.0
        self.update_raw(ask, bid, mid)

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given tick.

        Parameters
        ----------
        tick : TradeTick
            The tick for the update.

        """
        Condition.not_none(tick, "tick")

        cdef double price = Price.raw_to_f64_c(tick._mem.price.raw)
        self.update_raw(price, price, price)

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double(),
        )

    cpdef void update_raw(self, double high, double low, double close):
        """
        Update the indicator with the given prices.

        Parameters
        ----------
        high : double
            The high price for calculations.
        low : double
            The low price for calculations.
        close : double
            The closing price for calculations

        """
        # Add data to queues
        cdef double typical = (high + low + close) / 3.0

        self._prices.append(typical)
        self._ma.update_raw(typical)

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if len(self._prices) >= self.period:
                self._set_initialized(True)

        # Calculate values
        cdef double std = fast_std_with_mean(
            values=np.asarray(self._prices, dtype=np.float64),
            mean=self._ma.value,
        )

        # Set values
        self.upper = self._ma.value + (self.k * std)
        self.middle = self._ma.value
        self.lower = self._ma.value - (self.k * std)

    cpdef void _reset(self):
        self._ma.reset()
        self._prices.clear()

        self.upper = 0.0
        self.middle = 0.0
        self.lower = 0.0


cdef class DonchianChannel(Indicator):
    """
    Donchian Channels are three lines generated by moving average calculations
    that comprise an indicator formed by upper and lower bands around a
    mid-range or median band. The upper band marks the highest price of a
    instrument_id over N periods while the lower band marks the lowest price of a
    instrument_id over N periods. The area between the upper and lower bands
    represents the Donchian Channel.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    """

    def __init__(self, int period):
        Condition.positive_int(period, "period")
        super().__init__(params=[period])

        self.period = period
        self._upper_prices = deque(maxlen=period)
        self._lower_prices = deque(maxlen=period)

        self.upper = 0
        self.middle = 0
        self.lower = 0

    cpdef void handle_quote_tick(self, QuoteTick tick):
        """
        Update the indicator with the given ticks high and low prices.

        Parameters
        ----------
        tick : TradeTick
            The tick for the update.

        """
        Condition.not_none(tick, "tick")

        cdef double ask = Price.raw_to_f64_c(tick._mem.ask_price.raw)
        cdef double bid = Price.raw_to_f64_c(tick._mem.bid_price.raw)
        self.update_raw(ask, bid)

    cpdef void handle_trade_tick(self, TradeTick tick):
        """
        Update the indicator with the given ticks price.

        Parameters
        ----------
        tick : TradeTick
            The tick for the update.

        """
        Condition.not_none(tick, "tick")

        cdef double price = Price.raw_to_f64_c(tick._mem.price.raw)
        self.update_raw(price, price)

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(bar.high.as_double(), bar.low.as_double())

    cpdef void update_raw(self, double high, double low):
        """
        Update the indicator with the given prices.

        Parameters
        ----------
        high : double
            The price for the upper channel.
        low : double
            The price for the lower channel.

        """
        # Add data to queues
        self._upper_prices.append(high)
        self._lower_prices.append(low)

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if len(self._upper_prices) >= self.period and len(self._lower_prices) >= self.period:
                self._set_initialized(True)

        # Set values
        self.upper = max(self._upper_prices)
        self.lower = min(self._lower_prices)
        self.middle = (self.upper + self.lower) / 2

    cpdef void _reset(self):
        self._upper_prices.clear()
        self._lower_prices.clear()

        self.upper = 0
        self.middle = 0
        self.lower = 0


cdef class KeltnerChannel(Indicator):
    """
    The Keltner channel is a volatility based envelope set above and below a
    central moving average. Traditionally the middle band is an EMA based on the
    typical price (high + low + close) / 3, the upper band is the middle band
    plus the ATR. The lower band is the middle band minus the ATR.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    k_multiplier : double
        The multiplier for the ATR (> 0).
    ma_type : MovingAverageType
        The moving average type for the middle band (cannot be None).
    ma_type_atr : MovingAverageType
        The moving average type for the internal ATR (cannot be None).
    use_previous : bool
        The boolean flag indicating whether previous price values should be used.
    atr_floor : double
        The ATR floor (minimum) output value for the indicator (>= 0).
    """

    def __init__(
        self,
        int period,
        double k_multiplier,
        MovingAverageType ma_type=MovingAverageType.EXPONENTIAL,
        MovingAverageType ma_type_atr=MovingAverageType.SIMPLE,
        bint use_previous=True,
        double atr_floor=0,
    ):
        Condition.positive_int(period, "period")
        Condition.positive(k_multiplier, "k_multiplier")
        Condition.not_negative(atr_floor, "atr_floor")

        params = [
            period,
            k_multiplier,
            get_ma_type_name(ma_type),
            get_ma_type_name(ma_type_atr),
            use_previous,
            atr_floor,
        ]
        super().__init__(params=params)

        self.period = period
        self.k_multiplier = k_multiplier
        self._ma = MovingAverageFactory.create(period, ma_type)
        self._atr = AverageTrueRange(period, ma_type_atr, use_previous, atr_floor)
        self.upper = 0
        self.middle = 0
        self.lower = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double()
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
        double close,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.

        """
        cdef double typical_price = (high + low + close) / 3.0

        self._ma.update_raw(typical_price)
        self._atr.update_raw(high, low, close)

        self.upper = self._ma.value + (self._atr.value * self.k_multiplier)
        self.middle = self._ma.value
        self.lower = self._ma.value - (self._atr.value * self.k_multiplier)

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self._ma.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        """
        Reset the indicator.

        All stateful fields are reset to their initial value.
        """
        self._ma.reset()
        self._atr.reset()
        self.upper = 0
        self.middle = 0
        self.lower = 0


cdef class VerticalHorizontalFilter(Indicator):
    """
    The Vertical Horizon Filter (VHF) was created by Adam White to identify
    trending and ranging markets.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    ma_type : MovingAverageType
        The moving average type for the indicator (cannot be None).
    """

    def __init__(
        self,
        int period,
        MovingAverageType ma_type=MovingAverageType.SIMPLE,
    ):
        Condition.positive_int(period, "period")
        params = [
            period,
        ]
        super().__init__(params=params)

        self.period = period
        self._prices = deque(maxlen=self.period)
        self._ma = MovingAverageFactory.create(period, ma_type)
        self._previous_close = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.close.as_double(),
        )

    cpdef void update_raw(self, double close):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        close : double
            The close price.

        """
        # Update inputs
        if not self.has_inputs:
            self._previous_close = close

        self._prices.append(close)

        cdef double max_price = max(self._prices)
        cdef double min_price = min(self._prices)

        self._ma.update_raw(fabs(close - self._previous_close))
        if self.initialized:
            self.value = fabs(max_price - min_price) / self.period / self._ma.value
        self._previous_close = close

        self._check_initialized()

    cdef void _check_initialized(self):
        if not self.initialized:
            self._set_has_inputs(True)
            if self._ma.initialized and len(self._prices) >= self.period:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._prices.clear()
        self._ma.reset()
        self._previous_close = 0
        self.value = 0


cdef class VolatilityRatio(Indicator):
    """
    An indicator which calculates the ratio of different ranges of volatility.
    Different moving average types can be selected for the inner ATR calculations.

    Parameters
    ----------
    fast_period : int
        The period for the fast ATR (> 0).
    slow_period : int
        The period for the slow ATR (> 0 & > fast_period).
    ma_type : MovingAverageType
        The moving average type for the ATR calculations.
    use_previous : bool
        The boolean flag indicating whether previous price values should be used.
    value_floor : double
        The floor (minimum) output value for the indicator (>= 0).

    Raises
    ------
    ValueError
        If `fast_period` is not positive (> 0).
    ValueError
        If `slow_period` is not positive (> 0).
    ValueError
        If `fast_period` is not < `slow_period`.
    ValueError
        If `value_floor` is negative (< 0).
    """

    def __init__(
        self,
        int fast_period,
        int slow_period,
        MovingAverageType ma_type=MovingAverageType.SIMPLE,
        bint use_previous=True,
        double value_floor=0,
    ):
        Condition.positive_int(fast_period, "fast_period")
        Condition.positive_int(slow_period, "slow_period")
        Condition.is_true(fast_period < slow_period, "fast_period was >= slow_period")
        Condition.not_negative(value_floor, "value_floor")

        params = [
            fast_period,
            slow_period,
            get_ma_type_name(ma_type),
            use_previous,
            value_floor,
        ]
        super().__init__(params=params)

        self.fast_period = fast_period
        self.slow_period = slow_period
        self._atr_fast = AverageTrueRange(fast_period, ma_type, use_previous, value_floor)
        self._atr_slow = AverageTrueRange(slow_period, ma_type, use_previous, value_floor)
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double(),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
        double close,
    ):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.

        """
        self._atr_fast.update_raw(high, low, close)
        self._atr_slow.update_raw(high, low, close)

        if self._atr_fast.value > 0:  # Guard against divide by zero
            self.value = self._atr_slow.value / self._atr_fast.value

        self._check_initialized()

    cdef void _check_initialized(self):
        if not self.initialized:
            self._set_has_inputs(True)

            if self._atr_fast.initialized and self._atr_slow.initialized:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._atr_fast.reset()
        self._atr_slow.reset()
        self.value = 0


cdef class KeltnerPosition(Indicator):
    """
    An indicator which calculates the relative position of the given price
    within a defined Keltner channel. This provides a measure of the relative
    'extension' of a market from the mean, as a multiple of volatility.

    Parameters
    ----------
    period : int
        The rolling window period for the indicator (> 0).
    k_multiplier : double
        The multiplier for the ATR (> 0).
    ma_type : MovingAverageType
        The moving average type for the middle band (cannot be None).
    ma_type_atr : MovingAverageType
        The moving average type for the internal ATR (cannot be None).
    use_previous : bool
        The boolean flag indicating whether previous price values should be used.
    atr_floor : double
        The ATR floor (minimum) output value for the indicator (>= 0).
    """

    def __init__(
        self,
        int period,
        double k_multiplier,
        MovingAverageType ma_type=MovingAverageType.EXPONENTIAL,
        MovingAverageType ma_type_atr=MovingAverageType.SIMPLE,
        bint use_previous=True,
        double atr_floor=0,
    ):
        Condition.positive_int(period, "period")
        Condition.positive(k_multiplier, "k_multiplier")
        Condition.not_negative(atr_floor, "atr_floor")

        params = [
            period,
            k_multiplier,
            get_ma_type_name(ma_type),
            get_ma_type_name(ma_type_atr),
            use_previous,
            atr_floor,
        ]
        super().__init__(params=params)

        self.period = period
        self.k_multiplier = k_multiplier

        self._kc = KeltnerChannel(
            period,
            k_multiplier,
            ma_type,
            ma_type_atr,
            use_previous,
            atr_floor,
        )

        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double(),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
        double close,
    ):
        """
        Update the indicator with the given raw value.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.

        """
        self._kc.update_raw(high, low, close)

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self._kc.initialized:
                self._set_initialized(True)

        cdef double k_width = (self._kc.upper - self._kc.lower) / 2

        if k_width > 0:
            self.value = (close - self._kc.middle) / k_width
        else:
            self.value = 0

    cpdef void _reset(self):
        self._kc.reset()
        self.value = 0

</document_content>
</document>
<document index="2371">
<source>nautilus_trader/indicators/volume.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from collections import deque

import pandas as pd

from nautilus_trader.indicators.averages import MovingAverageFactory
from nautilus_trader.indicators.volatility import AverageTrueRange

from cpython.datetime cimport datetime

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.indicators.averages cimport MovingAverageType
from nautilus_trader.indicators.base cimport Indicator
from nautilus_trader.model.data cimport Bar


cdef str get_ma_type_name(MovingAverageType ma_type):
    if ma_type == MovingAverageType.SIMPLE:
        return "SIMPLE"
    elif ma_type == MovingAverageType.EXPONENTIAL:
        return "EXPONENTIAL"
    elif ma_type == MovingAverageType.DOUBLE_EXPONENTIAL:
        return "DOUBLE_EXPONENTIAL"
    elif ma_type == MovingAverageType.WILDER:
        return "WILDER"
    elif ma_type == MovingAverageType.HULL:
        return "HULL"
    elif ma_type == MovingAverageType.ADAPTIVE:
        return "ADAPTIVE"
    elif ma_type == MovingAverageType.WEIGHTED:
        return "WEIGHTED"
    elif ma_type == MovingAverageType.VARIABLE_INDEX_DYNAMIC:
        return "VARIABLE_INDEX_DYNAMIC"
    else:
        return "UNKNOWN"


cdef class OnBalanceVolume(Indicator):
    """
    An indicator which calculates the momentum of relative positive or negative
    volume.

    Parameters
    ----------
    period : int
        The period for the indicator, zero indicates no window (>= 0).

    Raises
    ------
    ValueError
        If `period` is negative (< 0).
    """

    def __init__(self, int period=0):
        Condition.not_negative(period, "period")
        super().__init__(params=[period])

        self.period = period
        self._obv = deque(maxlen=None if period == 0 else period)
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.open.as_double(),
            bar.close.as_double(),
            bar.volume.as_double(),
        )

    cpdef void update_raw(
        self,
        double open,
        double close,
        double volume,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        open : double
            The high price.
        close : double
            The low price.
        volume : double
            The close price.

        """
        if close > open:
            self._obv.append(volume)
        elif close < open:
            self._obv.append(-volume)
        else:
            self._obv.append(0)

        self.value = sum(self._obv)

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if (self.period == 0 and len(self._obv) > 0) or len(self._obv) >= self.period:
                self._set_initialized(True)

    cpdef void _reset(self):
        self._obv.clear()
        self.value = 0


cdef class VolumeWeightedAveragePrice(Indicator):
    """
    An indicator which calculates the volume weighted average price for the day.
    """

    def __init__(self):
        super().__init__(params=[])

        self._day = 0
        self._price_volume = 0
        self._volume_total = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            (
                bar.close.as_double() +
                bar.high.as_double() +
                bar.low.as_double()
            ) / 3.0,
            bar.volume.as_double(),
            pd.Timestamp(bar.ts_init, tz="UTC"),
        )

    cpdef void update_raw(
        self,
        double price,
        double volume,
        datetime timestamp,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        price : double
            The update price.
        volume : double
            The update volume.
        timestamp : datetime
            The current timestamp.

        """
        # On a new day reset the indicator
        if timestamp.day != self._day:
            self.reset()
            self._day = timestamp.day
            self.value = price

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            self._set_initialized(True)

        # No weighting for this price (also avoiding divide by zero)
        if volume == 0:
            return

        self._price_volume += price * volume
        self._volume_total += volume
        self.value = self._price_volume / self._volume_total

    cpdef void _reset(self):
        self._day = 0
        self._price_volume = 0
        self._volume_total = 0
        self.value = 0


cdef class KlingerVolumeOscillator(Indicator):
    """
    This indicator was developed by Stephen J. Klinger. It is designed to predict
    price reversals in a market by comparing volume to price.

    Parameters
    ----------
    fast_period : int
        The period for the fast moving average (> 0).
    slow_period : int
        The period for the slow moving average (> 0 & > fast_sma).
    signal_period : int
        The period for the moving average difference's moving average (> 0).
    ma_type : MovingAverageType
        The moving average type for the calculations.
    """

    def __init__(
        self,
        int fast_period,
        int slow_period,
        int signal_period,
        MovingAverageType ma_type=MovingAverageType.EXPONENTIAL,
    ):
        Condition.positive_int(fast_period, "fast_period")
        Condition.positive_int(slow_period, "slow_period")
        Condition.is_true(slow_period > fast_period, "fast_period was >= slow_period")
        Condition.positive_int(signal_period, "signal_period")
        params = [
            fast_period,
            slow_period,
            signal_period,
            get_ma_type_name(ma_type),
        ]
        super().__init__(params=params)

        self.fast_period = fast_period
        self.slow_period = slow_period
        self.signal_period = signal_period
        self._fast_ma = MovingAverageFactory.create(fast_period, ma_type)
        self._slow_ma = MovingAverageFactory.create(slow_period, ma_type)
        self._signal_ma = MovingAverageFactory.create(signal_period, ma_type)
        self._hlc3 = 0
        self._previous_hlc3 = 0
        self.value = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double(),
            bar.volume.as_double(),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
        double close,
        double volume,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.
        volume : double
            The volume.

        """
        self._hlc3 = (high + low + close)/3.0

        if self._hlc3 > self._previous_hlc3:
            self._fast_ma.update_raw(volume)
            self._slow_ma.update_raw(volume)
        elif self._hlc3 < self._previous_hlc3:
            self._fast_ma.update_raw(-volume)
            self._slow_ma.update_raw(-volume)
        else:
            self._fast_ma.update_raw(0)
            self._slow_ma.update_raw(0)

        if self._slow_ma.initialized:
            self._signal_ma.update_raw(self._fast_ma.value - self._slow_ma.value)
            self.value = self._signal_ma.value

        # Initialization logic
        if not self.initialized:
            self._set_has_inputs(True)
            if self._signal_ma.initialized:
                self._set_initialized(True)

        self._previous_hlc3 = self._hlc3

    cpdef void _reset(self):
        self._fast_ma.reset()
        self._slow_ma.reset()
        self._signal_ma.reset()
        self._hlc3 = 0
        self._previous_hlc3 = 0
        self.value = 0


cdef class Pressure(Indicator):
    """
    An indicator which calculates the relative volume (multiple of average volume)
    to move the market across a relative range (multiple of ATR).

    Parameters
    ----------
    period : int
        The period for the indicator (> 0).
    ma_type : MovingAverageType
        The moving average type for the calculations.
    atr_floor : double
        The ATR floor (minimum) output value for the indicator (>= 0.).

    Raises
    ------
    ValueError
        If `period` is not positive (> 0).
    ValueError
        If `atr_floor` is negative (< 0).
    """

    def __init__(
        self,
        int period,
        MovingAverageType ma_type=MovingAverageType.EXPONENTIAL,
        double atr_floor=0,
    ):
        Condition.positive_int(period, "period")
        Condition.not_negative(atr_floor, "atr_floor")

        params=[
            period,
            get_ma_type_name(ma_type),
            atr_floor,
        ]
        super().__init__(params=params)

        self.period = period
        self._atr = AverageTrueRange(period, ma_type, True, atr_floor)
        self._average_volume = MovingAverageFactory.create(period, ma_type)
        self.value = 0
        self.value_cumulative = 0

    cpdef void handle_bar(self, Bar bar):
        """
        Update the indicator with the given bar.

        Parameters
        ----------
        bar : Bar
            The update bar.

        """
        Condition.not_none(bar, "bar")

        self.update_raw(
            bar.high.as_double(),
            bar.low.as_double(),
            bar.close.as_double(),
            bar.volume.as_double(),
        )

    cpdef void update_raw(
        self,
        double high,
        double low,
        double close,
        double volume,
    ):
        """
        Update the indicator with the given raw values.

        Parameters
        ----------
        high : double
            The high price.
        low : double
            The low price.
        close : double
            The close price.
        volume : double
            The volume.

        """
        self._atr.update_raw(high, low, close)
        self._average_volume.update_raw(volume)

        # Initialization logic (do not move this to the bottom as guard against zero will return)
        if not self.initialized:
            self._set_has_inputs(True)
            if self._atr.initialized:
                self._set_initialized(True)

        # Guard against zero values
        if self._average_volume.value == 0 or self._atr.value == 0:
            self.value = 0
            return

        cdef double relative_volume = volume / self._average_volume.value
        cdef double buy_pressure = ((close - low) / self._atr.value) * relative_volume
        cdef double sell_pressure = ((high - close) / self._atr.value) * relative_volume

        self.value = buy_pressure - sell_pressure
        self.value_cumulative += self.value

    cpdef void _reset(self):
        self._atr.reset()
        self._average_volume.reset()
        self.value = 0
        self.value_cumulative = 0

</document_content>
</document>
<document index="2390">
<source>nautilus_trader/model/book.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import pickle
from operator import itemgetter

import pandas as pd

from libc.stdint cimport int64_t
from libc.stdint cimport uint8_t
from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.rust.core cimport CVec
from nautilus_trader.core.rust.model cimport PRICE_RAW_MAX
from nautilus_trader.core.rust.model cimport PRICE_RAW_MIN
from nautilus_trader.core.rust.model cimport BookAction
from nautilus_trader.core.rust.model cimport BookLevel_API
from nautilus_trader.core.rust.model cimport BookOrder_t
from nautilus_trader.core.rust.model cimport BookType
from nautilus_trader.core.rust.model cimport OrderBook_API
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport Price_t
from nautilus_trader.core.rust.model cimport Quantity_t
from nautilus_trader.core.rust.model cimport book_order_new
from nautilus_trader.core.rust.model cimport level_clone
from nautilus_trader.core.rust.model cimport level_drop
from nautilus_trader.core.rust.model cimport level_exposure
from nautilus_trader.core.rust.model cimport level_orders
from nautilus_trader.core.rust.model cimport level_price
from nautilus_trader.core.rust.model cimport level_side
from nautilus_trader.core.rust.model cimport level_size
from nautilus_trader.core.rust.model cimport orderbook_add
from nautilus_trader.core.rust.model cimport orderbook_apply_delta
from nautilus_trader.core.rust.model cimport orderbook_apply_deltas
from nautilus_trader.core.rust.model cimport orderbook_apply_depth
from nautilus_trader.core.rust.model cimport orderbook_asks
from nautilus_trader.core.rust.model cimport orderbook_best_ask_price
from nautilus_trader.core.rust.model cimport orderbook_best_ask_size
from nautilus_trader.core.rust.model cimport orderbook_best_bid_price
from nautilus_trader.core.rust.model cimport orderbook_best_bid_size
from nautilus_trader.core.rust.model cimport orderbook_bids
from nautilus_trader.core.rust.model cimport orderbook_book_type
from nautilus_trader.core.rust.model cimport orderbook_check_integrity
from nautilus_trader.core.rust.model cimport orderbook_clear
from nautilus_trader.core.rust.model cimport orderbook_clear_asks
from nautilus_trader.core.rust.model cimport orderbook_clear_bids
from nautilus_trader.core.rust.model cimport orderbook_delete
from nautilus_trader.core.rust.model cimport orderbook_drop
from nautilus_trader.core.rust.model cimport orderbook_get_avg_px_for_quantity
from nautilus_trader.core.rust.model cimport orderbook_get_quantity_for_price
from nautilus_trader.core.rust.model cimport orderbook_has_ask
from nautilus_trader.core.rust.model cimport orderbook_has_bid
from nautilus_trader.core.rust.model cimport orderbook_instrument_id
from nautilus_trader.core.rust.model cimport orderbook_midpoint
from nautilus_trader.core.rust.model cimport orderbook_new
from nautilus_trader.core.rust.model cimport orderbook_pprint_to_cstr
from nautilus_trader.core.rust.model cimport orderbook_reset
from nautilus_trader.core.rust.model cimport orderbook_sequence
from nautilus_trader.core.rust.model cimport orderbook_simulate_fills
from nautilus_trader.core.rust.model cimport orderbook_spread
from nautilus_trader.core.rust.model cimport orderbook_ts_last
from nautilus_trader.core.rust.model cimport orderbook_update
from nautilus_trader.core.rust.model cimport orderbook_update_count
from nautilus_trader.core.rust.model cimport orderbook_update_quote_tick
from nautilus_trader.core.rust.model cimport orderbook_update_trade_tick
from nautilus_trader.core.rust.model cimport vec_drop_book_levels
from nautilus_trader.core.rust.model cimport vec_drop_book_orders
from nautilus_trader.core.rust.model cimport vec_drop_fills
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.model.data cimport BookOrder
from nautilus_trader.model.data cimport OrderBookDelta
from nautilus_trader.model.data cimport OrderBookDeltas
from nautilus_trader.model.data cimport OrderBookDepth10
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.functions cimport book_type_to_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class OrderBook(Data):
    """
    Provides an order book which can handle L1/L2/L3 granularity data.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the order book.
    book_type : BookType {``L1_MBP``, ``L2_MBP``, ``L3_MBO``}
        The order book type.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        BookType book_type,
    ) -> None:
        self._book_type = book_type
        self._mem = orderbook_new(
            instrument_id._mem,
            book_type,
        )

    def __del__(self) -> None:
        if self._mem._0 != NULL:
            orderbook_drop(self._mem)

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__} {book_type_to_str(self.book_type)}\n"
            f"instrument: {self.instrument_id}\n"
            f"sequence: {self.sequence}\n"
            f"ts_last: {self.ts_last}\n"
            f"update_count: {self.update_count}\n"
            f"{self.pprint()}"
        )

    def __getstate__(self):
        cdef list orders = [o for level in self.bids() + self.asks() for o in level.orders()]
        return (
            self.instrument_id.value,
            self.book_type.value,
            self.ts_last,
            self.sequence,
            pickle.dumps(orders),
        )

    def __setstate__(self, state):
        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
        self._book_type = state[1]
        self._mem = orderbook_new(
            instrument_id._mem,
            state[1],
        )
        cdef int64_t ts_last = state[2]
        cdef int64_t sequence = state[3]
        cdef list orders = pickle.loads(state[4])

        cdef int64_t i
        for i in range(len(orders)):
            self.add(orders[i], ts_last, sequence)

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the books instrument ID.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(orderbook_instrument_id(&self._mem))

    @property
    def book_type(self) -> BookType:
        """
        Return the order book type.

        Returns
        -------
        BookType

        """
        return self._book_type

    @property
    def sequence(self) -> int:
        """
        Return the last sequence number for the book.

        Returns
        -------
        int

        """
        return orderbook_sequence(&self._mem)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return orderbook_ts_last(&self._mem)

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return orderbook_ts_last(&self._mem)

    @property
    def ts_last(self) -> int:
        """
        Return the UNIX timestamp (nanoseconds) when the order book was last updated.

        Returns
        -------
        int

        """
        return orderbook_ts_last(&self._mem)

    @property
    def update_count(self) -> int:
        """
        Return the books update count.

        Returns
        -------
        int

        """
        return orderbook_update_count(&self._mem)

    cpdef void reset(self):
        """
        Reset the order book (clear all stateful values).
        """
        orderbook_reset(&self._mem)

    cpdef void add(self, BookOrder order, uint64_t ts_event, uint8_t flags=0, uint64_t sequence=0):
        """
        Add the given order to the book.

        Parameters
        ----------
        order : BookOrder
            The order to add.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the book event occurred.
        flags : uint8_t, default 0
            The record flags bit field, indicating event end and data information.
        sequence : uint64_t, default 0
            The unique sequence number for the update. If default 0 then will increment the `sequence`.

        Raises
        ------
        RuntimeError
            If the book type is L1_MBP.

        """
        Condition.not_none(order, "order")

        if self._book_type == BookType.L1_MBP:
            raise RuntimeError("Invalid book operation: cannot add order for L1_MBP book")

        orderbook_add(&self._mem, order._mem, flags, sequence, ts_event)

    cpdef void update(self, BookOrder order, uint64_t ts_event, uint8_t flags=0, uint64_t sequence=0):
        """
        Update the given order in the book.

        Parameters
        ----------
        order : Order
            The order to update.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the book event occurred.
        flags : uint8_t, default 0
            The record flags bit field, indicating event end and data information.
        sequence : uint64_t, default 0
            The unique sequence number for the update. If default 0 then will increment the `sequence`.

        """
        Condition.not_none(order, "order")

        orderbook_update(&self._mem, order._mem, flags, sequence, ts_event)

    cpdef void delete(self, BookOrder order, uint64_t ts_event, uint8_t flags=0, uint64_t sequence=0):
        """
        Cancel the given order in the book.

        Parameters
        ----------
        order : Order
            The order to delete.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the book event occurred.
        flags : uint8_t, default 0
            The record flags bit field, indicating event end and data information.
        sequence : uint64_t, default 0
            The unique sequence number for the update. If default 0 then will increment the `sequence`.

        """
        Condition.not_none(order, "order")

        orderbook_delete(&self._mem, order._mem, flags, sequence, ts_event)

    cpdef void clear(self, uint64_t ts_event, uint64_t sequence=0):
        """
        Clear the entire order book.
        """
        orderbook_clear(&self._mem, sequence, ts_event)

    cpdef void clear_bids(self, uint64_t ts_event, uint64_t sequence=0):
        """
        Clear the bids from the order book.
        """
        orderbook_clear_bids(&self._mem, sequence, ts_event)

    cpdef void clear_asks(self, uint64_t ts_event, uint64_t sequence=0):
        """
        Clear the asks from the order book.
        """
        orderbook_clear_asks(&self._mem, sequence, ts_event)

    cpdef void apply_delta(self, OrderBookDelta delta):
        """
        Apply the order book delta.

        Parameters
        ----------
        delta : OrderBookDelta
            The delta to apply.

        Raises
        ------
        ValueError
            If `delta.book_type` is not equal to `self.type`.

        """
        Condition.not_none(delta, "delta")

        orderbook_apply_delta(&self._mem, &delta._mem)

    cpdef void apply_deltas(self, OrderBookDeltas deltas):
        """
        Apply the bulk deltas to the order book.

        Parameters
        ----------
        deltas : OrderBookDeltas
            The deltas to apply.

        """
        Condition.not_none(deltas, "deltas")

        orderbook_apply_deltas(&self._mem, &deltas._mem)

    cpdef void apply_depth(self, OrderBookDepth10 depth):
        """
        Apply the depth update to the order book.

        Parameters
        ----------
        depth : OrderBookDepth10
            The depth update to apply.

        """
        Condition.not_none(depth, "depth")

        orderbook_apply_depth(&self._mem, &depth._mem)

    cpdef void apply(self, Data data):
        """
        Apply the given data to the order book.

        Parameters
        ----------
        delta : OrderBookDelta, OrderBookDeltas
            The data to apply.

        """
        if isinstance(data, OrderBookDelta):
            self.apply_delta(data)
        elif isinstance(data, OrderBookDeltas):
            self.apply_deltas(data)
        elif isinstance(data, OrderBookDepth10):
            self.apply_depth(data)
        else:  # pragma: no-cover (design time error)
            raise RuntimeError(f"invalid order book data type, was {type(data)}")  # pragma: no-cover (design time error)

    cpdef void check_integrity(self):
        """
        Check book integrity.

        For all order books:
        - The bid side price should not be greater than the ask side price.

        Raises
        ------
        RuntimeError
            If book integrity check fails.

        """
        if not orderbook_check_integrity(&self._mem):
            raise RuntimeError(f"Integrity error: orders in cross [{self.best_bid_price()} {self.best_ask_price()}]")

    cpdef list bids(self):
        """
        Return the bid levels for the order book.

        Returns
        -------
        list[BookLevel]
            Sorted in descending order of price.

        """
        cdef CVec raw_levels_vec = orderbook_bids(&self._mem)
        cdef BookLevel_API* raw_levels = <BookLevel_API*>raw_levels_vec.ptr

        cdef list levels = []

        cdef:
            uint64_t i
        for i in range(raw_levels_vec.len):
            levels.append(BookLevel.from_mem_c(raw_levels[i]))

        vec_drop_book_levels(raw_levels_vec)

        return levels

    cpdef list asks(self):
        """
        Return the bid levels for the order book.

        Returns
        -------
        list[BookLevel]
            Sorted in ascending order of price.

        """
        cdef CVec raw_levels_vec = orderbook_asks(&self._mem)
        cdef BookLevel_API* raw_levels = <BookLevel_API*>raw_levels_vec.ptr

        cdef list levels = []

        cdef:
            uint64_t i
        for i in range(raw_levels_vec.len):
            levels.append(BookLevel.from_mem_c(raw_levels[i]))

        vec_drop_book_levels(raw_levels_vec)

        return levels

    cpdef best_bid_price(self):
        """
        Return the best bid price in the book (if no bids then returns ``None``).

        Returns
        -------
        double

        """
        if not orderbook_has_bid(&self._mem):
            return None

        return Price.from_mem_c(orderbook_best_bid_price(&self._mem))

    cpdef best_ask_price(self):
        """
        Return the best ask price in the book (if no asks then returns ``None``).

        Returns
        -------
        double

        """
        if not orderbook_has_ask(&self._mem):
            return None

        return Price.from_mem_c(orderbook_best_ask_price(&self._mem))

    cpdef best_bid_size(self):
        """
        Return the best bid size in the book (if no bids then returns ``None``).

        Returns
        -------
        double

        """
        if not orderbook_has_bid(&self._mem):
            return None

        return Quantity.from_mem_c(orderbook_best_bid_size(&self._mem))

    cpdef best_ask_size(self):
        """
        Return the best ask size in the book (if no asks then returns ``None``).

        Returns
        -------
        double or ``None``

        """
        if not orderbook_has_ask(&self._mem):
            return None

        return Quantity.from_mem_c(orderbook_best_ask_size(&self._mem))

    cpdef spread(self):
        """
        Return the top-of-book spread (if no bids or asks then returns ``None``).

        Returns
        -------
        double or ``None``

        """
        if not orderbook_has_bid(&self._mem) or not orderbook_has_ask(&self._mem):
            return None

        return orderbook_spread(&self._mem)

    cpdef midpoint(self):
        """
        Return the mid point (if no market exists then returns ``None``).

        Returns
        -------
        double or ``None``

        """
        if not orderbook_has_bid(&self._mem) or not orderbook_has_ask(&self._mem):
            return None

        return orderbook_midpoint(&self._mem)

    cpdef double get_avg_px_for_quantity(self, Quantity quantity, OrderSide order_side):
        """
        Return the average price expected for the given `quantity` based on the current state
        of the order book.

        Parameters
        ----------
        quantity : Quantity
            The quantity for the calculation.
        order_side : OrderSide
            The order side for the calculation.

        Returns
        -------
        double

        Raises
        ------
        ValueError
            If `order_side` is equal to ``NO_ORDER_SIDE``

        Warnings
        --------
        If no average price can be calculated then will return 0.0 (zero).

        """
        Condition.not_none(quantity, "quantity")
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")

        return orderbook_get_avg_px_for_quantity(&self._mem, quantity._mem, order_side)

    cpdef double get_quantity_for_price(self, Price price, OrderSide order_side):
        """
        Return the current total quantity for the given `price` based on the current state
        of the order book.

        Parameters
        ----------
        price : Price
            The quantity for the calculation.
        order_side : OrderSide
            The order side for the calculation.

        Returns
        -------
        double

        Raises
        ------
        ValueError
            If `order_side` is equal to ``NO_ORDER_SIDE``

        """
        Condition.not_none(price, "price")
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")

        return orderbook_get_quantity_for_price(&self._mem, price._mem, order_side)

    cpdef list simulate_fills(self, Order order, uint8_t price_prec, uint8_t size_prec, bint is_aggressive):
        """
        Simulate filling the book with the given order.

        Parameters
        ----------
        order : Order
            The order to simulate fills for.
        price_prec : uint8_t
            The price precision for the fills.
        size_prec : uint8_t
            The size precision for the fills (based on the instrument definition).
        is_aggressive : bool
            If the order is an aggressive liquidity taking order.

        """
        Condition.not_none(order, "order")

        if order.leaves_qty._mem.precision != size_prec:
            raise RuntimeError(
                f"Invalid size precision for order leaves quantity {order.leaves_qty._mem.precision} "
                f"when instrument size precision is {size_prec}. "
                f"Check order quantity precision matches the {order.instrument.id} instrument"
            )

        cdef Price order_price
        cdef Price_t price
        price.precision = price_prec
        if is_aggressive:
            price.raw = PRICE_RAW_MAX if order.side == OrderSide.BUY else PRICE_RAW_MIN
        else:
            order_price = order.price
            price.raw = order_price._mem.raw

        cdef BookOrder_t submit_order = book_order_new(
            order.side,
            price,
            order.leaves_qty._mem,
            0,
        )

        cdef CVec raw_fills_vec = orderbook_simulate_fills(&self._mem, submit_order)
        cdef (Price_t, Quantity_t)* raw_fills = <(Price_t, Quantity_t)*>raw_fills_vec.ptr
        cdef list fills = []

        cdef:
            uint64_t i
            (Price_t, Quantity_t) raw_fill
            Price fill_price
            Quantity fill_size
        for i in range(raw_fills_vec.len):
            raw_fill = raw_fills[i]
            fill_price = Price.from_mem_c(raw_fill[0])
            fill_size = Quantity.from_mem_c(raw_fill[1])
            fills.append((fill_price, fill_size))
            if fill_price.precision != price_prec:
                raise RuntimeError(f"{fill_price.precision=} did not match instrument {price_prec=}")
            if fill_size.precision != size_prec:
                raise RuntimeError(f"{fill_size.precision=} did not match instrument {size_prec=}")

        vec_drop_fills(raw_fills_vec)

        return fills

    cpdef void update_quote_tick(self, QuoteTick tick):
        """
        Update the order book with the given quote tick.

        This operation is only valid for ``L1_MBP`` books maintaining a top level.

        Parameters
        ----------
        tick : QuoteTick
            The quote tick to update with.

        Raises
        ------
        RuntimeError
            If `book_type` is not ``L1_MBP``.

        """
        if self._book_type != BookType.L1_MBP:
            raise RuntimeError(
                "Invalid book operation: "
                f"cannot update with quote for {book_type_to_str(self.book_type)} book",
            )

        orderbook_update_quote_tick(&self._mem, &tick._mem)

    cpdef void update_trade_tick(self, TradeTick tick):
        """
        Update the order book with the given trade tick.

        Parameters
        ----------
        tick : TradeTick
            The trade tick to update with.

        Raises
        ------
        RuntimeError
            If `book_type` is not ``L1_MBP``.

        """
        if self._book_type != BookType.L1_MBP:
            raise RuntimeError(
                "Invalid book operation: "
                f"cannot update with trade for {book_type_to_str(self.book_type)} book",
            )

        orderbook_update_trade_tick(&self._mem, &tick._mem)

    cpdef QuoteTick to_quote_tick(self):
        """
        Return a `QuoteTick` created from the top of book levels.

        Returns ``None`` when the top-of-book bid or ask is missing or invalid
        (zero size).

        Returns
        -------
        QuoteTick or ``None``

        """
        # Get the best bid and ask prices and sizes
        cdef Price bid_price = self.best_bid_price()
        cdef Price ask_price = self.best_ask_price()

        if bid_price is None or ask_price is None:
            return None

        cdef Quantity bid_size = self.best_bid_size()
        cdef Quantity ask_size = self.best_ask_size()

        if bid_size is None or ask_size is None:
            return None

        # Check for zero sizes
        if bid_size._mem.raw == 0 or ask_size._mem.raw == 0:
            return None

        return QuoteTick(
            instrument_id=self.instrument_id,
            bid_price=bid_price,
            ask_price=ask_price,
            bid_size=bid_size,
            ask_size=ask_size,
            ts_event=self.ts_last,
            ts_init=self.ts_last,
        )

    cpdef str pprint(self, int num_levels=3):
        """
        Return a string representation of the order book in a human-readable table format.

        Parameters
        ----------
        num_levels : int
            The number of levels to include.

        Returns
        -------
        str

        """
        return cstr_to_pystr(orderbook_pprint_to_cstr(&self._mem, num_levels))


cdef class BookLevel:
    """
    Represents an order book price level.

    A price level on one side of the order book with one or more individual orders.

    This class is read-only and cannot be initialized from Python.

    Parameters
    ----------
    price : Price
        The price for the level.
    orders : list[BookOrder]
        The orders for the level.

    Raises
    ------
    ValueError
        If `orders` is empty.
    """

    def __del__(self) -> None:
        if self._mem._0 != NULL:
            level_drop(self._mem)

    def __eq__(self, BookLevel other) -> bool:
        if other is None:
            return False
        return self.price._mem.raw == other.price._mem.raw

    def __lt__(self, BookLevel other) -> bool:
        return self.price._mem.raw < other.price._mem.raw

    def __le__(self, BookLevel other) -> bool:
        return self.price._mem.raw <= other.price._mem.raw

    def __gt__(self, BookLevel other) -> bool:
        return self.price._mem.raw > other.price._mem.raw

    def __ge__(self, BookLevel other) -> bool:
        return self.price._mem.raw >= other.price._mem.raw

    def __repr__(self) -> str:
        return f"BookLevel(price={self.price}, orders={self.orders()})"

    @property
    def side(self) -> OrderSide:
        """
        Return the side for the level.

        Returns
        -------
        OrderSide

        """
        return <OrderSide>level_side(&self._mem)


    @property
    def price(self) -> Price:
        """
        Return the price for the level.

        Returns
        -------
        Price

        """
        return Price.from_mem_c(level_price(&self._mem))

    @staticmethod
    cdef BookLevel from_mem_c(BookLevel_API mem):
        cdef BookLevel level = BookLevel.__new__(BookLevel)
        level._mem = level_clone(&mem)
        return level

    cpdef list orders(self):
        """
        Return the orders for the level.

        Returns
        -------
        list[BookOrder]

        """
        cdef CVec raw_orders_vec = level_orders(&self._mem)
        cdef BookOrder_t* raw_orders = <BookOrder_t*>raw_orders_vec.ptr

        cdef list book_orders = []

        cdef:
            uint64_t i
        for i in range(raw_orders_vec.len):
            book_orders.append(BookOrder.from_mem_c(raw_orders[i]))

        vec_drop_book_orders(raw_orders_vec)

        return book_orders

    cpdef double size(self):
        """
        Return the size at this level.

        Returns
        -------
        double

        """
        return level_size(&self._mem)

    cpdef double exposure(self):
        """
        Return the exposure at this level (price * volume).

        Returns
        -------
        double

        """
        return level_exposure(&self._mem)


def py_should_handle_own_book_order(Order order) -> bool:
    return should_handle_own_book_order(order)

</document_content>
</document>
<document index="2394">
<source>nautilus_trader/model/data.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import pickle
import warnings

import numpy as np
import pandas as pd

from nautilus_trader.core import nautilus_pyo3

from cpython.datetime cimport timedelta
from cpython.mem cimport PyMem_Free
from cpython.mem cimport PyMem_Malloc
from cpython.pycapsule cimport PyCapsule_Destructor
from cpython.pycapsule cimport PyCapsule_GetPointer
from cpython.pycapsule cimport PyCapsule_New
from libc.stdint cimport uint8_t
from libc.stdint cimport uint32_t
from libc.stdint cimport uint64_t
from libc.stdint cimport uintptr_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.rust.core cimport CVec
from nautilus_trader.core.rust.core cimport millis_to_nanos
from nautilus_trader.core.rust.core cimport secs_to_nanos
from nautilus_trader.core.rust.model cimport DEPTH10_LEN
from nautilus_trader.core.rust.model cimport AggregationSource
from nautilus_trader.core.rust.model cimport AggressorSide
from nautilus_trader.core.rust.model cimport Bar_t
from nautilus_trader.core.rust.model cimport BarSpecification_t
from nautilus_trader.core.rust.model cimport BarType_t
from nautilus_trader.core.rust.model cimport BookAction
from nautilus_trader.core.rust.model cimport BookOrder_t
from nautilus_trader.core.rust.model cimport Data_t
from nautilus_trader.core.rust.model cimport Data_t_Tag
from nautilus_trader.core.rust.model cimport IndexPriceUpdate_t
from nautilus_trader.core.rust.model cimport InstrumentCloseType
from nautilus_trader.core.rust.model cimport MarketStatusAction
from nautilus_trader.core.rust.model cimport MarkPriceUpdate_t
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport Price_t
from nautilus_trader.core.rust.model cimport PriceRaw
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.core.rust.model cimport Quantity_t
from nautilus_trader.core.rust.model cimport QuantityRaw
from nautilus_trader.core.rust.model cimport RecordFlag
from nautilus_trader.core.rust.model cimport bar_eq
from nautilus_trader.core.rust.model cimport bar_hash
from nautilus_trader.core.rust.model cimport bar_new
from nautilus_trader.core.rust.model cimport bar_specification_eq
from nautilus_trader.core.rust.model cimport bar_specification_ge
from nautilus_trader.core.rust.model cimport bar_specification_gt
from nautilus_trader.core.rust.model cimport bar_specification_hash
from nautilus_trader.core.rust.model cimport bar_specification_le
from nautilus_trader.core.rust.model cimport bar_specification_lt
from nautilus_trader.core.rust.model cimport bar_specification_new
from nautilus_trader.core.rust.model cimport bar_specification_to_cstr
from nautilus_trader.core.rust.model cimport bar_to_cstr
from nautilus_trader.core.rust.model cimport bar_type_aggregation_source
from nautilus_trader.core.rust.model cimport bar_type_check_parsing
from nautilus_trader.core.rust.model cimport bar_type_composite
from nautilus_trader.core.rust.model cimport bar_type_eq
from nautilus_trader.core.rust.model cimport bar_type_from_cstr
from nautilus_trader.core.rust.model cimport bar_type_ge
from nautilus_trader.core.rust.model cimport bar_type_gt
from nautilus_trader.core.rust.model cimport bar_type_hash
from nautilus_trader.core.rust.model cimport bar_type_instrument_id
from nautilus_trader.core.rust.model cimport bar_type_is_composite
from nautilus_trader.core.rust.model cimport bar_type_is_standard
from nautilus_trader.core.rust.model cimport bar_type_le
from nautilus_trader.core.rust.model cimport bar_type_lt
from nautilus_trader.core.rust.model cimport bar_type_new
from nautilus_trader.core.rust.model cimport bar_type_new_composite
from nautilus_trader.core.rust.model cimport bar_type_spec
from nautilus_trader.core.rust.model cimport bar_type_standard
from nautilus_trader.core.rust.model cimport bar_type_to_cstr
from nautilus_trader.core.rust.model cimport book_order_debug_to_cstr
from nautilus_trader.core.rust.model cimport book_order_eq
from nautilus_trader.core.rust.model cimport book_order_exposure
from nautilus_trader.core.rust.model cimport book_order_hash
from nautilus_trader.core.rust.model cimport book_order_new
from nautilus_trader.core.rust.model cimport book_order_signed_size
from nautilus_trader.core.rust.model cimport index_price_update_eq
from nautilus_trader.core.rust.model cimport index_price_update_hash
from nautilus_trader.core.rust.model cimport index_price_update_new
from nautilus_trader.core.rust.model cimport index_price_update_to_cstr
from nautilus_trader.core.rust.model cimport instrument_id_from_cstr
from nautilus_trader.core.rust.model cimport mark_price_update_eq
from nautilus_trader.core.rust.model cimport mark_price_update_hash
from nautilus_trader.core.rust.model cimport mark_price_update_new
from nautilus_trader.core.rust.model cimport mark_price_update_to_cstr
from nautilus_trader.core.rust.model cimport orderbook_delta_eq
from nautilus_trader.core.rust.model cimport orderbook_delta_hash
from nautilus_trader.core.rust.model cimport orderbook_delta_new
from nautilus_trader.core.rust.model cimport orderbook_deltas_clone
from nautilus_trader.core.rust.model cimport orderbook_deltas_drop
from nautilus_trader.core.rust.model cimport orderbook_deltas_flags
from nautilus_trader.core.rust.model cimport orderbook_deltas_instrument_id
from nautilus_trader.core.rust.model cimport orderbook_deltas_is_snapshot
from nautilus_trader.core.rust.model cimport orderbook_deltas_new
from nautilus_trader.core.rust.model cimport orderbook_deltas_sequence
from nautilus_trader.core.rust.model cimport orderbook_deltas_ts_event
from nautilus_trader.core.rust.model cimport orderbook_deltas_ts_init
from nautilus_trader.core.rust.model cimport orderbook_deltas_vec_deltas
from nautilus_trader.core.rust.model cimport orderbook_deltas_vec_drop
from nautilus_trader.core.rust.model cimport orderbook_depth10_ask_counts_array
from nautilus_trader.core.rust.model cimport orderbook_depth10_asks_array
from nautilus_trader.core.rust.model cimport orderbook_depth10_bid_counts_array
from nautilus_trader.core.rust.model cimport orderbook_depth10_bids_array
from nautilus_trader.core.rust.model cimport orderbook_depth10_clone
from nautilus_trader.core.rust.model cimport orderbook_depth10_eq
from nautilus_trader.core.rust.model cimport orderbook_depth10_hash
from nautilus_trader.core.rust.model cimport orderbook_depth10_new
from nautilus_trader.core.rust.model cimport quote_tick_eq
from nautilus_trader.core.rust.model cimport quote_tick_hash
from nautilus_trader.core.rust.model cimport quote_tick_new
from nautilus_trader.core.rust.model cimport quote_tick_to_cstr
from nautilus_trader.core.rust.model cimport symbol_new
from nautilus_trader.core.rust.model cimport trade_id_new
from nautilus_trader.core.rust.model cimport trade_tick_eq
from nautilus_trader.core.rust.model cimport trade_tick_hash
from nautilus_trader.core.rust.model cimport trade_tick_new
from nautilus_trader.core.rust.model cimport trade_tick_to_cstr
from nautilus_trader.core.rust.model cimport venue_new
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.core.string cimport pystr_to_cstr
from nautilus_trader.core.string cimport ustr_to_pystr
from nautilus_trader.model.data cimport BarAggregation
from nautilus_trader.model.data cimport BarIntervalType
from nautilus_trader.model.functions cimport aggregation_source_from_str
from nautilus_trader.model.functions cimport aggressor_side_from_str
from nautilus_trader.model.functions cimport aggressor_side_to_str
from nautilus_trader.model.functions cimport bar_aggregation_from_str
from nautilus_trader.model.functions cimport bar_aggregation_to_str
from nautilus_trader.model.functions cimport book_action_from_str
from nautilus_trader.model.functions cimport book_action_to_str
from nautilus_trader.model.functions cimport instrument_close_type_from_str
from nautilus_trader.model.functions cimport instrument_close_type_to_str
from nautilus_trader.model.functions cimport market_status_action_from_str
from nautilus_trader.model.functions cimport market_status_action_to_str
from nautilus_trader.model.functions cimport order_side_from_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport price_type_from_str
from nautilus_trader.model.functions cimport price_type_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.identifiers cimport TradeId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.objects cimport price_new
from nautilus_trader.model.objects cimport quantity_new


_SUPPORTED_BAR_AGGREGATIONS = (
    BarAggregation.MILLISECOND,
    BarAggregation.SECOND,
    BarAggregation.MINUTE,
    BarAggregation.HOUR,
    BarAggregation.DAY,
    BarAggregation.WEEK,
    BarAggregation.MONTH,
    BarAggregation.YEAR,
    BarAggregation.TICK,
    BarAggregation.TICK_IMBALANCE,
    BarAggregation.TICK_RUNS,
    BarAggregation.VOLUME,
    BarAggregation.VOLUME_IMBALANCE,
    BarAggregation.VOLUME_RUNS,
    BarAggregation.VALUE,
    BarAggregation.VALUE_IMBALANCE,
    BarAggregation.VALUE_RUNS,
    BarAggregation.RENKO,
)


cpdef str supported_bar_aggregations_str():
    cdef list[str] names = []

    # Using an imperative for loop here as closures not supported in cpdef
    cdef BarAggregation aggregation
    for aggregation in _SUPPORTED_BAR_AGGREGATIONS:
        names.append(bar_aggregation_to_str(aggregation))

    return ", ".join(names)


cpdef str bar_aggregation_not_implemented_message(BarAggregation aggregation):
    agg_str = bar_aggregation_to_str(aggregation)
    supported = supported_bar_aggregations_str()
    return (
        f"BarAggregation.{agg_str} is not currently implemented. "
        f"Supported aggregations are: {supported}."
    )


cdef inline BookOrder order_from_mem_c(BookOrder_t mem):
    cdef BookOrder order = BookOrder.__new__(BookOrder)
    order._mem = mem
    return order


cdef inline OrderBookDelta delta_from_mem_c(OrderBookDelta_t mem):
    cdef OrderBookDelta delta = OrderBookDelta.__new__(OrderBookDelta)
    delta._mem = mem
    return delta


cdef inline OrderBookDeltas deltas_from_mem_c(OrderBookDeltas_API mem):
    cdef OrderBookDeltas deltas = OrderBookDeltas.__new__(OrderBookDeltas)
    deltas._mem = orderbook_deltas_clone(&mem)
    return deltas


cdef inline OrderBookDepth10 depth10_from_mem_c(OrderBookDepth10_t mem):
    cdef OrderBookDepth10 depth10 = OrderBookDepth10.__new__(OrderBookDepth10)
    depth10._mem = mem
    return depth10


cdef inline QuoteTick quote_from_mem_c(QuoteTick_t mem):
    cdef QuoteTick quote = QuoteTick.__new__(QuoteTick)
    quote._mem = mem
    return quote


cdef inline TradeTick trade_from_mem_c(TradeTick_t mem):
    cdef TradeTick trade = TradeTick.__new__(TradeTick)
    trade._mem = mem
    return trade


cdef inline str data_tag_to_str(Data_t_Tag tag):
    if tag == Data_t_Tag.DELTA:
        return "DELTA"
    elif tag == Data_t_Tag.DELTAS:
        return "DELTAS"
    elif tag == Data_t_Tag.DEPTH10:
        return "DEPTH10"
    elif tag == Data_t_Tag.QUOTE:
        return "QUOTE"
    elif tag == Data_t_Tag.TRADE:
        return "TRADE"
    elif tag == Data_t_Tag.BAR:
        return "BAR"
    elif tag == Data_t_Tag.MARK_PRICE_UPDATE:
        return "MARK_PRICE_UPDATE"
    elif tag == Data_t_Tag.INDEX_PRICE_UPDATE:
        return "INDEX_PRICE_UPDATE"
    elif tag == Data_t_Tag.INSTRUMENT_CLOSE:
        return "INSTRUMENT_CLOSE"
    else:
        return f"UNKNOWN({int(tag)})"


cdef inline Bar bar_from_mem_c(Bar_t mem):
    cdef Bar bar = Bar.__new__(Bar)
    bar._mem = mem
    return bar


cdef inline MarkPriceUpdate mark_price_from_mem_c(MarkPriceUpdate_t mem):
    cdef MarkPriceUpdate update = MarkPriceUpdate.__new__(MarkPriceUpdate)
    update._mem = mem
    return update


cdef inline IndexPriceUpdate index_price_from_mem_c(IndexPriceUpdate_t mem):
    cdef IndexPriceUpdate update = IndexPriceUpdate.__new__(IndexPriceUpdate)
    update._mem = mem
    return update


# SAFETY: Do NOT deallocate the capsule here
cpdef list capsule_to_list(capsule):
    cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
    cdef Data_t* ptr = <Data_t*>data.ptr
    cdef list objects = []

    cdef uint64_t i
    for i in range(0, data.len):
        if ptr[i].tag == Data_t_Tag.DELTA:
            objects.append(delta_from_mem_c(ptr[i].delta))
        elif ptr[i].tag == Data_t_Tag.DELTAS:
            objects.append(deltas_from_mem_c(ptr[i].deltas))
        elif ptr[i].tag == Data_t_Tag.DEPTH10:
            objects.append(depth10_from_mem_c(orderbook_depth10_clone(ptr[i].depth10)))
        elif ptr[i].tag == Data_t_Tag.QUOTE:
            objects.append(quote_from_mem_c(ptr[i].quote))
        elif ptr[i].tag == Data_t_Tag.TRADE:
            objects.append(trade_from_mem_c(ptr[i].trade))
        elif ptr[i].tag == Data_t_Tag.BAR:
            objects.append(bar_from_mem_c(ptr[i].bar))
        elif ptr[i].tag == Data_t_Tag.MARK_PRICE_UPDATE:
            objects.append(mark_price_from_mem_c(ptr[i].mark_price_update))
        elif ptr[i].tag == Data_t_Tag.INDEX_PRICE_UPDATE:
            objects.append(index_price_from_mem_c(ptr[i].index_price_update))
        else:
            raise RuntimeError("Invalid data element to convert from `PyCapsule`")

    return objects


# SAFETY: Do NOT deallocate the capsule here
cpdef Data capsule_to_data(capsule):
    cdef Data_t* ptr = <Data_t*>PyCapsule_GetPointer(capsule, NULL)

    if ptr.tag == Data_t_Tag.DELTA:
        return delta_from_mem_c(ptr.delta)
    elif ptr.tag == Data_t_Tag.DELTAS:
        return deltas_from_mem_c(ptr.deltas)
    elif ptr.tag == Data_t_Tag.DEPTH10:
        return depth10_from_mem_c(orderbook_depth10_clone(ptr.depth10))
    elif ptr.tag == Data_t_Tag.QUOTE:
        return quote_from_mem_c(ptr.quote)
    elif ptr.tag == Data_t_Tag.TRADE:
        return trade_from_mem_c(ptr.trade)
    elif ptr.tag == Data_t_Tag.BAR:
        return bar_from_mem_c(ptr.bar)
    elif ptr.tag == Data_t_Tag.MARK_PRICE_UPDATE:
        return mark_price_from_mem_c(ptr.mark_price_update)
    elif ptr.tag == Data_t_Tag.INDEX_PRICE_UPDATE:
        return index_price_from_mem_c(ptr.index_price_update)
    else:
        raise RuntimeError("Invalid data element to convert from `PyCapsule`")


cdef class BarSpecification:
    """
    Represents a bar aggregation specification that defines how market data should be
    aggregated into bars (candlesticks).

    A bar specification consists of three main components:
    - **Step**: The quantity or interval for aggregation (e.g., 5 for 5-minute bars)
    - **Aggregation**: The method/rule for aggregation (time, tick, volume, value, etc.)
    - **Price Type**: Which price to use for aggregation (BID, ASK, MID, LAST)

    Bar specifications are used to define different types of bars:

    **Time-based bars**: Aggregate data over fixed time intervals
    - Examples: 1-MINUTE-LAST, 5-MINUTE-MID, 1-HOUR-BID

    **Tick-based bars**: Aggregate data after a certain number of ticks
    - Examples: 100-TICK-LAST, 1000-TICK-MID

    **Volume-based bars**: Aggregate data after a certain volume threshold
    - Examples: 1000-VOLUME-LAST, 10000-VOLUME-MID

    **Value-based bars**: Aggregate data after a certain dollar value threshold
    - Examples: 100000-VALUE-LAST, 1000000-VALUE-MID

    **Information-based bars**: Advanced aggregation based on information flow
    - Examples: 1000-VALUE_IMBALANCE-MID, 500-VALUE_RUNS-LAST

    The specification determines:
    - What triggers bar creation (aggregation method)
    - How often bars are created (step size)
    - Which price level to use for OHLCV calculation (price type)

    Parameters
    ----------
    step : int
        The step size for bar aggregation. Must be positive.
        - For time bars: interval in time units (1=1min, 5=5min, etc.)
        - For tick bars: number of ticks per bar
        - For volume/value bars: threshold amount
    aggregation : BarAggregation
        The aggregation method (MINUTE, TICK, VOLUME, VALUE, etc.)
    price_type : PriceType
        The price type to use (BID, ASK, MID, LAST)

    Raises
    ------
    ValueError
        If step is not valid or if invalid aggregation/price_type combinations

    Notes
    -----
    **Time Bar Aggregation Steps**:

    Time-based bars have specific constraints on allowed step values to ensure
    alignment with standard market time intervals:

    - **MILLISECOND**: Steps 1-999 milliseconds (must divide evenly into 1000)
        Valid: 1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500
    - **SECOND**: Steps 1-59 seconds (must divide evenly into 60)
        Valid: 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30
    - **MINUTE**: Steps 1-59 minutes (must divide evenly into 60)
        Valid: 1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30
    - **HOUR**: Steps 1-23 hours (must divide evenly into 24)
        Valid: 1, 2, 3, 4, 6, 8, 12
    - **DAY**: Only step=1 allowed (1 day intervals)
    - **WEEK**: Only step=1 allowed (1 week intervals)
    - **MONTH**: Steps 1-11 months (must divide evenly into 12)
        Valid: 1, 2, 3, 4, 6 (e.g., 1-month, quarterly, semi-annual)

    Invalid step values will raise ValueError during construction.

    **Composite Bars**:

    Composite bars are created by aggregating smaller time frame bars into larger
    time frame bars internally within the system.
    For example, a 5-minute composite bar can be created by aggregating five 1-minute
    bars.

    Examples
    --------
    Create time bar specifications with valid steps:

    >>> spec1 = BarSpecification(1, BarAggregation.MINUTE, PriceType.LAST)   # 1-min
    >>> spec4h = BarSpecification(4, BarAggregation.HOUR, PriceType.LAST)    # 4-hour
    >>> spec6m = BarSpecification(6, BarAggregation.MONTH, PriceType.LAST)   # semi-annual

    >>> # Invalid steps will raise ValueError
    >>> try:
    ...     invalid = BarSpecification(7, BarAggregation.MINUTE, PriceType.LAST)  # 7 doesn't divide 60
    ... except ValueError as e:
    ...     print(f"Error: {e}")

    Create composite bar setup:

    >>> # Composite 5-minute specification for internal aggregation
    >>> composite_spec = BarSpecification(5, BarAggregation.MINUTE, PriceType.LAST)
    >>> composite_bar_type = BarType(instrument_id, composite_spec, AggregationSource.INTERNAL)

    Check aggregation type and get timedelta:

    >>> spec = BarSpecification(30, BarAggregation.SECOND, PriceType.LAST)
    >>> spec.is_time_aggregated()
    True
    >>> spec.timedelta
    datetime.timedelta(seconds=30)

    >>> # Note: MONTH and YEAR aggregation doesn't support timedelta conversion
    >>> month_spec = BarSpecification(1, BarAggregation.MONTH, PriceType.LAST)
    >>> month_spec.is_time_aggregated()
    True
    >>> # month_spec.timedelta  # This would raise ValueError

    >>> # Threshold-based bars
    >>> tick_spec = BarSpecification(1000, BarAggregation.TICK, PriceType.MID)
    >>> tick_spec.is_threshold_aggregated()
    True
    >>> tick_spec.is_time_aggregated()
    False

    Parse from string representation:

    >>> spec = BarSpecification.from_str("15-MINUTE-BID")
    >>> print(f"Step: {spec.step}, Aggregation: {spec.aggregation}")
    Step: 15, Aggregation: BarAggregation.MINUTE
    """

    def __init__(
        self,
        int step,
        BarAggregation aggregation,
        PriceType price_type,
    ) -> None:
        Condition.positive_int(step, "step")


        def validate_step(subunits: int, allow_equal: bool = False):
            if subunits % step != 0:
                raise ValueError(
                    f"Invalid step in bar_type.spec.step: "
                    f"{step} for aggregation={aggregation}. "
                    f"step must evenly divide {subunits} (so it is periodic)."
                )
            if not allow_equal and subunits == step:
                raise ValueError(
                    f"Invalid step in bar_type.spec.step: "
                    f"{step} for aggregation={aggregation}. "
                    f"step must not be {subunits}. "
                    "Use higher aggregation unit instead."
                )

        if aggregation is BarAggregation.MILLISECOND:
            validate_step(1000)
        elif aggregation is BarAggregation.SECOND:
            validate_step(60)
        elif aggregation is BarAggregation.MINUTE:
            validate_step(60)
        elif aggregation is BarAggregation.HOUR:
            validate_step(24)
        elif aggregation is BarAggregation.DAY:
            validate_step(1, allow_equal=True)
        elif aggregation is BarAggregation.WEEK:
            validate_step(1, allow_equal=True)
        elif aggregation is BarAggregation.MONTH:
            validate_step(12)
        elif aggregation is BarAggregation.YEAR:
            # Allow any step for YEAR aggregation (1-YEAR, 2-YEAR, 5-YEAR, etc.).
            # No further validation needed as any positive int step is valid for
            # years.
            pass

        self._mem = bar_specification_new(
            step,
            aggregation,
            price_type
        )

    def __getstate__(self):
        return (
            self._mem.step,
            self._mem.aggregation,
            self._mem.price_type,
        )

    def __setstate__(self, state):
        self._mem = bar_specification_new(
            state[0],
            state[1],
            state[2]
        )

    cdef str to_str(self):
        return cstr_to_pystr(bar_specification_to_cstr(&self._mem))

    def __eq__(self, BarSpecification other) -> bool:
        if other is None:
            return False
        return bar_specification_eq(&self._mem, &other._mem)

    def __lt__(self, BarSpecification other) -> bool:
        return bar_specification_lt(&self._mem, &other._mem)

    def __le__(self, BarSpecification other) -> bool:
        return bar_specification_le(&self._mem, &other._mem)

    def __gt__(self, BarSpecification other) -> bool:
        return bar_specification_gt(&self._mem, &other._mem)

    def __ge__(self, BarSpecification other) -> bool:
        return bar_specification_ge(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return bar_specification_hash(&self._mem)

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self})"

    @property
    def step(self) -> int:
        """
        Return the step size for the specification.

        Returns
        -------
        int

        """
        return self._mem.step

    @property
    def aggregation(self) -> BarAggregation:
        """
        Return the aggregation for the specification.

        Returns
        -------
        BarAggregation

        """
        return self._mem.aggregation

    @property
    def price_type(self) -> PriceType:
        """
        Return the price type for the specification.

        Returns
        -------
        PriceType

        """
        return self._mem.price_type

    cpdef uint64_t get_interval_ns(self):
            """
            Return the interval length in nanoseconds for time-based bar specifications.

            Converts the bar specification's time interval to nanoseconds based on its
            aggregation type and step size. This method is used for time calculations
            and (TODO: bar alignment).

            Returns
            -------
            uint64_t
                The interval length in nanoseconds.

            Raises
            ------
            ValueError
                If the aggregation is not a time-based aggregation.

            Notes
            -----
            Only time-based aggregations can be converted to nanosecond intervals.
            Threshold-based and information-based aggregations will raise a ValueError.

            Month or year intervals use proxy values to estimate their respective durations.

            Examples
            --------
            >>> spec = BarSpecification(5, BarAggregation.MINUTE, PriceType.LAST)
            >>> spec.get_interval_ns()  # Returns 5 minutes in nanoseconds
            300000000000
            """
            cdef BarAggregation aggregation = <BarAggregation>self._mem.aggregation
            cdef int step = self._mem.step

            if aggregation is BarAggregation.MILLISECOND:
                return millis_to_nanos(step)
            elif aggregation is BarAggregation.SECOND:
                return secs_to_nanos(step)
            elif aggregation is BarAggregation.MINUTE:
                return step * secs_to_nanos(60)
            elif aggregation is BarAggregation.HOUR:
                return step * secs_to_nanos(60 * 60)
            elif aggregation is BarAggregation.DAY:
                return step * secs_to_nanos(60 * 60 * 24)
            elif aggregation is BarAggregation.WEEK:
                return step * secs_to_nanos(60 * 60 * 24 * 7)
            elif aggregation is BarAggregation.MONTH:
                return step * secs_to_nanos(60 * 60 * 24 * 30) # Proxy for comparing bar lengths
            elif aggregation is BarAggregation.YEAR:
                return step * secs_to_nanos(60 * 60 * 24 * 365) # Proxy for comparing bar lengths
            else:
                # Design time error
                raise ValueError(
                    f"Aggregation not time based, was {bar_aggregation_to_str(aggregation)}",
                )

    @property
    def timedelta(self) -> pd.Timedelta:
        """
        Return the timedelta for the specification.

        Returns
        -------
        pandas.Timedelta

        Raises
        ------
        ValueError
            If `aggregation` is not a time aggregation, or is``MONTH`` (which is ambiguous).

        """
        return pd.Timedelta(self.get_interval_ns())

    cdef str aggregation_string_c(self):
        return bar_aggregation_to_str(self.aggregation)

    @staticmethod
    cdef BarSpecification from_mem_c(BarSpecification_t mem):
        cdef BarSpecification spec = BarSpecification.__new__(BarSpecification)
        spec._mem = mem
        return spec

    @staticmethod
    cdef BarSpecification from_str_c(str value):
        Condition.valid_string(value, 'value')

        cdef list pieces = value.rsplit('-', maxsplit=2)

        if len(pieces) != 3:
            raise ValueError(
                f"The `BarSpecification` string value was malformed, was {value}",
            )

        return BarSpecification(
            int(pieces[0]),
            bar_aggregation_from_str(pieces[1]),
            price_type_from_str(pieces[2]),
        )

    @staticmethod
    cdef bint check_time_aggregated_c(BarAggregation aggregation):
        if (
            aggregation == BarAggregation.MILLISECOND
            or aggregation == BarAggregation.SECOND
            or aggregation == BarAggregation.MINUTE
            or aggregation == BarAggregation.HOUR
            or aggregation == BarAggregation.DAY
            or aggregation == BarAggregation.WEEK
            or aggregation == BarAggregation.MONTH
            or aggregation == BarAggregation.YEAR
        ):
            return True
        else:
            return False

    @staticmethod
    cdef bint check_threshold_aggregated_c(BarAggregation aggregation):
        if (
            aggregation == BarAggregation.TICK
            or aggregation == BarAggregation.TICK_IMBALANCE
            or aggregation == BarAggregation.VOLUME
            or aggregation == BarAggregation.VOLUME_IMBALANCE
            or aggregation == BarAggregation.VALUE
            or aggregation == BarAggregation.VALUE_IMBALANCE
        ):
            return True
        else:
            return False

    @staticmethod
    cdef bint check_information_aggregated_c(BarAggregation aggregation):
        if (
            aggregation == BarAggregation.TICK_RUNS
            or aggregation == BarAggregation.VOLUME_RUNS
            or aggregation == BarAggregation.VALUE_RUNS
        ):
            return True
        else:
            return False

    @staticmethod
    def from_str(str value) -> BarSpecification:
        """
        Return a bar specification parsed from the given string.

        Parameters
        ----------
        value : str
            The bar specification string to parse.

        Examples
        --------
        String format example is '200-TICK-MID'.

        Returns
        -------
        BarSpecification

        Raises
        ------
        ValueError
            If `value` is not a valid string.

        """
        return BarSpecification.from_str_c(value)

    @staticmethod
    def from_timedelta(timedelta duration, PriceType price_type) -> BarSpecification:
        """
        Return a bar specification parsed from the given timedelta and price_type.

        Parameters
        ----------
        duration : timedelta
            The bar specification timedelta to parse.
        price_type : PriceType
            The bar specification price_type.

        Examples
        --------
        BarSpecification.from_timedelta(datetime.timedelta(minutes=5), PriceType.LAST).

        Returns
        -------
        BarSpecification

        Raises
        ------
        ValueError
            If `duration` is not rounded step of aggregation.

        """
        if duration.days >= 7:
            bar_spec = BarSpecification(duration.days / 7, BarAggregation.WEEK, price_type)
        elif duration.days >= 1:
            bar_spec = BarSpecification(duration.days, BarAggregation.DAY, price_type)
        elif duration.total_seconds() >= 3600:
            bar_spec = BarSpecification(duration.total_seconds() / 3600, BarAggregation.HOUR, price_type)
        elif duration.total_seconds() >= 60:
            bar_spec = BarSpecification(duration.total_seconds() / 60, BarAggregation.MINUTE, price_type)
        elif duration.total_seconds() >= 1:
            bar_spec = BarSpecification(duration.total_seconds(), BarAggregation.SECOND, price_type)
        else:
            bar_spec = BarSpecification(duration.total_seconds() * 1000, BarAggregation.MILLISECOND, price_type)

        if bar_spec.timedelta.total_seconds() == duration.total_seconds():
            return bar_spec
        else:
            raise ValueError(
                f"Duration {repr(duration)} is ambiguous.",
            )

    @staticmethod
    def check_time_aggregated(BarAggregation aggregation):
        """
        Check if the given aggregation is a time-based aggregation type.

        Time-based aggregation creates bars at fixed time intervals, where each bar
        represents market data for a specific time period. These bars are emitted
        when the time interval expires, regardless of trading activity level.

        Time-based aggregation types include:
        - ``MILLISECOND``: Bars created every N milliseconds
        - ``SECOND``: Bars created every N seconds
        - ``MINUTE``: Bars created every N minutes
        - ``HOUR``: Bars created every N hours
        - ``DAY``: Bars created every N days (calendar days)
        - ``WEEK``: Bars created every N weeks (calendar weeks)
        - ``MONTH``: Bars created every N months (calendar months)
        - ``YEAR``: Bars created every N years (calendar years)

        This is distinct from threshold-based aggregation (TICK, VOLUME, VALUE)
        which creates bars when activity thresholds are reached, and information-based
        aggregation (RUNS) which creates bars based on market microstructure patterns.

        Parameters
        ----------
        aggregation : BarAggregation
            The aggregation type to check.

        Returns
        -------
        bool
            True if the aggregation is time-based, else False.

        Examples
        --------
        >>> BarSpecification.check_time_aggregated(BarAggregation.MINUTE)
        True
        >>> BarSpecification.check_time_aggregated(BarAggregation.TICK)
        False

        """
        return BarSpecification.check_time_aggregated_c(aggregation)

    @staticmethod
    def check_threshold_aggregated(BarAggregation aggregation):
        """
        Check if the given aggregation is a threshold-based aggregation type.

        Threshold-based aggregation creates bars when accumulated market activity
        reaches predefined thresholds, providing activity-driven sampling rather
        than time-driven sampling. These bars capture market dynamics based on
        actual trading patterns and volumes.

        Threshold-based aggregation types include:
        - ``TICK``: Bars created after N ticks (price changes)
        - ``TICK_IMBALANCE``: Bars created when tick imbalance reaches threshold
        - ``VOLUME``: Bars created after N units of volume are traded
        - ``VOLUME_IMBALANCE``: Bars created when volume imbalance reaches threshold
        - ``VALUE``: Bars created after N units of notional value are traded
        - ``VALUE_IMBALANCE``: Bars created when value imbalance reaches threshold

        This differs from time-based aggregation which creates bars at fixed time
        intervals, and information-based aggregation which creates bars based on
        market microstructure patterns and runs.

        Parameters
        ----------
        aggregation : BarAggregation
            The aggregation type to check.

        Returns
        -------
        bool
            True if the aggregation is threshold-based, else False.

        Examples
        --------
        >>> BarSpecification.check_threshold_aggregated(BarAggregation.VOLUME)
        True
        >>> BarSpecification.check_threshold_aggregated(BarAggregation.MINUTE)
        False

        """
        return BarSpecification.check_threshold_aggregated_c(aggregation)

    @staticmethod
    def check_information_aggregated(BarAggregation aggregation):
        """
        Check if the given aggregation is an information-based aggregation type.

        Information-based aggregation creates bars based on market microstructure
        patterns and sequential runs of similar market events. These bars capture
        information flow and market efficiency patterns by detecting sequences
        of directionally similar price movements or trading activity.

        Information-based aggregation types include:
        - ``TICK_RUNS``: Bars created when runs of tick price movements occur
        - ``VOLUME_RUNS``: Bars created when runs of volume patterns occur
        - ``VALUE_RUNS``: Bars created when runs of value patterns occur

        Runs are sequences of consecutive events with the same directional property
        (e.g., consecutive upticks or downticks). This aggregation method is useful
        for analyzing market microstructure, information flow, and detecting
        patterns in high-frequency trading activity.

        This differs from time-based aggregation (fixed intervals) and threshold-based
        aggregation (activity levels), focusing instead on sequential patterns and
        information content of market events.

        Parameters
        ----------
        aggregation : BarAggregation
            The aggregation type to check.

        Returns
        -------
        bool
            True if the aggregation is information-based, else False.

        Examples
        --------
        >>> BarSpecification.check_information_aggregated(BarAggregation.TICK_RUNS)
        True
        >>> BarSpecification.check_information_aggregated(BarAggregation.VOLUME)
        False

        """
        return BarSpecification.check_information_aggregated_c(aggregation)

    cpdef bint is_time_aggregated(self):
            """
            Return a value indicating whether the aggregation method is time-driven.

            Time-based aggregation creates bars at fixed time intervals based on calendar
            or clock time, providing consistent temporal sampling of market data. Each bar
            covers a specific time period regardless of trading activity level.

            Time-based aggregation types supported:
            - ``MILLISECOND``: Fixed millisecond intervals (high-frequency sampling)
            - ``SECOND``: Fixed second intervals (short-term patterns)
            - ``MINUTE``: Fixed minute intervals (most common for retail trading)
            - ``HOUR``: Fixed hour intervals (intraday analysis)
            - ``DAY``: Fixed daily intervals (daily charts, longer-term analysis)
            - ``WEEK``: Fixed weekly intervals (weekly patterns, medium-term trends)
            - ``MONTH``: Fixed monthly intervals (long-term analysis, seasonal patterns)
            - ``YEAR``: Fixed yearly intervals (annual trends, long-term investment)

            Time-based bars are ideal for:
            - Regular time-series analysis and charting
            - Consistent temporal sampling across different market conditions
            - Traditional technical analysis and pattern recognition
            - Comparing market behavior across fixed time periods

            This differs from threshold aggregation (volume/tick-based) which creates
            bars when activity levels are reached, and information aggregation which
            creates bars based on market microstructure patterns.

            Returns
            -------
            bool
                True if the aggregation method is time-based, else False.

            See Also
            --------
            is_threshold_aggregated : Check for threshold-based aggregation
            is_information_aggregated : Check for information-based aggregation

            Examples
            --------
            Create a 5-minute bar specification using last price:

            >>> spec = BarSpecification(5, BarAggregation.MINUTE, PriceType.LAST)
            >>> str(spec)
            '5-MINUTE-LAST'

            Create a tick bar specification:

            >>> spec = BarSpecification(1000, BarAggregation.TICK, PriceType.MID)
            >>> str(spec)
            '1000-TICK-MID'

            Parse from string:

            >>> spec = BarSpecification.from_str("15-MINUTE-BID")
            >>> spec.step
            15
            >>> spec.aggregation
            BarAggregation.MINUTE

            Check aggregation type:

            >>> spec = BarSpecification(1, BarAggregation.HOUR, PriceType.LAST)
            >>> spec.is_time_aggregated()
            True
            >>> spec.is_threshold_aggregated()
            False
            """
            return BarSpecification.check_time_aggregated_c(self.aggregation)

    cpdef bint is_threshold_aggregated(self):
        """
        Return a value indicating whether the aggregation method is threshold-based.

        Threshold-based aggregation types trigger bar creation when cumulative
        activity reaches predefined levels, making them ideal for volume and
        value-driven analysis rather than time-based intervals.

        **Threshold-Based Aggregation Types**

        Activity threshold types supported:
        - ``TICK``: Bars based on tick count thresholds (every N ticks)
        - ``VOLUME``: Bars based on volume thresholds (every N units traded)
        - ``VALUE``: Bars based on notional value thresholds (every N dollars/currency traded)

        Imbalance threshold types supported:
        - ``TICK_IMBALANCE``: Bars based on cumulative tick flow imbalances
        - ``VOLUME_IMBALANCE``: Bars based on cumulative volume imbalances
        - ``VALUE_IMBALANCE``: Bars based on cumulative value flow imbalances

        Threshold-based bars are ideal for:
        - Volume and activity-based analysis independent of time
        - Capturing market activity during varying trading intensities
        - Equal-activity sampling for statistical analysis
        - Risk management based on position sizing and exposure levels
        - Algorithmic trading strategies sensitive to market participation

        This differs from time-based aggregation (fixed time intervals) and
        information-based aggregation (information content patterns), focusing
        instead on measurable activity and participation thresholds.

        Returns
        -------
        bool
            True if the aggregation method is threshold-based, else False.

        See Also
        --------
        check_threshold_aggregated : Static method for threshold aggregation checking
        is_time_aggregated : Check for time-based aggregation
        is_information_aggregated : Check for information-based aggregation

        Examples
        --------
        >>> spec = BarSpecification(1000, BarAggregation.TICK, PriceType.LAST)
        >>> spec.is_threshold_aggregated()
        True
        >>> spec = BarSpecification(100000, BarAggregation.VOLUME, PriceType.LAST)
        >>> spec.is_threshold_aggregated()
        True
        >>> spec = BarSpecification(5, BarAggregation.MINUTE, PriceType.LAST)
        >>> spec.is_threshold_aggregated()
        False

        """
        return BarSpecification.check_threshold_aggregated_c(self.aggregation)

    cpdef bint is_information_aggregated(self):
        """
        Return a value indicating whether the aggregation method is information-driven.

        Information-based aggregation creates bars based on market microstructure
        patterns and sequential runs of similar market events. This aggregation
        method captures information flow, market efficiency patterns, and the
        sequential nature of trading activity by detecting directional runs.

        Information-based aggregation types supported:
        - ``TICK_RUNS``: Bars based on runs of directional tick movements (upticks/downticks)
        - ``VOLUME_RUNS``: Bars based on runs of volume patterns and clustering
        - ``VALUE_RUNS``: Bars based on runs of notional value patterns

        A "run" is a sequence of consecutive market events with the same directional
        or categorical property. For example, a tick run might be 5 consecutive
        upticks followed by 3 consecutive downticks.

        Information-based bars are ideal for:
        - Market microstructure analysis and information flow studies
        - Detecting patterns in high-frequency trading and market efficiency
        - Analyzing sequential dependencies in market data
        - Capturing information content rather than just time or activity levels
        - Studying market maker behavior and order flow dynamics

        This differs from time-based aggregation (fixed time intervals) and
        threshold-based aggregation (activity levels), focusing instead on the
        sequential information content and patterns within market events.

        Returns
        -------
        bool
            True if the aggregation method is information-based, else False.

        See Also
        --------
        Get timedelta for time-based bars:

        >>> spec = BarSpecification(30, BarAggregation.SECOND, PriceType.LAST)
        >>> spec.timedelta
        datetime.timedelta(seconds=30)

        Examples
        --------
        >>> spec = BarSpecification(1000, BarAggregation.VALUE_RUNS, PriceType.LAST)
        >>> spec.is_information_aggregated()
        True
        >>> spec = BarSpecification(1000, BarAggregation.VOLUME, PriceType.LAST)
        >>> spec.is_information_aggregated()
        False

        """
        return BarSpecification.check_information_aggregated_c(self.aggregation)


cdef class BarType:
    """
    Represents a bar type including the instrument ID, bar specification and
    aggregation source.

    Parameters
    ----------
    instrument_id : InstrumentId
        The bar type's instrument ID.
    bar_spec : BarSpecification
        The bar type's specification.
    aggregation_source : AggregationSource, default EXTERNAL
        The bar type aggregation source. If ``INTERNAL`` the `DataEngine`
        will subscribe to the necessary ticks and aggregate bars accordingly.
        Else if ``EXTERNAL`` then bars will be subscribed to directly from
        the venue / data provider.

    Notes
    -----
    - Time aggregations support timedelta conversion
    - Threshold aggregations (tick, volume, value) don't have fixed time intervals
    - Information aggregations use complex algorithms for bar creation
    - String representation format: "{step}-{aggregation}-{price_type}"
        It is expected that all bar aggregation methods other than time will be
        internally aggregated.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        BarSpecification bar_spec not None,
        AggregationSource aggregation_source=AggregationSource.EXTERNAL,
    ) -> None:
        self._mem = bar_type_new(
            instrument_id._mem,
            bar_spec._mem,
            aggregation_source
        )

    def __getstate__(self):
        if self.is_standard():
            spec = self.spec

            return (
                self.instrument_id.value,
                spec.step,
                spec.aggregation,
                spec.price_type,
                self.aggregation_source,
            )
        else:
            composite = self.composite()
            spec = self.spec
            spec_composite = composite.spec

            return (
                self.instrument_id.value,
                spec.step,
                spec.aggregation,
                spec.price_type,
                self.aggregation_source,

                spec_composite.step,
                spec_composite.aggregation,
                composite.aggregation_source
            )

    def __setstate__(self, state):
        if len(state) == 5:
            instrument_id = InstrumentId.from_str_c(state[0])

            self._mem = bar_type_new(
                instrument_id._mem,
                bar_specification_new(
                    state[1],
                    state[2],
                    state[3]
                ),
                state[4],
            )
        else:
            instrument_id = InstrumentId.from_str_c(state[0])
            composite_instrument_id = InstrumentId.from_str_c(state[5])

            self._mem = bar_type_new_composite(
                instrument_id._mem,
                bar_specification_new(
                    state[1],
                    state[2],
                    state[3]
                ),
                state[4],

                state[5],
                state[6],
                state[7],
            )

    cdef str to_str(self):
        return cstr_to_pystr(bar_type_to_cstr(&self._mem))

    def __eq__(self, BarType other) -> bool:
        if other is None:
            return False
        return self.to_str() == other.to_str()

    def __lt__(self, BarType other) -> bool:
        return self.to_str() < other.to_str()

    def __le__(self, BarType other) -> bool:
        return self.to_str() <= other.to_str()

    def __gt__(self, BarType other) -> bool:
        return self.to_str() > other.to_str()

    def __ge__(self, BarType other) -> bool:
        return self.to_str() >= other.to_str()

    def __hash__(self) -> int:
        return hash(self.to_str())

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self})"

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the instrument ID for the bar type.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(bar_type_instrument_id(&self._mem))

    @property
    def spec(self) -> BarSpecification:
        """
        Return the specification for the bar type.

        Returns
        -------
        BarSpecification

        """
        return BarSpecification.from_mem_c(bar_type_spec(&self._mem))

    @property
    def aggregation_source(self) -> AggregationSource:
        """
        Return the aggregation source for the bar type.

        Returns
        -------
        AggregationSource

        """
        return bar_type_aggregation_source(&self._mem)

    @staticmethod
    cdef BarType from_mem_c(BarType_t mem):
        cdef BarType bar_type = BarType.__new__(BarType)
        bar_type._mem = mem
        return bar_type

    @staticmethod
    cdef BarType from_str_c(str value):
        Condition.valid_string(value, "value")

        cdef str parse_err = cstr_to_pystr(bar_type_check_parsing(pystr_to_cstr(value)))
        if parse_err:
            raise ValueError(parse_err)

        cdef BarType bar_type = BarType.__new__(BarType)
        bar_type._mem = bar_type_from_cstr(pystr_to_cstr(value))
        return bar_type

    @staticmethod
    def from_str(str value) -> BarType:
        """
        Return a bar type parsed from the given string.

        Parameters
        ----------
        value : str
            The bar type string to parse.

        Returns
        -------
        BarType

        Raises
        ------
        ValueError
            If `value` is not a valid string.

        """
        return BarType.from_str_c(value)

    cpdef bint is_externally_aggregated(self):
        """
        Return a value indicating whether the bar aggregation source is ``EXTERNAL``.

        Returns
        -------
        bool

        """
        return self.aggregation_source == AggregationSource.EXTERNAL

    cpdef bint is_internally_aggregated(self):
        """
        Return a value indicating whether the bar aggregation source is ``INTERNAL``.

        Returns
        -------
        bool

        """
        return self.aggregation_source == AggregationSource.INTERNAL

    @staticmethod
    def new_composite(
        InstrumentId instrument_id,
        BarSpecification bar_spec,
        AggregationSource aggregation_source,

        int composite_step,
        BarAggregation composite_aggregation,
        AggregationSource composite_aggregation_source,
    ) -> BarType:
        return BarType.from_mem_c(
            bar_type_new_composite(
                instrument_id._mem,
                bar_spec._mem,
                aggregation_source,

                composite_step,
                composite_aggregation,
                composite_aggregation_source,
            )
        )

    cpdef bint is_standard(self):
        """
        Return a value indicating whether the bar type corresponds to `BarType::Standard` in Rust.

        Returns
        -------
        bool

        """
        return bar_type_is_standard(&self._mem)

    cpdef bint is_composite(self):
        """
        Return a value indicating whether the bar type corresponds to `BarType::Composite` in Rust.

        Returns
        -------
        bool

        """
        return bar_type_is_composite(&self._mem)

    cpdef BarType standard(self):
        cdef BarType bar_type = BarType.__new__(BarType)
        bar_type._mem = bar_type_standard(&self._mem)
        return bar_type

    cpdef BarType  composite(self):
        cdef BarType bar_type = BarType.__new__(BarType)
        bar_type._mem = bar_type_composite(&self._mem)
        return bar_type

    cpdef tuple[InstrumentId, BarSpecification] id_spec_key(self):
        """
        Return the instrument ID and bar specification as a tuple key.

        Useful as a hashmap key when aggregation source should be ignored,
        such as for indicator registration where INTERNAL and EXTERNAL bars
        should trigger the same indicators.

        Returns
        -------
        tuple[InstrumentId, BarSpecification]

        """
        return (self.instrument_id, self.spec)


cdef class Bar(Data):
    """
    Represents an aggregated bar.

    Parameters
    ----------
    bar_type : BarType
        The bar type for this bar.
    open : Price
        The bars open price.
    high : Price
        The bars high price.
    low : Price
        The bars low price.
    close : Price
        The bars close price.
    volume : Quantity
        The bars volume.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    is_revision : bool, default False
        If this bar is a revision of a previous bar with the same `ts_event`.

    Raises
    ------
    ValueError
        If `high` is not >= `low`.
    ValueError
        If `high` is not >= `close`.
    ValueError
        If `low` is not <= `close`.

    """

    def __init__(
        self,
        BarType bar_type not None,
        Price open not None,
        Price high not None,
        Price low not None,
        Price close not None,
        Quantity volume not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint is_revision = False,
    ) -> None:
        Condition.is_true(high._mem.raw >= open._mem.raw, "high was < open")
        Condition.is_true(high._mem.raw >= low._mem.raw, "high was < low")
        Condition.is_true(high._mem.raw >= close._mem.raw, "high was < close")
        Condition.is_true(low._mem.raw <= close._mem.raw, "low was > close")
        Condition.is_true(low._mem.raw <= open._mem.raw, "low was > open")

        self._mem = bar_new(
            bar_type._mem,
            open._mem,
            high._mem,
            low._mem,
            close._mem,
            volume._mem,
            ts_event,
            ts_init,
        )
        self.is_revision = is_revision

    def __getstate__(self):
        bar_type = BarType.from_mem_c(self._mem.bar_type)
        bart_type_state = bar_type.__getstate__()

        return bart_type_state + (
            self._mem.open.raw,
            self._mem.high.raw,
            self._mem.low.raw,
            self._mem.close.raw,
            self._mem.close.precision,
            self._mem.volume.raw,
            self._mem.volume.precision,
            self.ts_event,
            self.ts_init,
        )

    def __setstate__(self, state):
        cdef InstrumentId instrument_id
        cdef uint8_t price_prec
        cdef uint8_t size_prec

        if len(state) == 14:
            instrument_id = InstrumentId.from_str_c(state[0])
            price_prec = state[9]
            size_prec = state[11]

            self._mem = bar_new(
                bar_type_new(
                    instrument_id._mem,
                    bar_specification_new(
                        state[1],
                        state[2],
                        state[3],
                    ),
                    state[4],
                ),
                price_new(state[5], price_prec),
                price_new(state[6], price_prec),
                price_new(state[7], price_prec),
                price_new(state[8], price_prec),
                quantity_new(state[10], size_prec),
                state[12],
                state[13],
            )
        else:
            instrument_id = InstrumentId.from_str_c(state[0])
            price_prec = state[12]
            size_prec = state[14]

            self._mem = bar_new(
                bar_type_new_composite(
                    instrument_id._mem,
                    bar_specification_new(
                        state[1],
                        state[2],
                        state[3]
                    ),
                    state[4],

                    state[5],
                    state[6],
                    state[7]
                ),
                price_new(state[8], price_prec),
                price_new(state[9], price_prec),
                price_new(state[10], price_prec),
                price_new(state[11], price_prec),
                quantity_new(state[13], size_prec),
                state[15],
                state[16],
            )

    def __eq__(self, Bar other) -> bool:
        if other is None:
            return False
        return self.to_str() == other.to_str()

    def __hash__(self) -> int:
        return hash(self.to_str())

    cdef str to_str(self):
        return cstr_to_pystr(bar_to_cstr(&self._mem))

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self})"

    @property
    def bar_type(self) -> BarType:
        """
        Return the bar type of bar.

        Returns
        -------
        BarType

        """
        return BarType.from_mem_c(self._mem.bar_type)

    @property
    def open(self) -> Price:
        """
        Return the open price of the bar.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.open.raw, self._mem.open.precision)

    @property
    def high(self) -> Price:
        """
        Return the high price of the bar.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.high.raw, self._mem.high.precision)

    @property
    def low(self) -> Price:
        """
        Return the low price of the bar.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.low.raw, self._mem.low.precision)

    @property
    def close(self) -> Price:
        """
        Return the close price of the bar.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.close.raw, self._mem.close.precision)

    @property
    def volume(self) -> Quantity:
        """
        Return the volume of the bar.

        Returns
        -------
        Quantity

        """
        return Quantity.from_raw_c(self._mem.volume.raw, self._mem.volume.precision)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef Bar from_mem_c(Bar_t mem):
        return bar_from_mem_c(mem)

    @staticmethod
    cdef Bar from_raw_c(
        BarType bar_type,
        PriceRaw open,
        PriceRaw high,
        PriceRaw low,
        PriceRaw close,
        uint8_t price_prec,
        QuantityRaw volume,
        uint8_t size_prec,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        cdef Price_t open_price = price_new(open, price_prec)
        cdef Price_t high_price = price_new(high, price_prec)
        cdef Price_t low_price = price_new(low, price_prec)
        cdef Price_t close_price = price_new(close, price_prec)
        cdef Quantity_t volume_qty = quantity_new(volume, size_prec)
        cdef Bar bar = Bar.__new__(Bar)
        bar._mem = bar_new(
            bar_type._mem,
            open_price,
            high_price,
            low_price,
            close_price,
            volume_qty,
            ts_event,
            ts_init,
        )

        return bar

    @staticmethod
    cdef list[Bar] from_raw_arrays_to_list_c(
        BarType bar_type,
        uint8_t price_prec,
        uint8_t size_prec,
        double[:] opens,
        double[:] highs,
        double[:] lows,
        double[:] closes,
        double[:] volumes,
        uint64_t[:] ts_events,
        uint64_t[:] ts_inits,
    ):
        Condition.is_true(
            len(opens) == len(highs) == len(lows) == len(lows) ==
            len(closes) == len(volumes) == len(ts_events) == len(ts_inits),
            "Array lengths must be equal",
        )

        cdef int count = ts_events.shape[0]
        cdef list[Bar] bars = []

        cdef:
            int i
            Price open_price
            Price high_price
            Price low_price
            Price close_price
            Quantity volume_qty
            Bar bar
        for i in range(count):
            open_price = Price(opens[i], price_prec)
            high_price = Price(highs[i], price_prec)
            low_price = Price(lows[i], price_prec)
            close_price = Price(closes[i], price_prec)
            volume_qty = Quantity(volumes[i], size_prec)
            bar = Bar.__new__(Bar)
            bar._mem = bar_new(
                bar_type._mem,
                open_price._mem,
                high_price._mem,
                low_price._mem,
                close_price._mem,
                volume_qty._mem,
                ts_events[i],
                ts_inits[i],
            )
            bars.append(bar)

        return bars

    @staticmethod
    def from_raw_arrays_to_list(
        BarType bar_type,
        uint8_t price_prec,
        uint8_t size_prec,
        double[:] opens,
        double[:] highs,
        double[:] lows,
        double[:] closes,
        double[:] volumes,
        uint64_t[:] ts_events,
        uint64_t[:] ts_inits,
    ) -> list[Bar]:
        return Bar.from_raw_arrays_to_list_c(
            bar_type,
            price_prec,
            size_prec,
            opens,
            highs,
            lows,
            closes,
            volumes,
            ts_events,
            ts_inits,
        )

    @staticmethod
    cdef Bar from_dict_c(dict values):
        Condition.not_none(values, "values")
        return Bar(
            bar_type=BarType.from_str_c(values["bar_type"]),
            open=Price.from_str_c(values["open"]),
            high=Price.from_str_c(values["high"]),
            low=Price.from_str_c(values["low"]),
            close=Price.from_str_c(values["close"]),
            volume=Quantity.from_str_c(values["volume"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(Bar obj):
        Condition.not_none(obj, "obj")
        return {
            "type": type(obj).__name__,
            "bar_type": str(obj.bar_type),
            "open": str(obj.open),
            "high": str(obj.high),
            "low": str(obj.low),
            "close": str(obj.close),
            "volume": str(obj.volume),
            "ts_event": obj._mem.ts_event,
            "ts_init": obj._mem.ts_init,
        }

    @staticmethod
    cdef Bar from_pyo3_c(pyo3_bar):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        capsule = pyo3_bar.as_pycapsule()
        cdef Data_t* ptr = <Data_t*>PyCapsule_GetPointer(capsule, NULL)
        if ptr == NULL:
            raise ValueError("Invalid Data_t PyCapsule (NULL)")

        # Validate the tag to prevent segfault
        if ptr.tag != Data_t_Tag.BAR:
            raise ValueError(f"Invalid Data_t tag: expected BAR, was {data_tag_to_str(ptr.tag)}")

        return bar_from_mem_c(ptr.bar)

    @staticmethod
    def from_raw(
        BarType bar_type,
        PriceRaw open,
        PriceRaw high,
        PriceRaw low,
        PriceRaw close,
        uint8_t price_prec,
        QuantityRaw volume,
        uint8_t size_prec,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> Bar:
        return Bar.from_raw_c(
            bar_type,
            open,
            high,
            low,
            close,
            price_prec,
            volume,
            size_prec,
            ts_event,
            ts_init,
        )

    @staticmethod
    def from_dict(dict values) -> Bar:
        """
        Return a bar parsed from the given values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        Bar

        """
        return Bar.from_dict_c(values)

    @staticmethod
    def to_dict(Bar obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return Bar.to_dict_c(obj)

    @staticmethod
    def to_pyo3_list(list bars) -> list[nautilus_pyo3.Bar]:
        """
        Return pyo3 Rust bars converted from the given legacy Cython objects.

        Parameters
        ----------
        bars : list[Bar]
            The legacy Cython bars to convert from.

        Returns
        -------
        list[nautilus_pyo3.Bar]

        """
        cdef list output = []

        pyo3_bar_type = None
        cdef uint8_t price_prec = 0
        cdef uint8_t volume_prec = 0

        cdef:
            Bar bar
            BarType bar_type
        for bar in bars:
            if pyo3_bar_type is None:
                bar_type = bar.bar_type
                pyo3_bar_type = nautilus_pyo3.BarType.from_str(bar_type.to_str())
                price_prec = bar._mem.open.precision
                volume_prec = bar._mem.volume.precision

            pyo3_bar = nautilus_pyo3.Bar(
                pyo3_bar_type,
                nautilus_pyo3.Price.from_raw(bar._mem.open.raw, price_prec),
                nautilus_pyo3.Price.from_raw(bar._mem.high.raw, price_prec),
                nautilus_pyo3.Price.from_raw(bar._mem.low.raw, price_prec),
                nautilus_pyo3.Price.from_raw(bar._mem.close.raw, price_prec),
                nautilus_pyo3.Quantity.from_raw(bar._mem.volume.raw, volume_prec),
                bar._mem.ts_event,
                bar._mem.ts_init,
            )
            output.append(pyo3_bar)

        return output

    @staticmethod
    def from_pyo3_list(list pyo3_bars) -> list[Bar]:
        """
        Return legacy Cython bars converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_bars : list[nautilus_pyo3.Bar]
            The pyo3 Rust bars to convert from.

        Returns
        -------
        list[Bar]

        """
        cdef list[Bar] output = []

        for pyo3_bar in pyo3_bars:
            output.append(Bar.from_pyo3_c(pyo3_bar))

        return output

    @staticmethod
    def from_pyo3(pyo3_bar) -> Bar:
        """
        Return a legacy Cython bar converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_bar : nautilus_pyo3.Bar
            The pyo3 Rust bar to convert from.

        Returns
        -------
        Bar

        """
        return Bar.from_pyo3_c(pyo3_bar)

    def to_pyo3(self) -> nautilus_pyo3.Bar:
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.Bar

        """
        return nautilus_pyo3.Bar(
            nautilus_pyo3.BarType.from_str(BarType.from_mem_c(self._mem.bar_type).to_str()),
            nautilus_pyo3.Price.from_raw(self._mem.open.raw, self._mem.open.precision),
            nautilus_pyo3.Price.from_raw(self._mem.high.raw, self._mem.high.precision),
            nautilus_pyo3.Price.from_raw(self._mem.low.raw, self._mem.low.precision),
            nautilus_pyo3.Price.from_raw(self._mem.close.raw, self._mem.close.precision),
            nautilus_pyo3.Quantity.from_raw(self._mem.volume.raw, self._mem.volume.precision),
            self._mem.ts_event,
            self._mem.ts_init,
        )

    cpdef bint is_single_price(self):
        """
        If the OHLC are all equal to a single price.

        Returns
        -------
        bool

        """
        return self._mem.open.raw == self._mem.high.raw == self._mem.low.raw == self._mem.close.raw


cdef class DataType:
    """
    Represents a data type including metadata.

    Parameters
    ----------
    type : type
        The `Data` type of the data.
    metadata : dict
        The data types metadata.

    Raises
    ------
    ValueError
        If `type` is not either a subclass of `Data` or meets the `Data` contract.
    TypeError
        If `metadata` contains a key or value which is not hashable.

    Warnings
    --------
    This class may be used as a key in hash maps throughout the system, thus
    the key and value contents of metadata must themselves be hashable.

    """

    def __init__(self, type type not None, dict metadata = None) -> None:  # noqa (shadows built-in type)
        if not issubclass(type, Data):
            if not (hasattr(type, "ts_event") and hasattr(type, "ts_init")):
                raise TypeError("`type` was not a subclass of `Data`")

        self.type = type
        self.metadata = metadata or {}
        self.topic = self.type.__name__ + '.' + '.'.join([
            f'{k}={v if v is not None else "*"}' for k, v in self.metadata.items()
        ]) if self.metadata else self.type.__name__ + "*"

        self._key = frozenset(self.metadata.items())
        self._hash = hash((self.type, self._key))  # Assign hash for improved time complexity

    def __eq__(self, DataType other) -> bool:
        if other is None:
            return False
        return self.type == other.type and self._key == other._key  # noqa

    def __lt__(self, DataType other) -> bool:
        return str(self) < str(other)

    def __le__(self, DataType other) -> bool:
        return str(self) <= str(other)

    def __gt__(self, DataType other) -> bool:
        return str(self) > str(other)

    def __ge__(self, DataType other) -> bool:
        return str(self) >= str(other)

    def __hash__(self) -> int:
        return self._hash

    def __str__(self) -> str:
        return f"{self.type.__name__}{self.metadata if self.metadata else ''}"

    def __repr__(self) -> str:
        return f"{type(self).__name__}(type={self.type.__name__}, metadata={self.metadata})"


cdef class CustomData(Data):
    """
    Provides a wrapper for custom data which includes data type information.

    Parameters
    ----------
    data_type : DataType
        The data type.
    data : Data
        The data object to wrap.

    """

    def __init__(
        self,
        DataType data_type not None,
        Data data not None,
    ) -> None:
        self.data_type = data_type
        self.data = data

    def __repr__(self) -> str:
        return f"{type(self).__name__}(data_type={self.data_type}, data={self.data})"

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self.data.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self.data.ts_init


# Represents a 'NULL' order (used for 'CLEAR' actions by OrderBookDelta)
NULL_ORDER = BookOrder(
    side=OrderSide.NO_ORDER_SIDE,
    price=Price(0, 0),
    size=Quantity(0, 0),
    order_id=0,
)


cdef class BookOrder:
    """
    Represents an order in a book.

    Parameters
    ----------
    side : OrderSide {``BUY``, ``SELL``}
        The order side.
    price : Price
        The order price.
    size : Quantity
        The order size.
    order_id : uint64_t
        The order ID.

    """

    def __init__(
        self,
        OrderSide side,
        Price price not None,
        Quantity size not None,
        uint64_t order_id,
    ) -> None:
        self._mem = book_order_new(
            side,
            price._mem,
            size._mem,
            order_id,
        )

    def __getstate__(self):
        return (
            self._mem.side,
            self._mem.price.raw,
            self._mem.price.precision,
            self._mem.size.raw,
            self._mem.size.precision,
            self._mem.order_id,
        )

    def __setstate__(self, state):
        cdef Price_t price = price_new(state[1], state[2])
        cdef Quantity_t size = quantity_new(state[3], state[4])
        self._mem = book_order_new(
            state[0],
            price,
            size,
            state[5],
        )

    def __eq__(self, BookOrder other) -> bool:
        if other is None:
            return False
        return book_order_eq(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return book_order_hash(&self._mem)

    def __repr__(self) -> str:
        return cstr_to_pystr(book_order_debug_to_cstr(&self._mem))

    @staticmethod
    cdef BookOrder from_raw_c(
        OrderSide side,
        PriceRaw price_raw,
        uint8_t price_prec,
        QuantityRaw size_raw,
        uint8_t size_prec,
        uint64_t order_id,
    ):
        cdef Price_t price = price_new(price_raw, price_prec)
        cdef Quantity_t size = quantity_new(size_raw, size_prec)
        cdef BookOrder order = BookOrder.__new__(BookOrder)
        order._mem = book_order_new(
            side,
            price,
            size,
            order_id,
        )
        return order

    @property
    def price(self) -> Price:
        """
        Return the book orders price.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.price.raw, self._mem.price.precision)

    @property
    def size(self) -> Quantity:
        """
        Return the book orders size.

        Returns
        -------
        Quantity

        """
        return Quantity.from_raw_c(self._mem.size.raw, self._mem.size.precision)

    @property
    def side(self) -> OrderSide:
        """
        Return the book orders side.

        Returns
        -------
        OrderSide

        """
        return <OrderSide>self._mem.side

    @property
    def order_id(self) -> uint64_t:
        """
        Return the book orders side.

        Returns
        -------
        uint64_t

        """
        return self._mem.order_id

    @staticmethod
    cdef BookOrder from_mem_c(BookOrder_t mem):
        return order_from_mem_c(mem)

    cpdef double exposure(self):
        """
        Return the total exposure for this order (price * size).

        Returns
        -------
        double

        """
        return book_order_exposure(&self._mem)

    cpdef double signed_size(self):
        """
        Return the signed size of the order (negative for ``SELL``).

        Returns
        -------
        double

        """
        return book_order_signed_size(&self._mem)

    @staticmethod
    def from_raw(
        OrderSide side,
        PriceRaw price_raw,
        uint8_t price_prec,
        QuantityRaw size_raw,
        uint8_t size_prec,
        uint64_t order_id,
    ) -> BookOrder:
        """
        Return an book order from the given raw values.

        Parameters
        ----------
        side : OrderSide {``BUY``, ``SELL``}
            The order side.
        price_raw : int
            The order raw price (as a scaled fixed-point integer).
        price_prec : uint8_t
            The order price precision.
        size_raw : int
            The order raw size (as a scaled fixed-point integer).
        size_prec : uint8_t
            The order size precision.
        order_id : uint64_t
            The order ID.

        Returns
        -------
        BookOrder

        """
        return BookOrder.from_raw_c(
            side,
            price_raw,
            price_prec,
            size_raw,
            size_prec,
            order_id,
        )

    @staticmethod
    cdef BookOrder from_dict_c(dict values):
        Condition.not_none(values, "values")
        return BookOrder(
            side=order_side_from_str(values["side"]),
            price=Price.from_str(values["price"]),
            size=Quantity.from_str(values["size"]),
            order_id=values["order_id"],
        )

    @staticmethod
    cdef dict to_dict_c(BookOrder obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "BookOrder",
            "side": order_side_to_str(obj.side),
            "price": str(obj.price),
            "size": str(obj.size),
            "order_id": obj.order_id,
        }

    @staticmethod
    def from_dict(dict values) -> BookOrder:
        """
        Return an order from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        BookOrder

        """
        return BookOrder.from_dict_c(values)

    @staticmethod
    def to_dict(BookOrder obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return BookOrder.to_dict_c(obj)


cdef class OrderBookDelta(Data):
    """
    Represents a single update/difference on an `OrderBook`.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the book.
    action : BookAction {``ADD``, ``UPDATE``, ``DELETE``, ``CLEAR``}
        The order book delta action.
    order : BookOrder or ``None``
        The book order for the delta.
    flags : uint8_t
        The record flags bit field, indicating event end and data information.
        A value of zero indicates no flags.
    sequence : uint64_t
        The unique sequence number for the update.
        If no sequence number provided in the source data then use a value of zero.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.

    Raises
    ------
    ValueError
        If `action` is `ADD` or `UPDATE` and `order.size` is not positive (> 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        BookAction action,
        BookOrder order: BookOrder | None,
        uint8_t flags,
        uint64_t sequence,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        # Placeholder for now
        cdef BookOrder_t book_order = order._mem if order is not None else book_order_new(
            OrderSide.NO_ORDER_SIDE,
            price_new(0, 0),
            quantity_new(0, 0),
            0,
        )

        if action == BookAction.ADD or action == BookAction.UPDATE:
            Condition.positive_int(book_order.size.raw, "size")

        self._mem = orderbook_delta_new(
            instrument_id._mem,
            action,
            book_order,
            flags,
            sequence,
            ts_event,
            ts_init,
        )

    def __getstate__(self):
        return (
            self.instrument_id.value,
            self._mem.action,
            self._mem.order.side,
            self._mem.order.price.raw,
            self._mem.order.price.precision,
            self._mem.order.size.raw,
            self._mem.order.size.precision,
            self._mem.order.order_id,
            self._mem.flags,
            self._mem.sequence,
            self._mem.ts_event,
            self._mem.ts_init,
        )

    def __setstate__(self, state):
        cdef BookAction action = state[1]
        cdef Price_t price = price_new(state[3], state[4])
        cdef Quantity_t size = quantity_new(state[5], state[6])

        if action == BookAction.ADD or action == BookAction.UPDATE:
            Condition.positive_int(size.raw, "size")

        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
        cdef BookOrder_t book_order = book_order_new(
            state[2],
            price,
            size,
            state[7],
        )
        self._mem = orderbook_delta_new(
            instrument_id._mem,
            action,
            book_order,
            state[8],
            state[9],
            state[10],
            state[11],
        )

    def __eq__(self, OrderBookDelta other) -> bool:
        if other is None:
            return False
        return orderbook_delta_eq(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return orderbook_delta_hash(&self._mem)

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"action={book_action_to_str(self.action)}, "
            f"order={self.order}, "
            f"flags={self._mem.flags}, "
            f"sequence={self._mem.sequence}, "
            f"ts_event={self._mem.ts_event}, "
            f"ts_init={self._mem.ts_init})"
        )

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the deltas book instrument ID.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def action(self) -> BookAction:
        """
        Return the deltas book action {``ADD``, ``UPDATE``, ``DELETE``, ``CLEAR``}

        Returns
        -------
        BookAction

        """
        return <BookAction>self._mem.action

    @property
    def is_add(self) -> BookAction:
        """
        If the deltas book action is an ``ADD``.

        Returns
        -------
        bool

        """
        return <BookAction>self._mem.action == BookAction.ADD

    @property
    def is_update(self) -> BookAction:
        """
        If the deltas book action is an ``UPDATE``.

        Returns
        -------
        bool

        """
        return <BookAction>self._mem.action == BookAction.UPDATE

    @property
    def is_delete(self) -> BookAction:
        """
        If the deltas book action is a ``DELETE``.

        Returns
        -------
        bool

        """
        return <BookAction>self._mem.action == BookAction.DELETE

    @property
    def is_clear(self) -> BookAction:
        """
        If the deltas book action is a ``CLEAR``.

        Returns
        -------
        bool

        """
        return <BookAction>self._mem.action == BookAction.CLEAR

    @property
    def order(self) -> BookOrder | None:
        """
        Return the deltas book order for the action.

        Returns
        -------
        BookOrder

        """
        cdef BookOrder_t order = self._mem.order
        if order is None:
            return None
        return order_from_mem_c(order)

    @property
    def flags(self) -> uint8_t:
        """
        Return the flags for the delta.

        Returns
        -------
        uint8_t

        """
        return self._mem.flags

    @property
    def sequence(self) -> uint64_t:
        """
        Return the sequence number for the delta.

        Returns
        -------
        uint64_t

        """
        return self._mem.sequence

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef OrderBookDelta from_raw_c(
        InstrumentId instrument_id,
        BookAction action,
        OrderSide side,
        PriceRaw price_raw,
        uint8_t price_prec,
        QuantityRaw size_raw,
        uint8_t size_prec,
        uint64_t order_id,
        uint8_t flags,
        uint64_t sequence,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        cdef Price_t price = price_new(price_raw, price_prec)
        cdef Quantity_t size = quantity_new(size_raw, size_prec)
        cdef BookOrder_t book_order = book_order_new(
            side,
            price,
            size,
            order_id,
        )

        if action == BookAction.ADD or action == BookAction.UPDATE:
            Condition.positive_int(size_raw, "size_raw")

        cdef OrderBookDelta delta = OrderBookDelta.__new__(OrderBookDelta)
        delta._mem = orderbook_delta_new(
            instrument_id._mem,
            action,
            book_order,
            flags,
            sequence,
            ts_event,
            ts_init,
        )
        return delta

    @staticmethod
    cdef OrderBookDelta from_mem_c(OrderBookDelta_t mem):
        return delta_from_mem_c(mem)

    @staticmethod
    cdef OrderBookDelta from_pyo3_c(pyo3_delta):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        capsule = pyo3_delta.as_pycapsule()
        cdef Data_t* ptr = <Data_t*>PyCapsule_GetPointer(capsule, NULL)
        if ptr == NULL:
            raise ValueError("Invalid Data_t PyCapsule (NULL)")

        # Validate the tag to prevent segfault
        if ptr.tag != Data_t_Tag.DELTA:
            raise ValueError(f"Invalid Data_t tag: expected DELTA, was {data_tag_to_str(ptr.tag)}")

        return delta_from_mem_c(ptr.delta)

    @staticmethod
    cdef OrderBookDelta from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef BookAction action = book_action_from_str(values["action"])
        cdef BookOrder order = BookOrder.from_dict_c(values["order"])
        return OrderBookDelta(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            action=action,
            order=order,
            flags=values["flags"],
            sequence=values["sequence"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(OrderBookDelta obj):
        Condition.not_none(obj, "obj")
        cdef BookOrder order = obj.order
        return {
            "type": "OrderBookDelta",
            "instrument_id": obj.instrument_id.value,
            "action": book_action_to_str(obj._mem.action),
            "order": {
                "side": order_side_to_str(order._mem.side),
                "price": str(order.price),
                "size": str(order.size),
                "order_id": order._mem.order_id,
            },
            "flags": obj._mem.flags,
            "sequence": obj._mem.sequence,
            "ts_event": obj._mem.ts_event,
            "ts_init": obj._mem.ts_init,
        }

    @staticmethod
    cdef OrderBookDelta clear_c(
        InstrumentId instrument_id,
        uint64_t sequence,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        return OrderBookDelta(
            instrument_id=instrument_id,
            action=BookAction.CLEAR,
            order=None,
            flags=0,
            sequence=sequence,
            ts_event=ts_event,
            ts_init=ts_init,
        )

    @staticmethod
    cdef list[OrderBookDelta] capsule_to_list_c(object capsule):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
        cdef OrderBookDelta_t* ptr = <OrderBookDelta_t*>data.ptr
        cdef list[OrderBookDelta] deltas = []

        cdef uint64_t i
        for i in range(0, data.len):
            deltas.append(delta_from_mem_c(ptr[i]))

        return deltas

    @staticmethod
    cdef object list_to_capsule_c(list items):
        # Create a C struct buffer
        cdef uint64_t len_ = len(items)
        cdef OrderBookDelta_t *data = <OrderBookDelta_t *>PyMem_Malloc(len_ * sizeof(OrderBookDelta_t))
        cdef uint64_t i
        for i in range(len_):
            data[i] = (<OrderBookDelta>items[i])._mem
        if not data:
            raise MemoryError()

        # Create CVec
        cdef CVec *cvec = <CVec *>PyMem_Malloc(1 * sizeof(CVec))
        cvec.ptr = data
        cvec.len = len_
        cvec.cap = len_

        # Create PyCapsule
        return PyCapsule_New(cvec, NULL, <PyCapsule_Destructor>capsule_destructor)

    @staticmethod
    def list_from_capsule(capsule) -> list[OrderBookDelta]:
        return OrderBookDelta.capsule_to_list_c(capsule)

    @staticmethod
    def capsule_from_list(list items):
        return OrderBookDelta.list_to_capsule_c(items)

    @staticmethod
    def from_raw(
        InstrumentId instrument_id,
        BookAction action,
        OrderSide side,
        PriceRaw price_raw,
        uint8_t price_prec,
        QuantityRaw size_raw,
        uint8_t size_prec,
        uint64_t order_id,
        uint8_t flags,
        uint64_t sequence,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> OrderBookDelta:
        """
        Return an order book delta from the given raw values.

        Parameters
        ----------
        instrument_id : InstrumentId
            The trade instrument ID.
        action : BookAction {``ADD``, ``UPDATE``, ``DELETE``, ``CLEAR``}
            The order book delta action.
        side : OrderSide {``BUY``, ``SELL``}
            The order side.
        price_raw : int
            The order raw price (as a scaled fixed-point integer).
        price_prec : uint8_t
            The order price precision.
        size_raw : int
            The order raw size (as a scaled fixed-point integer).
        size_prec : uint8_t
            The order size precision.
        order_id : uint64_t
            The order ID.
        flags : uint8_t
            The record flags bit field, indicating event end and data information.
            A value of zero indicates no flags.
        sequence : uint64_t
            The unique sequence number for the update.
            If no sequence number provided in the source data then use a value of zero.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the tick event occurred.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the data object was initialized.

        Returns
        -------
        OrderBookDelta

        """
        return OrderBookDelta.from_raw_c(
            instrument_id,
            action,
            side,
            price_raw,
            price_prec,
            size_raw,
            size_prec,
            order_id,
            flags,
            sequence,
            ts_event,
            ts_init,
        )

    @staticmethod
    def from_dict(dict values) -> OrderBookDelta:
        """
        Return an order book delta from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderBookDelta

        """
        return OrderBookDelta.from_dict_c(values)

    @staticmethod
    def to_dict(OrderBookDelta obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderBookDelta.to_dict_c(obj)

    @staticmethod
    def clear(InstrumentId instrument_id, uint64_t sequence, uint64_t ts_event, uint64_t ts_init):
        """
        Return an order book delta which acts as an initial ``CLEAR``.

        Returns
        -------
        OrderBookDelta

        """
        return OrderBookDelta.clear_c(instrument_id, sequence, ts_event, ts_init)


    @staticmethod
    def to_pyo3_list(list[OrderBookDelta] deltas) -> list[nautilus_pyo3.OrderBookDelta]:
        """
        Return pyo3 Rust order book deltas converted from the given legacy Cython objects.

        Parameters
        ----------
        pyo3_deltas : list[OrderBookDelta]
            The pyo3 Rust order book deltas to convert from.

        Returns
        -------
        list[nautilus_pyo3.OrderBookDelta]

        """
        cdef list output = []

        pyo3_instrument_id = None
        cdef uint8_t price_prec = 0
        cdef uint8_t size_prec = 0

        cdef:
            OrderBookDelta delta
            BookOrder book_order
        for delta in deltas:
            if pyo3_instrument_id is None:
                pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(delta.instrument_id.value)
            if price_prec == 0:
                price_prec = delta._mem.order.price.precision
            if size_prec == 0:
                size_prec = delta._mem.order.size.precision

            pyo3_book_order = nautilus_pyo3.BookOrder(
               nautilus_pyo3.OrderSide(order_side_to_str(delta._mem.order.side)),
               nautilus_pyo3.Price.from_raw(delta._mem.order.price.raw, price_prec),
               nautilus_pyo3.Quantity.from_raw(delta._mem.order.size.raw, size_prec),
               delta._mem.order.order_id,
            )

            pyo3_delta = nautilus_pyo3.OrderBookDelta(
                pyo3_instrument_id,
                nautilus_pyo3.BookAction(book_action_to_str(delta._mem.action)),
                pyo3_book_order,
                delta._mem.flags,
                delta._mem.sequence,
                delta._mem.ts_event,
                delta._mem.ts_init,
            )
            output.append(pyo3_delta)

        return output

    @staticmethod
    def from_pyo3(pyo3_delta) -> OrderBookDelta:
        """
        Return a legacy Cython order book delta converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_delta : nautilus_pyo3.OrderBookDelta
            The pyo3 Rust order book delta to convert from.

        Returns
        -------
        OrderBookDelta

        """
        return OrderBookDelta.from_pyo3_c(pyo3_delta)

    @staticmethod
    def from_pyo3_list(list pyo3_deltas) -> list[OrderBookDelta]:
        """
        Return legacy Cython order book deltas converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_deltas : list[nautilus_pyo3.OrderBookDelta]
            The pyo3 Rust order book deltas to convert from.

        Returns
        -------
        list[OrderBookDelta]

        """
        cdef list[OrderBookDelta] output = []

        for pyo3_delta in pyo3_deltas:
            output.append(OrderBookDelta.from_pyo3_c(pyo3_delta))

        return output


cdef class OrderBookDeltas(Data):
    """
    Represents a batch of `OrderBookDelta` updates for an `OrderBook`.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the book.
    deltas : list[OrderBookDelta]
        The batch of order book changes.

    Raises
    ------
    ValueError
        If `deltas` is an empty list.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        list deltas not None,
    ) -> None:
        Condition.not_empty(deltas, "deltas")

        cdef uint64_t len_ = len(deltas)

        # Create a C OrderBookDeltas_t buffer
        cdef OrderBookDelta_t *data = <OrderBookDelta_t *>PyMem_Malloc(len_ * sizeof(OrderBookDelta_t))
        if not data:
            raise MemoryError()

        cdef uint64_t i
        cdef OrderBookDelta delta
        for i in range(len_):
            delta = deltas[i]
            data[i] = <OrderBookDelta_t>delta._mem

        # Create CVec
        cdef CVec *cvec = <CVec *>PyMem_Malloc(1 * sizeof(CVec))
        if not cvec:
            raise MemoryError()

        cvec.ptr = data
        cvec.len = len_
        cvec.cap = len_

        # Transfer data to Rust
        self._mem = orderbook_deltas_new(
            instrument_id._mem,
            cvec,
        )

        PyMem_Free(cvec.ptr) # De-allocate buffer
        PyMem_Free(cvec) # De-allocate cvec

    def __getstate__(self):
        return (
            self.instrument_id.value,
            pickle.dumps(self.deltas),
        )

    def __setstate__(self, state):
        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])

        cdef list deltas = pickle.loads(state[1])

        cdef uint64_t len_ = len(deltas)

        # Create a C OrderBookDeltas_t buffer
        cdef OrderBookDelta_t *data = <OrderBookDelta_t *>PyMem_Malloc(len_ * sizeof(OrderBookDelta_t))
        if not data:
            raise MemoryError()

        cdef uint64_t i
        cdef OrderBookDelta delta
        for i in range(len_):
            delta = deltas[i]
            data[i] = <OrderBookDelta_t>delta._mem

        # Create CVec
        cdef CVec *cvec = <CVec *>PyMem_Malloc(1 * sizeof(CVec))
        if not cvec:
            raise MemoryError()

        cvec.ptr = data
        cvec.len = len_
        cvec.cap = len_

        # Transfer data to Rust
        self._mem = orderbook_deltas_new(
            instrument_id._mem,
            cvec,
        )

        PyMem_Free(cvec.ptr) # De-allocate buffer
        PyMem_Free(cvec) # De-allocate cvec

    def __del__(self) -> None:
        if self._mem._0 != NULL:
            orderbook_deltas_drop(self._mem)

    def __eq__(self, OrderBookDeltas other) -> bool:
        if other is None:
            return False
        return OrderBookDeltas.to_dict_c(self) == OrderBookDeltas.to_dict_c(other)

    def __hash__(self) -> int:
        return hash(frozenset(OrderBookDeltas.to_dict_c(self)))

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"{self.deltas}, "
            f"is_snapshot={self.is_snapshot}, "
            f"sequence={self.sequence}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the deltas book instrument ID.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(orderbook_deltas_instrument_id(&self._mem))

    @property
    def deltas(self) -> list[OrderBookDelta]:
        """
        Return the contained deltas.

        Returns
        -------
        list[OrderBookDeltas]

        """
        cdef CVec raw_deltas_vec = orderbook_deltas_vec_deltas(&self._mem)
        cdef OrderBookDelta_t* raw_deltas = <OrderBookDelta_t*>raw_deltas_vec.ptr

        cdef list[OrderBookDelta] deltas = []

        cdef:
            uint64_t i
        for i in range(raw_deltas_vec.len):
            deltas.append(delta_from_mem_c(raw_deltas[i]))

        orderbook_deltas_vec_drop(raw_deltas_vec)

        return deltas

    @property
    def is_snapshot(self) -> bool:
        """
        If the deltas is a snapshot.

        Returns
        -------
        bool

        """
        return <bint>orderbook_deltas_is_snapshot(&self._mem)

    @property
    def flags(self) -> uint8_t:
        """
        Return the flags for the last delta.

        Returns
        -------
        uint8_t

        """
        return orderbook_deltas_flags(&self._mem)

    @property
    def sequence(self) -> uint64_t:
        """
        Return the sequence number for the last delta.

        Returns
        -------
        uint64_t

        """
        return orderbook_deltas_sequence(&self._mem)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return orderbook_deltas_ts_event(&self._mem)

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return orderbook_deltas_ts_init(&self._mem)

    @staticmethod
    cdef OrderBookDeltas from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OrderBookDeltas(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            deltas=[OrderBookDelta.from_dict_c(d) for d in values["deltas"]],
        )

    @staticmethod
    cdef dict to_dict_c(OrderBookDeltas obj):
        Condition.not_none(obj, "obj")
        return {
            "type": obj.__class__.__name__,
            "instrument_id": obj.instrument_id.value,
            "deltas": [OrderBookDelta.to_dict_c(d) for d in obj.deltas],
        }

    @staticmethod
    def from_dict(dict values) -> OrderBookDeltas:
        """
        Return order book deltas from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderBookDeltas

        """
        return OrderBookDeltas.from_dict_c(values)

    @staticmethod
    def to_dict(OrderBookDeltas obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderBookDeltas.to_dict_c(obj)

    @staticmethod
    def batch(list data: list[OrderBookDelta]) -> list[OrderBookDeltas]:
        """
        Groups the given list of `OrderBookDelta` records into batches, creating `OrderBookDeltas`
        objects when an `F_LAST` flag is encountered.

        The method iterates through the `data` list and appends each `OrderBookDelta` to the current
        batch. When an `F_LAST` flag is found, it indicates the end of a batch. The batch is then
        appended to the list of completed batches and a new batch is started.

        Returns
        -------
        list[OrderBookDeltas]

        Raises
        ------
        ValueError
            If `data` is empty.
        TypeError
            If `data` is not a list of `OrderBookDelta`.

        Warnings
        --------
        UserWarning
            If there are remaining deltas in the final batch after the last `F_LAST` flag.

        """
        Condition.not_empty(data, "data")
        cdef OrderBookDelta first = data[0]

        cdef InstrumentId instrument_id = first.instrument_id
        cdef list[list[OrderBookDelta]] batches = []
        cdef list[OrderBookDelta] batch = []

        cdef:
            OrderBookDelta delta
        for delta in data:
            batch.append(delta)
            if delta.flags == RecordFlag.F_LAST:
                batches.append(batch)
                batch = []

        cdef list[OrderBookDeltas] deltas = [OrderBookDeltas(instrument_id, deltas=batch) for batch in batches]

        if batch:
            warnings.warn(
                f"Batched {len(batches):_} `OrderBookDeltas`, but found {len(batch):_} remaining deltas "
                "without an 'F_LAST' flag. This can indicate incomplete data processing, as deltas "
                "should typically end with an 'F_LAST' flag to signal the end of a batch. If using streaming, "
                "this warning can occur if the last chunk did not include a final 'F_LAST' delta.",
                UserWarning,
            )
            deltas.append(OrderBookDeltas(instrument_id, deltas=batch))

        return deltas

    cpdef to_capsule(self):
        cdef OrderBookDeltas_API *data = <OrderBookDeltas_API *>PyMem_Malloc(sizeof(OrderBookDeltas_API))
        data[0] = self._mem
        capsule = PyCapsule_New(data, NULL, <PyCapsule_Destructor>capsule_destructor_deltas)
        return capsule

    cpdef to_pyo3(self):
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.OrderBookDeltas

        """
        capsule = self.to_capsule()
        deltas = nautilus_pyo3.OrderBookDeltas.from_pycapsule(capsule)
        return deltas



cdef class OrderBookDepth10(Data):
    """
    Represents a self-contained order book update with a fixed depth of 10 levels per side.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the book.
    bids : list[BookOrder]
        The bid side orders for the update.
    asks : list[BookOrder]
        The ask side orders for the update.
    bid_counts : list[uint32_t]
        The count of bid orders per level for the update. Can be zeros if data not available.
    ask_counts : list[uint32_t]
        The count of ask orders per level for the update. Can be zeros if data not available.
    flags : uint8_t
        The record flags bit field, indicating event end and data information.
        A value of zero indicates no flags.
    sequence : uint64_t
        The unique sequence number for the update.
        If no sequence number provided in the source data then use a value of zero.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the tick event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.

    Raises
    ------
    ValueError
        If `bids`, `asks`, `bid_counts`, `ask_counts` lengths are greater than 10.
    ValueError
        If `bids`, `asks`, `bid_counts`, `ask_counts` lengths are not equal.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        list bids not None,
        list asks not None,
        list bid_counts not None,
        list ask_counts not None,
        uint8_t flags,
        uint64_t sequence,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        cdef uint32_t bids_len = len(bids)
        cdef uint32_t asks_len = len(asks)
        Condition.is_true(bids_len <= 10, f"bids length greater than maximum 10, was {bids_len}")
        Condition.is_true(asks_len <= 10, f"asks length greater than maximum 10, was {asks_len}")
        Condition.equal(bids_len, asks_len, "bids length", "asks length")
        Condition.equal(bids_len, len(bid_counts), "len(bids)", "len(bid_counts)")
        Condition.equal(asks_len, len(ask_counts), "len(asks)", "len(ask_counts)")

        if bids_len < 10:
            # Fill remaining levels with with null orders and zero counts
            bids.extend([NULL_ORDER] * (10 - bids_len))
            asks.extend([NULL_ORDER] * (10 - asks_len))
            bid_counts.extend([0] * (10 - bids_len))
            ask_counts.extend([0] * (10 - asks_len))

        # Create temporary arrays to copy data to Rust
        cdef BookOrder_t *bids_array = <BookOrder_t *>PyMem_Malloc(DEPTH10_LEN * sizeof(BookOrder_t))
        cdef BookOrder_t *asks_array = <BookOrder_t *>PyMem_Malloc(DEPTH10_LEN * sizeof(BookOrder_t))
        cdef uint32_t *bid_counts_array = <uint32_t *>PyMem_Malloc(DEPTH10_LEN * sizeof(uint32_t))
        cdef uint32_t *ask_counts_array = <uint32_t *>PyMem_Malloc(DEPTH10_LEN * sizeof(uint32_t))
        if bids_array == NULL or asks_array == NULL or bid_counts_array == NULL or ask_counts_array == NULL:
            raise MemoryError("Failed to allocate memory for data transfer array")

        cdef uint64_t i
        cdef BookOrder order
        try:
            for i in range(DEPTH10_LEN):
                order = bids[i]
                bids_array[i] = <BookOrder_t>order._mem
                bid_counts_array[i] = bid_counts[i]
                order = asks[i]
                asks_array[i] = <BookOrder_t>order._mem
                ask_counts_array[i] = ask_counts[i]

            self._mem = orderbook_depth10_new(
                instrument_id._mem,
                bids_array,
                asks_array,
                bid_counts_array,
                ask_counts_array,
                flags,
                sequence,
                ts_event,
                ts_init,
            )
        finally:
            # Deallocate temporary data transfer arrays
            PyMem_Free(bids_array)
            PyMem_Free(asks_array)
            PyMem_Free(bid_counts_array)
            PyMem_Free(ask_counts_array)

    def __getstate__(self):
        return (
            self.instrument_id.value,
            pickle.dumps(self.bids),
            pickle.dumps(self.asks),
            pickle.dumps(self.bid_counts),
            pickle.dumps(self.ask_counts),
            self._mem.flags,
            self._mem.sequence,
            self._mem.ts_event,
            self._mem.ts_init,
        )

    def __setstate__(self, state):
        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])

        # Create temporary arrays to copy data to Rust
        cdef BookOrder_t *bids_array = <BookOrder_t *>PyMem_Malloc(DEPTH10_LEN * sizeof(BookOrder_t))
        cdef BookOrder_t *asks_array = <BookOrder_t *>PyMem_Malloc(DEPTH10_LEN * sizeof(BookOrder_t))
        cdef uint32_t *bid_counts_array = <uint32_t *>PyMem_Malloc(DEPTH10_LEN * sizeof(uint32_t))
        cdef uint32_t *ask_counts_array = <uint32_t *>PyMem_Malloc(DEPTH10_LEN * sizeof(uint32_t))
        if bids_array == NULL or asks_array == NULL or bid_counts_array == NULL or ask_counts_array == NULL:
            raise MemoryError("Failed to allocate memory for data transfer array")

        cdef list[BookOrder] bids = pickle.loads(state[1])
        cdef list[BookOrder] asks = pickle.loads(state[2])
        cdef list[uint32_t] bid_counts = pickle.loads(state[3])
        cdef list[uint32_t] ask_counts = pickle.loads(state[4])

        cdef uint64_t i
        cdef BookOrder order
        try:
            for i in range(DEPTH10_LEN):
                order = bids[i]
                bids_array[i] = <BookOrder_t>order._mem
                bid_counts_array[i] = bid_counts[i]
                order = asks[i]
                asks_array[i] = <BookOrder_t>order._mem
                ask_counts_array[i] = ask_counts[i]

            self._mem = orderbook_depth10_new(
                instrument_id._mem,
                bids_array,
                asks_array,
                bid_counts_array,
                ask_counts_array,
                state[5],
                state[6],
                state[7],
                state[8],
            )
        finally:
            # Deallocate temporary data transfer arrays
            PyMem_Free(bids_array)
            PyMem_Free(asks_array)
            PyMem_Free(bid_counts_array)
            PyMem_Free(ask_counts_array)

    def __eq__(self, OrderBookDepth10 other) -> bool:
        if other is None:
            return False
        return orderbook_depth10_eq(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return orderbook_depth10_hash(&self._mem)

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"bids={self.bids}, "
            f"asks={self.asks}, "
            f"bid_counts={self.bid_counts}, "
            f"ask_counts={self.ask_counts}, "
            f"flags={self.flags}, "
            f"sequence={self.sequence}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the depth updates book instrument ID.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def bids(self) -> list[BookOrder]:
        """
        Return the bid orders for the update.

        Returns
        -------
        list[BookOrder]

        """
        cdef const BookOrder_t* bids_array = orderbook_depth10_bids_array(&self._mem)
        cdef list[BookOrder] bids = [];

        cdef uint64_t i
        cdef BookOrder order
        for i in range(DEPTH10_LEN):
            order = order_from_mem_c(bids_array[i])
            bids.append(order)

        return bids

    @property
    def asks(self) -> list[BookOrder]:
        """
        Return the ask orders for the update.

        Returns
        -------
        list[BookOrder]

        """
        cdef const BookOrder_t* asks_array = orderbook_depth10_asks_array(&self._mem)
        cdef list[BookOrder] asks = [];

        cdef uint64_t i
        cdef BookOrder order
        for i in range(DEPTH10_LEN):
            order = order_from_mem_c(asks_array[i])
            asks.append(order)

        return asks

    cpdef QuoteTick to_quote_tick(self):
        """
        Return a `QuoteTick` created from the top of book levels.

        Returns ``None`` when the top-of-book bid or ask is missing or invalid
        (NULL order or zero size).

        Returns
        -------
        QuoteTick or ``None``

        """
        cdef list[BookOrder] bids = self.bids
        cdef list[BookOrder] asks = self.asks

        if not bids or not asks:
            return None

        cdef BookOrder top_bid = bids[0]
        cdef BookOrder top_ask = asks[0]

        if (
            top_bid.side == OrderSide.NO_ORDER_SIDE or
            top_ask.side == OrderSide.NO_ORDER_SIDE or
            top_bid._mem.size.raw == 0 or
            top_ask._mem.size.raw == 0
        ):
            return None

        return QuoteTick(
            instrument_id=self.instrument_id,
            bid_price=top_bid.price,
            ask_price=top_ask.price,
            bid_size=top_bid.size,
            ask_size=top_ask.size,
            ts_event=self.ts_event,
            ts_init=self.ts_init,
        )

    @property
    def bid_counts(self) -> list[uint32_t]:
        """
        Return the count of bid orders per level for the update.

        Returns
        -------
        list[uint32_t]

        """
        cdef const uint32_t* bid_counts_array = orderbook_depth10_bid_counts_array(&self._mem)
        cdef list[uint32_t] bid_counts = [];

        cdef uint64_t i
        for i in range(DEPTH10_LEN):
            bid_counts.append(<uint32_t>bid_counts_array[i])

        return bid_counts

    @property
    def ask_counts(self) -> list[uint32_t]:
        """
        Return the count of ask orders level for the update.

        Returns
        -------
        list[uint32_t]

        """
        cdef const uint32_t* ask_counts_array = orderbook_depth10_ask_counts_array(&self._mem)
        cdef list[uint32_t] ask_counts = [];

        cdef uint64_t i
        for i in range(DEPTH10_LEN):
            ask_counts.append(<uint32_t>ask_counts_array[i])

        return ask_counts

    @property
    def flags(self) -> uint8_t:
        """
        Return the flags for the depth update.

        Returns
        -------
        uint8_t

        """
        return self._mem.flags

    @property
    def sequence(self) -> uint64_t:
        """
        Return the sequence number for the depth update.

        Returns
        -------
        uint64_t

        """
        return self._mem.sequence

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef OrderBookDepth10 from_mem_c(OrderBookDepth10_t mem):
        return depth10_from_mem_c(mem)

    @staticmethod
    cdef OrderBookDepth10 from_pyo3_c(pyo3_depth10):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        capsule = pyo3_depth10.as_pycapsule()
        cdef Data_t* ptr = <Data_t*>PyCapsule_GetPointer(capsule, NULL)
        if ptr == NULL:
            raise ValueError("Invalid Data_t PyCapsule (NULL)")

        # Validate the tag to prevent segfault
        if ptr.tag != Data_t_Tag.DEPTH10:
            raise ValueError(f"Invalid Data_t tag: expected DEPTH10, was {data_tag_to_str(ptr.tag)}")

        return depth10_from_mem_c(orderbook_depth10_clone(ptr.depth10))

    @staticmethod
    cdef OrderBookDepth10 from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OrderBookDepth10(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            bids=[BookOrder.from_dict_c(o) for o in values["bids"]],
            asks=[BookOrder.from_dict_c(o) for o in values["asks"]],
            bid_counts=values["bid_counts"],
            ask_counts=values["ask_counts"],
            flags=values["flags"],
            sequence=values["sequence"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(OrderBookDepth10 obj):
        Condition.not_none(obj, "obj")
        return {
            "type": obj.__class__.__name__,
            "instrument_id": obj.instrument_id.value,
            "bids": [BookOrder.to_dict_c(o) for o in obj.bids],
            "asks": [BookOrder.to_dict_c(o) for o in obj.asks],
            "bid_counts": obj.bid_counts,
            "ask_counts": obj.ask_counts,
            "flags": obj.flags,
            "sequence": obj.sequence,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    cdef list[OrderBookDepth10] capsule_to_list_c(object capsule):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
        cdef OrderBookDepth10_t* ptr = <OrderBookDepth10_t*>data.ptr
        cdef list[OrderBookDepth10] depths = []

        cdef uint64_t i
        for i in range(0, data.len):
            depths.append(depth10_from_mem_c(ptr[i]))

        return depths

    @staticmethod
    cdef object list_to_capsule_c(list items):
        # Create a C struct buffer
        cdef uint64_t len_ = len(items)
        cdef OrderBookDepth10_t * data = <OrderBookDepth10_t *>PyMem_Malloc(len_ * sizeof(OrderBookDepth10_t))
        cdef uint64_t i
        for i in range(len_):
            data[i] = (<OrderBookDepth10>items[i])._mem
        if not data:
            raise MemoryError()

        # Create CVec
        cdef CVec * cvec = <CVec *>PyMem_Malloc(1 * sizeof(CVec))
        cvec.ptr = data
        cvec.len = len_
        cvec.cap = len_

        # Create PyCapsule
        return PyCapsule_New(cvec, NULL, <PyCapsule_Destructor>capsule_destructor)

    @staticmethod
    def list_from_capsule(capsule) -> list[OrderBookDepth10]:
        return OrderBookDepth10.capsule_to_list_c(capsule)

    @staticmethod
    def capsule_from_list(list items):
        return OrderBookDepth10.list_to_capsule_c(items)

    @staticmethod
    def from_dict(dict values) -> OrderBookDepth10:
        """
        Return order book depth from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderBookDepth10

        """
        return OrderBookDepth10.from_dict_c(values)

    @staticmethod
    def to_dict(OrderBookDepth10 obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderBookDepth10.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_depth) -> OrderBookDepth10:
        """
        Return a legacy Cython order book depth converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_depth : nautilus_pyo3.OrderBookDepth10
            The pyo3 Rust order book depth to convert from.

        Returns
        -------
        OrderBookDepth10

        """
        return OrderBookDepth10.from_pyo3_c(pyo3_depth)

    @staticmethod
    def from_pyo3_list(pyo3_depths) -> list[OrderBookDepth10]:
        """
        Return legacy Cython order book depths converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_depths : nautilus_pyo3.OrderBookDepth10
            The pyo3 Rust order book depths to convert from.

        Returns
        -------
        list[OrderBookDepth10]

        """
        cdef list[OrderBookDepth10] output = []

        for pyo3_depth in pyo3_depths:
            output.append(OrderBookDepth10.from_pyo3_c(pyo3_depth))

        return output


cdef class InstrumentStatus(Data):
    """
    Represents an event that indicates a change in an instrument market status.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the status change.
    action : MarketStatusAction
        The instrument market status action.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the status event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reason : str, optional
        Additional details about the cause of the status change.
    trading_event : str, optional
        Further information about the status change (if provided).
    is_trading : bool, optional
        The state of trading in the instrument.
    is_quoting : bool, optional
        The state of quoting in the instrument.
    is_short_sell_restricted : bool, optional
        The state of short sell restrictions for the instrument (if applicable).

    """

    def __init__(
        self,
        InstrumentId instrument_id,
        MarketStatusAction action,
        uint64_t ts_event,
        uint64_t ts_init,
        str reason = None,
        str trading_event = None,
        is_trading: bool | None = None,
        is_quoting: bool | None = None,
        is_short_sell_restricted: bool | None = None,
    ) -> None:
        self.instrument_id = instrument_id
        self.action = action
        self.ts_event = ts_event
        self.ts_init = ts_init
        self.reason = reason
        self.trading_event = trading_event
        self._is_trading = is_trading
        self._is_quoting = is_quoting
        self._is_short_sell_restricted = is_short_sell_restricted

    def __eq__(self, InstrumentStatus other) -> bool:
        if other is None:
            return False
        return InstrumentStatus.to_dict_c(self) == InstrumentStatus.to_dict_c(other)

    def __hash__(self) -> int:
        return hash(frozenset(InstrumentStatus.to_dict_c(self)))

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"action={market_status_action_to_str(self.action)}, "
            f"reason={self.reason}, "
            f"trading_event={self.trading_event}, "
            f"is_trading={self.is_trading}, "
            f"is_quoting={self.is_quoting}, "
            f"is_short_sell_restricted={self.is_short_sell_restricted}, "
            f"ts_event={self.ts_event})"
        )

    @property
    def is_trading(self) -> bool | None:
        """
        Return the state of trading in the instrument (if known).

        returns
        -------
        bool or ``None``

        """
        return self._is_trading

    @property
    def is_quoting(self) -> bool | None:
        """
        Return the state of quoting in the instrument (if known).

        returns
        -------
        bool or ``None``

        """
        return self._is_quoting

    @property
    def is_short_sell_restricted(self) -> bool | None:
        """
        Return the state of short sell restrictions for the instrument (if known and applicable).

        returns
        -------
        bool or ``None``

        """
        return self._is_short_sell_restricted

    @staticmethod
    cdef InstrumentStatus from_dict_c(dict values):
        Condition.not_none(values, "values")
        return InstrumentStatus(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            action=market_status_action_from_str(values["action"]),
            reason=values["reason"],
            trading_event=values["trading_event"],
            is_trading=values["is_trading"],
            is_quoting=values["is_quoting"],
            is_short_sell_restricted=values["is_short_sell_restricted"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(InstrumentStatus obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "InstrumentStatus",
            "instrument_id": obj.instrument_id.to_str(),
            "action": market_status_action_to_str(obj.action),
            "reason": obj.reason,
            "trading_event": obj.trading_event,
            "is_trading": obj.is_trading,
            "is_quoting": obj.is_quoting,
            "is_short_sell_restricted": obj.is_short_sell_restricted,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> InstrumentStatus:
        """
        Return an instrument status update from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        InstrumentStatus

        """
        return InstrumentStatus.from_dict_c(values)

    @staticmethod
    def to_dict(InstrumentStatus obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return InstrumentStatus.to_dict_c(obj)

    @staticmethod
    def from_pyo3_list(list pyo3_status_list) -> list[QuoteTick]:
        """
        Return legacy Cython instrument status converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_status_list : list[nautilus_pyo3.InstrumentStatus]
            The pyo3 Rust instrument status list to convert from.

        Returns
        -------
        list[InstrumentStatus]

        """
        cdef list[InstrumentStatus] output = []

        for pyo3_status in pyo3_status_list:
            output.append(InstrumentStatus.from_pyo3(pyo3_status))

        return output

    @staticmethod
    def from_pyo3(pyo3_status) -> InstrumentStatus:
        """
        Return a legacy Cython quote tick converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_status : nautilus_pyo3.InstrumentStatus
            The pyo3 Rust instrument status to convert from.

        Returns
        -------
        InstrumentStatus

        """
        return InstrumentStatus(
            instrument_id=InstrumentId.from_str(pyo3_status.instrument_id.value),
            action=pyo3_status.action.value,
            ts_event=pyo3_status.ts_event,
            ts_init=pyo3_status.ts_init,
            reason=pyo3_status.reason,
            trading_event=pyo3_status.trading_event,
            is_trading=pyo3_status.is_trading,
            is_quoting=pyo3_status.is_quoting,
            is_short_sell_restricted=pyo3_status.is_short_sell_restricted,
        )

    def to_pyo3(self) -> nautilus_pyo3.InstrumentStatus:
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.InstrumentStatus

        """
        return nautilus_pyo3.InstrumentStatus(
            nautilus_pyo3.InstrumentId.from_str(self.instrument_id.value),
            nautilus_pyo3.MarketStatusAction(market_status_action_to_str(self.action)),
            self.ts_event,
            self.ts_init,
            self.reason,
            self.trading_event,
            self.is_trading,
            self.is_quoting,
            self.is_short_sell_restricted,
        )


cdef class InstrumentClose(Data):
    """
    Represents an instrument close at a venue.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    close_price : Price
        The closing price for the instrument.
    close_type : InstrumentCloseType
        The type of closing price.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the close price event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Price close_price not None,
        InstrumentCloseType close_type,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        self.instrument_id = instrument_id
        self.close_price = close_price
        self.close_type = close_type
        self.ts_event = ts_event
        self.ts_init = ts_init

    def __eq__(self, InstrumentClose other) -> bool:
        if other is None:
            return False
        return InstrumentClose.to_dict_c(self) == InstrumentClose.to_dict_c(other)

    def __hash__(self) -> int:
        return hash(frozenset(InstrumentClose.to_dict_c(self)))

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"close_price={self.close_price}, "
            f"close_type={instrument_close_type_to_str(self.close_type)})"
        )

    @staticmethod
    cdef InstrumentClose from_dict_c(dict values):
        Condition.not_none(values, "values")
        return InstrumentClose(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            close_price=Price.from_str_c(values["close_price"]),
            close_type=instrument_close_type_from_str(values["close_type"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(InstrumentClose obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "InstrumentClose",
            "instrument_id": obj.instrument_id.to_str(),
            "close_price": str(obj.close_price),
            "close_type": instrument_close_type_to_str(obj.close_type),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> InstrumentClose:
        """
        Return an instrument close price event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        InstrumentClose

        """
        return InstrumentClose.from_dict_c(values)

    @staticmethod
    def to_dict(InstrumentClose obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return InstrumentClose.to_dict_c(obj)

    @staticmethod
    def to_pyo3_list(list[InstrumentClose] closes) -> list[nautilus_pyo3.InstrumentClose]:
        """
        Return pyo3 Rust index prices converted from the given legacy Cython objects.

        Parameters
        ----------
        closes : list[InstrumentClose]
            The legacy Cython Rust instrument closes to convert from.

        Returns
        -------
        list[nautilus_pyo3.InstrumentClose]

        """
        cdef list output = []

        pyo3_instrument_id = None
        cdef uint8_t price_prec = 0

        cdef:
            InstrumentClose close
        for close in closes:
            if pyo3_instrument_id is None:
                pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(close.instrument_id.value)
                price_prec = close.close_price.precision

            pyo3_close = nautilus_pyo3.InstrumentClose(
                pyo3_instrument_id,
                nautilus_pyo3.Price(float(close.close_price), price_prec),
                nautilus_pyo3.InstrumentCloseType(instrument_close_type_to_str(close.close_type)),
                close.ts_event,
                close.ts_init,
            )
            output.append(pyo3_close)

        return output

    @staticmethod
    def from_pyo3_list(list pyo3_closes) -> list[InstrumentClose]:
        """
        Return legacy Cython instrument closes converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_closes : list[nautilus_pyo3.InstrumentClose]
            The pyo3 Rust instrument closes to convert from.

        Returns
        -------
        list[InstrumentClose]

        """
        cdef list[InstrumentClose] output = []

        for pyo3_close in pyo3_closes:
            output.append(InstrumentClose.from_pyo3_c(pyo3_close))

        return output

    @staticmethod
    def from_pyo3(pyo3_close) -> InstrumentClose:
        """
        Return a legacy Cython instrument close converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_close : nautilus_pyo3InstrumentClose.
            The pyo3 Rust instrument close to convert from.

        Returns
        -------
        InstrumentClose

        """
        return InstrumentClose(
            instrument_id=InstrumentId.from_str(pyo3_close.instrument_id.value),
            close_price=Price(float(pyo3_close.close_price), pyo3_close.close_price.precision),
            close_type=instrument_close_type_from_str(pyo3_close.close_type.value),
            ts_event=pyo3_close.ts_event,
            ts_init=pyo3_close.ts_init,
        )

    def to_pyo3(self) -> nautilus_pyo3.InstrumentClose:
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.InstrumentClose

        """
        return nautilus_pyo3.InstrumentClose(
            nautilus_pyo3.InstrumentId.from_str(self.instrument_id.value),
            nautilus_pyo3.Price(float(self.close_price), self.close_price.precision),
            nautilus_pyo3.InstrumentCloseType(instrument_close_type_to_str(self.close_type)),
            self.ts_event,
            self.ts_init,
        )


cdef class QuoteTick(Data):
    """
    Represents a single quote tick in a market.

    Contains information about the best top-of-book bid and ask.

    Parameters
    ----------
    instrument_id : InstrumentId
        The quotes instrument ID.
    bid_price : Price
        The top-of-book bid price.
    ask_price : Price
        The top-of-book ask price.
    bid_size : Quantity
        The top-of-book bid size.
    ask_size : Quantity
        The top-of-book ask size.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the tick event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.

    Raises
    ------
    ValueError
        If `bid.precision` != `ask.precision`.
    ValueError
        If `bid_size.precision` != `ask_size.precision`.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Price bid_price not None,
        Price ask_price not None,
        Quantity bid_size not None,
        Quantity ask_size not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        Condition.equal(bid_price._mem.precision, ask_price._mem.precision, "bid_price.precision", "ask_price.precision")
        Condition.equal(bid_size._mem.precision, ask_size._mem.precision, "bid_size.precision", "ask_size.precision")

        self._mem = quote_tick_new(
            instrument_id._mem,
            bid_price._mem,
            ask_price._mem,
            bid_size._mem,
            ask_size._mem,
            ts_event,
            ts_init,
        )

    def __getstate__(self):
        return (
            self.instrument_id.value,
            self._mem.bid_price.raw,
            self._mem.ask_price.raw,
            self._mem.bid_price.precision,
            self._mem.ask_price.precision,
            self._mem.bid_size.raw,
            self._mem.ask_size.raw,
            self._mem.bid_size.precision,
            self._mem.ask_size.precision,
            self.ts_event,
            self.ts_init,
        )

    def __setstate__(self, state):
        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
        cdef Price_t bid_price = price_new(state[1], state[3])
        cdef Price_t ask_price = price_new(state[2], state[4])
        cdef Quantity_t bid_size = quantity_new(state[5], state[7])
        cdef Quantity_t ask_size = quantity_new(state[6], state[8])
        self._mem = quote_tick_new(
            instrument_id._mem,
            bid_price,
            ask_price,
            bid_size,
            ask_size,
            state[9],
            state[10],
        )

    def __eq__(self, QuoteTick other) -> bool:
        if other is None:
            return False
        return quote_tick_eq(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return quote_tick_hash(&self._mem)

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self})"

    cdef str to_str(self):
        return cstr_to_pystr(quote_tick_to_cstr(&self._mem))

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the tick instrument ID.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def bid_price(self) -> Price:
        """
        Return the top-of-book bid price.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.bid_price.raw, self._mem.bid_price.precision)

    @property
    def ask_price(self) -> Price:
        """
        Return the top-of-book ask price.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.ask_price.raw, self._mem.ask_price.precision)

    @property
    def bid_size(self) -> Quantity:
        """
        Return the top-of-book bid size.

        Returns
        -------
        Quantity

        """
        return Quantity.from_raw_c(self._mem.bid_size.raw, self._mem.bid_size.precision)

    @property
    def ask_size(self) -> Quantity:
        """
        Return the top-of-book ask size.

        Returns
        -------
        Quantity

        """
        return Quantity.from_raw_c(self._mem.ask_size.raw, self._mem.ask_size.precision)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef QuoteTick from_mem_c(QuoteTick_t mem):
        return quote_from_mem_c(mem)

    @staticmethod
    cdef QuoteTick from_pyo3_c(pyo3_quote):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        capsule = pyo3_quote.as_pycapsule()
        cdef Data_t* ptr = <Data_t*>PyCapsule_GetPointer(capsule, NULL)
        if ptr == NULL:
            raise ValueError("Invalid Data_t PyCapsule (NULL)")

        # Validate the tag to prevent segfault
        if ptr.tag != Data_t_Tag.QUOTE:
            raise ValueError(f"Invalid Data_t tag: expected QUOTE, was {data_tag_to_str(ptr.tag)}")

        return quote_from_mem_c(ptr.quote)

    @staticmethod
    cdef QuoteTick from_dict_c(dict values):
        Condition.not_none(values, "values")
        return QuoteTick(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            bid_price=Price.from_str_c(values["bid_price"]),
            ask_price=Price.from_str_c(values["ask_price"]),
            bid_size=Quantity.from_str_c(values["bid_size"]),
            ask_size=Quantity.from_str_c(values["ask_size"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(QuoteTick obj):
        Condition.not_none(obj, "obj")
        return {
            "type": type(obj).__name__,
            "instrument_id": str(obj.instrument_id),
            "bid_price": str(obj.bid_price),
            "ask_price": str(obj.ask_price),
            "bid_size": str(obj.bid_size),
            "ask_size": str(obj.ask_size),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    cdef QuoteTick from_raw_c(
        InstrumentId instrument_id,
        PriceRaw bid_price_raw,
        PriceRaw ask_price_raw,
        uint8_t bid_price_prec,
        uint8_t ask_price_prec,
        QuantityRaw bid_size_raw,
        QuantityRaw ask_size_raw,
        uint8_t bid_size_prec,
        uint8_t ask_size_prec,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        cdef Price_t bid_price = price_new(bid_price_raw, bid_price_prec)
        cdef Price_t ask_price = price_new(ask_price_raw, ask_price_prec)
        cdef Quantity_t bid_size = quantity_new(bid_size_raw, bid_size_prec)
        cdef Quantity_t ask_size = quantity_new(ask_size_raw, ask_size_prec)
        cdef QuoteTick quote = QuoteTick.__new__(QuoteTick)
        quote._mem = quote_tick_new(
            instrument_id._mem,
            bid_price,
            ask_price,
            bid_size,
            ask_size,
            ts_event,
            ts_init,
        )
        return quote

    @staticmethod
    cdef list[QuoteTick] from_raw_arrays_to_list_c(
        InstrumentId instrument_id,
        uint8_t price_prec,
        uint8_t size_prec,
        double[:] bid_prices_raw,
        double[:] ask_prices_raw,
        double[:] bid_sizes_raw,
        double[:] ask_sizes_raw,
        uint64_t[:] ts_events,
        uint64_t[:] ts_inits,
    ):
        Condition.is_true(len(bid_prices_raw) == len(ask_prices_raw) == len(bid_sizes_raw) == len(ask_sizes_raw)
                       == len(ts_events) == len(ts_inits), "Array lengths must be equal")

        cdef int count = ts_events.shape[0]
        cdef list[QuoteTick] quotes = []

        cdef:
            int i
            cdef Price bid_price
            cdef Price ask_price
            cdef Quantity bid_size
            cdef Quantity ask_size
            QuoteTick quote
        for i in range(count):
            bid_price = Price(bid_prices_raw[i], price_prec)
            ask_price = Price(ask_prices_raw[i], price_prec)
            bid_size = Quantity(bid_sizes_raw[i], size_prec)
            ask_size = Quantity(ask_sizes_raw[i], size_prec)

            quote = QuoteTick.__new__(QuoteTick)
            quote._mem = quote_tick_new(
                instrument_id._mem,
                bid_price._mem,
                ask_price._mem,
                bid_size._mem,
                ask_size._mem,
                ts_events[i],
                ts_inits[i],
            )
            quotes.append(quote)

        return quotes

    @staticmethod
    def from_raw_arrays_to_list(
        instrument_id: InstrumentId,
        price_prec: int,
        size_prec: int,
        bid_prices_raw: np.ndarray,
        ask_prices_raw: np.ndarray,
        bid_sizes_raw: np.ndarray,
        ask_sizes_raw: np.ndarray,
        ts_events: np.ndarray,
        ts_inits: np.ndarray,
    ) -> list[QuoteTick]:
        return QuoteTick.from_raw_arrays_to_list_c(
            instrument_id,
            price_prec,
            size_prec,
            bid_prices_raw,
            ask_prices_raw,
            bid_sizes_raw,
            ask_sizes_raw,
            ts_events,
            ts_inits,
        )

    @staticmethod
    cdef list[QuoteTick] capsule_to_list_c(object capsule):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
        cdef QuoteTick_t* ptr = <QuoteTick_t*>data.ptr
        cdef list[QuoteTick] quotes = []

        cdef uint64_t i
        for i in range(0, data.len):
            quotes.append(quote_from_mem_c(ptr[i]))

        return quotes

    @staticmethod
    cdef object list_to_capsule_c(list items):
        # Create a C struct buffer
        cdef uint64_t len_ = len(items)
        cdef QuoteTick_t * data = <QuoteTick_t *>PyMem_Malloc(len_ * sizeof(QuoteTick_t))
        cdef uint64_t i
        for i in range(len_):
            data[i] = (<QuoteTick>items[i])._mem
        if not data:
            raise MemoryError()

        # Create CVec
        cdef CVec *cvec = <CVec *>PyMem_Malloc(1 * sizeof(CVec))
        cvec.ptr = data
        cvec.len = len_
        cvec.cap = len_

        # Create PyCapsule
        return PyCapsule_New(cvec, NULL, <PyCapsule_Destructor>capsule_destructor)

    @staticmethod
    def list_from_capsule(capsule) -> list[QuoteTick]:
        return QuoteTick.capsule_to_list_c(capsule)

    @staticmethod
    def capsule_from_list(list items):
        return QuoteTick.list_to_capsule_c(items)

    @staticmethod
    def from_raw(
        InstrumentId instrument_id,
        PriceRaw bid_price_raw,
        PriceRaw ask_price_raw,
        uint8_t bid_price_prec,
        uint8_t ask_price_prec,
        QuantityRaw bid_size_raw ,
        QuantityRaw ask_size_raw,
        uint8_t bid_size_prec,
        uint8_t ask_size_prec,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> QuoteTick:
        """
        Return a quote tick from the given raw values.

        Parameters
        ----------
        instrument_id : InstrumentId
            The quotes instrument ID.
        bid_price_raw : int
            The raw top-of-book bid price (as a scaled fixed-point integer).
        ask_price_raw : int
            The raw top-of-book ask price (as a scaled fixed-point integer).
        bid_price_prec : uint8_t
            The bid price precision.
        ask_price_prec : uint8_t
            The ask price precision.
        bid_size_raw : int
            The raw top-of-book bid size (as a scaled fixed-point integer).
        ask_size_raw : int
            The raw top-of-book ask size (as a scaled fixed-point integer).
        bid_size_prec : uint8_t
            The bid size precision.
        ask_size_prec : uint8_t
            The ask size precision.
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the tick event occurred.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the data object was initialized.

        Returns
        -------
        QuoteTick

        Raises
        ------
        ValueError
            If `bid_price_prec` != `ask_price_prec`.
        ValueError
            If `bid_size_prec` != `ask_size_prec`.

        """
        Condition.equal(bid_price_prec, ask_price_prec, "bid_price_prec", "ask_price_prec")
        Condition.equal(bid_size_prec, ask_size_prec, "bid_size_prec", "ask_size_prec")

        return QuoteTick.from_raw_c(
            instrument_id,
            bid_price_raw,
            ask_price_raw,
            bid_price_prec,
            ask_price_prec,
            bid_size_raw,
            ask_size_raw,
            bid_size_prec,
            ask_size_prec,
            ts_event,
            ts_init,
        )

    @staticmethod
    def from_dict(dict values) -> QuoteTick:
        """
        Return a quote tick parsed from the given values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        QuoteTick

        """
        return QuoteTick.from_dict_c(values)

    @staticmethod
    def to_dict(QuoteTick obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return QuoteTick.to_dict_c(obj)

    @staticmethod
    def from_pyo3_list(list pyo3_quotes) -> list[QuoteTick]:
        """
        Return legacy Cython quotes converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_quotes : list[nautilus_pyo3.QuoteTick]
            The pyo3 Rust quotes to convert from.

        Returns
        -------
        list[QuoteTick]

        """
        cdef list[QuoteTick] output = []

        for pyo3_quote in pyo3_quotes:
            output.append(QuoteTick.from_pyo3_c(pyo3_quote))

        return output

    @staticmethod
    def to_pyo3_list(list[QuoteTick] quotes) -> list[nautilus_pyo3.QuoteTick]:
        """
        Return pyo3 Rust quotes converted from the given legacy Cython objects.

        Parameters
        ----------
        quotes : list[QuoteTick]
            The legacy Cython quotes to convert from.

        Returns
        -------
        list[nautilus_pyo3.QuoteTick]

        """
        cdef list output = []

        pyo3_instrument_id = None
        cdef uint8_t bid_prec = 0
        cdef uint8_t ask_prec = 0
        cdef uint8_t bid_size_prec = 0
        cdef uint8_t ask_size_prec = 0

        cdef:
            QuoteTick quote
        for quote in quotes:
            if pyo3_instrument_id is None:
                pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(quote.instrument_id.value)
                bid_prec = quote.bid_price.precision
                ask_prec = quote.ask_price.precision
                bid_size_prec = quote.bid_size.precision
                ask_size_prec = quote.ask_size.precision

            pyo3_quote = nautilus_pyo3.QuoteTick(
                pyo3_instrument_id,
                nautilus_pyo3.Price.from_raw(quote._mem.bid_price.raw, bid_prec),
                nautilus_pyo3.Price.from_raw(quote._mem.ask_price.raw, ask_prec),
                nautilus_pyo3.Quantity.from_raw(quote._mem.bid_size.raw, bid_size_prec),
                nautilus_pyo3.Quantity.from_raw(quote._mem.ask_size.raw, ask_size_prec),
                quote._mem.ts_event,
                quote._mem.ts_init,
            )
            output.append(pyo3_quote)

        return output

    @staticmethod
    def from_pyo3(pyo3_quote) -> QuoteTick:
        """
        Return a legacy Cython quote tick converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_quote : nautilus_pyo3.QuoteTick
            The pyo3 Rust quote tick to convert from.

        Returns
        -------
        QuoteTick

        """
        return QuoteTick.from_pyo3_c(pyo3_quote)

    def to_pyo3(self) -> nautilus_pyo3.QuoteTick:
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.QuoteTick

        """
        return nautilus_pyo3.QuoteTick(
            nautilus_pyo3.InstrumentId.from_str(self.instrument_id.value),
            nautilus_pyo3.Price.from_raw(self._mem.bid_price.raw, self._mem.bid_price.precision),
            nautilus_pyo3.Price.from_raw(self._mem.ask_price.raw, self._mem.ask_price.precision),
            nautilus_pyo3.Quantity.from_raw(self._mem.bid_size.raw, self._mem.bid_size.precision),
            nautilus_pyo3.Quantity.from_raw(self._mem.ask_size.raw, self._mem.ask_size.precision),
            self._mem.ts_event,
            self._mem.ts_init,
        )

    cpdef Price extract_price(self, PriceType price_type):
        """
        Extract the price for the given price type.

        Parameters
        ----------
        price_type : PriceType
            The price type to extract.

        Returns
        -------
        Price

        """
        if price_type == PriceType.MID:
            return Price.from_raw_c(((self._mem.bid_price.raw + self._mem.ask_price.raw) / 2), self._mem.bid_price.precision + 1)
        elif price_type == PriceType.BID:
            return self.bid_price
        elif price_type == PriceType.ASK:
            return self.ask_price
        else:
            raise ValueError(f"Cannot extract with PriceType {price_type_to_str(price_type)}")

    cpdef Quantity extract_size(self, PriceType price_type):
        """
        Extract the size for the given price type.

        Parameters
        ----------
        price_type : PriceType
            The price type to extract.

        Returns
        -------
        Quantity

        """
        if price_type == PriceType.MID:
            return Quantity.from_raw_c((self._mem.bid_size.raw + self._mem.ask_size.raw) / 2, self._mem.bid_size.precision + 1)
        elif price_type == PriceType.BID:
            return self.bid_size
        elif price_type == PriceType.ASK:
            return self.ask_size
        else:
            raise ValueError(f"Cannot extract with PriceType {price_type_to_str(price_type)}")


cdef class TradeTick(Data):
    """
    Represents a single trade tick in a market.

    Contains information about a single unique trade which matched buyer and
    seller counterparties.

    Parameters
    ----------
    instrument_id : InstrumentId
        The trade instrument ID.
    price : Price
        The traded price.
    size : Quantity
        The traded size.
    aggressor_side : AggressorSide
        The trade aggressor side.
    trade_id : TradeId
        The trade match ID (assigned by the venue).
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the tick event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.

    Raises
    ------
    ValueError
        If `trade_id` is not a valid string.
    ValueError
        If `size` is not positive (> 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Price price not None,
        Quantity size not None,
        AggressorSide aggressor_side,
        TradeId trade_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        Condition.positive_int(size._mem.raw, "size")

        self._mem = trade_tick_new(
            instrument_id._mem,
            price._mem,
            size._mem,
            aggressor_side,
            trade_id._mem,
            ts_event,
            ts_init,
        )

    def __getstate__(self):
        return (
            self.instrument_id.value,
            self._mem.price.raw,
            self._mem.price.precision,
            self._mem.size.raw,
            self._mem.size.precision,
            self._mem.aggressor_side,
            self.trade_id.value,
            self.ts_event,
            self.ts_init,
        )

    def __setstate__(self, state):
        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
        cdef Price_t price = price_new(state[1], state[2])
        cdef Quantity_t size = quantity_new(state[3], state[4])
        Condition.positive_int(size.raw, "size")

        self._mem = trade_tick_new(
            instrument_id._mem,
            price,
            size,
            state[5],
            TradeId(state[6])._mem,
            state[7],
            state[8],
        )

    def __eq__(self, TradeTick other) -> bool:
        if other is None:
            return False
        return trade_tick_eq(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return trade_tick_hash(&self._mem)

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self.to_str()})"

    cdef str to_str(self):
        return cstr_to_pystr(trade_tick_to_cstr(&self._mem))

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the ticks instrument ID.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def trade_id(self) -> InstrumentId:
        """
        Return the ticks trade match ID.

        Returns
        -------
        Price

        """
        return TradeId.from_mem_c(self._mem.trade_id)

    @property
    def price(self) -> Price:
        """
        Return the ticks price.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.price.raw, self._mem.price.precision)

    @property
    def size(self) -> Quantity:
        """
        Return the ticks size.

        Returns
        -------
        Quantity

        """
        return Quantity.from_raw_c(self._mem.size.raw, self._mem.size.precision)

    @property
    def aggressor_side(self) -> AggressorSide:
        """
        Return the ticks aggressor side.

        Returns
        -------
        AggressorSide

        """
        return <AggressorSide>self._mem.aggressor_side

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef TradeTick from_mem_c(TradeTick_t mem):
        return trade_from_mem_c(mem)

    @staticmethod
    cdef TradeTick from_pyo3_c(pyo3_trade):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        capsule = pyo3_trade.as_pycapsule()
        cdef Data_t* ptr = <Data_t*>PyCapsule_GetPointer(capsule, NULL)
        if ptr == NULL:
            raise ValueError("Invalid Data_t PyCapsule (NULL)")

        # Validate the tag to prevent segfault
        if ptr.tag != Data_t_Tag.TRADE:
            raise ValueError(f"Invalid Data_t tag: expected TRADE, was {data_tag_to_str(ptr.tag)}")

        return trade_from_mem_c(ptr.trade)

    @staticmethod
    cdef TradeTick from_raw_c(
        InstrumentId instrument_id,
        PriceRaw price_raw,
        uint8_t price_prec,
        QuantityRaw size_raw,
        uint8_t size_prec,
        AggressorSide aggressor_side,
        TradeId trade_id,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        Condition.positive_int(size_raw, "size_raw")

        cdef Price_t price = price_new(price_raw, price_prec)
        cdef Quantity_t size = quantity_new(size_raw, size_prec)

        cdef TradeTick trade = TradeTick.__new__(TradeTick)
        trade._mem = trade_tick_new(
            instrument_id._mem,
            price,
            size,
            aggressor_side,
            trade_id._mem,
            ts_event,
            ts_init,
        )
        return trade

    @staticmethod
    cdef list[TradeTick] from_raw_arrays_to_list_c(
        InstrumentId instrument_id,
        uint8_t price_prec,
        uint8_t size_prec,
        double[:] prices_raw,
        double[:] sizes_raw,
        uint8_t[:] aggressor_sides,
        list[str] trade_ids,
        uint64_t[:] ts_events,
        uint64_t[:] ts_inits,
    ):
        Condition.is_true(len(prices_raw) == len(sizes_raw) == len(aggressor_sides) == len(trade_ids) ==
                       len(ts_events) == len(ts_inits), "Array lengths must be equal")

        cdef int count = ts_events.shape[0]
        cdef list[TradeTick] trades = []

        cdef:
            int i
            Price price
            Quantity size
            AggressorSide aggressor_side
            TradeId trade_id
            TradeTick trade
        for i in range(count):
            price = Price(prices_raw[i], price_prec)
            size = Quantity(sizes_raw[i], size_prec)
            Condition.positive_int(size.raw, "size")
            aggressor_side = <AggressorSide>aggressor_sides[i]
            trade_id = TradeId(trade_ids[i])
            trade = TradeTick.__new__(TradeTick)
            trade._mem = trade_tick_new(
                instrument_id._mem,
                price._mem,
                size._mem,
                aggressor_side,
                trade_id._mem,
                ts_events[i],
                ts_inits[i],
            )
            trades.append(trade)

        return trades

    @staticmethod
    def from_raw_arrays_to_list(
        InstrumentId instrument_id,
        uint8_t price_prec,
        uint8_t size_prec,
        double[:] prices_raw,
        double[:] sizes_raw,
        uint8_t[:] aggressor_sides,
        list[str] trade_ids,
        uint64_t[:] ts_events,
        uint64_t[:] ts_inits,
    ) -> list[TradeTick]:
        return TradeTick.from_raw_arrays_to_list_c(
            instrument_id,
            price_prec,
            size_prec,
            prices_raw,
            sizes_raw,
            aggressor_sides,
            trade_ids,
            ts_events,
            ts_inits,
        )

    @staticmethod
    cdef list[TradeTick] capsule_to_list_c(capsule):
        # SAFETY: Do NOT deallocate the capsule here
        # It is supposed to be deallocated by the creator
        cdef CVec* data = <CVec *>PyCapsule_GetPointer(capsule, NULL)
        cdef TradeTick_t* ptr = <TradeTick_t *>data.ptr
        cdef list[TradeTick] trades = []

        cdef uint64_t i
        for i in range(0, data.len):
            trades.append(trade_from_mem_c(ptr[i]))

        return trades

    @staticmethod
    cdef object list_to_capsule_c(list items):
        # Create a C struct buffer
        cdef uint64_t len_ = len(items)
        cdef TradeTick_t *data = <TradeTick_t *>PyMem_Malloc(len_ * sizeof(TradeTick_t))
        cdef uint64_t i
        for i in range(len_):
            data[i] = (<TradeTick>items[i])._mem
        if not data:
            raise MemoryError()

        # Create CVec
        cdef CVec *cvec = <CVec *>PyMem_Malloc(1 * sizeof(CVec))
        cvec.ptr = data
        cvec.len = len_
        cvec.cap = len_

        # Create PyCapsule
        return PyCapsule_New(cvec, NULL, <PyCapsule_Destructor>capsule_destructor)

    @staticmethod
    def list_from_capsule(capsule) -> list[TradeTick]:
        return TradeTick.capsule_to_list_c(capsule)

    @staticmethod
    def capsule_from_list(items):
        return TradeTick.list_to_capsule_c(items)

    @staticmethod
    cdef TradeTick from_dict_c(dict values):
        Condition.not_none(values, "values")
        return TradeTick(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            price=Price.from_str_c(values["price"]),
            size=Quantity.from_str_c(values["size"]),
            aggressor_side=aggressor_side_from_str(values["aggressor_side"]),
            trade_id=TradeId(values["trade_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(TradeTick obj):
        Condition.not_none(obj, "obj")
        return {
            "type": type(obj).__name__,
            "instrument_id": str(obj.instrument_id),
            "price": str(obj.price),
            "size": str(obj.size),
            "aggressor_side": aggressor_side_to_str(obj._mem.aggressor_side),
            "trade_id": str(obj.trade_id),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_raw(
        InstrumentId instrument_id,
        PriceRaw price_raw,
        uint8_t price_prec,
        QuantityRaw size_raw,
        uint8_t size_prec,
        AggressorSide aggressor_side,
        TradeId trade_id,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> TradeTick:
        """
        Return a trade tick from the given raw values.

        Parameters
        ----------
        instrument_id : InstrumentId
            The trade instrument ID.
        price_raw : int
            The traded raw price (as a scaled fixed-point integer).
        price_prec : uint8_t
            The traded price precision.
        size_raw : int
            The traded raw size (as a scaled fixed-point integer).
        size_prec : uint8_t
            The traded size precision.
        aggressor_side : AggressorSide
            The trade aggressor side.
        trade_id : TradeId
            The trade match ID (assigned by the venue).
        ts_event : uint64_t
            UNIX timestamp (nanoseconds) when the tick event occurred.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the data object was initialized.

        Returns
        -------
        TradeTick

        """
        return TradeTick.from_raw_c(
            instrument_id,
            price_raw,
            price_prec,
            size_raw,
            size_prec,
            aggressor_side,
            trade_id,
            ts_event,
            ts_init,
        )

    @staticmethod
    def from_dict(dict values) -> TradeTick:
        """
        Return a trade tick from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        TradeTick

        """
        return TradeTick.from_dict_c(values)

    @staticmethod
    def to_dict(TradeTick obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return TradeTick.to_dict_c(obj)

    @staticmethod
    def to_pyo3_list(list[TradeTick] trades) -> list[nautilus_pyo3.TradeTick]:
        """
        Return pyo3 Rust trades converted from the given legacy Cython objects.

        Parameters
        ----------
        ticks : list[TradeTick]
            The legacy Cython Rust trades to convert from.

        Returns
        -------
        list[nautilus_pyo3.TradeTick]

        """
        cdef list output = []

        pyo3_instrument_id = None
        cdef uint8_t price_prec = 0
        cdef uint8_t size_prec = 0

        cdef:
            TradeTick trade
        for trade in trades:
            if pyo3_instrument_id is None:
                pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(trade.instrument_id.value)
                price_prec = trade.price.precision
                size_prec = trade.size.precision

            pyo3_trade = nautilus_pyo3.TradeTick(
                pyo3_instrument_id,
                nautilus_pyo3.Price.from_raw(trade._mem.price.raw, price_prec),
                nautilus_pyo3.Quantity.from_raw(trade._mem.size.raw, size_prec),
                nautilus_pyo3.AggressorSide(aggressor_side_to_str(trade._mem.aggressor_side)),
                nautilus_pyo3.TradeId(trade.trade_id.value),
                trade._mem.ts_event,
                trade._mem.ts_init,
            )
            output.append(pyo3_trade)

        return output

    @staticmethod
    def from_pyo3_list(list pyo3_trades) -> list[TradeTick]:
        """
        Return legacy Cython trades converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_trades : list[nautilus_pyo3.TradeTick]
            The pyo3 Rust trades to convert from.

        Returns
        -------
        list[TradeTick]

        """
        cdef list[TradeTick] output = []

        for pyo3_trade in pyo3_trades:
            output.append(TradeTick.from_pyo3_c(pyo3_trade))

        return output

    @staticmethod
    def from_pyo3(pyo3_trade) -> TradeTick:
        """
        Return a legacy Cython trade tick converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_trade : nautilus_pyo3.TradeTick
            The pyo3 Rust trade tick to convert from.

        Returns
        -------
        TradeTick

        """
        return TradeTick.from_pyo3_c(pyo3_trade)

    def to_pyo3(self) -> nautilus_pyo3.TradeTick:
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.TradeTick

        """
        return nautilus_pyo3.TradeTick(
            nautilus_pyo3.InstrumentId.from_str(self.instrument_id.value),
            nautilus_pyo3.Price.from_raw(self._mem.price.raw, self._mem.price.precision),
            nautilus_pyo3.Quantity.from_raw(self._mem.size.raw, self._mem.size.precision),
            nautilus_pyo3.AggressorSide(aggressor_side_to_str(self._mem.aggressor_side)),
            nautilus_pyo3.TradeId(self.trade_id.value),
            self._mem.ts_event,
            self._mem.ts_init,
        )


cdef class MarkPriceUpdate(Data):
    """
    Represents a mark price update.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the mark price.
    value : Price
        The mark price.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the update occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Price value not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        self._mem = mark_price_update_new(
            instrument_id._mem,
            value._mem,
            ts_event,
            ts_init,
        )

    def __eq__(self, MarkPriceUpdate other) -> bool:
        if other is None:
            return False
        return mark_price_update_eq(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return mark_price_update_hash(&self._mem)

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self.to_str()})"

    cdef str to_str(self):
        return cstr_to_pystr(mark_price_update_to_cstr(&self._mem))

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the instrument ID.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def value(self) -> Price:
        """
        The mark price.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.value.raw, self._mem.value.precision)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef MarkPriceUpdate from_dict_c(dict values):
        Condition.not_none(values, "values")
        return MarkPriceUpdate(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            value=Price.from_str_c(values["value"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(MarkPriceUpdate obj):
        Condition.not_none(obj, "obj")
        return {
            "type": type(obj).__name__,
            "instrument_id": str(obj.instrument_id),
            "value": str(obj.value),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> MarkPriceUpdate:
        """
        Return a mark price from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        MarkPriceUpdate

        """
        return MarkPriceUpdate.from_dict_c(values)

    @staticmethod
    def to_dict(MarkPriceUpdate obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return MarkPriceUpdate.to_dict_c(obj)

    @staticmethod
    def to_pyo3_list(list[MarkPriceUpdate] mark_prices) -> list[nautilus_pyo3.MarkPriceUpdate]:
        """
        Return pyo3 Rust mark prices converted from the given legacy Cython objects.

        Parameters
        ----------
        mark_prices : list[MarkPriceUpdate]
            The legacy Cython Rust mark prices to convert from.

        Returns
        -------
        list[nautilus_pyo3.MarkPriceUpdate]

        """
        cdef list output = []

        pyo3_instrument_id = None
        cdef uint8_t price_prec = 0

        cdef:
            MarkPriceUpdate mark_price
        for mark_price in mark_prices:
            if pyo3_instrument_id is None:
                pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(mark_price.instrument_id.value)
                price_prec = mark_price.value.precision

            pyo3_mark_price = nautilus_pyo3.MarkPriceUpdate(
                pyo3_instrument_id,
                nautilus_pyo3.Price(float(mark_price.value), price_prec),
                mark_price.ts_event,
                mark_price.ts_init,
            )
            output.append(pyo3_mark_price)

        return output

    @staticmethod
    def from_pyo3_list(list pyo3_mark_prices) -> list[MarkPriceUpdate]:
        """
        Return legacy Cython trades converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_mark_prices : list[nautilus_pyo3.MarkPriceUpdate]
            The pyo3 Rust mark prices to convert from.

        Returns
        -------
        list[MarkPriceUpdate]

        """
        cdef list[MarkPriceUpdate] output = []

        for pyo3_mark_price in pyo3_mark_prices:
            output.append(MarkPriceUpdate.from_pyo3_c(pyo3_mark_price))

        return output

    @staticmethod
    def from_pyo3(pyo3_mark_price) -> MarkPriceUpdate:
        """
        Return a legacy Cython mark price converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_trade : nautilus_pyo3.MarkPriceUpdate
            The pyo3 Rust mark price to convert from.

        Returns
        -------
        MarkPriceUpdate

        """
        return MarkPriceUpdate(
            instrument_id=InstrumentId.from_str(pyo3_mark_price.instrument_id.value),
            value=Price(float(pyo3_mark_price.value), pyo3_mark_price.value.precision),
            ts_event=pyo3_mark_price.ts_event,
            ts_init=pyo3_mark_price.ts_init,
        )

    def to_pyo3(self) -> nautilus_pyo3.MarkPriceUpdate:
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.MarkPriceUpdate

        """
        return nautilus_pyo3.MarkPriceUpdate(
            nautilus_pyo3.InstrumentId.from_str(self.instrument_id.value),
            nautilus_pyo3.Price(float(self.value), self.value.precision),
            self.ts_event,
            self.ts_init,
        )


cdef class IndexPriceUpdate(Data):
    """
    Represents an index price update.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the index price.
    value : Price
        The index price.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the update occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.

    """
    def __init__(
        self,
        InstrumentId instrument_id not None,
        Price value not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        self._mem = index_price_update_new(
            instrument_id._mem,
            value._mem,
            ts_event,
            ts_init,
        )

    def __eq__(self, IndexPriceUpdate other) -> bool:
        if other is None:
            return False
        return index_price_update_eq(&self._mem, &other._mem)

    def __hash__(self) -> int:
        return index_price_update_hash(&self._mem)

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self.to_str()})"

    cdef str to_str(self):
        return cstr_to_pystr(index_price_update_to_cstr(&self._mem))

    @property
    def instrument_id(self) -> InstrumentId:
        """
        Return the instrument ID.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def value(self) -> Price:
        """
        The mark price.

        Returns
        -------
        Price

        """
        return Price.from_raw_c(self._mem.value.raw, self._mem.value.precision)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef IndexPriceUpdate from_dict_c(dict values):
        Condition.not_none(values, "values")
        return IndexPriceUpdate(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            value=Price.from_str_c(values["value"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(IndexPriceUpdate obj):
        Condition.not_none(obj, "obj")
        return {
            "type": type(obj).__name__,
            "instrument_id": str(obj.instrument_id),
            "value": str(obj.value),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> IndexPriceUpdate:
        """
        Return an index price from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        IndexPriceUpdate

        """
        return IndexPriceUpdate.from_dict_c(values)

    @staticmethod
    def to_dict(IndexPriceUpdate obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return IndexPriceUpdate.to_dict_c(obj)

    @staticmethod
    def to_pyo3_list(list[IndexPriceUpdate] index_prices) -> list[nautilus_pyo3.IndexPriceUpdate]:
        """
        Return pyo3 Rust index prices converted from the given legacy Cython objects.

        Parameters
        ----------
        mark_prices : list[IndexPriceUpdate]
            The legacy Cython Rust index prices to convert from.

        Returns
        -------
        list[nautilus_pyo3.IndexPriceUpdate]

        """
        cdef list output = []

        pyo3_instrument_id = None
        cdef uint8_t price_prec = 0

        cdef:
            IndexPriceUpdate index_price
        for index_price in index_prices:
            if pyo3_instrument_id is None:
                pyo3_instrument_id = nautilus_pyo3.InstrumentId.from_str(index_price.instrument_id.value)
                price_prec = index_price.value.precision

            pyo3_index_price = nautilus_pyo3.IndexPriceUpdate(
                pyo3_instrument_id,
                nautilus_pyo3.Price(float(index_price.value), price_prec),
                index_price.ts_event,
                index_price.ts_init,
            )
            output.append(pyo3_index_price)

        return output

    @staticmethod
    def from_pyo3_list(list pyo3_index_prices) -> list[IndexPriceUpdate]:
        """
        Return legacy Cython index prices converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_index_prices : list[nautilus_pyo3.IndexPriceUpdate]
            The pyo3 Rust index prices to convert from.

        Returns
        -------
        list[IndexPriceUpdate]

        """
        cdef list[IndexPriceUpdate] output = []

        for pyo3_index_price in pyo3_index_prices:
            output.append(IndexPriceUpdate.from_pyo3_c(pyo3_index_price))

        return output

    @staticmethod
    def from_pyo3(pyo3_index_price) -> IndexPriceUpdate:
        """
        Return a legacy Cython index price converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_trade : nautilus_pyo3.IndexPriceUpdate
            The pyo3 Rust index price to convert from.

        Returns
        -------
        IndexPriceUpdate

        """
        return IndexPriceUpdate(
            instrument_id=InstrumentId.from_str(pyo3_index_price.instrument_id.value),
            value=Price(float(pyo3_index_price.value), pyo3_index_price.value.precision),
            ts_event=pyo3_index_price.ts_event,
            ts_init=pyo3_index_price.ts_init,
        )

    def to_pyo3(self) -> nautilus_pyo3.IndexPriceUpdate:
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.IndexPriceUpdate

        """
        return nautilus_pyo3.IndexPriceUpdate(
            nautilus_pyo3.InstrumentId.from_str(self.instrument_id.value),
            nautilus_pyo3.Price(float(self.value), self.value.precision),
            self.ts_event,
            self.ts_init,
        )


cdef class FundingRateUpdate(Data):
    """
    Represents a funding rate update for a perpetual swap instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the funding rate.
    rate : Decimal
        The current funding rate.
    next_funding_ns : int, optional
        UNIX timestamp (nanoseconds) of the next funding payment (if available).
    ts_event : int
        UNIX timestamp (nanoseconds) when the update occurred.
    ts_init : int
        UNIX timestamp (nanoseconds) when the data object was initialized.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        rate not None,
        uint64_t ts_event,
        uint64_t ts_init,
        next_funding_ns = None,
    ) -> None:
        self.instrument_id = instrument_id
        self.rate = rate
        self.next_funding_ns = next_funding_ns
        self._ts_event = ts_event
        self._ts_init = ts_init

    def __eq__(self, FundingRateUpdate other) -> bool:
        if other is None:
            return False
        return (
            self.instrument_id == other.instrument_id
            and self.rate == other.rate
            and self.next_funding_ns == other.next_funding_ns
        )

    def __hash__(self) -> int:
        return hash((
            self.instrument_id,
            self.rate,
            self.next_funding_ns,
        ))

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"rate={self.rate}, "
            f"next_funding_ns={self.next_funding_ns}, "
            f"ts_event={self._ts_event}, "
            f"ts_init={self._ts_init})"
        )

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef FundingRateUpdate from_dict_c(dict values):
        Condition.not_none(values, "values")
        return FundingRateUpdate(
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            rate=values["rate"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            next_funding_ns=values.get("next_funding_ns"),
        )

    @staticmethod
    cdef dict to_dict_c(FundingRateUpdate obj):
        Condition.not_none(obj, "obj")
        result = {
            "type": type(obj).__name__,
            "instrument_id": str(obj.instrument_id),
            "rate": obj.rate,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }
        if obj.next_funding_ns is not None:
            result["next_funding_ns"] = obj.next_funding_ns
        return result

    @staticmethod
    def from_dict(dict values) -> FundingRateUpdate:
        """
        Return a funding rate update from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        FundingRateUpdate

        """
        return FundingRateUpdate.from_dict_c(values)

    @staticmethod
    def to_dict(FundingRateUpdate obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return FundingRateUpdate.to_dict_c(obj)

    @staticmethod
    def from_pyo3_list(list pyo3_funding_rates) -> list[FundingRateUpdate]:
        """
        Return legacy Cython funding rate updates converted from the given pyo3 Rust objects.

        Parameters
        ----------
        pyo3_funding_rates : list[nautilus_pyo3.FundingRateUpdate]
            The pyo3 Rust funding rate updates to convert from.

        Returns
        -------
        list[FundingRateUpdate]

        """
        cdef list[FundingRateUpdate] output = []

        for pyo3_funding_rate in pyo3_funding_rates:
            output.append(FundingRateUpdate.from_pyo3(pyo3_funding_rate))

        return output

    @staticmethod
    def from_pyo3(pyo3_funding_rate) -> FundingRateUpdate:
        """
        Return a legacy Cython funding rate update converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_funding_rate : nautilus_pyo3.FundingRateUpdate
            The pyo3 Rust funding rate update to convert from.

        Returns
        -------
        FundingRateUpdate

        """
        return FundingRateUpdate(
            instrument_id=InstrumentId.from_str(pyo3_funding_rate.instrument_id.value),
            rate=pyo3_funding_rate.rate,
            next_funding_ns=pyo3_funding_rate.next_funding_ns,
            ts_event=pyo3_funding_rate.ts_event,
            ts_init=pyo3_funding_rate.ts_init,
        )

</document_content>
</document>
<document index="2399">
<source>nautilus_trader/model/events/account.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.functions cimport account_type_from_str
from nautilus_trader.model.functions cimport account_type_to_str
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.objects cimport AccountBalance
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport MarginBalance


cdef class AccountState(Event):
    """
    Represents an event which includes information on the state of the account.

    Parameters
    ----------
    account_id : AccountId
        The account ID (with the venue).
    account_type : AccountType
        The account type for the event.
    base_currency : Currency, optional
        The account base currency. Use None for multi-currency accounts.
    reported : bool
        If the state is reported from the exchange (otherwise system calculated).
    balances : list[AccountBalance]
        The account balances.
    margins : list[MarginBalance]
        The margin balances (can be empty).
    info : dict [str, object]
        The additional implementation specific account information.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the account state event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.

    Raises
    ------
    ValueError
        If `balances` is empty.
    """

    def __init__(
        self,
        AccountId account_id not None,
        AccountType account_type,
        Currency base_currency,
        bint reported,
        list balances not None,
        list margins not None,  # Can be empty
        dict info not None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        Condition.not_empty(balances, "balances")

        self.account_id = account_id
        self.account_type = account_type
        self.base_currency = base_currency
        self.balances = [balance.copy() for balance in balances]
        self.margins = [margin.copy() for margin in margins]
        self.is_reported = reported
        self.info = info

        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self._event_id == other.id

    def __hash__(self) -> int:
        return hash(self._event_id)

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"account_id={self.account_id.to_str()}, "
            f"account_type={account_type_to_str(self.account_type)}, "
            f"base_currency={self.base_currency}, "
            f"is_reported={self.is_reported}, "
            f"balances=[{', '.join([str(b) for b in self.balances])}], "
            f"margins=[{', '.join([str(m) for m in self.margins])}], "
            f"event_id={self._event_id.to_str()})"
        )

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init


    @staticmethod
    cdef AccountState from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str base_str = values["base_currency"]
        return AccountState(
            account_id=AccountId(values["account_id"]),
            account_type=account_type_from_str(values["account_type"]),
            base_currency=Currency.from_str_c(base_str) if base_str is not None else None,
            reported=values["reported"],
            balances=[AccountBalance.from_dict(b) for b in values["balances"]],
            margins=[MarginBalance.from_dict(m) for m in values["margins"]],
            info=values["info"],
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(AccountState obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "AccountState",
            "account_id": obj.account_id.to_str(),
            "account_type": account_type_to_str(obj.account_type),
            "base_currency": obj.base_currency.code if obj.base_currency else None,
            "balances": [b.to_dict() for b in obj.balances],
            "margins": [m.to_dict() for m in obj.margins],
            "reported": obj.is_reported,
            "info": obj.info,
            "event_id": obj._event_id.to_str(),
            "ts_event": obj._ts_event,
            "ts_init": obj._ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> AccountState:
        """
        Return an account state event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        AccountState

        """
        return AccountState.from_dict_c(values)

    @staticmethod
    def to_dict(AccountState obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return AccountState.to_dict_c(obj)

</document_content>
</document>
<document index="2401">
<source>nautilus_trader/model/events/order.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from typing import Any

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.rust.model cimport order_accepted_new
from nautilus_trader.core.rust.model cimport order_denied_new
from nautilus_trader.core.rust.model cimport order_emulated_new
from nautilus_trader.core.rust.model cimport order_rejected_new
from nautilus_trader.core.rust.model cimport order_released_new
from nautilus_trader.core.rust.model cimport order_submitted_new
from nautilus_trader.core.rust.model cimport strategy_id_new
from nautilus_trader.core.rust.model cimport trader_id_new
from nautilus_trader.core.string cimport cstr_to_pybytes
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.core.string cimport pystr_to_cstr
from nautilus_trader.core.string cimport ustr_to_pystr
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.functions cimport contingency_type_from_str
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_from_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_from_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_from_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_from_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trigger_type_from_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TradeId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class OrderEvent(Event):
    """
    The abstract base class for all order events.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        raise NotImplementedError("abstract property must be implemented")

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        raise NotImplementedError("abstract property must be implemented")

    def set_client_order_id(self, ClientOrderId client_order_id):
        raise NotImplementedError("abstract method `set_client_order_i` must be implemented")


cdef class OrderInitialized(OrderEvent):
    """
    Represents an event where an order has been initialized.

    This is a seed event which can instantiate any order through a creation
    method. This event should contain enough information to be able to send it
    'over the wire' and have a valid order created with exactly the same
    properties as if it had been instantiated locally.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    order_type : OrderType
        The order type.
    quantity : Quantity
        The order quantity.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}
        The order time in force.
    post_only : bool
        If the order will only provide liquidity (make a market).
    reduce_only : bool
        If the order carries the 'reduce-only' execution instruction.
    quote_quantity : bool
        If the order quantity is denominated in the quote currency.
    options : dict[str, str]
        The order initialization options. Contains mappings for specific
        order parameters.
    emulation_trigger : TriggerType, default ``NO_TRIGGER``
        The type of market price trigger to use for local order emulation.
        - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
        - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
        Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
    trigger_instrument_id : InstrumentId or ``None``
        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
    contingency_type : ContingencyType
        The order contingency type.
    order_list_id : OrderListId or ``None``
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId] or ``None``
        The order linked client order ID(s).
    parent_order_id : ClientOrderId or ``None``
        The orders parent client order ID.
    exec_algorithm_id : ExecAlgorithmId or ``None``
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId or ``None``
        The execution algorithm spawning primary client order ID.
    tags : list[str] or ``None``
        The custom user tags for the order.
    event_id : UUID4
        The event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `contingency_type` is not ``NO_CONTINGENCY``, and `linked_order_ids` is ``None`` or empty.
    ValueError
        If `exec_algorithm_id` is not ``None``, and `exec_spawn_id` is ``None``.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        OrderType order_type,
        Quantity quantity not None,
        TimeInForce time_in_force,
        bint post_only,
        bint reduce_only,
        bint quote_quantity,
        dict[str, object] options not None,
        TriggerType emulation_trigger,
        InstrumentId trigger_instrument_id: InstrumentId | None,
        ContingencyType contingency_type,
        OrderListId order_list_id: OrderListId | None,
        list[ClientOrderId] linked_order_ids: list[ClientOrderId] | None,
        ClientOrderId parent_order_id: ClientOrderId | None,
        ExecAlgorithmId exec_algorithm_id: ExecAlgorithmId | None,
        dict[str, object] exec_algorithm_params: dict[str, object] | None,
        ClientOrderId exec_spawn_id: ClientOrderId | None,
        list[str] tags: list[str] | None,
        UUID4 event_id not None,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NONE")
        if contingency_type != ContingencyType.NO_CONTINGENCY:
            Condition.is_true(linked_order_ids, f"`linked_order_ids` was `None` or empty when `contingency_type` {contingency_type_to_str(contingency_type)}")
        if exec_algorithm_id is not None:
            Condition.not_none(exec_spawn_id, "exec_spawn_id")

        self._trader_id = trader_id
        self._strategy_id = strategy_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._event_id = event_id
        self._ts_event = ts_init  # Timestamp identical to ts_init
        self._ts_init = ts_init
        self._reconciliation = reconciliation

        self.side = order_side
        self.order_type = order_type
        self.quantity = quantity
        self.time_in_force = time_in_force
        self.post_only = post_only
        self.reduce_only = reduce_only
        self.quote_quantity = quote_quantity
        self.options = options
        self.emulation_trigger = emulation_trigger
        self.trigger_instrument_id = trigger_instrument_id
        self.contingency_type = contingency_type
        self.order_list_id = order_list_id
        self.linked_order_ids = linked_order_ids
        self.parent_order_id = parent_order_id
        self.exec_algorithm_id = exec_algorithm_id
        self.exec_algorithm_params = exec_algorithm_params
        self.exec_spawn_id = exec_spawn_id
        self.tags = tags

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        cdef ClientOrderId o
        cdef str linked_order_ids = "None"
        if self.linked_order_ids:
            linked_order_ids = str([o.value for o in self.linked_order_ids])
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"side={order_side_to_str(self.side)}, "
            f"type={order_type_to_str(self.order_type)}, "
            f"quantity={self.quantity.to_formatted_str()}, "
            f"time_in_force={time_in_force_to_str(self.time_in_force)}, "
            f"post_only={self.post_only}, "
            f"reduce_only={self.reduce_only}, "
            f"quote_quantity={self.quote_quantity}, "
            f"options={self.options}, "
            f"emulation_trigger={trigger_type_to_str(self.emulation_trigger)}, "
            f"trigger_instrument_id={self.trigger_instrument_id}, "
            f"contingency_type={contingency_type_to_str(self.contingency_type)}, "
            f"order_list_id={self.order_list_id}, "
            f"linked_order_ids={linked_order_ids}, "
            f"parent_order_id={self.parent_order_id}, "
            f"exec_algorithm_id={self.exec_algorithm_id}, "
            f"exec_algorithm_params={self.exec_algorithm_params}, "
            f"exec_spawn_id={self.exec_spawn_id}, "
            f"tags={self.tags})"
        )

    def __repr__(self) -> str:
        cdef ClientOrderId o
        cdef str linked_order_ids = "None"
        if self.linked_order_ids:
            linked_order_ids = str([o.value for o in self.linked_order_ids])
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"side={order_side_to_str(self.side)}, "
            f"type={order_type_to_str(self.order_type)}, "
            f"quantity={self.quantity.to_formatted_str()}, "
            f"time_in_force={time_in_force_to_str(self.time_in_force)}, "
            f"post_only={self.post_only}, "
            f"reduce_only={self.reduce_only}, "
            f"quote_quantity={self.quote_quantity}, "
            f"options={self.options}, "
            f"emulation_trigger={trigger_type_to_str(self.emulation_trigger)}, "
            f"trigger_instrument_id={self.trigger_instrument_id}, "
            f"contingency_type={contingency_type_to_str(self.contingency_type)}, "
            f"order_list_id={self.order_list_id}, "
            f"linked_order_ids={linked_order_ids}, "
            f"parent_order_id={self.parent_order_id}, "
            f"exec_algorithm_id={self.exec_algorithm_id}, "
            f"exec_algorithm_params={self.exec_algorithm_params}, "
            f"exec_spawn_id={self.exec_spawn_id}, "
            f"tags={self.tags}, "
            f"event_id={self.id}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return None  # Pending assignment by venue

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return None  # Pending assignment by system

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return False  # Internal system event

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderInitialized from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str trigger_instrument_id = values["trigger_instrument_id"]
        cdef str order_list_id_str = values["order_list_id"]
        cdef str parent_order_id_str = values["parent_order_id"]
        cdef str exec_algorithm_id_str = values["exec_algorithm_id"]
        cdef str exec_spawn_id_str = values["exec_spawn_id"]

        linked_order_ids = values.get("linked_order_ids")
        tags = values.get("tags")

        if isinstance(linked_order_ids, str):
            linked_order_ids = linked_order_ids.split(",")
        if isinstance(tags, str):
            tags = tags.split(",")

        return OrderInitialized(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            order_side=order_side_from_str(values["order_side"]),
            order_type=order_type_from_str(values["order_type"]),
            quantity=Quantity.from_str_c(values["quantity"]),
            time_in_force=time_in_force_from_str(values["time_in_force"]),
            post_only=values["post_only"],
            reduce_only=values["reduce_only"],
            quote_quantity=values["quote_quantity"],
            options=values["options"],
            emulation_trigger=trigger_type_from_str(values["emulation_trigger"]) if values["emulation_trigger"] is not None else TriggerType.NO_TRIGGER,
            trigger_instrument_id=InstrumentId.from_str_c(trigger_instrument_id) if trigger_instrument_id is not None else None,
            contingency_type=contingency_type_from_str(values["contingency_type"]),
            order_list_id=OrderListId(order_list_id_str) if order_list_id_str is not None else None,
            linked_order_ids=[ClientOrderId(o_str) for o_str in linked_order_ids] if linked_order_ids is not None else None,
            parent_order_id=ClientOrderId(parent_order_id_str) if parent_order_id_str is not None else None,
            exec_algorithm_id=ExecAlgorithmId(exec_algorithm_id_str) if exec_algorithm_id_str is not None else None,
            exec_algorithm_params=values["exec_algorithm_params"],
            exec_spawn_id=ClientOrderId(exec_spawn_id_str) if exec_spawn_id_str is not None else None,
            tags=tags,
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderInitialized obj):
        Condition.not_none(obj, "obj")
        cdef ClientOrderId o
        return {
            "type": "OrderInitialized",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "order_side": order_side_to_str(obj.side),
            "order_type": order_type_to_str(obj.order_type),
            "quantity": str(obj.quantity),
            "time_in_force": time_in_force_to_str(obj.time_in_force),
            "post_only": obj.post_only,
            "reduce_only": obj.reduce_only,
            "quote_quantity": obj.quote_quantity,
            "options": obj.options,
            "emulation_trigger": trigger_type_to_str(obj.emulation_trigger),
            "trigger_instrument_id": obj.trigger_instrument_id.value if obj.trigger_instrument_id is not None else None,
            "contingency_type": contingency_type_to_str(obj.contingency_type),
            "order_list_id": obj.order_list_id.value if obj.order_list_id is not None else None,
            "linked_order_ids": [o.value for o in obj.linked_order_ids] if obj.linked_order_ids is not None else None,
            "parent_order_id": obj.parent_order_id.value if obj.parent_order_id is not None else None,
            "exec_algorithm_id": obj.exec_algorithm_id.value if obj.exec_algorithm_id is not None else None,
            "exec_algorithm_params": obj.exec_algorithm_params,
            "exec_spawn_id": obj.exec_spawn_id.value if obj.exec_spawn_id is not None else None,
            "tags": obj.tags if obj.tags is not None else None,
            "event_id": obj.id.value,
            "ts_init": obj.ts_init,
            "ts_event": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderInitialized:
        """
        Return an order initialized event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderInitialized

        """
        return OrderInitialized.from_dict_c(values)

    @staticmethod
    def to_dict(OrderInitialized obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderInitialized.to_dict_c(obj)


cdef class OrderDenied(OrderEvent):
    """
    Represents an event where an order has been denied by the Nautilus system.

    This could be due an unsupported feature, a risk limit exceedance, or for
    any other reason that an otherwise valid order is not able to be submitted.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    reason : str
        The order denied reason.
    event_id : UUID4
        The event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.

    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        str reason,
        UUID4 event_id not None,
        uint64_t ts_init,
    ):
        self._mem = order_denied_new(
            trader_id._mem,
            strategy_id._mem,
            instrument_id._mem,
            client_order_id._mem,
            pystr_to_cstr(reason or str(None)),
            event_id._mem,
            ts_init,
            ts_init,
        )

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"reason='{self.reason}')"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"reason='{self.reason}', "
            f"event_id={self.id}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return TraderId.from_mem_c(self._mem.trader_id)

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return StrategyId.from_mem_c(self._mem.strategy_id)

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return ClientOrderId.from_mem_c(self._mem.client_order_id)

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return None  # No assignment from venue

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return None  # No assignment

    @property
    def reason(self) -> str:
        """
        Return the reason the order was denied.

        Returns
        -------
        str

        """
        return ustr_to_pystr(self._mem.reason)

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return False  # Internal system event

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return UUID4.from_mem_c(self._mem.event_id)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef OrderDenied from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OrderDenied(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            reason=values["reason"],
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(OrderDenied obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderDenied",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "reason": obj.reason,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> OrderDenied:
        """
        Return an order denied event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderDenied

        """
        return OrderDenied.from_dict_c(values)

    @staticmethod
    def to_dict(OrderDenied obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderDenied.to_dict_c(obj)


cdef class OrderEmulated(OrderEvent):
    """
    Represents an event where an order has become emulated by the Nautilus system.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    event_id : UUID4
        The event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.

    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        UUID4 event_id not None,
        uint64_t ts_init,
    ):
        self._mem = order_emulated_new(
            trader_id._mem,
            strategy_id._mem,
            instrument_id._mem,
            client_order_id._mem,
            event_id._mem,
            ts_init,
            ts_init,
        )

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"event_id={self.id}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return TraderId.from_mem_c(self._mem.trader_id)

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return StrategyId.from_mem_c(self._mem.strategy_id)

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return ClientOrderId.from_mem_c(self._mem.client_order_id)

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return None  # No assignment from venue

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return None  # No assignment

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return False  # Internal system event

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return UUID4.from_mem_c(self._mem.event_id)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef OrderEmulated from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OrderEmulated(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(OrderEmulated obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderEmulated",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "event_id": obj.id.value,
            "ts_event": obj.ts_init,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> OrderEmulated:
        """
        Return an order emulated event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderEmulated

        """
        return OrderEmulated.from_dict_c(values)

    @staticmethod
    def to_dict(OrderEmulated obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderEmulated.to_dict_c(obj)


cdef class OrderReleased(OrderEvent):
    """
    Represents an event where an order was released from the `OrderEmulator` by the Nautilus system.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    released_price : Price
        The price which released the order from the emulator.
    event_id : UUID4
        The event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.

    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        Price released_price not None,
        UUID4 event_id not None,
        uint64_t ts_init,
    ):
        self._mem = order_released_new(
            trader_id._mem,
            strategy_id._mem,
            instrument_id._mem,
            client_order_id._mem,
            released_price._mem,
            event_id._mem,
            ts_init,
            ts_init,
        )

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"released_price={self.released_price})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"released_price={self.released_price}, "
            f"event_id={self.id}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return TraderId.from_mem_c(self._mem.trader_id)

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return StrategyId.from_mem_c(self._mem.strategy_id)

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return ClientOrderId.from_mem_c(self._mem.client_order_id)

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return None  # No assignment from venue

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return None  # No assignment

    @property
    def released_price(self) -> Price:
        """
        The released price for the event.

        Returns
        -------
        Price

        """
        return Price.from_mem_c(self._mem.released_price)

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return False  # Internal system event

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return UUID4.from_mem_c(self._mem.event_id)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef OrderReleased from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OrderReleased(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            released_price=Price.from_str_c(values["released_price"]),
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(OrderReleased obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderReleased",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "released_price": str(obj.released_price),
            "event_id": obj.id.value,
            "ts_event": obj.ts_init,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> OrderReleased:
        """
        Return an order released event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderReleased

        """
        return OrderReleased.from_dict_c(values)

    @staticmethod
    def to_dict(OrderReleased obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderReleased.to_dict_c(obj)


cdef class OrderSubmitted(OrderEvent):
    """
    Represents an event where an order has been submitted by the system to the
    trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    account_id : AccountId
        The account ID (with the venue).
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order submitted event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        AccountId account_id not None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        self._mem = order_submitted_new(
            trader_id._mem,
            strategy_id._mem,
            instrument_id._mem,
            client_order_id._mem,
            account_id._mem,
            event_id._mem,
            ts_event,
            ts_init,
        )

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"account_id={self.account_id}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"account_id={self.account_id}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return TraderId.from_mem_c(self._mem.trader_id)

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return StrategyId.from_mem_c(self._mem.strategy_id)

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return ClientOrderId.from_mem_c(self._mem.client_order_id)

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return None  # Pending assignment by venue

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return AccountId.from_mem_c(self._mem.account_id)

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return False  # Internal system event

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return UUID4.from_mem_c(self._mem.event_id)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef OrderSubmitted from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OrderSubmitted(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            account_id=AccountId(values["account_id"]),
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(OrderSubmitted obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderSubmitted",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "account_id": obj.account_id.value,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> OrderSubmitted:
        """
        Return an order submitted event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderSubmitted

        """
        return OrderSubmitted.from_dict_c(values)

    @staticmethod
    def to_dict(OrderSubmitted obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderSubmitted.to_dict_c(obj)


cdef class OrderAccepted(OrderEvent):
    """
    Represents an event where an order has been accepted by the trading venue.

    This event often corresponds to a `NEW` OrdStatus <39> field in FIX execution reports.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId
        The venue order ID (assigned by the venue).
    account_id : AccountId
        The account ID (with the venue).
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order accepted event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.

    References
    ----------
    https://www.onixs.biz/fix-dictionary/5.0.SP2/tagNum_39.html
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id not None,
        AccountId account_id not None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        self._mem = order_accepted_new(
            trader_id._mem,
            strategy_id._mem,
            instrument_id._mem,
            client_order_id._mem,
            venue_order_id._mem,
            account_id._mem,
            event_id._mem,
            ts_event,
            ts_init,
            reconciliation,
        )

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return TraderId.from_mem_c(self._mem.trader_id)

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return StrategyId.from_mem_c(self._mem.strategy_id)

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return ClientOrderId.from_mem_c(self._mem.client_order_id)

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return VenueOrderId.from_mem_c(self._mem.venue_order_id)

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return AccountId.from_mem_c(self._mem.account_id)

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return <bint>self._mem.reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return UUID4.from_mem_c(self._mem.event_id)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef OrderAccepted from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OrderAccepted(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(values["venue_order_id"]),
            account_id=AccountId(values["account_id"]),
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderAccepted obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderAccepted",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value,
            "account_id": obj.account_id.value,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderAccepted:
        """
        Return an order accepted event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderAccepted

        """
        return OrderAccepted.from_dict_c(values)

    @staticmethod
    def to_dict(OrderAccepted obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderAccepted.to_dict_c(obj)


cdef class OrderRejected(OrderEvent):
    """
    Represents an event where an order has been rejected by the trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    account_id : AccountId
        The account ID (with the venue).
    reason : str
        The order rejected reason.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order rejected event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.
    due_post_only : bool, default False
        If the order was rejected because it was post-only and would execute immediately as a taker.

    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        AccountId account_id not None,
        str reason,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
        bint due_post_only=False,
    ):
        self._mem = order_rejected_new(
            trader_id._mem,
            strategy_id._mem,
            instrument_id._mem,
            client_order_id._mem,
            account_id._mem,
            pystr_to_cstr(reason or "None"),
            event_id._mem,
            ts_event,
            ts_init,
            reconciliation,
            due_post_only,
        )

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"account_id={self.account_id}, "
            f"reason='{self.reason}', "
            f"due_post_only={self.due_post_only}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"account_id={self.account_id}, "
            f"reason='{self.reason}', "
            f"due_post_only={self.due_post_only}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return TraderId.from_mem_c(self._mem.trader_id)

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return StrategyId.from_mem_c(self._mem.strategy_id)

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_mem_c(self._mem.instrument_id)

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return ClientOrderId.from_mem_c(self._mem.client_order_id)

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return None  # Not assigned

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return AccountId.from_mem_c(self._mem.account_id)

    @property
    def reason(self) -> str:
        """
        Return the reason the order was rejected.

        Returns
        -------
        str

        """
        return ustr_to_pystr(self._mem.reason)

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return <bint>self._mem.reconciliation

    @property
    def due_post_only(self) -> bool:
        """
        If the order was rejected because it was post-only and would execute immediately as a taker.

        Returns
        -------
        bool

        """
        return <bint>self._mem.due_post_only

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return UUID4.from_mem_c(self._mem.event_id)

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._mem.ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._mem.ts_init

    @staticmethod
    cdef OrderRejected from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OrderRejected(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            account_id=AccountId(values["account_id"]),
            reason=values["reason"],
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
            due_post_only=values.get("due_post_only", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderRejected obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderRejected",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "account_id": obj.account_id.value,
            "reason": obj.reason,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
            "due_post_only": obj.due_post_only,
        }

    @staticmethod
    def from_dict(dict values) -> OrderRejected:
        """
        Return an order rejected event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderRejected

        """
        return OrderRejected.from_dict_c(values)

    @staticmethod
    def to_dict(OrderRejected obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderRejected.to_dict_c(obj)


cdef class OrderCanceled(OrderEvent):
    """
    Represents an event where an order has been canceled at the trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue).
    account_id : AccountId or ``None``
        The account ID (with the venue).
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when order canceled event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        AccountId account_id: AccountId | None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        self._trader_id = trader_id
        self._strategy_id = strategy_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderCanceled from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str v = values.get("venue_order_id")
        cdef str a = values.get("account_id")
        return OrderCanceled(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            account_id=AccountId(a) if a is not None else None,
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderCanceled obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderCanceled",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value if obj.venue_order_id is not None else None,
            "account_id": obj.account_id.value if obj.account_id is not None else None,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderCanceled:
        """
        Return an order canceled event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderCanceled

        """
        return OrderCanceled.from_dict_c(values)

    @staticmethod
    def to_dict(OrderCanceled obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderCanceled.to_dict_c(obj)


cdef class OrderExpired(OrderEvent):
    """
    Represents an event where an order has expired at the trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue).
    account_id : AccountId or ``None``
        The account ID (with the venue).
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order expired event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        AccountId account_id: AccountId | None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        self._trader_id = trader_id
        self._strategy_id = strategy_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderExpired from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str v = values.get("venue_order_id")
        cdef str a = values.get("account_id")
        return OrderExpired(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            account_id=AccountId(a) if a is not None else None,
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderExpired obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderExpired",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value if obj.venue_order_id is not None else None,
            "account_id": obj.account_id.value if obj.account_id is not None else None,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderExpired:
        """
        Return an order expired event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderExpired

        """
        return OrderExpired.from_dict_c(values)

    @staticmethod
    def to_dict(OrderExpired obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderExpired.to_dict_c(obj)


cdef class OrderTriggered(OrderEvent):
    """
    Represents an event where an order has triggered.

    Applicable to :class:`StopLimit` orders only.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue).
    account_id : AccountId or ``None``
        The account ID (with the venue).
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order triggered event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        AccountId account_id: AccountId | None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        self._trader_id = trader_id
        self._strategy_id = strategy_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderTriggered from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str v = values.get("venue_order_id")
        cdef str a = values.get("account_id")
        return OrderTriggered(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            account_id=AccountId(a) if a is not None else None,
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderTriggered obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderTriggered",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value if obj.venue_order_id is not None else None,
            "account_id": obj.account_id.value if obj.account_id is not None else None,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderTriggered:
        """
        Return an order triggered event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderTriggered

        """
        return OrderTriggered.from_dict_c(values)

    @staticmethod
    def to_dict(OrderTriggered obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderTriggered.to_dict_c(obj)


cdef class OrderPendingUpdate(OrderEvent):
    """
    Represents an event where an `ModifyOrder` command has been sent to the
    trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue).
    account_id : AccountId or ``None``
        The account ID (with the venue).
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order pending update event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        AccountId account_id: AccountId | None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        self._trader_id = trader_id
        self._strategy_id = strategy_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderPendingUpdate from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str v = values.get("venue_order_id")
        cdef str a = values.get("account_id")
        return OrderPendingUpdate(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            account_id=AccountId(a) if a is not None else None,
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderPendingUpdate obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderPendingUpdate",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value if obj.venue_order_id is not None else None,
            "account_id": obj.account_id.value if obj.account_id is not None else None,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderPendingUpdate:
        """
        Return an order pending update event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderPendingUpdate

        """
        return OrderPendingUpdate.from_dict_c(values)

    @staticmethod
    def to_dict(OrderPendingUpdate obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderPendingUpdate.to_dict_c(obj)


cdef class OrderPendingCancel(OrderEvent):
    """
    Represents an event where a `CancelOrder` command has been sent to the
    trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue).
    account_id : AccountId or ``None``
        The account ID (with the venue).
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order pending cancel event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        AccountId account_id: AccountId | None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        self._trader_id = trader_id
        self._strategy_id = strategy_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderPendingCancel from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str v = values.get("venue_order_id")
        cdef str a = values.get("account_id")
        return OrderPendingCancel(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            account_id=AccountId(a) if a is not None else None,
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderPendingCancel obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderPendingCancel",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value if obj.venue_order_id is not None else None,
            "account_id": obj.account_id.value if obj.account_id is not None else None,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderPendingCancel:
        """
        Return an order pending cancel event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderPendingCancel

        """
        return OrderPendingCancel.from_dict_c(values)

    @staticmethod
    def to_dict(OrderPendingCancel obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderPendingCancel.to_dict_c(obj)


cdef class OrderModifyRejected(OrderEvent):
    """
    Represents an event where a `ModifyOrder` command has been rejected by the
    trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue).
    account_id : AccountId or ``None``
        The account ID (with the venue).
    reason : str
        The order update rejected reason.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order update rejected event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.

    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        AccountId account_id: AccountId | None,
        str reason,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        self._strategy_id = strategy_id
        self._trader_id = trader_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._reason = reason or str(None)
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"reason='{self.reason}', "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"reason='{self.reason}', "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reason(self) -> str:
        """
        Return the reason the order was rejected.

        Returns
        -------
        str

        """
        return self._reason

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderModifyRejected from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str v = values.get("venue_order_id")
        cdef str a = values.get("account_id")
        return OrderModifyRejected(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            account_id=AccountId(a) if a is not None else None,
            reason=values["reason"],
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderModifyRejected obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderModifyRejected",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value if obj.venue_order_id is not None else None,
            "account_id": obj.account_id.value if obj.account_id is not None else None,
            "reason": obj.reason,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderModifyRejected:
        """
        Return an order update rejected event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderModifyRejected

        """
        return OrderModifyRejected.from_dict_c(values)

    @staticmethod
    def to_dict(OrderModifyRejected obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderModifyRejected.to_dict_c(obj)


cdef class OrderCancelRejected(OrderEvent):
    """
    Represents an event where a `CancelOrder` command has been rejected by the
    trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue).
    account_id : AccountId or ``None``
        The account ID (with the venue).
    reason : str
        The order cancel rejected reason.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order cancel rejected event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.

    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        AccountId account_id: AccountId | None,
        str reason,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        self._strategy_id = strategy_id
        self._trader_id = trader_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._reason = reason or str(None)
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"reason='{self.reason}', "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"reason='{self.reason}', "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reason(self) -> str:
        """
        Return the reason the order was rejected.

        Returns
        -------
        str

        """
        return self._reason

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderCancelRejected from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str v = values.get("venue_order_id")
        cdef str a = values.get("account_id")
        return OrderCancelRejected(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            account_id=AccountId(a) if a is not None else None,
            reason=values["reason"],
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderCancelRejected obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderCancelRejected",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value if obj.venue_order_id is not None else None,
            "account_id": obj.account_id.value if obj.account_id is not None else None,
            "reason": obj.reason,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderCancelRejected:
        """
        Return an order cancel rejected event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderCancelRejected

        """
        return OrderCancelRejected.from_dict_c(values)

    @staticmethod
    def to_dict(OrderCancelRejected obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderCancelRejected.to_dict_c(obj)


cdef class OrderUpdated(OrderEvent):
    """
    Represents an event where an order has been updated at the trading venue.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId or ``None``
        The venue order ID (assigned by the venue).
    account_id : AccountId or ``None``
        The account ID (with the venue).
    quantity : Quantity
        The orders current quantity.
    price : Price or ``None``
        The orders current price.
    trigger_price : Price or ``None``
        The orders current trigger.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order updated event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    reconciliation : bool, default False
        If the event was generated during reconciliation.

    Raises
    ------
    ValueError
        If `quantity` is not positive (> 0).
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id: VenueOrderId | None,
        AccountId account_id: AccountId | None,
        Quantity quantity not None,
        Price price: Price | None,
        Price trigger_price: Price | None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
    ):
        Condition.positive(quantity, "quantity")

        self._strategy_id = strategy_id
        self._trader_id = trader_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

        self.quantity = quantity
        self.price = price
        self.trigger_price = trigger_price

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"quantity={self.quantity.to_formatted_str() if self.quantity else None}, "
            f"price={self.price.to_formatted_str() if self.price else None}, "
            f"trigger_price={self.trigger_price.to_formatted_str() if self.trigger_price else None}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"quantity={self.quantity.to_formatted_str() if self.quantity else None}, "
            f"price={self.price.to_formatted_str() if self.price else None}, "
            f"trigger_price={self.trigger_price.to_formatted_str() if self.trigger_price else None}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderUpdated from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str v = values.get("venue_order_id")
        cdef str a = values.get("account_id")
        cdef str p = values.get("price")
        cdef str t = values.get("trigger_price")
        return OrderUpdated(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(v) if v is not None else None,
            account_id=AccountId(a) if a is not None else None,
            quantity=Quantity.from_str_c(values["quantity"]),
            price=Price.from_str_c(p) if p is not None else None,
            trigger_price=Price.from_str_c(t) if t is not None else None,
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderUpdated obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderUpdated",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value if obj.venue_order_id is not None else None,
            "account_id": obj.account_id.value if obj.account_id is not None else None,
            "quantity": str(obj.quantity),
            "price": str(obj.price) if obj.price is not None else None,
            "trigger_price": str(obj.trigger_price) if obj.trigger_price is not None else None,
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderUpdated:
        """
        Return an order updated event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderUpdated

        """
        return OrderUpdated.from_dict_c(values)

    @staticmethod
    def to_dict(OrderUpdated obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderUpdated.to_dict_c(obj)


cdef class OrderFilled(OrderEvent):
    """
    Represents an event where an order has been filled at the exchange.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    venue_order_id : VenueOrderId
        The venue order ID (assigned by the venue).
    account_id : AccountId
        The account ID (with the venue).
    trade_id : TradeId
        The trade match ID (assigned by the venue).
    position_id : PositionId or ``None``
        The position ID associated with the order fill (assigned by the venue).
    order_side : OrderSide {``BUY``, ``SELL``}
        The execution order side.
    order_type : OrderType
        The execution order type.
    last_qty : Quantity
        The fill quantity for this execution.
    last_px : Price
        The fill price for this execution (not average price).
    currency : Currency
        The currency of the price.
    commission : Money
        The fill commission.
    liquidity_side : LiquiditySide {``NO_LIQUIDITY_SIDE``, ``MAKER``, ``TAKER``}
        The execution liquidity side.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the order filled event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    info : dict[str, object], optional
        The additional fill information.
    reconciliation : bool, default False
        If the event was generated during reconciliation.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `last_qty` is not positive (> 0).
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        VenueOrderId venue_order_id not None,
        AccountId account_id not None,
        TradeId trade_id not None,
        PositionId position_id: PositionId | None,
        OrderSide order_side,
        OrderType order_type,
        Quantity last_qty not None,
        Price last_px not None,
        Currency currency not None,
        Money commission not None,
        LiquiditySide liquidity_side,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
        bint reconciliation=False,
        dict info = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NONE")
        Condition.positive_int(last_qty._mem.raw, "last_qty")

        if info is None:
            info = {}

        self._strategy_id = strategy_id
        self._trader_id = trader_id
        self._instrument_id = instrument_id
        self._client_order_id = client_order_id
        self._venue_order_id = venue_order_id
        self._account_id = account_id
        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init
        self._reconciliation = reconciliation

        self.trade_id = trade_id
        self.position_id = position_id
        self.order_side = order_side
        self.order_type = order_type
        self.last_qty = last_qty
        self.last_px = last_px
        self.currency = currency
        self.commission = commission
        self.liquidity_side = liquidity_side
        self.info = info

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"trade_id={self.trade_id}, "
            f"position_id={self.position_id}, "
            f"order_side={order_side_to_str(self.order_side)}, "
            f"order_type={order_type_to_str(self.order_type)}, "
            f"last_qty={self.last_qty.to_formatted_str()}, "
            f"last_px={self.last_px.to_formatted_str()} {self.currency.code}, "
            f"commission={self.commission.to_formatted_str()}, "
            f"liquidity_side={liquidity_side_to_str(self.liquidity_side)}, "
            f"ts_event={self.ts_event})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id}, "
            f"strategy_id={self.strategy_id}, "
            f"instrument_id={self.instrument_id}, "
            f"client_order_id={self.client_order_id}, "
            f"venue_order_id={self.venue_order_id}, "
            f"account_id={self.account_id}, "
            f"trade_id={self.trade_id}, "
            f"position_id={self.position_id}, "
            f"order_side={order_side_to_str(self.order_side)}, "
            f"order_type={order_type_to_str(self.order_type)}, "
            f"last_qty={self.last_qty.to_formatted_str()}, "
            f"last_px={self.last_px.to_formatted_str()} {self.currency.code}, "
            f"commission={self.commission.to_formatted_str()}, "
            f"liquidity_side={liquidity_side_to_str(self.liquidity_side)}, "
            f"event_id={self.id}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )

    def set_client_order_id(self, ClientOrderId client_order_id):
        self._client_order_id = client_order_id

    @property
    def trader_id(self) -> TraderId:
        """
        The trader ID associated with the event.

        Returns
        -------
        TraderId

        """
        return self._trader_id

    @property
    def strategy_id(self) -> TraderId:
        """
        The strategy ID associated with the event.

        Returns
        -------
        StrategyId

        """
        return self._strategy_id

    @property
    def instrument_id(self) -> InstrumentId:
        """
        The instrument ID associated with the event.

        Returns
        -------
        InstrumentId

        """
        return self._instrument_id

    @property
    def client_order_id(self) -> ClientOrderId:
        """
        The client order ID associated with the event.

        Returns
        -------
        ClientOrderId

        """
        return self._client_order_id

    @property
    def venue_order_id(self) -> VenueOrderId | None:
        """
        The venue order ID associated with the event.

        Returns
        -------
        VenueOrderId or ``None``

        """
        return self._venue_order_id

    @property
    def account_id(self) -> AccountId | None:
        """
        The account ID associated with the event.

        Returns
        -------
        AccountId or ``None``

        """
        return self._account_id

    @property
    def reconciliation(self) -> bool:
        """
        If the event was generated during reconciliation.

        Returns
        -------
        bool

        """
        return self._reconciliation

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef OrderFilled from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str position_id_str = values.get("position_id")
        return OrderFilled(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            client_order_id=ClientOrderId(values["client_order_id"]),
            venue_order_id=VenueOrderId(values["venue_order_id"]),
            account_id=AccountId(values["account_id"]),
            trade_id=TradeId(values["trade_id"]),
            position_id=PositionId(position_id_str) if position_id_str is not None else None,
            order_side=order_side_from_str(values["order_side"]),
            order_type=order_type_from_str(values["order_type"]),
            last_qty=Quantity.from_str_c(values["last_qty"]),
            last_px=Price.from_str_c(values["last_px"]),
            currency=Currency.from_str_c(values["currency"]),
            commission=Money.from_str_c(values["commission"]),
            liquidity_side=liquidity_side_from_str(values["liquidity_side"]),
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            info=values["info"],
            reconciliation=values.get("reconciliation", False),
        )

    @staticmethod
    cdef dict to_dict_c(OrderFilled obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OrderFilled",
            "trader_id": obj.trader_id.value,
            "strategy_id": obj.strategy_id.value,
            "instrument_id": obj.instrument_id.value,
            "client_order_id": obj.client_order_id.value,
            "venue_order_id": obj.venue_order_id.value,
            "account_id": obj.account_id.value,
            "trade_id": obj.trade_id.value,
            "position_id": obj.position_id.value if obj.position_id else None,
            "order_side": order_side_to_str(obj.order_side),
            "order_type": order_type_to_str(obj.order_type),
            "last_qty": str(obj.last_qty),
            "last_px": str(obj.last_px),
            "currency": obj.currency.code,
            "commission": str(obj.commission),
            "liquidity_side": liquidity_side_to_str(obj.liquidity_side),
            "event_id": obj.id.value,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "info": obj.info,
            "reconciliation": obj.reconciliation,
        }

    @staticmethod
    def from_dict(dict values) -> OrderFilled:
        """
        Return an order filled event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        OrderFilled

        """
        return OrderFilled.from_dict_c(values)

    @staticmethod
    def to_dict(OrderFilled obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OrderFilled.to_dict_c(obj)

    cdef bint is_buy_c(self):
        return self.order_side == OrderSide.BUY

    cdef bint is_sell_c(self):
        return self.order_side == OrderSide.SELL

    @property
    def is_buy(self):
        """
        Return whether the fill order side is ``BUY``.

        Returns
        -------
        bool

        """
        return self.is_buy_c()

    @property
    def is_sell(self):
        """
        Return whether the fill order side is ``SELL``.

        Returns
        -------
        bool

        """
        return self.is_sell_c()

</document_content>
</document>
<document index="2403">
<source>nautilus_trader/model/events/position.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.functions cimport order_side_from_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport position_adjustment_type_from_str
from nautilus_trader.model.functions cimport position_adjustment_type_to_str
from nautilus_trader.model.functions cimport position_side_from_str
from nautilus_trader.model.functions cimport position_side_to_str
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.position cimport Position


cdef class PositionEvent(Event):
    """
    The base class for all position events.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    position_id : PositionId
        The position IDt.
    account_id : AccountId
        The strategy ID.
    opening_order_id : ClientOrderId
        The client order ID for the order which opened the position.
    closing_order_id : ClientOrderId
        The client order ID for the order which closed the position.
    entry : OrderSide {``BUY``, ``SELL``}
        The position entry order side.
    side : PositionSide {``FLAT``, ``LONG``, ``SHORT``}
        The current position side.
    signed_qty : double
        The current signed quantity (positive for ``LONG``, negative for ``SHORT``).
    quantity : Quantity
        The current open quantity.
    peak_qty : Quantity
        The peak directional quantity reached by the position.
    last_qty : Quantity
        The last fill quantity for the position.
    last_px : Price
        The last fill price for the position (not average price).
    currency : Currency
        The position quote currency.
    avg_px_open : double
        The average open price.
    avg_px_close : double
        The average close price.
    realized_return : double
        The realized return for the position.
    realized_pnl : Money
        The realized PnL for the position.
    unrealized_pnl : Money
        The unrealized PnL for the position.
    event_id : UUID4
        The event ID.
    ts_opened : uint64_t
        UNIX timestamp (nanoseconds) when the position opened event occurred.
    ts_closed : uint64_t
        UNIX timestamp (nanoseconds) when the position closed event occurred.
    duration_ns : uint64_t
        The total open duration (nanoseconds), will be 0 if still open.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        PositionId position_id not None,
        AccountId account_id not None,
        ClientOrderId opening_order_id not None,
        ClientOrderId closing_order_id: ClientOrderId | None,
        OrderSide entry,
        PositionSide side,
        double signed_qty,
        Quantity quantity not None,
        Quantity peak_qty not None,
        Quantity last_qty not None,
        Price last_px not None,
        Currency currency not None,
        double avg_px_open,
        double avg_px_close,
        double realized_return,
        Money realized_pnl not None,
        Money unrealized_pnl not None,
        UUID4 event_id not None,
        uint64_t ts_opened,
        uint64_t ts_closed,
        uint64_t duration_ns,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        self.trader_id = trader_id
        self.strategy_id = strategy_id
        self.instrument_id = instrument_id
        self.position_id = position_id
        self.account_id = account_id
        self.opening_order_id = opening_order_id
        self.closing_order_id = closing_order_id
        self.entry = entry
        self.side = side
        self.signed_qty = signed_qty
        self.quantity = quantity
        self.peak_qty = peak_qty
        self.last_qty = last_qty
        self.last_px = last_px
        self.currency = currency
        self.avg_px_open = avg_px_open
        self.avg_px_close = avg_px_close
        self.realized_return = realized_return
        self.realized_pnl = realized_pnl
        self.unrealized_pnl = unrealized_pnl
        self.ts_opened = ts_opened
        self.ts_closed = ts_closed
        self.duration_ns = duration_ns

        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self._event_id == other.id

    def __hash__(self) -> int:
        return hash(self._event_id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id.to_str()}, "
            f"position_id={self.position_id.to_str()}, "
            f"account_id={self.account_id.to_str()}, "
            f"opening_order_id={self.opening_order_id.to_str()}, "
            f"closing_order_id={self.closing_order_id}, "  # Can be None
            f"entry={order_side_to_str(self.entry)}, "
            f"side={position_side_to_str(self.side)}, "
            f"signed_qty={self.signed_qty}, "
            f"quantity={self.quantity.to_formatted_str()}, "
            f"peak_qty={self.peak_qty.to_formatted_str()}, "
            f"currency={self.currency.code}, "
            f"avg_px_open={self.avg_px_open}, "
            f"avg_px_close={self.avg_px_close}, "
            f"realized_return={self.realized_return:.5f}, "
            f"realized_pnl={self.realized_pnl.to_formatted_str()}, "
            f"unrealized_pnl={self.unrealized_pnl.to_formatted_str()}, "
            f"ts_opened={self.ts_opened}, "
            f"ts_last={self.ts_event}, "
            f"ts_closed={self.ts_closed}, "
            f"duration_ns={self.duration_ns})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"position_id={self.position_id.to_str()}, "
            f"account_id={self.account_id.to_str()}, "
            f"opening_order_id={self.opening_order_id.to_str()}, "
            f"closing_order_id={self.closing_order_id}, "  # Can be None
            f"entry={order_side_to_str(self.entry)}, "
            f"side={position_side_to_str(self.side)}, "
            f"signed_qty={self.signed_qty}, "
            f"quantity={self.quantity.to_formatted_str()}, "
            f"peak_qty={self.peak_qty.to_formatted_str()}, "
            f"currency={self.currency.code}, "
            f"avg_px_open={self.avg_px_open}, "
            f"avg_px_close={self.avg_px_close}, "
            f"realized_return={self.realized_return:.5f}, "
            f"realized_pnl={self.realized_pnl.to_formatted_str()}, "
            f"unrealized_pnl={self.unrealized_pnl.to_formatted_str()}, "
            f"ts_opened={self.ts_opened}, "
            f"ts_last={self._ts_event}, "
            f"ts_closed={self.ts_closed}, "
            f"duration_ns={self.duration_ns}, "
            f"event_id={self._event_id.to_str()})"
        )

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init


cdef class PositionOpened(PositionEvent):
    """
    Represents an event where a position has been opened.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    position_id : PositionId
        The position IDt.
    account_id : AccountId
        The strategy ID.
    opening_order_id : ClientOrderId
        The client order ID for the order which opened the position.
    strategy_id : StrategyId
        The strategy ID associated with the event.
    entry : OrderSide {``BUY``, ``SELL``}
        The position entry order side.
    side : PositionSide {``LONG``, ``SHORT``}
        The current position side.
    signed_qty : double
        The current signed quantity (positive for ``LONG``, negative for ``SHORT``).
    quantity : Quantity
        The current open quantity.
    peak_qty : Quantity
        The peak directional quantity reached by the position.
    last_qty : Quantity
        The last fill quantity for the position.
    last_px : Price
        The last fill price for the position (not average price).
    currency : Currency
        The position quote currency.
    avg_px_open : double
        The average open price.
    realized_pnl : Money
        The realized PnL for the position.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the position opened event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        PositionId position_id not None,
        AccountId account_id not None,
        ClientOrderId opening_order_id not None,
        OrderSide entry,
        PositionSide side,
        double signed_qty,
        Quantity quantity not None,
        Quantity peak_qty not None,
        Quantity last_qty not None,
        Price last_px not None,
        Currency currency not None,
        double avg_px_open,
        Money realized_pnl not None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        assert side != PositionSide.FLAT  # Design-time check: position side matches event
        super().__init__(
            trader_id,
            strategy_id,
            instrument_id,
            position_id,
            account_id,
            opening_order_id,
            None,  # Position is still open
            entry,
            side,
            signed_qty,
            quantity,
            peak_qty,
            last_qty,
            last_px,
            currency,
            avg_px_open,
            0.0,
            0.0,
            realized_pnl,
            Money(0, realized_pnl.currency),
            event_id,
            ts_event,
            0,
            0,
            ts_event,
            ts_init,
        )

    @staticmethod
    cdef PositionOpened create_c(
        Position position,
        OrderFilled fill,
        UUID4 event_id,
        uint64_t ts_init,
    ):
        Condition.not_none(position, "position")
        Condition.not_none(fill, "fill")
        Condition.not_none(event_id, "event_id")

        return PositionOpened(
            trader_id=position.trader_id,
            strategy_id=position.strategy_id,
            instrument_id=position.instrument_id,
            position_id=position.id,
            account_id=position.account_id,
            opening_order_id=position.opening_order_id,
            entry=position.entry,
            side=position.side,
            signed_qty=position.signed_qty,
            quantity=position.quantity,
            peak_qty=position.peak_qty,
            last_qty=fill.last_qty,
            last_px=fill.last_px,
            currency=position.quote_currency,
            avg_px_open=position.avg_px_open,
            realized_pnl=position.realized_pnl,
            event_id=event_id,
            ts_event=position.ts_opened,
            ts_init=ts_init,
        )

    @staticmethod
    cdef PositionOpened from_dict_c(dict values):
        Condition.not_none(values, "values")
        return PositionOpened(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            position_id=PositionId(values["position_id"]),
            account_id=AccountId(values["account_id"]),
            opening_order_id=ClientOrderId(values["opening_order_id"]),
            entry=order_side_from_str(values["entry"]),
            side=position_side_from_str(values["side"]),
            signed_qty=values["signed_qty"],
            quantity=Quantity.from_str_c(values["quantity"]),
            peak_qty=Quantity.from_str_c(values["peak_qty"]),
            last_qty=Quantity.from_str_c(values["last_qty"]),
            last_px=Price.from_str_c(values["last_px"]),
            currency=Currency.from_str_c(values["currency"]),
            avg_px_open=values["avg_px_open"],
            realized_pnl=Money.from_str_c(values["realized_pnl"]),
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(PositionOpened obj):
        Condition.not_none(obj, "obj")
        return {
            "type": type(obj).__name__,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "position_id": obj.position_id.to_str(),
            "account_id": obj.account_id.to_str(),
            "opening_order_id": obj.opening_order_id.to_str(),
            "entry": order_side_to_str(obj.entry),
            "side": position_side_to_str(obj.side),
            "signed_qty": obj.signed_qty,
            "quantity": str(obj.quantity),
            "peak_qty": str(obj.peak_qty),
            "last_qty": str(obj.last_qty),
            "last_px": str(obj.last_px),
            "currency": obj.currency.code,
            "avg_px_open": obj.avg_px_open,
            "realized_pnl": str(obj.realized_pnl),
            "duration_ns": obj.duration_ns,
            "event_id": obj._event_id.to_str(),
            "ts_event": obj._ts_event,
            "ts_init": obj._ts_init,
        }

    @staticmethod
    def create(
        Position position,
        OrderFilled fill,
        UUID4 event_id,
        uint64_t ts_init,
    ):
        """
        Return a position opened event from the given params.

        Parameters
        ----------
        position : Position
            The position for the event.
        fill : OrderFilled
            The order fill for the event.
        event_id : UUID4
            The event ID.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        PositionOpened

        """
        return PositionOpened.create_c(position, fill, event_id, ts_init)

    @staticmethod
    def from_dict(dict values) -> PositionOpened:
        """
        Return a position opened event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        PositionOpened

        """
        return PositionOpened.from_dict_c(values)

    @staticmethod
    def to_dict(PositionOpened obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return PositionOpened.to_dict_c(obj)


cdef class PositionChanged(PositionEvent):
    """
    Represents an event where a position has changed.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    position_id : PositionId
        The position IDt.
    account_id : AccountId
        The strategy ID.
    opening_order_id : ClientOrderId
        The client order ID for the order which opened the position.
    strategy_id : StrategyId
        The strategy ID associated with the event.
    entry : OrderSide {``BUY``, ``SELL``}
        The position entry order side.
    side : PositionSide {``FLAT``, ``LONG``, ``SHORT``}
        The current position side.
    signed_qty : double
        The current signed quantity (positive for ``LONG``, negative for ``SHORT``).
    quantity : Quantity
        The current open quantity.
    peak_qty : Quantity
        The peak directional quantity reached by the position.
    last_qty : Quantity
        The last fill quantity for the position.
    last_px : Price
        The last fill price for the position (not average price).
    currency : Currency
        The position quote currency.
    avg_px_open : double
        The average open price.
    avg_px_close : double
        The average close price.
    realized_return : double
        The realized return for the position.
    realized_pnl : Money
        The realized PnL for the position.
    unrealized_pnl : Money
        The unrealized PnL for the position.
    event_id : UUID4
        The event ID.
    ts_opened : uint64_t
        UNIX timestamp (nanoseconds) when the position opened event occurred.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the position changed event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        PositionId position_id not None,
        AccountId account_id not None,
        ClientOrderId opening_order_id not None,
        OrderSide entry,
        PositionSide side,
        double signed_qty,
        Quantity quantity not None,
        Quantity peak_qty not None,
        Quantity last_qty not None,
        Price last_px not None,
        Currency currency not None,
        double avg_px_open,
        double avg_px_close,
        double realized_return,
        Money realized_pnl not None,
        Money unrealized_pnl not None,
        UUID4 event_id not None,
        uint64_t ts_opened,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        assert side != PositionSide.FLAT  # Design-time check: position side matches event
        super().__init__(
            trader_id,
            strategy_id,
            instrument_id,
            position_id,
            account_id,
            opening_order_id,
            None,  # Position is still open
            entry,
            side,
            signed_qty,
            quantity,
            peak_qty,
            last_qty,
            last_px,
            currency,
            avg_px_open,
            avg_px_close,
            realized_return,
            realized_pnl,
            unrealized_pnl,
            event_id,
            ts_opened,
            0,
            0,
            ts_event,
            ts_init,
        )

    @staticmethod
    cdef PositionChanged create_c(
        Position position,
        OrderFilled fill,
        UUID4 event_id,
        uint64_t ts_init,
    ):
        Condition.not_none(position, "position")
        Condition.not_none(fill, "fill")
        Condition.not_none(event_id, "event_id")

        return PositionChanged(
            trader_id=position.trader_id,
            strategy_id=position.strategy_id,
            instrument_id=position.instrument_id,
            position_id=position.id,
            account_id=position.account_id,
            opening_order_id=position.opening_order_id,
            entry=position.entry,
            side=position.side,
            signed_qty=position.signed_qty,
            quantity=position.quantity,
            peak_qty=position.peak_qty,
            last_qty=fill.last_qty,
            last_px=fill.last_px,
            currency=position.quote_currency,
            avg_px_open=position.avg_px_open,
            avg_px_close=position.avg_px_close,
            realized_return=position.realized_return,
            realized_pnl=position.realized_pnl,
            unrealized_pnl=position.unrealized_pnl(fill.last_px),
            event_id=event_id,
            ts_opened=position.ts_opened,
            ts_event=position.last_event_c().ts_event,
            ts_init=ts_init,
        )

    @staticmethod
    cdef PositionChanged from_dict_c(dict values):
        Condition.not_none(values, "values")
        return PositionChanged(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            position_id=PositionId(values["position_id"]),
            account_id=AccountId(values["account_id"]),
            opening_order_id=ClientOrderId(values["opening_order_id"]),
            entry=order_side_from_str(values["entry"]),
            side=position_side_from_str(values["side"]),
            signed_qty=values["signed_qty"],
            quantity=Quantity.from_str_c(values["quantity"]),
            peak_qty=Quantity.from_str_c(values["peak_qty"]),
            last_qty=Quantity.from_str_c(values["last_qty"]),
            last_px=Price.from_str_c(values["last_px"]),
            currency=Currency.from_str_c(values["currency"]),
            avg_px_open=values["avg_px_open"],
            avg_px_close=values["avg_px_close"],
            realized_return=values["realized_return"],
            realized_pnl=Money.from_str_c(values["realized_pnl"]),
            unrealized_pnl=Money.from_str_c(values["unrealized_pnl"]),
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_opened=values["ts_opened"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(PositionChanged obj):
        Condition.not_none(obj, "obj")
        return {
            "type": type(obj).__name__,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "position_id": obj.position_id.to_str(),
            "account_id": obj.account_id.to_str(),
            "opening_order_id": obj.opening_order_id.to_str(),
            "entry": order_side_to_str(obj.entry),
            "side": position_side_to_str(obj.side),
            "signed_qty": obj.signed_qty,
            "quantity": str(obj.quantity),
            "peak_qty": str(obj.peak_qty),
            "last_qty": str(obj.last_qty),
            "last_px": str(obj.last_px),
            "currency": obj.currency.code,
            "avg_px_open": obj.avg_px_open,
            "avg_px_close": obj.avg_px_close,
            "realized_return": obj.realized_return,
            "realized_pnl": str(obj.realized_pnl),
            "unrealized_pnl": str(obj.unrealized_pnl),
            "event_id": obj._event_id.to_str(),
            "ts_opened": obj.ts_opened,
            "ts_event": obj._ts_event,
            "ts_init": obj._ts_init,
        }

    @staticmethod
    def create(
        Position position,
        OrderFilled fill,
        UUID4 event_id,
        uint64_t ts_init,
    ):
        """
        Return a position changed event from the given params.

        Parameters
        ----------
        position : Position
            The position for the event.
        fill : OrderFilled
            The order fill for the event.
        event_id : UUID4
            The event ID.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        PositionChanged

        """
        return PositionChanged.create_c(position, fill, event_id, ts_init)

    @staticmethod
    def from_dict(dict values) -> PositionChanged:
        """
        Return a position changed event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        PositionChanged

        """
        return PositionChanged.from_dict_c(values)

    @staticmethod
    def to_dict(PositionChanged obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return PositionChanged.to_dict_c(obj)


cdef class PositionClosed(PositionEvent):
    """
    Represents an event where a position has been closed.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    position_id : PositionId
        The position IDt.
    account_id : AccountId
        The strategy ID.
    opening_order_id : ClientOrderId
        The client order ID for the order which opened the position.
    closing_order_id : ClientOrderId
        The client order ID for the order which closed the position.
    strategy_id : StrategyId
        The strategy ID associated with the event.
    entry : OrderSide {``BUY``, ``SELL``}
        The position entry order side.
    side : PositionSide {``FLAT``}
        The current position side.
    signed_qty : double
        The current signed quantity (positive for ``LONG``, negative for ``SHORT``).
    quantity : Quantity
        The current open quantity.
    peak_qty : Quantity
        The peak directional quantity reached by the position.
    last_qty : Quantity
        The last fill quantity for the position.
    last_px : Price
        The last fill price for the position (not average price).
    currency : Currency
        The position quote currency.
    avg_px_open : Decimal
        The average open price.
    avg_px_close : Decimal
        The average close price.
    realized_return : Decimal
        The realized return for the position.
    realized_pnl : Money
        The realized PnL for the position.
    event_id : UUID4
        The event ID.
    ts_opened : uint64_t
        UNIX timestamp (nanoseconds) when the position opened event occurred.
    ts_closed : uint64_t
        UNIX timestamp (nanoseconds) when the position closed event occurred.
    duration_ns : uint64_t
        The total open duration (nanoseconds).
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        PositionId position_id not None,
        AccountId account_id not None,
        ClientOrderId opening_order_id not None,
        ClientOrderId closing_order_id not None,
        OrderSide entry,
        PositionSide side,
        double signed_qty,
        Quantity quantity not None,
        Quantity peak_qty not None,
        Quantity last_qty not None,
        Price last_px not None,
        Currency currency not None,
        double avg_px_open,
        double avg_px_close,
        double realized_return,
        Money realized_pnl not None,
        UUID4 event_id not None,
        uint64_t ts_opened,
        uint64_t ts_closed,
        uint64_t duration_ns,
        uint64_t ts_init,
    ):
        assert side == PositionSide.FLAT  # Design-time check: position side matches event

        super().__init__(
            trader_id,
            strategy_id,
            instrument_id,
            position_id,
            account_id,
            opening_order_id,
            closing_order_id,
            entry,
            side,
            signed_qty,
            quantity,
            peak_qty,
            last_qty,
            last_px,
            currency,
            avg_px_open,
            avg_px_close,
            realized_return,
            realized_pnl,
            Money(0, realized_pnl.currency),  # No further unrealized PnL
            event_id,
            ts_opened,
            ts_closed,
            duration_ns,
            ts_closed,  # ts_event = ts_closed
            ts_init,
        )

    @staticmethod
    cdef PositionClosed create_c(
        Position position,
        OrderFilled fill,
        UUID4 event_id,
        uint64_t ts_init,
    ):
        Condition.not_none(position, "position")
        Condition.not_none(fill, "fill")
        Condition.not_none(event_id, "event_id")

        return PositionClosed(
            trader_id=position.trader_id,
            strategy_id=position.strategy_id,
            instrument_id=position.instrument_id,
            position_id=position.id,
            account_id=position.account_id,
            opening_order_id=position.opening_order_id,
            closing_order_id=position.closing_order_id,
            entry=position.entry,
            side=position.side,
            signed_qty=position.signed_qty,
            quantity=position.quantity,
            peak_qty=position.peak_qty,
            last_qty=fill.last_qty,
            last_px=fill.last_px,
            currency=position.quote_currency,
            avg_px_open=position.avg_px_open,
            avg_px_close=position.avg_px_close,
            realized_return=position.realized_return,
            realized_pnl=position.realized_pnl,
            event_id=event_id,
            ts_opened=position.ts_opened,
            ts_closed=position.ts_closed,
            duration_ns=position.duration_ns,
            ts_init=ts_init,
        )

    @staticmethod
    cdef PositionClosed from_dict_c(dict values):
        Condition.not_none(values, "values")
        return PositionClosed(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            position_id=PositionId(values["position_id"]),
            account_id=AccountId(values["account_id"]),
            opening_order_id=ClientOrderId(values["opening_order_id"]),
            closing_order_id=ClientOrderId(values["closing_order_id"]),
            entry=order_side_from_str(values["entry"]),
            side=position_side_from_str(values["side"]),
            signed_qty=values["signed_qty"],
            quantity=Quantity.from_str_c(values["quantity"]),
            peak_qty=Quantity.from_str_c(values["peak_qty"]),
            last_qty=Quantity.from_str_c(values["last_qty"]),
            last_px=Price.from_str_c(values["last_px"]),
            currency=Currency.from_str_c(values["currency"]),
            avg_px_open=values["avg_px_open"],
            avg_px_close=values["avg_px_close"],
            realized_return=values["realized_return"],
            realized_pnl=Money.from_str_c(values["realized_pnl"]),
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_opened=values["ts_opened"],
            ts_closed=values["ts_closed"],
            duration_ns=values["duration_ns"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(PositionClosed obj):
        Condition.not_none(obj, "obj")
        return {
            "type": type(obj).__name__,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "position_id": obj.position_id.to_str(),
            "account_id": obj.account_id.to_str(),
            "opening_order_id": obj.opening_order_id.to_str(),
            "closing_order_id": obj.closing_order_id.to_str(),
            "entry": order_side_to_str(obj.entry),
            "side": position_side_to_str(obj.side),
            "signed_qty": obj.signed_qty,
            "quantity": str(obj.quantity),
            "peak_qty": str(obj.peak_qty),
            "last_qty": str(obj.last_qty),
            "last_px": str(obj.last_px),
            "currency": obj.currency.code,
            "avg_px_open": obj.avg_px_open,
            "avg_px_close": obj.avg_px_close,
            "realized_return": obj.realized_return,
            "realized_pnl": str(obj.realized_pnl),
            "event_id": obj._event_id.to_str(),
            "ts_opened": obj.ts_opened,
            "ts_closed": obj.ts_closed,
            "duration_ns": obj.duration_ns,
            "ts_init": obj._ts_init,
        }

    @staticmethod
    def create(
        Position position,
        OrderFilled fill,
        UUID4 event_id,
        uint64_t ts_init,
    ):
        """
        Return a position closed event from the given params.

        Parameters
        ----------
        position : Position
            The position for the event.
        fill : OrderFilled
            The order fill for the event.
        event_id : UUID4
            The event ID.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        PositionClosed

        """
        return PositionClosed.create_c(position, fill, event_id, ts_init)

    @staticmethod
    def from_dict(dict values) -> PositionClosed:
        """
        Return a position closed event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        PositionClosed

        """
        return PositionClosed.from_dict_c(values)

    @staticmethod
    def to_dict(PositionClosed obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return PositionClosed.to_dict_c(obj)


cdef class PositionAdjusted(Event):
    """
    Represents an adjustment to a position's quantity or realized PnL.

    This event is used to track changes to positions that occur outside of normal
    order fills, such as commission adjustments or funding payments.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID.
    strategy_id : StrategyId
        The strategy ID.
    instrument_id : InstrumentId
        The instrument ID.
    position_id : PositionId
        The position ID.
    account_id : AccountId
        The account ID.
    adjustment_type : PositionAdjustmentType
        The type of adjustment.
    quantity_change : Decimal | None
        The quantity change (positive increases quantity, negative decreases).
    pnl_change : Money | None
        The PnL change.
    reason : str | None
        Optional reason or reference for the adjustment.
    event_id : UUID4
        The event ID.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        PositionId position_id not None,
        AccountId account_id not None,
        PositionAdjustmentType adjustment_type,
        object quantity_change,
        Money pnl_change: Money | None,
        str reason: str | None,
        UUID4 event_id not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        self.trader_id = trader_id
        self.strategy_id = strategy_id
        self.instrument_id = instrument_id
        self.position_id = position_id
        self.account_id = account_id
        self.adjustment_type = adjustment_type
        self.quantity_change = Decimal(str(quantity_change)) if quantity_change is not None else None
        self.pnl_change = pnl_change
        self.reason = reason

        self._event_id = event_id
        self._ts_event = ts_event
        self._ts_init = ts_init

    def __eq__(self, Event other) -> bool:
        if other is None:
            return False
        return self._event_id == other.id

    def __hash__(self) -> int:
        return hash(self._event_id)

    def __str__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id.to_str()}, "
            f"position_id={self.position_id.to_str()}, "
            f"account_id={self.account_id.to_str()}, "
            f"adjustment_type={self.adjustment_type}, "
            f"quantity_change={self.quantity_change}, "
            f"pnl_change={self.pnl_change}, "
            f"reason={self.reason})"
        )

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"trader_id={self.trader_id.to_str()}, "
            f"strategy_id={self.strategy_id.to_str()}, "
            f"instrument_id={self.instrument_id.to_str()}, "
            f"position_id={self.position_id.to_str()}, "
            f"account_id={self.account_id.to_str()}, "
            f"adjustment_type={self.adjustment_type}, "
            f"quantity_change={self.quantity_change}, "
            f"pnl_change={self.pnl_change}, "
            f"reason={self.reason}, "
            f"event_id={self._event_id.to_str()})"
        )

    @property
    def id(self) -> UUID4:
        """
        The event message identifier.

        Returns
        -------
        UUID4

        """
        return self._event_id

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the event occurred.

        Returns
        -------
        int

        """
        return self._ts_event

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return self._ts_init

    @staticmethod
    cdef PositionAdjusted from_dict_c(dict values):
        Condition.not_none(values, "values")

        cdef str reason = values.get("reason")

        cdef object quantity_change = None
        if values.get("quantity_change") is not None:
            quantity_change = Decimal(values["quantity_change"])

        cdef Money pnl_change = None
        if values.get("pnl_change") is not None:
            pnl_change = Money.from_str_c(values["pnl_change"])

        cdef str adj_type_value = values["adjustment_type"]
        cdef PositionAdjustmentType adjustment_type = position_adjustment_type_from_str(adj_type_value)

        return PositionAdjusted(
            trader_id=TraderId(values["trader_id"]),
            strategy_id=StrategyId(values["strategy_id"]),
            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
            position_id=PositionId(values["position_id"]),
            account_id=AccountId(values["account_id"]),
            adjustment_type=adjustment_type,
            quantity_change=quantity_change,
            pnl_change=pnl_change,
            reason=reason,
            event_id=UUID4.from_str_c(values["event_id"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(PositionAdjusted obj):
        Condition.not_none(obj, "obj")

        cdef str adjustment_type_str
        if obj.adjustment_type == PositionAdjustmentType.COMMISSION:
            adjustment_type_str = "COMMISSION"
        elif obj.adjustment_type == PositionAdjustmentType.FUNDING:
            adjustment_type_str = "FUNDING"
        else:
            adjustment_type_str = "UNKNOWN"

        return {
            "type": type(obj).__name__,
            "trader_id": obj.trader_id.to_str(),
            "strategy_id": obj.strategy_id.to_str(),
            "instrument_id": obj.instrument_id.to_str(),
            "position_id": obj.position_id.to_str(),
            "account_id": obj.account_id.to_str(),
            "adjustment_type": adjustment_type_str,
            "quantity_change": str(obj.quantity_change) if obj.quantity_change is not None else None,
            "pnl_change": str(obj.pnl_change) if obj.pnl_change is not None else None,
            "reason": obj.reason,
            "event_id": obj._event_id.to_str(),
            "ts_event": obj._ts_event,
            "ts_init": obj._ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> PositionAdjusted:
        """
        Return a position adjustment event from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        PositionAdjusted

        """
        return PositionAdjusted.from_dict_c(values)

    @staticmethod
    def to_dict(PositionAdjusted obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return PositionAdjusted.to_dict_c(obj)

</document_content>
</document>
<document index="2405">
<source>nautilus_trader/model/functions.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.core import nautilus_pyo3

from libc.stdint cimport uint8_t

from nautilus_trader.core.rust.model cimport account_type_from_cstr
from nautilus_trader.core.rust.model cimport account_type_to_cstr
from nautilus_trader.core.rust.model cimport aggregation_source_from_cstr
from nautilus_trader.core.rust.model cimport aggregation_source_to_cstr
from nautilus_trader.core.rust.model cimport aggressor_side_from_cstr
from nautilus_trader.core.rust.model cimport aggressor_side_to_cstr
from nautilus_trader.core.rust.model cimport asset_class_from_cstr
from nautilus_trader.core.rust.model cimport asset_class_to_cstr
from nautilus_trader.core.rust.model cimport bar_aggregation_from_cstr
from nautilus_trader.core.rust.model cimport bar_aggregation_to_cstr
from nautilus_trader.core.rust.model cimport book_action_from_cstr
from nautilus_trader.core.rust.model cimport book_action_to_cstr
from nautilus_trader.core.rust.model cimport book_type_from_cstr
from nautilus_trader.core.rust.model cimport book_type_to_cstr
from nautilus_trader.core.rust.model cimport contingency_type_from_cstr
from nautilus_trader.core.rust.model cimport contingency_type_to_cstr
from nautilus_trader.core.rust.model cimport currency_type_from_cstr
from nautilus_trader.core.rust.model cimport currency_type_to_cstr
from nautilus_trader.core.rust.model cimport instrument_class_from_cstr
from nautilus_trader.core.rust.model cimport instrument_class_to_cstr
from nautilus_trader.core.rust.model cimport instrument_close_type_from_cstr
from nautilus_trader.core.rust.model cimport instrument_close_type_to_cstr
from nautilus_trader.core.rust.model cimport liquidity_side_from_cstr
from nautilus_trader.core.rust.model cimport liquidity_side_to_cstr
from nautilus_trader.core.rust.model cimport market_status_action_from_cstr
from nautilus_trader.core.rust.model cimport market_status_action_to_cstr
from nautilus_trader.core.rust.model cimport market_status_from_cstr
from nautilus_trader.core.rust.model cimport market_status_to_cstr
from nautilus_trader.core.rust.model cimport oms_type_from_cstr
from nautilus_trader.core.rust.model cimport oms_type_to_cstr
from nautilus_trader.core.rust.model cimport option_kind_from_cstr
from nautilus_trader.core.rust.model cimport option_kind_to_cstr
from nautilus_trader.core.rust.model cimport order_side_from_cstr
from nautilus_trader.core.rust.model cimport order_side_to_cstr
from nautilus_trader.core.rust.model cimport order_status_from_cstr
from nautilus_trader.core.rust.model cimport order_status_to_cstr
from nautilus_trader.core.rust.model cimport order_type_from_cstr
from nautilus_trader.core.rust.model cimport order_type_to_cstr
from nautilus_trader.core.rust.model cimport position_adjustment_type_from_cstr
from nautilus_trader.core.rust.model cimport position_adjustment_type_to_cstr
from nautilus_trader.core.rust.model cimport position_side_from_cstr
from nautilus_trader.core.rust.model cimport position_side_to_cstr
from nautilus_trader.core.rust.model cimport price_type_from_cstr
from nautilus_trader.core.rust.model cimport price_type_to_cstr
from nautilus_trader.core.rust.model cimport record_flag_from_cstr
from nautilus_trader.core.rust.model cimport record_flag_to_cstr
from nautilus_trader.core.rust.model cimport time_in_force_from_cstr
from nautilus_trader.core.rust.model cimport time_in_force_to_cstr
from nautilus_trader.core.rust.model cimport trading_state_from_cstr
from nautilus_trader.core.rust.model cimport trading_state_to_cstr
from nautilus_trader.core.rust.model cimport trailing_offset_type_from_cstr
from nautilus_trader.core.rust.model cimport trailing_offset_type_to_cstr
from nautilus_trader.core.rust.model cimport trigger_type_from_cstr
from nautilus_trader.core.rust.model cimport trigger_type_to_cstr
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.core.string cimport pystr_to_cstr


cpdef AccountType account_type_from_str(str value):
    return account_type_from_cstr(pystr_to_cstr(value))


cpdef str account_type_to_str(AccountType value):
    return cstr_to_pystr(account_type_to_cstr(value))


cpdef AggregationSource aggregation_source_from_str(str value):
    return aggregation_source_from_cstr(pystr_to_cstr(value))


cpdef str aggregation_source_to_str(AggregationSource value):
    return cstr_to_pystr(aggregation_source_to_cstr(value))


cpdef AggressorSide aggressor_side_from_str(str value):
    return aggressor_side_from_cstr(pystr_to_cstr(value))


cpdef str aggressor_side_to_str(AggressorSide value):
    return cstr_to_pystr(aggressor_side_to_cstr(value))


cpdef AssetClass asset_class_from_str(str value):
    return asset_class_from_cstr(pystr_to_cstr(value))


cpdef str asset_class_to_str(AssetClass value):
    return cstr_to_pystr(asset_class_to_cstr(value))


cpdef InstrumentClass instrument_class_from_str(str value):
    return instrument_class_from_cstr(pystr_to_cstr(value))


cpdef str instrument_class_to_str(InstrumentClass value):
    return cstr_to_pystr(instrument_class_to_cstr(value))


cpdef BarAggregation bar_aggregation_from_str(str value):
    return <BarAggregation>bar_aggregation_from_cstr(pystr_to_cstr(value))


cpdef str bar_aggregation_to_str(BarAggregation value):
    return cstr_to_pystr(bar_aggregation_to_cstr(<uint8_t>value))


cpdef BookAction book_action_from_str(str value):
    return book_action_from_cstr(pystr_to_cstr(value))


cpdef str book_action_to_str(BookAction value):
    return cstr_to_pystr(book_action_to_cstr(value))


cpdef BookType book_type_from_str(str value):
    return book_type_from_cstr(pystr_to_cstr(value))


cpdef str book_type_to_str(BookType value):
    return cstr_to_pystr(book_type_to_cstr(value))


cpdef ContingencyType contingency_type_from_str(str value):
    return contingency_type_from_cstr(pystr_to_cstr(value))


cpdef str contingency_type_to_str(ContingencyType value):
    return cstr_to_pystr(contingency_type_to_cstr(value))


cpdef CurrencyType currency_type_from_str(str value):
    return currency_type_from_cstr(pystr_to_cstr(value))


cpdef str currency_type_to_str(CurrencyType value):
    return cstr_to_pystr(currency_type_to_cstr(value))


cpdef InstrumentCloseType instrument_close_type_from_str(str value):
    return instrument_close_type_from_cstr(pystr_to_cstr(value))


cpdef str instrument_close_type_to_str(InstrumentCloseType value):
    return cstr_to_pystr(instrument_close_type_to_cstr(value))


cpdef LiquiditySide liquidity_side_from_str(str value):
    return liquidity_side_from_cstr(pystr_to_cstr(value))


cpdef str liquidity_side_to_str(LiquiditySide value):
    return cstr_to_pystr(liquidity_side_to_cstr(value))


cpdef MarketStatus market_status_from_str(str value):
    return market_status_from_cstr(pystr_to_cstr(value))


cpdef str market_status_to_str(MarketStatus value):
    return cstr_to_pystr(market_status_to_cstr(value))


cpdef MarketStatusAction market_status_action_from_str(str value):
    return market_status_action_from_cstr(pystr_to_cstr(value))


cpdef str market_status_action_to_str(MarketStatusAction value):
    return cstr_to_pystr(market_status_action_to_cstr(value))


cpdef OmsType oms_type_from_str(str value):
    return oms_type_from_cstr(pystr_to_cstr(value))


cpdef str oms_type_to_str(OmsType value):
    return cstr_to_pystr(oms_type_to_cstr(value))


cpdef OptionKind option_kind_from_str(str value):
    return option_kind_from_cstr(pystr_to_cstr(value))


cpdef str option_kind_to_str(OptionKind value):
    return cstr_to_pystr(option_kind_to_cstr(value))


cpdef OrderSide order_side_from_str(str value):
    return order_side_from_cstr(pystr_to_cstr(value))


cpdef str order_side_to_str(OrderSide value):
    return cstr_to_pystr(order_side_to_cstr(value))


cpdef OrderStatus order_status_from_str(str value):
    return order_status_from_cstr(pystr_to_cstr(value))


cpdef str order_status_to_str(OrderStatus value):
    return cstr_to_pystr(order_status_to_cstr(value))


cpdef OrderType order_type_from_str(str value):
    return order_type_from_cstr(pystr_to_cstr(value))


cpdef str order_type_to_str(OrderType value):
    return cstr_to_pystr(order_type_to_cstr(value))


cpdef RecordFlag record_flag_from_str(str value):
    return record_flag_from_cstr(pystr_to_cstr(value))


cpdef str record_flag_to_str(RecordFlag value):
    return cstr_to_pystr(record_flag_to_cstr(value))


cpdef PositionSide position_side_from_str(str value):
    return position_side_from_cstr(pystr_to_cstr(value))


cpdef str position_side_to_str(PositionSide value):
    return cstr_to_pystr(position_side_to_cstr(value))


cpdef PositionAdjustmentType position_adjustment_type_from_str(str value):
    return position_adjustment_type_from_cstr(pystr_to_cstr(value))


cpdef str position_adjustment_type_to_str(PositionAdjustmentType value):
    return cstr_to_pystr(position_adjustment_type_to_cstr(value))


cpdef PriceType price_type_from_str(str value):
    return price_type_from_cstr(pystr_to_cstr(value))


cpdef str price_type_to_str(PriceType value):
    return cstr_to_pystr(price_type_to_cstr(value))


cpdef TimeInForce time_in_force_from_str(str value):
    return time_in_force_from_cstr(pystr_to_cstr(value))


cpdef str time_in_force_to_str(TimeInForce value):
    return cstr_to_pystr(time_in_force_to_cstr(value))


cpdef TradingState trading_state_from_str(str value):
    return trading_state_from_cstr(pystr_to_cstr(value))


cpdef str trading_state_to_str(TradingState value):
    return cstr_to_pystr(trading_state_to_cstr(value))


cpdef TrailingOffsetType trailing_offset_type_from_str(str value):
    return trailing_offset_type_from_cstr(pystr_to_cstr(value))


cpdef str trailing_offset_type_to_str(TrailingOffsetType value):
    return cstr_to_pystr(trailing_offset_type_to_cstr(value))


cpdef TriggerType trigger_type_from_str(str value):
    return trigger_type_from_cstr(pystr_to_cstr(value))


cpdef str trigger_type_to_str(TriggerType value):
    return cstr_to_pystr(trigger_type_to_cstr(value))


cpdef order_side_to_pyo3(OrderSide value):
    if value == OrderSide.BUY:
        return nautilus_pyo3.OrderSide.BUY
    if value == OrderSide.SELL:
        return nautilus_pyo3.OrderSide.SELL
    if value == OrderSide.NO_ORDER_SIDE:
        return nautilus_pyo3.OrderSide.NO_ORDER_SIDE

    raise ValueError(f"Unsupported `OrderSide`, was '{order_side_to_str(value)}'")


cpdef order_type_to_pyo3(OrderType value):
    if value == OrderType.MARKET:
        return nautilus_pyo3.OrderType.MARKET
    if value == OrderType.LIMIT:
        return nautilus_pyo3.OrderType.LIMIT
    if value == OrderType.STOP_MARKET:
        return nautilus_pyo3.OrderType.STOP_MARKET
    if value == OrderType.STOP_LIMIT:
        return nautilus_pyo3.OrderType.STOP_LIMIT
    if value == OrderType.MARKET_TO_LIMIT:
        return nautilus_pyo3.OrderType.MARKET_TO_LIMIT
    if value == OrderType.MARKET_IF_TOUCHED:
        return nautilus_pyo3.OrderType.MARKET_IF_TOUCHED
    if value == OrderType.LIMIT_IF_TOUCHED:
        return nautilus_pyo3.OrderType.LIMIT_IF_TOUCHED
    if value == OrderType.TRAILING_STOP_MARKET:
        return nautilus_pyo3.OrderType.TRAILING_STOP_MARKET
    if value == OrderType.TRAILING_STOP_LIMIT:
        return nautilus_pyo3.OrderType.TRAILING_STOP_LIMIT

    raise ValueError(f"Unsupported `OrderType`, was '{order_type_to_str(value)}'")


cpdef order_status_to_pyo3(OrderStatus value):
    if value == OrderStatus.INITIALIZED:
        return nautilus_pyo3.OrderStatus.INITIALIZED
    if value == OrderStatus.DENIED:
        return nautilus_pyo3.OrderStatus.DENIED
    if value == OrderStatus.EMULATED:
        return nautilus_pyo3.OrderStatus.EMULATED
    if value == OrderStatus.RELEASED:
        return nautilus_pyo3.OrderStatus.RELEASED
    if value == OrderStatus.SUBMITTED:
        return nautilus_pyo3.OrderStatus.SUBMITTED
    if value == OrderStatus.ACCEPTED:
        return nautilus_pyo3.OrderStatus.ACCEPTED
    if value == OrderStatus.REJECTED:
        return nautilus_pyo3.OrderStatus.REJECTED
    if value == OrderStatus.CANCELED:
        return nautilus_pyo3.OrderStatus.CANCELED
    if value == OrderStatus.EXPIRED:
        return nautilus_pyo3.OrderStatus.EXPIRED
    if value == OrderStatus.TRIGGERED:
        return nautilus_pyo3.OrderStatus.TRIGGERED
    if value == OrderStatus.PENDING_UPDATE:
        return nautilus_pyo3.OrderStatus.PENDING_UPDATE
    if value == OrderStatus.PENDING_CANCEL:
        return nautilus_pyo3.OrderStatus.PENDING_CANCEL
    if value == OrderStatus.PARTIALLY_FILLED:
        return nautilus_pyo3.OrderStatus.PARTIALLY_FILLED
    if value == OrderStatus.FILLED:
        return nautilus_pyo3.OrderStatus.FILLED

    raise ValueError(f"Unsupported `OrderStatus`, was '{order_status_to_str(value)}'")


cpdef time_in_force_to_pyo3(TimeInForce value):
    if value == TimeInForce.GTC:
        return nautilus_pyo3.TimeInForce.GTC
    if value == TimeInForce.IOC:
        return nautilus_pyo3.TimeInForce.IOC
    if value == TimeInForce.FOK:
        return nautilus_pyo3.TimeInForce.FOK
    if value == TimeInForce.GTD:
        return nautilus_pyo3.TimeInForce.GTD
    if value == TimeInForce.DAY:
        return nautilus_pyo3.TimeInForce.DAY
    if value == TimeInForce.AT_THE_OPEN:
        return nautilus_pyo3.TimeInForce.AT_THE_OPEN
    if value == TimeInForce.AT_THE_CLOSE:
        return nautilus_pyo3.TimeInForce.AT_THE_CLOSE

    raise ValueError(f"Unsupported `TimeInForce`, was '{time_in_force_to_str(value)}'")


cpdef trigger_type_to_pyo3(TriggerType value):
    if value == TriggerType.NO_TRIGGER:
        return nautilus_pyo3.TriggerType.NO_TRIGGER
    if value == TriggerType.DEFAULT:
        return nautilus_pyo3.TriggerType.DEFAULT
    if value == TriggerType.LAST_PRICE:
        return nautilus_pyo3.TriggerType.LAST_PRICE
    if value == TriggerType.MARK_PRICE:
        return nautilus_pyo3.TriggerType.MARK_PRICE
    if value == TriggerType.INDEX_PRICE:
        return nautilus_pyo3.TriggerType.INDEX_PRICE
    if value == TriggerType.BID_ASK:
        return nautilus_pyo3.TriggerType.BID_ASK
    if value == TriggerType.DOUBLE_LAST:
        return nautilus_pyo3.TriggerType.DOUBLE_LAST
    if value == TriggerType.DOUBLE_BID_ASK:
        return nautilus_pyo3.TriggerType.DOUBLE_BID_ASK

    raise ValueError(f"Unsupported `TriggerType`, was '{trigger_type_to_str(value)}'")


cpdef trailing_offset_type_to_pyo3(TrailingOffsetType value):
    if value == TrailingOffsetType.NO_TRAILING_OFFSET:
        return nautilus_pyo3.TrailingOffsetType.NO_TRAILING_OFFSET
    if value == TrailingOffsetType.PRICE:
        return nautilus_pyo3.TrailingOffsetType.PRICE
    if value == TrailingOffsetType.BASIS_POINTS:
        return nautilus_pyo3.TrailingOffsetType.BASIS_POINTS
    if value == TrailingOffsetType.TICKS:
        return nautilus_pyo3.TrailingOffsetType.TICKS
    if value == TrailingOffsetType.PRICE_TIER:
        return nautilus_pyo3.TrailingOffsetType.PRICE_TIER

    raise ValueError(f"Unsupported `TrailingOffsetType`, was '{trailing_offset_type_to_str(value)}'")


cpdef contingency_type_to_pyo3(ContingencyType value):
    if value == ContingencyType.NO_CONTINGENCY:
        return nautilus_pyo3.ContingencyType.NO_CONTINGENCY
    if value == ContingencyType.OCO:
        return nautilus_pyo3.ContingencyType.OCO
    if value == ContingencyType.OTO:
        return nautilus_pyo3.ContingencyType.OTO
    if value == ContingencyType.OUO:
        return nautilus_pyo3.ContingencyType.OUO

    raise ValueError(f"Unsupported `ContingencyType`, was '{contingency_type_to_str(value)}'")


cpdef OrderSide order_side_from_pyo3(value: nautilus_pyo3.OrderSide):
    if value == nautilus_pyo3.OrderSide.BUY:
        return OrderSide.BUY
    if value == nautilus_pyo3.OrderSide.SELL:
        return OrderSide.SELL
    if value == nautilus_pyo3.OrderSide.NO_ORDER_SIDE:
        return OrderSide.NO_ORDER_SIDE

    raise ValueError(f"Unsupported `OrderSide`, was '{value}'")


cpdef OrderType order_type_from_pyo3(value: nautilus_pyo3.OrderType):
    if value == nautilus_pyo3.OrderType.MARKET:
        return OrderType.MARKET
    if value == nautilus_pyo3.OrderType.LIMIT:
        return OrderType.LIMIT
    if value == nautilus_pyo3.OrderType.STOP_MARKET:
        return OrderType.STOP_MARKET
    if value == nautilus_pyo3.OrderType.STOP_LIMIT:
        return OrderType.STOP_LIMIT
    if value == nautilus_pyo3.OrderType.MARKET_TO_LIMIT:
        return OrderType.MARKET_TO_LIMIT
    if value == nautilus_pyo3.OrderType.MARKET_IF_TOUCHED:
        return OrderType.MARKET_IF_TOUCHED
    if value == nautilus_pyo3.OrderType.LIMIT_IF_TOUCHED:
        return OrderType.LIMIT_IF_TOUCHED
    if value == nautilus_pyo3.OrderType.TRAILING_STOP_MARKET:
        return OrderType.TRAILING_STOP_MARKET
    if value == nautilus_pyo3.OrderType.TRAILING_STOP_LIMIT:
        return OrderType.TRAILING_STOP_LIMIT

    raise ValueError(f"Unsupported `OrderType`, was '{value}'")


cpdef OrderStatus order_status_from_pyo3(value: nautilus_pyo3.OrderStatus):
    if value == nautilus_pyo3.OrderStatus.INITIALIZED:
        return OrderStatus.INITIALIZED
    if value == nautilus_pyo3.OrderStatus.DENIED:
        return OrderStatus.DENIED
    if value == nautilus_pyo3.OrderStatus.EMULATED:
        return OrderStatus.EMULATED
    if value == nautilus_pyo3.OrderStatus.RELEASED:
        return OrderStatus.RELEASED
    if value == nautilus_pyo3.OrderStatus.SUBMITTED:
        return OrderStatus.SUBMITTED
    if value == nautilus_pyo3.OrderStatus.ACCEPTED:
        return OrderStatus.ACCEPTED
    if value == nautilus_pyo3.OrderStatus.REJECTED:
        return OrderStatus.REJECTED
    if value == nautilus_pyo3.OrderStatus.CANCELED:
        return OrderStatus.CANCELED
    if value == nautilus_pyo3.OrderStatus.EXPIRED:
        return OrderStatus.EXPIRED
    if value == nautilus_pyo3.OrderStatus.TRIGGERED:
        return OrderStatus.TRIGGERED
    if value == nautilus_pyo3.OrderStatus.PENDING_UPDATE:
        return OrderStatus.PENDING_UPDATE
    if value == nautilus_pyo3.OrderStatus.PENDING_CANCEL:
        return OrderStatus.PENDING_CANCEL
    if value == nautilus_pyo3.OrderStatus.PARTIALLY_FILLED:
        return OrderStatus.PARTIALLY_FILLED
    if value == nautilus_pyo3.OrderStatus.FILLED:
        return OrderStatus.FILLED

    raise ValueError(f"Unsupported `OrderStatus`, was '{value}'")


cpdef TimeInForce time_in_force_from_pyo3(value: nautilus_pyo3.TimeInForce):
    if value == nautilus_pyo3.TimeInForce.GTC:
        return TimeInForce.GTC
    if value == nautilus_pyo3.TimeInForce.IOC:
        return TimeInForce.IOC
    if value == nautilus_pyo3.TimeInForce.FOK:
        return TimeInForce.FOK
    if value == nautilus_pyo3.TimeInForce.GTD:
        return TimeInForce.GTD
    if value == nautilus_pyo3.TimeInForce.DAY:
        return TimeInForce.DAY
    if value == nautilus_pyo3.TimeInForce.AT_THE_OPEN:
        return TimeInForce.AT_THE_OPEN
    if value == nautilus_pyo3.TimeInForce.AT_THE_CLOSE:
        return TimeInForce.AT_THE_CLOSE

    raise ValueError(f"Unsupported `TimeInForce`, was '{value}'")


cpdef LiquiditySide liquidity_side_from_pyo3(value: nautilus_pyo3.LiquiditySide):
    if value == nautilus_pyo3.LiquiditySide.NO_LIQUIDITY_SIDE:
        return LiquiditySide.NO_LIQUIDITY_SIDE
    if value == nautilus_pyo3.LiquiditySide.MAKER:
        return LiquiditySide.MAKER
    if value == nautilus_pyo3.LiquiditySide.TAKER:
        return LiquiditySide.TAKER

    raise ValueError(f"Unsupported `LiquiditySide`, was '{value}'")


cpdef ContingencyType contingency_type_from_pyo3(value: nautilus_pyo3.ContingencyType):
    if value == nautilus_pyo3.ContingencyType.NO_CONTINGENCY:
        return ContingencyType.NO_CONTINGENCY
    if value == nautilus_pyo3.ContingencyType.OCO:
        return ContingencyType.OCO
    if value == nautilus_pyo3.ContingencyType.OTO:
        return ContingencyType.OTO
    if value == nautilus_pyo3.ContingencyType.OUO:
        return ContingencyType.OUO

    raise ValueError(f"Unsupported `ContingencyType`, was '{value}'")


cpdef PositionSide position_side_from_pyo3(value: nautilus_pyo3.PositionSide):
    if value == nautilus_pyo3.PositionSide.FLAT:
        return PositionSide.FLAT
    if value == nautilus_pyo3.PositionSide.LONG:
        return PositionSide.LONG
    if value == nautilus_pyo3.PositionSide.SHORT:
        return PositionSide.SHORT

    raise ValueError(f"Unsupported `PositionSide`, was '{value}'")

</document_content>
</document>
<document index="2407">
<source>nautilus_trader/model/greeks.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from typing import Callable

from nautilus_trader.core.nautilus_pyo3 import black_scholes_greeks
from nautilus_trader.core.nautilus_pyo3 import imply_vol_and_greeks
from nautilus_trader.model.enums import InstrumentClass
from nautilus_trader.model.enums import PriceType
from nautilus_trader.model.greeks_data import GreeksData
from nautilus_trader.model.greeks_data import PortfolioGreeks

from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Logger
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.rust.model cimport OptionKind
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.model.data cimport DataType
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.position cimport Position


cdef class GreeksCalculator:
    """
    Class used to calculate instrument and portfolio greeks (sensitivities of price moves with respect to market data moves).

    Useful for risk management of options and futures portfolios.
    Accessible from any class inheriting from the actor class including strategies.

    Parameters
    ----------
    msgbus : MessageBus
        The message bus for the calculator.
    cache : CacheFacade
        The cache for the calculator.
    clock : LiveClock
        The clock for the calculator.
    logger : Logger
        The logger for logging messages.

    Notes
    ----------
    Currently implemented greeks are:
    - Delta (first derivative of price with respect to spot move).
    - Gamma (second derivative of price with respect to spot move).
    - Vega (first derivative of price with respect to implied volatility of an option).
    - Theta (first derivative of price with respect to time to expiry).

    Vega is expressed in terms of absolute percent changes ((dV / dVol) / 100).
    Theta is expressed in terms of daily changes ((dV / d(T-t)) / 365.25, where T is the expiry of an option and t is the current time).

    Also note that for ease of implementation we consider that american options (for stock options for example) are european for the computation of greeks.

    """

    def __init__(
        self,
        MessageBus msgbus not None,
        CacheFacade cache not None,
        Clock clock not None,
    ) -> None:
        self._msgbus = msgbus
        self._cache = cache
        self._clock = clock
        self._log = Logger(type(self).__name__)

    def instrument_greeks(
        self,
        instrument_id: InstrumentId,
        flat_interest_rate: float = 0.0425,
        flat_dividend_yield: float | None = None,
        spot_shock: float = 0.,
        vol_shock: float = 0.,
        time_to_expiry_shock: float = 0.,
        use_cached_greeks: bool = False,
        cache_greeks: bool = False,
        publish_greeks: bool = False,
        ts_event: int = 0,
        position: Position | None = None,
        percent_greeks: bool = False,
        index_instrument_id: InstrumentId | None = None,
        beta_weights: dict[InstrumentId, float] | None = None,
        vega_time_weight_base: int | None = None,
    ) -> GreeksData | None:
        """
        Calculate option or underlying greeks for a given instrument and a quantity of 1.

        Additional features:
        - Apply shocks to the spot value of the instrument's underlying, implied volatility or time to expiry.
        - Compute percent greeks.
        - Compute beta-weighted delta and gamma with respect to an index.

        Parameters
        ----------
        instrument_id : InstrumentId
            The ID of the instrument to calculate greeks for.
        flat_interest_rate : float, default 0.0425
            The interest rate to use for calculations.
            The function first searches if an interest rate curve for the currency of the option is stored in cache;
            if not, flat_interest_rate is used.
        flat_dividend_yield : float, optional
            The dividend yield to use for calculations.
            The function first searches if a dividend yield curve is stored in cache using the instrument id of the underlying as key;
            if not, flat_dividend_yield is used if it's not None.
        spot_shock : float, default 0.0
            Shock to apply to spot price.
        vol_shock : float, default 0.0
            Shock to apply to implied volatility.
        time_to_expiry_shock : float, default 0.0
            Shock in years to apply to time to expiry.
        use_cached_greeks : bool, default False
            Whether to use cached greeks values if available.
        cache_greeks : bool, default False
            Whether to cache the calculated greeks.
        publish_greeks : bool, default False
            Whether to publish the calculated greeks.
        ts_event : int, default 0
            Timestamp of the event triggering the calculation, by default 0.
        position : Position, optional
            Optional position used to calculate the pnl of a Future when necessary.
        percent_greeks : bool, optional
            Whether to compute greeks as percentage of the underlying price, by default False.
        index_instrument_id : InstrumentId, optional
            The reference instrument id beta is computed with respect to.
        beta_weights : dict[InstrumentId, float], optional
            Dictionary of beta weights used to compute portfolio delta and gamma.
        vega_time_weight_base : int, optional
            Base value in days for time-weighting vega. When provided, vega is multiplied by sqrt(vega_time_weight_base / expiry_in_days).
            Also enables percent vega calculation where vega is multiplied by vol / 100.

        Returns
        -------
        GreeksData
          The calculated option greeks data
          Contains price, delta, gamma, vega, theta as well as additional information used for the computation.

        """
        instrument = self._cache.instrument(instrument_id)

        if instrument.instrument_class is not InstrumentClass.OPTION:
            multiplier = float(instrument.multiplier)
            underlying_instrument_id = instrument.id
            underlying_price_obj = self._cache.price(underlying_instrument_id, PriceType.LAST)

            if underlying_price_obj is None:
                self._log.warning(f"No last price available for {underlying_instrument_id}")
                return None

            underlying_price = float(underlying_price_obj)

            delta, _, _ = self.modify_greeks(multiplier, 0., underlying_instrument_id, underlying_price + spot_shock, underlying_price,
                                             percent_greeks, index_instrument_id, beta_weights, 0.0, 0.0, 0, None)
            greeks_data = GreeksData.from_delta(instrument_id, delta, multiplier, ts_event)

            if position is not None:
                greeks_data.pnl = multiplier * ((underlying_price + spot_shock) - position.avg_px_open)
                greeks_data.price = greeks_data.pnl

            return greeks_data

        greeks_data = None
        underlying_instrument_id = InstrumentId.from_str(f"{instrument.underlying}.{instrument_id.venue}")

        if use_cached_greeks and (greeks_data := self._cache.greeks(instrument_id)) is not None:
            self._log.debug(f"Using cached greeks for {instrument_id=}")
            pass
        else:
            utc_now_ns = ts_event if ts_event is not None else self._clock.timestamp_ns()
            utc_now = unix_nanos_to_dt(utc_now_ns)

            expiry_utc = instrument.expiration_utc
            expiry_int = int(expiry_utc.strftime("%Y%m%d"))
            expiry_in_days = min((expiry_utc - utc_now).days, 1)
            expiry_in_years = expiry_in_days / 365.25

            currency = instrument.quote_currency.code

            if (yield_curve := self._cache.yield_curve(currency)) is not None:
                interest_rate = yield_curve(expiry_in_years)
            else:
                interest_rate = flat_interest_rate

            # cost of carry is 0 for futures
            cost_of_carry = 0.

            if (dividend_curve := self._cache.yield_curve(str(underlying_instrument_id))) is not None:
                dividend_yield = dividend_curve(expiry_in_years)
                cost_of_carry = interest_rate - dividend_yield
            elif flat_dividend_yield is not None:
                # Use a dividend rate of 0. to have a cost of carry of interest rate for options on stocks
                cost_of_carry = interest_rate - flat_dividend_yield

            multiplier = float(instrument.multiplier)
            is_call = instrument.option_kind is OptionKind.CALL
            strike = float(instrument.strike_price)

            option_mid_price_obj = self._cache.price(instrument_id, PriceType.MID)
            underlying_price_obj = self._cache.price(underlying_instrument_id, PriceType.LAST)

            if option_mid_price_obj is None:
                self._log.warning(f"No mid price available for option {instrument_id}")
                return

            if underlying_price_obj is None:
                self._log.warning(f"No last price available for underlying {underlying_instrument_id}")
                return

            option_mid_price = float(option_mid_price_obj)
            underlying_price = float(underlying_price_obj)

            greeks = imply_vol_and_greeks(underlying_price, interest_rate, cost_of_carry, is_call, strike,
                                          expiry_in_years, option_mid_price, multiplier)
            delta, gamma, vega = self.modify_greeks(greeks.delta, greeks.gamma, underlying_instrument_id, underlying_price,
                                                     underlying_price, percent_greeks, index_instrument_id, beta_weights,
                                                     greeks.vega, greeks.vol, expiry_in_days, vega_time_weight_base)

            greeks_data = GreeksData(utc_now_ns, utc_now_ns, instrument_id, is_call, strike, expiry_int, expiry_in_days, expiry_in_years, multiplier, 1.0,
                                     underlying_price, interest_rate, cost_of_carry, greeks.vol, 0., greeks.price, delta, gamma, vega, greeks.theta,
                                     abs(greeks.delta / multiplier))

            # adding greeks to cache
            if cache_greeks:
                self._cache.add_greeks(greeks_data)

            # publishing greeks on the message bus so they can be written to a catalog from streamed objects
            if publish_greeks:
                data_type = DataType(GreeksData)
                self._msgbus.publish_c(topic=f"data.{instrument_id.venue}.{instrument_id.symbol.topic()}", msg=greeks_data)

        if spot_shock != 0. or vol_shock != 0. or time_to_expiry_shock != 0.:
            underlying_price = greeks_data.underlying_price
            shocked_underlying_price = underlying_price + spot_shock
            shocked_vol = greeks_data.vol + vol_shock
            shocked_time_to_expiry = greeks_data.expiry_in_years - time_to_expiry_shock

            greeks = black_scholes_greeks(shocked_underlying_price, greeks_data.interest_rate, greeks_data.cost_of_carry,
                                          shocked_vol, greeks_data.is_call, greeks_data.strike, shocked_time_to_expiry, greeks_data.multiplier)
            delta, gamma, vega = self.modify_greeks(greeks.delta, greeks.gamma, underlying_instrument_id, shocked_underlying_price, underlying_price,
                                                     percent_greeks, index_instrument_id, beta_weights,
                                                     greeks.vega, shocked_vol, int(shocked_time_to_expiry * 365.25), vega_time_weight_base)

            greeks_data = GreeksData(greeks_data.ts_event, greeks_data.ts_event,
                                     greeks_data.instrument_id, greeks_data.is_call, greeks_data.strike, greeks_data.expiry,
                                     int(shocked_time_to_expiry * 365.25), shocked_time_to_expiry, greeks_data.multiplier, greeks_data.quantity, shocked_underlying_price,
                                     greeks_data.interest_rate, greeks_data.cost_of_carry, shocked_vol, 0., greeks.price, delta, gamma, vega,
                                     greeks.theta, abs(greeks.delta / greeks_data.multiplier))

        if position is not None:
            greeks_data.pnl = greeks_data.price - greeks_data.multiplier * position.avg_px_open

        return greeks_data

    def modify_greeks(
        self,
        delta_input: float,
        gamma_input: float,
        underlying_instrument_id: InstrumentId,
        underlying_price: float,
        unshocked_underlying_price: float,
        percent_greeks: bool,
        index_instrument_id: InstrumentId | None,
        beta_weights: dict[InstrumentId, float] | None,
        vega_input: float = 0.0,
        vol: float = 0.0,
        expiry_in_days: int = 0,
        vega_time_weight_base: int | None = None,
    ) -> tuple[float, float, float]:
        """
        Modify delta and gamma based on beta weighting and percentage calculations.

        Parameters
        ----------
        delta_input : float
            The input delta value.
        gamma_input : float
            The input gamma value.
        underlying_instrument_id : InstrumentId
            The ID of the underlying instrument.
        underlying_price : float
            The current price of the underlying asset.
        unshocked_underlying_price : float
            The base (non-shocked) price of the underlying asset.
        percent_greeks : bool, optional
            Whether to compute greeks as percentage of the underlying price, by default False.
        index_instrument_id : InstrumentId, optional
            The reference instrument id beta is computed with respect to.
        beta_weights : dict[InstrumentId, float], optional
            Dictionary of beta weights used to compute portfolio delta and gamma.
        vega_input : float, default 0.0
            The original vega value.
        vol : float, default 0.0
            The implied volatility.
        expiry_in_days : int, default 0
            Days to expiry.
        vega_time_weight_base : int, optional
            Base value in days for time-weighting vega.

        Returns
        -------
        tuple[float, float, float]
            Modified delta, gamma, and vega values.

        Notes
        -----
        The beta weighting of delta and gamma follows this equation linking the returns of a stock x to the ones of an index I:
        (x - x0) / x0 = alpha + beta (I - I0) / I0 + epsilon

        beta can be obtained by linear regression of stock_return = alpha + beta index_return, it's equal to:
        beta = Covariance(stock_returns, index_returns) / Variance(index_returns)

        Considering alpha == 0:
        x = x0 + beta x0 / I0 (I-I0)
        I = I0 + 1 / beta I0 / x0 (x - x0)

        These two last equations explain the beta weighting below, considering the price of an option is V(x) and delta and gamma
        are the first and second derivatives respectively of V.

        Also percent greeks assume a change of variable to percent returns by writing:
        V(x = x0 * (1 + stock_percent_return / 100))
        or V(I = I0 * (1 + index_percent_return / 100))
        """
        delta = delta_input
        gamma = gamma_input
        vega = vega_input

        index_price = None
        delta_multiplier = 1.0

        if index_instrument_id is not None:
            index_price = float(self._cache.price(index_instrument_id, PriceType.LAST))

            beta = 1.
            if beta_weights is not None:
                beta = beta_weights.get(underlying_instrument_id, 1.0)

            if underlying_price != unshocked_underlying_price:
                index_price += 1. / beta * (index_price / unshocked_underlying_price) * (underlying_price - unshocked_underlying_price)

            delta_multiplier = beta * underlying_price / index_price
            delta *= delta_multiplier
            gamma *= delta_multiplier ** 2

        if percent_greeks:
            if index_price is None:
                delta *= underlying_price / 100.
                gamma *= (underlying_price / 100.) ** 2
            else:
                delta *= index_price / 100.
                gamma *= (index_price / 100.) ** 2

            vega = vega * vol / 100.0

        # Apply time weighting to vega if vega_time_weight_base is provided
        if vega_time_weight_base is not None and expiry_in_days > 0:
            time_weight = (vega_time_weight_base / expiry_in_days) ** 0.5
            vega *= time_weight

        return delta, gamma, vega

    def portfolio_greeks(
        self,
        underlyings : list[str] = None,
        Venue venue = None,
        InstrumentId instrument_id = None,
        StrategyId strategy_id = None,
        PositionSide side = PositionSide.NO_POSITION_SIDE,
        flat_interest_rate: float = 0.0425,
        flat_dividend_yield: float | None = None,
        spot_shock: float = 0.0,
        vol_shock: float = 0.0,
        time_to_expiry_shock: float = 0.0,
        use_cached_greeks: bool = False,
        cache_greeks: bool = False,
        publish_greeks: bool = False,
        percent_greeks: bool = False,
        index_instrument_id: InstrumentId | None = None,
        beta_weights: dict[InstrumentId, float] | None = None,
        greeks_filter: callable | None = None,
        vega_time_weight_base: int | None = None,
    ) -> PortfolioGreeks | None:
        """
        Calculate the portfolio Greeks for a given set of positions.

        Aggregates the Greeks data for all open positions that match the specified criteria.

        Additional features:
        - Apply shocks to the spot value of an instrument's underlying, implied volatility or time to expiry.
        - Compute percent greeks.
        - Compute beta-weighted delta and gamma with respect to an index.

        Parameters
        ----------
        underlyings : list, optional
            A list of underlying asset symbol prefixes as strings to filter positions.
            For example, ["AAPL", "MSFT"] would include positions for AAPL and MSFT stocks and options.
            Only positions with instruments starting with one of these symbols will be included.
            If more than one underlying is provided, using beta-weighted greeks is recommended.
        venue : Venue, optional
            The venue to filter positions.
            Only positions from this venue will be included.
        instrument_id : InstrumentId, optional
            The instrument ID to filter positions.
            Only positions for this instrument will be included.
        strategy_id : StrategyId, optional
            The strategy ID to filter positions.
            Only positions for this strategy will be included.
        side : PositionSide, default PositionSide.NO_POSITION_SIDE
            The position side to filter.
            Only positions with this side will be included.
        flat_interest_rate : float, default 0.05
            The interest rate to use for calculations when no curve is available.
        flat_dividend_yield : float, optional
            The dividend yield to use for calculations when no dividend curve is available.
        spot_shock : float, default 0.0
            Shock to apply to the underlying price.
        vol_shock : float, default 0.0
            Shock to apply to implied volatility.
        time_to_expiry_shock : float, default 0.0
            Shock in years to apply to time to expiry.
        use_cached_greeks : bool, default False
            Whether to use cached Greeks calculations if available.
        cache_greeks : bool, default False
            Whether to cache the calculated Greeks.
        publish_greeks : bool, default False
            Whether to publish the Greeks data to the message bus.
        percent_greeks : bool, optional
            Whether to compute greeks as percentage of the underlying price, by default False.
        index_instrument_id : InstrumentId, optional
            The reference instrument id beta is computed with respect to.
        beta_weights : dict[InstrumentId, float], optional
            Dictionary of beta weights used to compute portfolio delta and gamma.
        greeks_filter : callable, optional
            Filter function to select which greeks to add to the portfolio_greeks.
        vega_time_weight_base : int, optional
            Base value in days for time-weighting vega. When provided, vega is multiplied by sqrt(vega_time_weight_base / expiry_in_days).
            Also enables percent vega calculation where vega is multiplied by vol / 100.

        Returns
        -------
        PortfolioGreeks
            The aggregated Greeks data for the portfolio.
            Contains price, delta, gamma, vega, theta.

        Notes
        -----
        The method filters positions based on the provided parameters and calculates
        Greeks for each matching position. The Greeks are then weighted by position
        size and aggregated into portfolio-level risk metrics.

        """
        ts_event = self._clock.timestamp_ns()
        portfolio_greeks = PortfolioGreeks(ts_event, ts_event)
        open_positions = self._cache.positions_open(venue, instrument_id, strategy_id, side)

        for position in open_positions:
            position_instrument_id = position.instrument_id

            if underlyings is not None:
                skip_position = True

                for underlying in underlyings:
                    if position_instrument_id.value.startswith(underlying):
                        skip_position = False
                        break

                if skip_position:
                    continue

            quantity = position.signed_qty
            instrument_greeks = self.instrument_greeks(
                position_instrument_id,
                flat_interest_rate,
                flat_dividend_yield,
                spot_shock,
                vol_shock,
                time_to_expiry_shock,
                use_cached_greeks,
                cache_greeks,
                publish_greeks,
                ts_event,
                position,
                percent_greeks,
                index_instrument_id,
                beta_weights,
                vega_time_weight_base,
            )

            if instrument_greeks is None:
                self._log.error(f"No greeks available for underlying {position_instrument_id}")
                return

            position_greeks = quantity * instrument_greeks

            if greeks_filter is None or greeks_filter(position_greeks):
                portfolio_greeks += position_greeks

        return portfolio_greeks

    def subscribe_greeks(self, instrument_id: InstrumentId | None = None, handler: Callable[[GreeksData], None] = None) -> None:
        """
        Subscribe to Greeks data for a given underlying instrument.

        Useful for reading greeks from a backtesting data catalog and caching them for later use.

        Parameters
        ----------
        instrument_id : str, optional
            The underlying instrument ID subscribe to.
            Use for example InstrumentId.from_str("ES*.GLBX") to cache all ES greeks.
            If empty, subscribes to all Greeks data.
        handler : Callable[[GreeksData], None], optional
            The callback function to handle received Greeks data.
            If None, defaults to adding greeks to the cache.

        Returns
        -------
        None

        """
        used_handler = handler or (lambda greeks: self._cache.add_greeks(greeks))
        topic = f"data.GreeksData.{instrument_id.venue}.{instrument_id.symbol.topic()}" if instrument_id else "data.GreeksData.*"
        self._msgbus.subscribe(
            topic=topic,
            handler=used_handler,
        )

</document_content>
</document>
<document index="2410">
<source>nautilus_trader/model/identifiers.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.string cimport strcmp

from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport account_id_new
from nautilus_trader.core.rust.model cimport client_id_new
from nautilus_trader.core.rust.model cimport client_order_id_new
from nautilus_trader.core.rust.model cimport component_id_new
from nautilus_trader.core.rust.model cimport exec_algorithm_id_new
from nautilus_trader.core.rust.model cimport instrument_id_check_parsing
from nautilus_trader.core.rust.model cimport instrument_id_from_cstr
from nautilus_trader.core.rust.model cimport instrument_id_is_synthetic
from nautilus_trader.core.rust.model cimport instrument_id_new
from nautilus_trader.core.rust.model cimport instrument_id_to_cstr
from nautilus_trader.core.rust.model cimport interned_string_stats
from nautilus_trader.core.rust.model cimport order_list_id_new
from nautilus_trader.core.rust.model cimport position_id_new
from nautilus_trader.core.rust.model cimport strategy_id_new
from nautilus_trader.core.rust.model cimport symbol_is_composite
from nautilus_trader.core.rust.model cimport symbol_new
from nautilus_trader.core.rust.model cimport symbol_root
from nautilus_trader.core.rust.model cimport symbol_topic
from nautilus_trader.core.rust.model cimport trade_id_new
from nautilus_trader.core.rust.model cimport trade_id_to_cstr
from nautilus_trader.core.rust.model cimport trader_id_new
from nautilus_trader.core.rust.model cimport venue_code_exists
from nautilus_trader.core.rust.model cimport venue_from_cstr_code
from nautilus_trader.core.rust.model cimport venue_is_synthetic
from nautilus_trader.core.rust.model cimport venue_new
from nautilus_trader.core.rust.model cimport venue_order_id_new
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.core.string cimport pystr_to_cstr
from nautilus_trader.core.string cimport ustr_to_pystr


cdef class Identifier:
    """
    The abstract base class for all identifiers.
    """

    def __getstate__(self):
        raise NotImplementedError("method `__getstate__` must be implemented in the subclass")  # pragma: no cover

    def __setstate__(self, state):
        raise NotImplementedError("method `__setstate__` must be implemented in the subclass")  # pragma: no cover

    def __lt__(self, Identifier other) -> bool:
        if other is None:
            return NotImplemented
        return self.to_str() < other.to_str()

    def __le__(self, Identifier other) -> bool:
        if other is None:
            return NotImplemented
        return self.to_str() <= other.to_str()

    def __gt__(self, Identifier other) -> bool:
        if other is None:
            return NotImplemented
        return self.to_str() > other.to_str()

    def __ge__(self, Identifier other) -> bool:
        if other is None:
            return NotImplemented
        return self.to_str() >= other.to_str()

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return f"{type(self).__name__}('{self.to_str()}')"

    cdef str to_str(self):
        raise NotImplementedError("method `to_str` must be implemented in the subclass")  # pragma: no cover

    @property
    def value(self) -> str:
        """
        Return the identifier (ID) value.

        Returns
        -------
        str

        """
        return self.to_str()


cdef class Symbol(Identifier):
    """
    Represents a valid ticker symbol ID for a tradable instrument.

    Parameters
    ----------
    value : str
        The ticker symbol ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string.

    Warnings
    --------
    The ID value must be unique for a trading venue.

    References
    ----------
    https://en.wikipedia.org/wiki/Ticker_symbol
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = symbol_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = symbol_new(pystr_to_cstr(state))

    def __eq__(self, Symbol other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef Symbol from_mem_c(Symbol_t mem):
        cdef Symbol symbol = Symbol.__new__(Symbol)
        symbol._mem = mem
        return symbol

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)

    cpdef bint is_composite(self):
        """
        Returns true if the symbol string contains a period ('.').

        Returns
        -------
        str

        """
        return <bint>symbol_is_composite(&self._mem)

    cpdef str root(self):
        """
        Return the symbol root.

        The symbol root is the substring that appears before the first period ('.')
        in the full symbol string. It typically represents the underlying asset for
        futures and options contracts. If no period is found, the entire symbol
        string is considered the root.

        Returns
        -------
        str

        """
        return cstr_to_pystr(symbol_root(&self._mem))

    cpdef str topic(self):
        """
        Return the symbol topic.

        The symbol topic is the root symbol with a wildcard '*' appended if the symbol has a root,
        otherwise returns the full symbol string.

        Returns
        -------
        str

        """
        return cstr_to_pystr(symbol_topic(&self._mem))


cdef class Venue(Identifier):
    """
    Represents a valid trading venue ID.

    Parameters
    ----------
    name : str
        The venue ID value.

    Raises
    ------
    ValueError
        If `name` is not a valid string.
    """

    def __init__(self, str name not None) -> None:
        Condition.valid_string(name, "name")
        self._mem = venue_new(pystr_to_cstr(name))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = venue_new(pystr_to_cstr(state))

    def __eq__(self, Venue other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)

    @staticmethod
    cdef Venue from_mem_c(Venue_t mem):
        cdef Venue venue = Venue.__new__(Venue)
        venue._mem = mem
        return venue

    @staticmethod
    cdef Venue from_code_c(str code):
        cdef const char* code_ptr = pystr_to_cstr(code)
        if not venue_code_exists(code_ptr):
            return None
        cdef Venue venue = Venue.__new__(Venue)
        venue._mem = venue_from_cstr_code(code_ptr)
        return venue

    cpdef bint is_synthetic(self):
        """
        Return whether the venue is synthetic ('SYNTH').

        Returns
        -------
        bool

        """
        return <bint>venue_is_synthetic(&self._mem)

    @staticmethod
    def from_code(str code):
        """
        Return the venue with the given `code` from the built-in internal map (if found).

        Currency only supports CME Globex exchange ISO 10383 MIC codes.

        Parameters
        ----------
        code : str
            The code of the venue.

        Returns
        -------
        Venue or ``None``

        """
        Condition.not_none(code, "code")

        return Venue.from_code_c(code)


cdef class InstrumentId(Identifier):
    """
    Represents a valid instrument ID.

    The symbol and venue combination should uniquely identify the instrument.

    Parameters
    ----------
    symbol : Symbol
        The instruments ticker symbol.
    venue : Venue
        The instruments trading venue.
    """

    def __init__(self, Symbol symbol not None, Venue venue not None) -> None:
        self._mem = instrument_id_new(
            symbol._mem,
            venue._mem,
        )

    @property
    def symbol(self) -> Symbol:
        """
        Returns the instrument ticker symbol.

        Returns
        -------
        Symbol

        """
        return Symbol.from_mem_c(self._mem.symbol)

    @property
    def venue(self) -> Venue:
        """
        Returns the instrument trading venue.

        Returns
        -------
        Venue

        """
        return Venue.from_mem_c(self._mem.venue)

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = instrument_id_from_cstr(pystr_to_cstr(state))

    def __eq__(self, InstrumentId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem.symbol._0, other._mem.symbol._0) == 0 and strcmp(self._mem.venue._0, other._mem.venue._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef InstrumentId from_mem_c(InstrumentId_t mem):
        cdef InstrumentId instrument_id = InstrumentId.__new__(InstrumentId)
        instrument_id._mem = mem
        return instrument_id

    @staticmethod
    cdef InstrumentId from_str_c(str value):
        Condition.valid_string(value, "value")

        cdef str parse_err = cstr_to_pystr(instrument_id_check_parsing(pystr_to_cstr(value)))
        if parse_err:
            raise ValueError(parse_err)

        cdef InstrumentId instrument_id = InstrumentId.__new__(InstrumentId)
        instrument_id._mem = instrument_id_from_cstr(pystr_to_cstr(value))
        return instrument_id

    cdef str to_str(self):
        return cstr_to_pystr(instrument_id_to_cstr(&self._mem))

    @staticmethod
    def from_str(value: str) -> InstrumentId:
        """
        Return an instrument ID parsed from the given string value.
        Must be correctly formatted including symbol and venue components either side of a single
        period.

        Examples: 'AUD/USD.IDEALPRO', 'BTCUSDT.BINANCE'

        Parameters
        ----------
        value : str
            The instrument ID string value to parse.

        Returns
        -------
        InstrumentId

        Raises
        ------
        ValueError
            If `value` is not a valid instrument ID string.

        """
        return InstrumentId.from_str_c(value)

    cpdef bint is_synthetic(self):
        """
        Return whether the instrument ID is a synthetic instrument (with venue of 'SYNTH').

        Returns
        -------
        bool

        """
        return <bint>instrument_id_is_synthetic(&self._mem)

    cpdef bint is_spread(self):
        """
        Return whether the instrument ID is a spread instrument (symbol contains '_' separator).

        Returns
        -------
        bool

        """
        return "_" in self.symbol.value

    @staticmethod
    def from_pyo3(pyo3_instrument_id) -> InstrumentId:
        """
        Return an instrument ID from the given PyO3 instance.

        Parameters
        ----------
        value : nautilus_pyo3.InstrumentId
            The PyO3 instrument ID instance.

        Returns
        -------
        InstrumentId

        """
        return InstrumentId.from_str_c(pyo3_instrument_id.value)

    cpdef to_pyo3(self):
        """
        Return a pyo3 object from this legacy Cython instance.

        Returns
        -------
        nautilus_pyo3.InstrumentId

        """
        return nautilus_pyo3.InstrumentId.from_str(self.to_str())

    @staticmethod
    def new_spread(instrument_ratios: list[tuple[InstrumentId, int]]) -> InstrumentId:
        """
        Create a spread InstrumentId from a list of (instrument_id, ratio) tuples.

        The resulting symbol will be in the format: (ratio1)symbol1_(ratio2)symbol2_...
        where positive ratios are shown as (ratio) and negative ratios as ((ratio)).
        All instrument IDs must have the same venue. The instrument IDs are sorted
        alphabetically by symbol before creating the spread symbol.

        Parameters
        ----------
        instrument_ratios : list[tuple[InstrumentId, int]]
            List of tuples containing (instrument_id, ratio) where ratio cannot be 0.

        Returns
        -------
        InstrumentId
            The spread instrument ID.

        Raises
        ------
        ValueError
            If the list is empty, ratios are zero, or venues don't match.

        Examples
        --------
        >>> from nautilus_trader.model.identifiers import InstrumentId, Symbol, Venue
        >>> id1 = InstrumentId(Symbol("MSFT"), Venue("NASDAQ"))
        >>> id2 = InstrumentId(Symbol("AAPL"), Venue("NASDAQ"))
        >>> spread = InstrumentId.new_spread([(id1, 1), (id2, -2)])
        >>> print(spread.symbol.value)
        ((2))AAPL_(1)MSFT

        """
        if len(instrument_ratios) <= 1:
            raise ValueError("instrument_ratios list needs to have at least 2 legs")

        # Validate all ratios are non-zero and venues match
        first_venue = instrument_ratios[0][0].venue

        for instrument_id, ratio in instrument_ratios:
            if ratio == 0:
                raise ValueError("ratio cannot be zero")

            if instrument_id.venue != first_venue:
                raise ValueError(f"All venues must match. Expected {first_venue}, was {instrument_id.venue}")

        # Sort instrument ratios alphabetically by symbol
        sorted_ratios = sorted(instrument_ratios, key=lambda x: x[0].symbol.value)

        # Build the composite symbol
        symbol_parts = []

        for instrument_id, ratio in sorted_ratios:
            if ratio > 0:
                symbol_part = f"({ratio}){instrument_id.symbol.value}"
            else:
                symbol_part = f"(({abs(ratio)})){instrument_id.symbol.value}"

            symbol_parts.append(symbol_part)

        composite_symbol = "_".join(symbol_parts)

        return InstrumentId(Symbol(composite_symbol), first_venue)

    def to_list(self) -> list[tuple[InstrumentId, int]]:
        """
        Parse this InstrumentId back into a list of (instrument_id, ratio) tuples.

        This is the inverse operation of new_spread(). The symbol must be in the format
        created by new_spread(): (ratio1)symbol1_(ratio2)symbol2_...
        The returned list is sorted alphabetically by symbol.

        Returns
        -------
        list[tuple[InstrumentId, int]]
            List of tuples containing (instrument_id, ratio), sorted alphabetically by symbol.

        Raises
        ------
        ValueError
            If the symbol format is not compatible with new_spread() format.

        Examples
        --------
        >>> from nautilus_trader.model.identifiers import InstrumentId, Symbol, Venue
        >>> spread = InstrumentId(Symbol("(1)AAPL_((2))MSFT"), Venue("NASDAQ"))
        >>> result = spread.to_list()
        >>> print(result)
        [(InstrumentId('AAPL.NASDAQ'), 1), (InstrumentId('MSFT.NASDAQ'), -2)]

        """
        import re

        symbol_str = self.symbol.value
        venue = self.venue

        # Split by underscore to get individual components
        components = symbol_str.split("_")
        result = []

        # Pattern to match (ratio)symbol or ((ratio))symbol
        pattern = r'^\(\((\d+)\)\)(.+)$|^\((\d+)\)(.+)$'

        for component in components:
            match = re.match(pattern, component)

            if not match:
                raise ValueError(f"Invalid symbol format for component: {component}")

            if match.group(1) is not None:  # Negative ratio: ((ratio))symbol
                ratio = -int(match.group(1))
                symbol_value = match.group(2)
            else:  # Positive ratio: (ratio)symbol
                ratio = int(match.group(3))
                symbol_value = match.group(4)

            instrument_id = InstrumentId(Symbol(symbol_value), venue)
            result.append((instrument_id, ratio))

        # Sort result alphabetically by symbol
        result.sort(key=lambda x: x[0].symbol.value)

        return result

    def n_legs(self):
        if not self.is_spread():
            return 1

        return sum([abs(component[1]) for component in self.to_list()])


cdef class ComponentId(Identifier):
    """
    Represents a valid component ID.

    Parameters
    ----------
    value : str
        The component ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string.

    Warnings
    --------
    The ID value must be unique at the trader level.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = component_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = component_id_new(pystr_to_cstr(state))

    def __eq__(self, ComponentId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef ComponentId from_mem_c(ComponentId_t mem):
        cdef ComponentId component_id = ComponentId.__new__(ComponentId)
        component_id._mem = mem
        return component_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)


cdef class ClientId(Identifier):
    """
    Represents a system client ID.

    Parameters
    ----------
    value : str
        The client ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string.

    Warnings
    --------
    The ID value must be unique at the trader level.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = client_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = client_id_new(pystr_to_cstr(state))

    def __eq__(self, ClientId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef ClientId from_mem_c(ClientId_t mem):
        cdef ClientId client_id = ClientId.__new__(ClientId)
        client_id._mem = mem
        return client_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)


cdef class TraderId(Identifier):
    """
    Represents a valid trader ID.

    Must be correctly formatted with two valid strings either side of a hyphen.
    It is expected a trader ID is the abbreviated name of the trader
    with an order ID tag number separated by a hyphen.

    Example: "TESTER-001".

    The reason for the numerical component of the ID is so that order and position IDs
    do not collide with those from another node instance.

    Parameters
    ----------
    value : str
        The trader ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string containing a hyphen.

    Warnings
    --------
    The name and tag combination ID value must be unique at the firm level.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = trader_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = trader_id_new(pystr_to_cstr(state))

    def __eq__(self, TraderId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef TraderId from_mem_c(TraderId_t mem):
        cdef TraderId trader_id = TraderId.__new__(TraderId)
        trader_id._mem = mem
        return trader_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)

    cpdef str get_tag(self):
        """
        Return the order ID tag value for this ID.

        Returns
        -------
        str

        """
        return self.to_str().split("-")[-1]


# External strategy ID constant
cdef StrategyId EXTERNAL_STRATEGY_ID = StrategyId("EXTERNAL")


cdef class StrategyId(Identifier):
    """
    Represents a valid strategy ID.

    Must be correctly formatted with two valid strings either side of a hyphen.
    It is expected a strategy ID is the class name of the strategy,
    with an order ID tag number separated by a hyphen.

    Example: "EMACross-001".

    The reason for the numerical component of the ID is so that order and position IDs
    do not collide with those from another strategy within the node instance.

    Parameters
    ----------
    value : str
        The strategy ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string containing a hyphen.

    Warnings
    --------
    The name and tag combination must be unique at the trader level.
    """

    def __init__(self, str value) -> None:
        Condition.valid_string(value, "value")
        Condition.is_true(value == "EXTERNAL" or "-" in value, "value was malformed: did not contain a hyphen '-'")

        self._mem = strategy_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = strategy_id_new(pystr_to_cstr(state))

    def __eq__(self, StrategyId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef StrategyId from_mem_c(StrategyId_t mem):
        cdef StrategyId strategy_id = StrategyId.__new__(StrategyId)
        strategy_id._mem = mem
        return strategy_id

    @staticmethod
    cdef StrategyId external_c():
        return EXTERNAL_STRATEGY_ID

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)

    cpdef str get_tag(self):
        """
        Return the order ID tag value for this ID.

        Returns
        -------
        str

        """
        return self.to_str().split("-")[-1]

    cpdef bint is_external(self):
        """
        If the strategy ID is the global 'external' strategy. This represents
        the strategy for all orders interacting with this instance of the system
        which did not originate from any strategy being managed by the system.

        Returns
        -------
        bool

        """
        return self == EXTERNAL_STRATEGY_ID


cdef class ExecAlgorithmId(Identifier):
    """
    Represents a valid execution algorithm ID.

    Parameters
    ----------
    value : str
        The execution algorithm ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = exec_algorithm_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = exec_algorithm_id_new(pystr_to_cstr(state))

    def __eq__(self, ExecAlgorithmId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef ExecAlgorithmId from_mem_c(ExecAlgorithmId_t mem):
        cdef ExecAlgorithmId exec_algorithm_id = ExecAlgorithmId.__new__(ExecAlgorithmId)
        exec_algorithm_id._mem = mem
        return exec_algorithm_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)



cdef class AccountId(Identifier):
    """
    Represents a valid account ID.

    Must be correctly formatted with two valid strings either side of a hyphen.
    It is expected an account ID is the name of the issuer with an account number
    separated by a hyphen.

    Example: "IB-D02851908".

    Parameters
    ----------
    value : str
        The account ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string containing a hyphen.

    Warnings
    --------
    The issuer and number ID combination must be unique at the firm level.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        Condition.is_true("-" in value, "value was malformed: did not contain a hyphen '-'")
        self._mem = account_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = account_id_new(pystr_to_cstr(state))

    def __eq__(self, AccountId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef AccountId from_mem_c(AccountId_t mem):
        cdef AccountId account_id = AccountId.__new__(AccountId)
        account_id._mem = mem
        return account_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)

    cpdef str get_issuer(self):
        """
        Return the account issuer for this ID.

        Returns
        -------
        str

        """
        return self.to_str().split("-")[0]

    cpdef str get_id(self):
        """
        Return the account ID without issuer name.

        Returns
        -------
        str

        """
        return self.to_str().split("-")[1]


cdef class ClientOrderId(Identifier):
    """
    Represents a valid client order ID (assigned by the Nautilus system).

    Parameters
    ----------
    value : str
        The client order ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string.

    Warnings
    --------
    The ID value must be unique at the firm level.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = client_order_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = client_order_id_new(pystr_to_cstr(state))

    def __eq__(self, ClientOrderId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef ClientOrderId from_mem_c(ClientOrderId_t mem):
        cdef ClientOrderId client_order_id = ClientOrderId.__new__(ClientOrderId)
        client_order_id._mem = mem
        return client_order_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)


cdef class VenueOrderId(Identifier):
    """
    Represents a valid venue order ID (assigned by a trading venue).

    Parameters
    ----------
    value : str
        The venue assigned order ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = venue_order_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = venue_order_id_new(pystr_to_cstr(state))

    def __eq__(self, VenueOrderId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef VenueOrderId from_mem_c(VenueOrderId_t mem):
        cdef VenueOrderId venue_order_id = VenueOrderId.__new__(VenueOrderId)
        venue_order_id._mem = mem
        return venue_order_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)


cdef class OrderListId(Identifier):
    """
    Represents a valid order list ID (assigned by the Nautilus system).

    Parameters
    ----------
    value : str
        The order list ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = order_list_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = order_list_id_new(pystr_to_cstr(state))

    def __eq__(self, OrderListId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef OrderListId from_mem_c(OrderListId_t mem):
        cdef OrderListId order_list_id = OrderListId.__new__(OrderListId)
        order_list_id._mem = mem
        return order_list_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)


cdef class PositionId(Identifier):
    """
    Represents a valid position ID.

    Parameters
    ----------
    value : str
        The position ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string containing a hyphen.
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        self._mem = position_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = position_id_new(pystr_to_cstr(state))

    def __eq__(self, PositionId other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem._0, other._mem._0) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef PositionId from_mem_c(PositionId_t mem):
        cdef PositionId position_id = PositionId.__new__(PositionId)
        position_id._mem = mem
        return position_id

    cdef str to_str(self):
        return ustr_to_pystr(self._mem._0)

    cdef bint is_virtual_c(self):
        return self.to_str().startswith("P-")


cdef class TradeId(Identifier):
    """
    Represents a valid trade match ID (assigned by a trading venue).

    Maximum length is 36 characters.
    Can correspond to the `TradeID <1003> field` of the FIX protocol.

    The unique ID assigned to the trade entity once it is received or matched by
    the exchange or central counterparty.

    Parameters
    ----------
    value : str
        The trade match ID value.

    Raises
    ------
    ValueError
        If `value` is not a valid string.
    ValueError
        If `value` length exceeds maximum 36 characters.

    References
    ----------
    https://www.onixs.biz/fix-dictionary/5.0/tagnum_1003.html
    """

    def __init__(self, str value not None) -> None:
        Condition.valid_string(value, "value")
        if len(value) > 36:
            Condition.in_range_int(len(value), 1, 36, "value")

        self._mem = trade_id_new(pystr_to_cstr(value))

    def __getstate__(self):
        return self.to_str()

    def __setstate__(self, state):
        self._mem = trade_id_new(pystr_to_cstr(state))

    def __eq__(self, TradeId other) -> bool:
        if other is None:
            return False
        return strcmp(trade_id_to_cstr(&self._mem), trade_id_to_cstr(&other._mem)) == 0

    def __hash__(self) -> int:
        # A rare zero hash will cause frequent recomputations
        if self._hash == 0:
            self._hash = hash(self.to_str())
        return self._hash

    @staticmethod
    cdef TradeId from_mem_c(TradeId_t mem):
        cdef TradeId trade_id = TradeId.__new__(TradeId)
        trade_id._mem = mem
        return trade_id

    cdef str to_str(self):
        return cstr_to_pystr(trade_id_to_cstr(&self._mem), False)

</document_content>
</document>
<document index="2414">
<source>nautilus_trader/model/instruments/base.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.math cimport floor
from libc.math cimport pow
from libc.stdint cimport uint64_t

from nautilus_trader.core import nautilus_pyo3

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.core cimport min_increment_precision_from_cstr
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.string cimport pystr_to_cstr
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.functions cimport instrument_class_from_str
from nautilus_trader.model.functions cimport instrument_class_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.betting cimport BettingInstrument
from nautilus_trader.model.instruments.binary_option cimport BinaryOption
from nautilus_trader.model.instruments.crypto_future cimport CryptoFuture
from nautilus_trader.model.instruments.crypto_option cimport CryptoOption
from nautilus_trader.model.instruments.crypto_perpetual cimport CryptoPerpetual
from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
from nautilus_trader.model.instruments.equity cimport Equity
from nautilus_trader.model.instruments.futures_contract cimport FuturesContract
from nautilus_trader.model.instruments.futures_spread cimport FuturesSpread
from nautilus_trader.model.instruments.option_contract cimport OptionContract
from nautilus_trader.model.instruments.option_spread cimport OptionSpread
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.tick_scheme.base cimport TICK_SCHEMES
from nautilus_trader.model.tick_scheme.base cimport get_tick_scheme


EXPIRING_INSTRUMENT_CLASSES = {
    InstrumentClass.FUTURE,
    InstrumentClass.FUTURES_SPREAD,
    InstrumentClass.OPTION,
    InstrumentClass.OPTION_SPREAD,
}

NEGATIVE_PRICE_INSTRUMENT_CLASSES = (
    InstrumentClass.OPTION,
    InstrumentClass.FUTURES_SPREAD,
    InstrumentClass.OPTION_SPREAD,
)


cdef class Instrument(Data):
    """
    The base class for all instruments.

    Represents a tradable instrument. This class can be used to
    define an instrument, or act as a parent class for more specific instruments.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the instrument.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    asset_class : AssetClass
        The instrument asset class.
    instrument_class : InstrumentClass
        The instrument class.
    quote_currency : Currency
        The quote currency.
    is_inverse : bool
        If the instrument costing is inverse (quantity expressed in quote currency units).
    price_precision : int
        The price decimal precision.
    size_precision : int
        The trading size decimal precision.
    size_increment : Quantity
        The minimum size increment.
    multiplier : Quantity
        The contract value multiplier (determines tick value).
    lot_size : Quantity, optional
        The rounded lot unit size (standard/board).
    margin_init : Decimal
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal
        The fee rate for liquidity makers as a percentage of order value (where 1.0 is 100%).
    taker_fee : Decimal
        The fee rate for liquidity takers as a percentage of order value (where 1.0 is 100%).
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    price_increment : Price, optional
        The minimum price increment (tick size).
    max_quantity : Quantity, optional
        The maximum allowable order quantity.
    min_quantity : Quantity, optional
        The minimum allowable order quantity.
    max_notional : Money, optional
        The maximum allowable order notional value.
    min_notional : Money, optional
        The minimum allowable order notional value.
    max_price : Price, optional
        The maximum allowable quoted price.
    min_price : Price, optional
        The minimum allowable quoted price.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `tick_scheme_name` is not a valid string.
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).
    ValueError
        If `price_precision` is not equal to price_increment.precision.
    ValueError
        If `size_increment` is not equal to size_increment.precision.
    ValueError
        If `multiplier` is not positive (> 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).
    ValueError
        If `lot size` is not positive (> 0).
    ValueError
        If `max_quantity` is not positive (> 0).
    ValueError
        If `min_quantity` is negative (< 0).
    ValueError
        If `max_notional` is not positive (> 0).
    ValueError
        If `min_notional` is negative (< 0).
    ValueError
        If `max_price` is not positive (> 0).
    ValueError
        If `min_price` is negative (< 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        AssetClass asset_class,
        InstrumentClass instrument_class,
        Currency quote_currency not None,
        bint is_inverse,
        int price_precision,
        int size_precision,
        Quantity size_increment not None,
        Quantity multiplier not None,
        margin_init not None: Decimal,
        margin_maint not None: Decimal,
        maker_fee not None: Decimal,
        taker_fee not None: Decimal,
        uint64_t ts_event,
        uint64_t ts_init,
        Price price_increment: Price | None = None,
        Quantity lot_size: Quantity | None = None,
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        Money max_notional: Money | None = None,
        Money min_notional: Money | None = None,
        Price max_price: Price | None = None,
        Price min_price: Price | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        Condition.not_negative_int(price_precision, "price_precision")
        Condition.not_negative_int(size_precision, "size_precision")
        Condition.positive(size_increment, "size_increment")
        Condition.equal(size_precision, size_increment.precision, "size_precision", "size_increment.precision")  # noqa
        Condition.positive(multiplier, "multiplier")
        Condition.not_negative(margin_init, "margin_init")
        Condition.not_negative(margin_maint, "margin_maint")

        if tick_scheme_name is not None:
            Condition.valid_string(tick_scheme_name, "tick_scheme_name")
            Condition.is_in(tick_scheme_name, TICK_SCHEMES, "tick_scheme_name", "TICK_SCHEMES")

        if price_increment is not None:
            Condition.positive(price_increment, "price_increment")

        if price_precision is not None and price_increment is not None:
            Condition.equal(price_precision, price_increment.precision, "price_precision", "price_increment.precision")  # noqa

        if lot_size is not None:
            Condition.positive(lot_size, "lot_size")

        if max_quantity is not None:
            Condition.positive(max_quantity, "max_quantity")

        if min_quantity is not None:
            Condition.not_negative(min_quantity, "min_quantity")

        if max_notional is not None:
            Condition.positive(max_notional, "max_notional")

        if min_notional is not None:
            Condition.not_negative(min_notional, "min_notional")

        if max_price is not None:
            Condition.positive(max_price, "max_price")

        if min_price is not None:
            Condition.not_negative(min_price, "min_price")

        Condition.type(margin_init, Decimal, "margin_init")
        Condition.not_negative(margin_init, "margin_init")
        Condition.type(margin_maint, Decimal, "margin_maint")
        Condition.not_negative(margin_maint, "margin_maint")
        Condition.type(maker_fee, Decimal, "maker_fee")
        Condition.type(taker_fee, Decimal, "taker_fee")

        self.id = instrument_id
        self.raw_symbol = raw_symbol
        self.asset_class = asset_class
        self.instrument_class = instrument_class
        self.quote_currency = quote_currency
        self.is_inverse = is_inverse
        self.price_precision = price_precision
        self.price_increment = price_increment or Price(pow(10.0, -price_precision), price_precision)
        self.tick_scheme_name = tick_scheme_name
        self.size_precision = size_precision
        self.size_increment = size_increment
        self.multiplier = multiplier
        self.lot_size = lot_size
        self.max_quantity = max_quantity
        self.min_quantity = min_quantity
        self.max_notional = max_notional
        self.min_notional = min_notional
        self.max_price = max_price
        self.min_price = min_price
        self.margin_init = margin_init
        self.margin_maint = margin_maint
        self.maker_fee = maker_fee
        self.taker_fee = taker_fee
        self.info = info
        self.ts_event = ts_event
        self.ts_init = ts_init

        self._min_price_increment_precision = min_increment_precision_from_cstr(pystr_to_cstr(str(self.price_increment)))
        self._min_size_increment_precision = min_increment_precision_from_cstr(pystr_to_cstr(str(self.size_increment)))
        self._increment_pow10 = 10 ** -self._min_size_increment_precision

        # Assign tick scheme if named
        if self.tick_scheme_name is not None:
            self._tick_scheme = get_tick_scheme(self.tick_scheme_name)

    def __eq__(self, Instrument other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __repr__(self) -> str:  # TODO: tick_scheme_name pending
        return (
            f"{type(self).__name__}"
            f"(id={self.id.to_str()}, "
            f"raw_symbol={self.raw_symbol}, "
            f"asset_class={asset_class_to_str(self.asset_class)}, "
            f"instrument_class={instrument_class_to_str(self.instrument_class)}, "
            f"quote_currency={self.quote_currency}, "
            f"is_inverse={self.is_inverse}, "
            f"price_precision={self.price_precision}, "
            f"price_increment={self.price_increment}, "
            f"size_precision={self.size_precision}, "
            f"size_increment={self.size_increment}, "
            f"multiplier={self.multiplier}, "
            f"lot_size={self.lot_size}, "
            f"margin_init={self.margin_init}, "
            f"margin_maint={self.margin_maint}, "
            f"maker_fee={self.maker_fee}, "
            f"taker_fee={self.taker_fee}, "
            f"info={self.info})"
        )

    @staticmethod
    cdef Instrument base_from_dict_c(dict values):
        cdef str lot_s = values["lot_size"]
        cdef str max_q = values["max_quantity"]
        cdef str min_q = values["min_quantity"]
        cdef str max_n = values["max_notional"]
        cdef str min_n = values["min_notional"]
        cdef str max_p = values["max_price"]
        cdef str min_p = values["min_price"]

        return Instrument(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            asset_class=asset_class_from_str(values["asset_class"]),
            instrument_class=instrument_class_from_str(values["instrument_class"]),
            quote_currency=Currency.from_str_c(values["quote_currency"]),
            is_inverse=values["is_inverse"],
            price_precision=values["price_precision"],
            size_precision=values["size_precision"],
            price_increment=Price.from_str_c(values["price_increment"]),
            size_increment=Quantity.from_str_c(values["size_increment"]),
            multiplier=Quantity.from_str_c(values["multiplier"]),
            lot_size=Quantity.from_str_c(lot_s) if lot_s is not None else None,
            max_quantity=Quantity.from_str_c(max_q) if max_q is not None else None,
            min_quantity=Quantity.from_str_c(min_q) if min_q is not None else None,
            max_notional=Money.from_str_c(max_n) if max_n is not None else None,
            min_notional=Money.from_str_c(min_n) if min_n is not None else None,
            max_price=Price.from_str_c(max_p) if max_p is not None else None,
            min_price=Price.from_str_c(min_p) if min_p is not None else None,
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values["info"],
        )

    @staticmethod
    cdef dict base_to_dict_c(Instrument obj):
        return {
            "type": "Instrument",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "asset_class": asset_class_to_str(obj.asset_class),
            "instrument_class": instrument_class_to_str(obj.instrument_class),
            "quote_currency": obj.quote_currency.code,
            "is_inverse": obj.is_inverse,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "lot_size": str(obj.lot_size) if obj.lot_size is not None else None,
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_notional": str(obj.max_notional) if obj.max_notional is not None else None,
            "min_notional": str(obj.min_notional) if obj.min_notional is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    def base_from_dict(dict values) -> Instrument:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        Instrument

        """
        return Instrument.base_from_dict_c(values)

    @staticmethod
    def base_to_dict(Instrument obj):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return Instrument.base_to_dict_c(obj)

    @property
    def symbol(self):
        """
        Return the instruments ticker symbol.

        Returns
        -------
        Symbol

        """
        return self.id.symbol

    @property
    def venue(self):
        """
        Return the instruments trading venue.

        Returns
        -------
        Venue

        """
        return self.id.venue

    cpdef bint is_spread(self):
        """
        Return whether the instrument is a spread instrument.

        Returns
        -------
        bool

        """
        return False

    cpdef Currency get_base_currency(self):
        """
        Return the instruments base currency (if applicable).

        Returns
        -------
        Currency or ``None``

        """
        return None

    cpdef Currency get_settlement_currency(self):
        """
        Return the currency used to settle a trade of the instrument.

        - Standard linear instruments = quote_currency
        - Inverse instruments = base_currency
        - Quanto instruments = settlement_currency

        Returns
        -------
        Currency

        """
        if self.is_inverse:
            return self.base_currency
        else:
            return self.quote_currency

    cpdef Currency get_cost_currency(self):
        """
        Return the currency used for PnL calculations for the instrument.

        - Standard linear instruments = quote_currency
        - Inverse instruments = base_currency
        - Quanto instruments TBD

        Returns
        -------
        Currency

        """
        if self.is_inverse:
            return self.base_currency
        else:
            return self.quote_currency

    cpdef void set_tick_scheme(self, str tick_scheme_name):
        """
        Set the tick scheme for the instrument.

        Sets both the `tick_scheme_name` and the corresponding tick scheme implementation
        used for price rounding and tick calculations.

        This will override any previously set tick scheme, including the `tick_scheme_name` field.

        Parameters
        ----------
        tick_scheme_name : str
            The name of the registered tick scheme.

        Raises
        ------
        ValueError
            If `tick_scheme_name` is not a valid string.
        ValueError
            If `tick_scheme_name` is not a registered tick scheme.

        """
        self.tick_scheme_name = tick_scheme_name
        self._tick_scheme = get_tick_scheme(tick_scheme_name)

    cpdef Price make_price(self, value):
        """
        Return a new price from the given value using the instruments price
        precision.

        Parameters
        ----------
        value : integer, float, str or Decimal
            The value of the price.

        Returns
        -------
        Price

        """
        cdef double rounded_value = round(float(value), self._min_price_increment_precision)

        return Price(rounded_value, precision=self.price_precision)

    cpdef Price next_bid_price(self, double value, int num_ticks=0):
        """
        Return the price `n` bid ticks away from value.

        If a given price is between two ticks, n=0 will find the nearest bid tick.

        Parameters
        ----------
        value : double
            The reference value.
        num_ticks : int, default 0
            The number of ticks to move.

        Returns
        -------
        Price

        Raises
        ------
        ValueError
            If a tick scheme is not initialized.

        """
        if self._tick_scheme is None:
            raise ValueError(
                f"No tick scheme for instrument {self.id.to_str()}. "
                "You can specify a tick scheme by passing a `tick_scheme_name` at initialization."
            )

        return self._tick_scheme.next_bid_price(value=value, n=num_ticks)

    cpdef Price next_ask_price(self, double value, int num_ticks=0):
        """
        Return the price `n` ask ticks away from value.

        If a given price is between two ticks, n=0 will find the nearest ask tick.

        Parameters
        ----------
        value : double
            The reference value.
        num_ticks : int, default 0
            The number of ticks to move.

        Returns
        -------
        Price

        Raises
        ------
        ValueError
            If a tick scheme is not initialized.

        """
        if self._tick_scheme is None:
            raise ValueError(
                f"No tick scheme for instrument {self.id.to_str()}. "
                "You can specify a tick scheme by passing a `tick_scheme_name` at initialization."
            )

        return self._tick_scheme.next_ask_price(value=value, n=num_ticks)

    cpdef list next_bid_prices(self, double value, int num_ticks=100):
        """
        Return a list of prices up to `num_ticks` bid ticks away from value.

        If a given price is between two ticks, the first price will be the nearest bid tick.
        Returns as many valid ticks as possible up to `num_ticks`. Will return an empty list
        if no valid ticks can be generated.

        Parameters
        ----------
        value : double
            The reference value.
        num_ticks : int, default 100
            The number of ticks to return.

        Returns
        -------
        list[Decimal]
            A list of bid prices as Decimal values.

        Raises
        ------
        ValueError
            If a tick scheme is not initialized.
        """
        if self._tick_scheme is None:
            raise ValueError(
                f"No tick scheme for instrument {self.id.to_str()}. "
                "You can specify a tick scheme by passing a `tick_scheme_name` at initialization."
            )

        if num_ticks <= 0:
            return []

        cdef:
            list prices = []
            Price price
            int i
        for i in range(num_ticks):
            try:
                price = self._tick_scheme.next_bid_price(value=value, n=i)

                if price is None:
                    break
                if self.min_price is not None and price < self.min_price:
                    break

                prices.append(price.as_decimal())
            except Exception:
                break

        return prices

    cpdef list next_ask_prices(self, double value, int num_ticks=100):
        """
        Return a list of prices up to `num_ticks` ask ticks away from value.

        If a given price is between two ticks, the first price will be the nearest ask tick.
        Returns as many valid ticks as possible up to `num_ticks`. Will return an empty list
        if no valid ticks can be generated.

        Parameters
        ----------
        value : double
            The reference value.
        num_ticks : int, default 100
            The number of ticks to return.

        Returns
        -------
        list[Decimal]
            A list of ask prices as Decimal values.

        Raises
        ------
        ValueError
            If a tick scheme is not initialized.
        """
        if self._tick_scheme is None:
            raise ValueError(
                f"No tick scheme for instrument {self.id.to_str()}. "
                "You can specify a tick scheme by passing a `tick_scheme_name` at initialization."
            )

        if num_ticks <= 0:
            return []

        cdef:
            list prices = []
            Price price
            int i
        for i in range(num_ticks):
            try:
                price = self._tick_scheme.next_ask_price(value=value, n=i)

                if price is None:
                    break

                if self.max_price is not None and price > self.max_price:
                    break

                prices.append(price.as_decimal())
            except Exception:
                break

        return prices

    cpdef Quantity make_qty(self, value, bint round_down=False):
        """
        Return a new quantity from the given value using the instruments size
        precision.

        Parameters
        ----------
        value : integer, float, str or Decimal
            The value of the quantity.
        round_down : bool, default False
            If True, always rounds down to the nearest valid increment.
            If False, uses the `round` function (banker's rounding) which
            rounds to the nearest even digit when exactly halfway between two values.

        Returns
        -------
        Quantity

        Raises
        ------
        ValueError
            If a non zero `value` is rounded to zero due to the instruments size increment or size precision.

        """
        # Check if original_value is greater than zero and rounded_value is "effectively" zero
        cdef double original_value = float(value)
        cdef double inc_pow10 = self._increment_pow10
        cdef double rounded_value = 0.0

        if round_down:
            # Round down to the nearest valid increment
            rounded_value = floor(original_value / inc_pow10) *inc_pow10
        else:
            # Use standard rounding behavior (banker's rounding)
            rounded_value = round(original_value, self._min_size_increment_precision)

        if original_value > 0 and rounded_value < inc_pow10 * 0.1:
            raise ValueError(
                f"Invalid `value` for quantity: {value} was rounded to zero "
                f"due to size increment {self.size_increment} "
                f"and size precision {self.size_precision}",
            )

        return Quantity(rounded_value, precision=self.size_precision)

    cpdef Money notional_value(
        self,
        Quantity quantity,
        Price price,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the notional value.

        Result will be in quote currency for standard instruments, or base
        currency for inverse instruments.

        Parameters
        ----------
        quantity : Quantity
            The total quantity.
        price : Price
            The price for the calculation.
        use_quote_for_inverse : bool
            If inverse instrument calculations use quote currency (instead of base).

        Returns
        -------
        Money

        """
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")

        if self.is_inverse:
            if use_quote_for_inverse:
                # Quantity is notional in quote currency
                return Money(quantity, self.quote_currency)

            return Money(quantity.as_f64_c() * float(self.multiplier) * (1.0 / price.as_f64_c()), self.base_currency)
        else:
            return Money(quantity.as_f64_c() * float(self.multiplier) * price.as_f64_c(), self.quote_currency)

    cpdef Quantity calculate_base_quantity(
        self,
        Quantity quantity,
        Price last_px,
    ):
        """
        Calculate the base asset quantity from the given quote asset `quantity` and last price.

        Parameters
        ----------
        quantity : Quantity
            The quantity to convert from.
        last_px : Price
            The last price for the instrument.

        Returns
        -------
        Quantity

        """
        Condition.not_none(quantity, "quantity")

        return Quantity(quantity.as_f64_c() * (1.0 / last_px.as_f64_c()), self.size_precision)


cpdef list[Instrument] instruments_from_pyo3(list pyo3_instruments):
    cdef list[Instrument] instruments = []

    for pyo3_instrument in pyo3_instruments:
        if isinstance(pyo3_instrument, nautilus_pyo3.BettingInstrument):
            instruments.append(BettingInstrument.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.BinaryOption):
            instruments.append(BinaryOption.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.CryptoPerpetual):
            instruments.append(CryptoPerpetual.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.CryptoFuture):
            instruments.append(CryptoFuture.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.CryptoOption):
            instruments.append(CryptoOption.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.CurrencyPair):
            instruments.append(CurrencyPair.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.Equity):
            instruments.append(Equity.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.FuturesContract):
            instruments.append(FuturesContract.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.FuturesSpread):
            instruments.append(FuturesSpread.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.OptionContract):
            instruments.append(OptionContract.from_pyo3_c(pyo3_instrument))
        elif isinstance(pyo3_instrument, nautilus_pyo3.OptionSpread):
            instruments.append(OptionSpread.from_pyo3_c(pyo3_instrument))
        else:
            RuntimeError(f"Instrument {pyo3_instrument} not supported")

    return instruments

</document_content>
</document>
<document index="2416">
<source>nautilus_trader/model/instruments/betting.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd

from nautilus_trader.core import nautilus_pyo3

from cpython.datetime cimport datetime
from libc.stdint cimport int8_t
from libc.stdint cimport int64_t
from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class BettingInstrument(Instrument):
    """
    Represents an instrument in a betting market.
    """

    def __init__(
        self,
        str venue_name not None,
        int event_type_id,
        str event_type_name not None,
        int competition_id,
        str competition_name not None,
        int event_id,
        str event_name not None,
        str event_country_code not None,
        datetime event_open_date not None,
        str betting_type not None,
        str market_id not None,
        str market_name not None,
        datetime market_start_time not None,
        str market_type not None,
        int selection_id,
        str selection_name not None,
        str currency not None,
        float selection_handicap,
        int8_t price_precision,
        int8_t size_precision,
        uint64_t ts_event,
        uint64_t ts_init,
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        Money max_notional: Money | None = None,
        Money min_notional: Money | None = None,
        Price max_price: Price | None = None,
        Price min_price: Price | None = None,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        assert event_open_date.tzinfo or market_start_time.tzinfo is not None

        # Event type (Sport) info e.g. Basketball
        self.event_type_id = event_type_id
        self.event_type_name = event_type_name

        # Competition e.g. NBA
        self.competition_id = competition_id
        self.competition_name = competition_name

        # Event info e.g. Utah Jazz @ Boston Celtics Wed 17 Mar, 10:40
        self.event_id = event_id
        self.event_name = event_name
        self.event_country_code = event_country_code
        self.event_open_date = pd.Timestamp(event_open_date).tz_convert("UTC")

        # Market Info e.g. Match odds / Handicap
        self.betting_type = betting_type
        self.market_id = market_id
        self.market_type = market_type
        self.market_name = market_name
        self.market_start_time = pd.Timestamp(market_start_time).tz_convert("UTC")

        # Selection/Runner (individual selection/runner) e.g. (LA Lakers)
        self.selection_id = selection_id
        self.selection_name = selection_name
        self.selection_handicap = selection_handicap

        cdef Symbol symbol = make_symbol(market_id, selection_id, selection_handicap)

        super().__init__(
            instrument_id=InstrumentId(symbol=symbol, venue=Venue(venue_name)),
            raw_symbol=symbol,
            asset_class=AssetClass.ALTERNATIVE,
            instrument_class=InstrumentClass.SPORTS_BETTING,
            quote_currency=Currency.from_str_c(currency),
            is_inverse=False,
            size_precision=size_precision,
            price_precision=price_precision,
            price_increment=None,
            size_increment=Quantity(0.01, precision=size_precision),
            multiplier=Quantity.from_int_c(1),
            lot_size=Quantity.from_int_c(1),
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=max_notional,
            min_notional=min_notional,
            max_price=max_price,
            min_price=min_price,
            margin_init=margin_init or Decimal(1),
            margin_maint=margin_maint or Decimal(1),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info or {},
        )
        if not min_price and tick_scheme_name:
            self.min_price = self._tick_scheme.min_price
        if not max_price and tick_scheme_name:
            self.max_price = self._tick_scheme.max_price

    @staticmethod
    cdef BettingInstrument from_dict_c(dict values):
        Condition.not_none(values, "values")
        data = values.copy()
        data["event_open_date"] = pd.Timestamp(data["event_open_date"], tz="UTC")
        data["market_start_time"] = pd.Timestamp(data["market_start_time"], tz="UTC")

        max_quantity = data.get("max_quantity")
        if max_quantity:
            data["max_quantity"] = Quantity.from_str(max_quantity)

        min_quantity = data.get("min_quantity")
        if min_quantity:
            data["min_quantity"] = Quantity.from_str(min_quantity)

        max_notional = data.get("max_notional")
        if max_notional:
            data["max_notional"] = Money.from_str(max_notional)

        min_notional = data.get("min_notional")
        if min_notional:
            data["min_notional"] = Money.from_str(min_notional)

        max_price = data.get("max_price")
        if max_price:
            data["max_price"] = Price.from_str(max_price)

        min_price = data.get("min_price")
        if min_price:
            data["min_price"] = Price.from_str(min_price)

        margin_init = data.get("margin_init")
        if margin_init:
            data["margin_init"] = Decimal(margin_init)

        margin_maint = data.get("margin_maint")
        if margin_maint:
            data["margin_maint"] = Decimal(margin_maint)

        maker_fee = data.get("maker_fee")
        if maker_fee:
            data["maker_fee"] = Decimal(maker_fee)

        taker_fee = data.get("taker_fee")
        if taker_fee:
            data["taker_fee"] = Decimal(taker_fee)

        tick_scheme_name = values.get("tick_scheme_name")
        if tick_scheme_name:
            data["tick_scheme_name"] = tick_scheme_name

        data.pop("raw_symbol", None)
        data.pop("price_increment", None)
        data.pop("size_increment", None)
        return BettingInstrument(**{k: v for k, v in data.items() if k not in ("id", "type")})

    @staticmethod
    cdef dict to_dict_c(BettingInstrument obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "BettingInstrument",
            "id": obj.id.to_str(),
            "raw_symbol": obj.id.symbol.value,
            "venue_name": obj.id.venue.value,
            "event_type_id": obj.event_type_id,
            "event_type_name": obj.event_type_name,
            "competition_id": obj.competition_id,
            "competition_name": obj.competition_name,
            "event_id": obj.event_id,
            "event_name": obj.event_name,
            "event_country_code": obj.event_country_code,
            "event_open_date": obj.event_open_date.value,
            "betting_type": obj.betting_type,
            "market_id": obj.market_id,
            "market_name": obj.market_name,
            "market_type": obj.market_type,
            "market_start_time": obj.market_start_time.value,
            "selection_id": obj.selection_id,
            "selection_name": obj.selection_name,
            "selection_handicap": obj.selection_handicap,
            "price_precision": obj.price_precision,
            "size_precision": obj.size_precision,
            "price_increment": str(obj.price_increment),
            "size_increment": str(obj.size_increment),
            "currency": obj.quote_currency.code,
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_notional": str(obj.max_notional) if obj.max_notional is not None else None,
            "min_notional": str(obj.min_notional) if obj.min_notional is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    def from_dict(dict values) -> BettingInstrument:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        BettingInstrument

        """
        return BettingInstrument.from_dict_c(values)

    @staticmethod
    def to_dict(BettingInstrument obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return BettingInstrument.to_dict_c(obj)

    cpdef Money notional_value(self, Quantity quantity, Price price, bint use_quote_for_inverse=False):
        Condition.not_none(quantity, "quantity")
        return Money(quantity.as_f64_c() * float(self.multiplier), self.quote_currency)


cpdef Symbol make_symbol(
    str market_id,
    int selection_id,
    float selection_handicap,
):
    """
    Make symbol.

    >>> make_symbol(market_id="1.201070830", selection_id=123456, selection_handicap=null_handicap())
    Symbol('1-201070830-123456-None')

    """
    market_id = market_id.replace(".", "-")
    handicap = selection_handicap if selection_handicap != null_handicap() else None

    cdef str value = f"{market_id}-{selection_id}-{handicap}".replace(" ", "").replace(":", "")
    assert len(value) <= 32, f"Symbol too long ({len(value)}): '{value}'"
    return Symbol(value)


cpdef double null_handicap():
    cdef double NULL_HANDICAP = -9999999.0
    return NULL_HANDICAP


cpdef object order_side_to_bet_side(OrderSide order_side):
    if order_side == OrderSide.BUY:
        return nautilus_pyo3.BetSide.LAY
    else:  # order_side == OrderSide.SELL
        return nautilus_pyo3.BetSide.BACK

</document_content>
</document>
<document index="2418">
<source>nautilus_trader/model/instruments/binary_option.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd
import pytz

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.rust.model cimport OptionKind
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.functions cimport instrument_class_from_str
from nautilus_trader.model.functions cimport instrument_class_to_str
from nautilus_trader.model.functions cimport option_kind_from_str
from nautilus_trader.model.functions cimport option_kind_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.base cimport Price
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Quantity


cdef class BinaryOption(Instrument):
    """
    Represents a generic binary option instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    asset_class : AssetClass
        The option contract asset class.
    currency : Currency
        The option contract currency.
    price_precision : int
        The price decimal precision.
    size_precision : int
        The trading size decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    size_increment : Quantity
        The minimum size increment.
    activation_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract activation.
    expiration_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract expiration.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    max_quantity : Quantity, optional
        The maximum allowable order quantity.
    min_quantity : Quantity, optional
        The minimum allowable order quantity.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    outcome : str, optional
        The binary outcome of the market.
    description : str, optional
        The market description.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        AssetClass asset_class,
        Currency currency not None,
        int price_precision,
        int size_precision,
        Price price_increment not None,
        Quantity size_increment not None,
        uint64_t activation_ns,
        uint64_t expiration_ns,
        uint64_t ts_event,
        uint64_t ts_init,
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str outcome = None,
        str description = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        if description is not None:
            Condition.valid_string(description, "description")
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=asset_class,
            instrument_class=InstrumentClass.BINARY_OPTION,
            quote_currency=currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=size_precision,
            price_increment=price_increment,
            size_increment=size_increment,
            multiplier=Quantity.from_int_c(1),
            lot_size=Quantity.from_int_c(1),
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=None,
            min_notional=None,
            max_price=None,
            min_price=None,
            margin_init=Decimal(0),
            margin_maint=Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.outcome = outcome
        self.description = description
        self.activation_ns = activation_ns
        self.expiration_ns = expiration_ns

    @property
    def activation_utc(self) -> pd.Timestamp:
        """
        Return the contract activation timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.activation_ns, tz=pytz.utc)

    @property
    def expiration_utc(self) -> pd.Timestamp:
        """
        Return the contract expiration timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.expiration_ns, tz=pytz.utc)

    @staticmethod
    cdef BinaryOption from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str max_q = values["max_quantity"]
        cdef str min_q = values["min_quantity"]
        return BinaryOption(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            asset_class=asset_class_from_str(values["asset_class"]),
            currency=Currency.from_str_c(values["currency"]),
            price_precision=values["price_precision"],
            size_precision=values["size_precision"],
            price_increment=Price.from_str(values["price_increment"]),
            size_increment=Quantity.from_str(values["size_increment"]),
            activation_ns=values["activation_ns"],
            expiration_ns=values["expiration_ns"],
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            outcome=values["outcome"],
            description=values["description"],
            max_quantity=Quantity.from_str(max_q) if max_q is not None else None,
            min_quantity=Quantity.from_str(min_q) if min_q is not None else None,
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values.get("info"),
        )

    @staticmethod
    cdef dict to_dict_c(BinaryOption obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "BinaryOption",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "outcome": obj.outcome,
            "description": obj.description,
            "asset_class": asset_class_to_str(obj.asset_class),
            "currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "size_precision": obj.size_precision,
            "price_increment": str(obj.price_increment),
            "size_increment": str(obj.size_increment),
            "activation_ns": obj.activation_ns,
            "expiration_ns": obj.expiration_ns,
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    def from_dict(dict values) -> BinaryOption:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
       BinaryOption

        """
        return BinaryOption.from_dict_c(values)

    @staticmethod
    def to_dict(BinaryOption obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return BinaryOption.to_dict_c(obj)

</document_content>
</document>
<document index="2420">
<source>nautilus_trader/model/instruments/cfd.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport CurrencyType
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class Cfd(Instrument):
    """
    Represents a Contract for Difference (CFD) instrument.

    Can represent both Fiat FX and Cryptocurrency pairs.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the instrument.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    asset_class : AssetClass
        The CFD contract asset class.
    quote_currency : Currency
        The quote currency.
    price_precision : int
        The price decimal precision.
    size_precision : int
        The trading size decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    size_increment : Quantity
        The minimum size increment.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    base_currency : Currency, optional
        The base currency.
    lot_size : Quantity, optional
        The rounded lot unit size.
    max_quantity : Quantity, optional
        The maximum allowable order quantity.
    min_quantity : Quantity, optional
        The minimum allowable order quantity.
    max_notional : Money, optional
        The maximum allowable order notional value.
    min_notional : Money, optional
        The minimum allowable order notional value.
    max_price : Price, optional
        The maximum allowable quoted price.
    min_price : Price, optional
        The minimum allowable quoted price.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `tick_scheme_name` is not a valid string.
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).
    ValueError
        If `price_precision` is not equal to price_increment.precision.
    ValueError
        If `size_increment` is not equal to size_increment.precision.
    ValueError
        If `lot_size` is not positive (> 0).
    ValueError
        If `max_quantity` is not positive (> 0).
    ValueError
        If `min_quantity` is negative (< 0).
    ValueError
        If `max_notional` is not positive (> 0).
    ValueError
        If `min_notional` is negative (< 0).
    ValueError
        If `max_price` is not positive (> 0).
    ValueError
        If `min_price` is negative (< 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).

    References
    ----------
    https://en.wikipedia.org/wiki/Contract_for_difference

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        AssetClass asset_class,
        Currency quote_currency not None,
        int price_precision,
        int size_precision,
        Price price_increment not None,
        Quantity size_increment not None,
        uint64_t ts_event,
        uint64_t ts_init,
        Currency base_currency: Currency | None = None,
        Quantity lot_size: Quantity | None = None,
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        Money max_notional: Money | None = None,
        Money min_notional: Money | None = None,
        Price max_price: Price | None = None,
        Price min_price: Price | None = None,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=asset_class,
            instrument_class=InstrumentClass.CFD,
            quote_currency=quote_currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=size_precision,
            price_increment=price_increment,
            size_increment=size_increment,
            multiplier=Quantity.from_int_c(1),
            lot_size=lot_size,
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=max_notional,
            min_notional=min_notional,
            max_price=max_price,
            min_price=min_price,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.base_currency = base_currency

    @staticmethod
    cdef Cfd from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str base_c = values["base_currency"]
        cdef str lot_s = values["lot_size"]
        cdef str max_q = values.get("max_quantity")
        cdef str min_q = values.get("min_quantity")
        cdef str max_n = values.get("max_notional")
        cdef str min_n = values.get("min_notional")
        cdef str max_p = values.get("max_price")
        cdef str min_p = values.get("min_price")
        return Cfd(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            asset_class=asset_class_from_str(values["asset_class"]),
            quote_currency=Currency.from_str_c(values["quote_currency"]),
            price_precision=values["price_precision"],
            size_precision=values["size_precision"],
            price_increment=Price.from_str_c(values["price_increment"]),
            size_increment=Quantity.from_str_c(values["size_increment"]),
            base_currency=Currency.from_str_c(values["base_currency"]) if base_c is not None else None,
            lot_size=Quantity.from_str_c(lot_s) if lot_s is not None else None,
            max_quantity=Quantity.from_str_c(max_q) if max_q is not None else None,
            min_quantity=Quantity.from_str_c(min_q) if min_q is not None else None,
            max_notional=Money.from_str_c(max_n) if max_n is not None else None,
            min_notional=Money.from_str_c(min_n) if min_n is not None else None,
            max_price=Price.from_str_c(max_p) if max_p is not None else None,
            min_price=Price.from_str_c(min_p) if min_p is not None else None,
            margin_init=Decimal(values.get("margin_init", 0)),
            margin_maint=Decimal(values.get("margin_maint", 0)),
            maker_fee=Decimal(values.get("maker_fee", 0)),
            taker_fee=Decimal(values.get("taker_fee", 0)),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values["info"],
        )

    @staticmethod
    cdef dict to_dict_c(Cfd obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "Cfd",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "asset_class": asset_class_to_str(obj.asset_class),
            "quote_currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "lot_size": str(obj.lot_size) if obj.lot_size is not None else None,
            "base_currency": obj.base_currency.code if obj.base_currency is not None else None,
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_notional": str(obj.max_notional) if obj.max_notional is not None else None,
            "min_notional": str(obj.min_notional) if obj.min_notional is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    def from_dict(dict values) -> Cfd:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        Cfd

        """
        return Cfd.from_dict_c(values)

    @staticmethod
    def to_dict(Cfd obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return Cfd.to_dict_c(obj)

    @staticmethod
    cdef Cfd from_pyo3_c(pyo3_instrument):
        return Cfd(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            asset_class=asset_class_from_str(str(pyo3_instrument.asset_class)),
            quote_currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
            price_precision=pyo3_instrument.price_precision,
            size_precision=pyo3_instrument.size_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            size_increment=Quantity.from_raw_c(pyo3_instrument.size_increment.raw, pyo3_instrument.size_precision),
            base_currency=Currency.from_str_c(pyo3_instrument.base_currency.code) if pyo3_instrument.base_currency is not None else None,
            lot_size=Quantity.from_str_c(pyo3_instrument.lot_size) if pyo3_instrument.lot_size is not None else None,
            max_quantity=Quantity.from_raw_c(pyo3_instrument.max_quantity.raw, pyo3_instrument.max_quantity.precision) if pyo3_instrument.max_quantity is not None else None,
            min_quantity=Quantity.from_raw_c(pyo3_instrument.min_quantity.raw, pyo3_instrument.min_quantity.precision) if pyo3_instrument.min_quantity is not None else None,
            max_notional=Money.from_str_c(str(pyo3_instrument.max_notional)) if pyo3_instrument.max_notional is not None else None,
            min_notional=Money.from_str_c(str(pyo3_instrument.min_notional)) if pyo3_instrument.min_notional is not None else None,
            max_price=Price.from_raw_c(pyo3_instrument.max_price.raw,pyo3_instrument.max_price.precision) if pyo3_instrument.max_price is not None else None,
            min_price=Price.from_raw_c(pyo3_instrument.min_price.raw,pyo3_instrument.min_price.precision) if pyo3_instrument.min_price is not None else None,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_pyo3(pyo3_instrument):
        return Cfd.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2422">
<source>nautilus_trader/model/instruments/commodity.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport CurrencyType
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class Commodity(Instrument):
    """
    Represents a commodity instrument in a spot/cash market.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the instrument.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    asset_class : AssetClass
        The Commodity contract asset class.
    quote_currency : Currency
        The quote currency.
    price_precision : int
        The price decimal precision.
    size_precision : int
        The trading size decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    size_increment : Quantity
        The minimum size increment.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    lot_size : Quantity, optional
        The rounded lot unit size.
    max_quantity : Quantity, optional
        The maximum allowable order quantity.
    min_quantity : Quantity, optional
        The minimum allowable order quantity.
    max_notional : Money, optional
        The maximum allowable order notional value.
    min_notional : Money, optional
        The minimum allowable order notional value.
    max_price : Price, optional
        The maximum allowable quoted price.
    min_price : Price, optional
        The minimum allowable quoted price.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `tick_scheme_name` is not a valid string.
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).
    ValueError
        If `price_precision` is not equal to price_increment.precision.
    ValueError
        If `size_increment` is not equal to size_increment.precision.
    ValueError
        If `lot_size` is not positive (> 0).
    ValueError
        If `max_quantity` is not positive (> 0).
    ValueError
        If `min_quantity` is negative (< 0).
    ValueError
        If `max_notional` is not positive (> 0).
    ValueError
        If `min_notional` is negative (< 0).
    ValueError
        If `max_price` is not positive (> 0).
    ValueError
        If `min_price` is negative (< 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        AssetClass asset_class,
        Currency quote_currency not None,
        int price_precision,
        int size_precision,
        Price price_increment not None,
        Quantity size_increment not None,
        uint64_t ts_event,
        uint64_t ts_init,
        Currency base_currency: Currency | None = None,
        Quantity lot_size: Quantity | None = None,
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        Money max_notional: Money | None = None,
        Money min_notional: Money | None = None,
        Price max_price: Price | None = None,
        Price min_price: Price | None = None,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=asset_class,
            instrument_class=InstrumentClass.SPOT,
            quote_currency=quote_currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=size_precision,
            price_increment=price_increment,
            size_increment=size_increment,
            multiplier=Quantity.from_int_c(1),
            lot_size=lot_size,
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=max_notional,
            min_notional=min_notional,
            max_price=max_price,
            min_price=min_price,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

    @staticmethod
    cdef Commodity from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str lot_s = values["lot_size"]
        cdef str max_q = values["max_quantity"]
        cdef str min_q = values["min_quantity"]
        cdef str max_n = values["max_notional"]
        cdef str min_n = values["min_notional"]
        cdef str max_p = values["max_price"]
        cdef str min_p = values["min_price"]
        return Commodity(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            asset_class=asset_class_from_str(values["asset_class"]),
            quote_currency=Currency.from_str_c(values["quote_currency"]),
            price_precision=values["price_precision"],
            size_precision=values["size_precision"],
            price_increment=Price.from_str_c(values["price_increment"]),
            size_increment=Quantity.from_str_c(values["size_increment"]),
            lot_size=Quantity.from_str_c(lot_s) if lot_s is not None else None,
            max_quantity=Quantity.from_str_c(max_q) if max_q is not None else None,
            min_quantity=Quantity.from_str_c(min_q) if min_q is not None else None,
            max_notional=Money.from_str_c(max_n) if max_n is not None else None,
            min_notional=Money.from_str_c(min_n) if min_n is not None else None,
            max_price=Price.from_str_c(max_p) if max_p is not None else None,
            min_price=Price.from_str_c(min_p) if min_p is not None else None,
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values["info"],
        )

    @staticmethod
    cdef dict to_dict_c(Commodity obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "Commodity",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "asset_class": asset_class_to_str(obj.asset_class),
            "quote_currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "lot_size": str(obj.lot_size) if obj.lot_size is not None else None,
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_notional": str(obj.max_notional) if obj.max_notional is not None else None,
            "min_notional": str(obj.min_notional) if obj.min_notional is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    def from_dict(dict values) -> Commodity:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        Commodity

        """
        return Commodity.from_dict_c(values)

    @staticmethod
    def to_dict(Commodity obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return Commodity.to_dict_c(obj)

    @staticmethod
    cdef Commodity from_pyo3_c(pyo3_instrument):
        return Commodity(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            asset_class=asset_class_from_str(str(pyo3_instrument.asset_class)),
            quote_currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
            price_precision=pyo3_instrument.price_precision,
            size_precision=pyo3_instrument.size_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            size_increment=Quantity.from_raw_c(pyo3_instrument.size_increment.raw, pyo3_instrument.size_precision),
            lot_size=Quantity.from_str_c(pyo3_instrument.lot_size) if pyo3_instrument.lot_size is not None else None,
            max_quantity=Quantity.from_raw_c(pyo3_instrument.max_quantity.raw, pyo3_instrument.max_quantity.precision) if pyo3_instrument.max_quantity is not None else None,
            min_quantity=Quantity.from_raw_c(pyo3_instrument.min_quantity.raw, pyo3_instrument.min_quantity.precision) if pyo3_instrument.min_quantity is not None else None,
            max_notional=Money.from_str_c(str(pyo3_instrument.max_notional)) if pyo3_instrument.max_notional is not None else None,
            min_notional=Money.from_str_c(str(pyo3_instrument.min_notional)) if pyo3_instrument.min_notional is not None else None,
            max_price=Price.from_raw_c(pyo3_instrument.max_price.raw,pyo3_instrument.max_price.precision) if pyo3_instrument.max_price is not None else None,
            min_price=Price.from_raw_c(pyo3_instrument.min_price.raw,pyo3_instrument.min_price.precision) if pyo3_instrument.min_price is not None else None,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_pyo3(pyo3_instrument):
        return Commodity.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2424">
<source>nautilus_trader/model/instruments/crypto_future.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd
import pytz

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.functions cimport instrument_class_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class CryptoFuture(Instrument):
    """
    Represents a deliverable futures contract instrument, with crypto assets
    as underlying and for settlement.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the instrument.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    underlying : Currency
        The underlying asset.
    quote_currency : Currency
        The contract quote currency.
    settlement_currency : Currency
        The settlement currency.
    is_inverse : bool
        If the instrument costing is inverse (quantity expressed in quote currency units).
    activation_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract activation.
    expiration_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract expiration.
    price_precision : int
        The price decimal precision.
    size_precision : int
        The trading size decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    size_increment : Quantity
        The minimum size increment.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    multiplier : Quantity, default 1
        The contract multiplier.
    lot_size : Quantity
        The rounded lot unit size (standard/board).
    max_quantity : Quantity, optional
        The maximum allowable order quantity.
    min_quantity : Quantity, optional
        The minimum allowable order quantity.
    max_notional : Money, optional
        The maximum allowable order notional value.
    min_notional : Money, optional
        The minimum allowable order notional value.
    max_price : Price, optional
        The maximum allowable quoted price.
    min_price : Price, optional
        The minimum allowable quoted price.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).
    ValueError
        If `price_precision` is not equal to price_increment.precision.
    ValueError
        If `size_increment` is not equal to size_increment.precision.
    ValueError
        If `lot size` is not positive (> 0).
    ValueError
        If `max_quantity` is not positive (> 0).
    ValueError
        If `min_quantity` is negative (< 0).
    ValueError
        If `max_notional` is not positive (> 0).
    ValueError
        If `min_notional` is negative (< 0).
    ValueError
        If `max_price` is not positive (> 0).
    ValueError
        If `min_price` is negative (< 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        Currency underlying not None,
        Currency quote_currency not None,
        Currency settlement_currency not None,
        bint is_inverse,
        uint64_t activation_ns,
        uint64_t expiration_ns,
        int price_precision,
        int size_precision,
        Price price_increment not None,
        Quantity size_increment not None,
        uint64_t ts_event,
        uint64_t ts_init,
        multiplier=Quantity.from_int_c(1),
        lot_size=Quantity.from_int_c(1),
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        Money max_notional: Money | None = None,
        Money min_notional: Money | None = None,
        Price max_price: Price | None = None,
        Price min_price: Price | None = None,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=AssetClass.CRYPTOCURRENCY,
            instrument_class=InstrumentClass.FUTURE,
            quote_currency=quote_currency,
            is_inverse=is_inverse,
            price_precision=price_precision,
            size_precision=size_precision,
            price_increment=price_increment,
            size_increment=size_increment,
            multiplier=multiplier,
            lot_size=lot_size,
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=max_notional,
            min_notional=min_notional,
            max_price=max_price,
            min_price=min_price,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.underlying = underlying
        self.settlement_currency = settlement_currency
        if settlement_currency != quote_currency and settlement_currency != underlying:
            self.is_quanto = True
        else:
            self.is_quanto = False
        self.activation_ns = activation_ns
        self.expiration_ns = expiration_ns

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}"
            f"(id={self.id.to_str()}, "
            f"raw_symbol={self.raw_symbol}, "
            f"asset_class={asset_class_to_str(self.asset_class)}, "
            f"instrument_class={instrument_class_to_str(self.instrument_class)}, "
            f"is_inverse={self.is_inverse}, "
            f"underlying={self.underlying}, "
            f"quote_currency={self.quote_currency}, "
            f"settlement_currency={self.settlement_currency}, "
            f"activation={format_iso8601(self.activation_utc, nanos_precision=False)}, "
            f"expiration={format_iso8601(self.expiration_utc, nanos_precision=False)}, "
            f"price_precision={self.price_precision}, "
            f"price_increment={self.price_increment}, "
            f"size_precision={self.size_precision}, "
            f"size_increment={self.size_increment}, "
            f"multiplier={self.multiplier}, "
            f"lot_size={self.lot_size}, "
            f"margin_init={self.margin_init}, "
            f"margin_maint={self.margin_maint}, "
            f"maker_fee={self.maker_fee}, "
            f"taker_fee={self.taker_fee}, "
            f"info={self.info})"
        )

    cpdef Currency get_base_currency(self):
        """
        Return the instruments base currency (underlying).

        Returns
        -------
        Currency

        """
        return self.underlying

    cpdef Currency get_settlement_currency(self):
        """
        Return the currency used to settle a trade of the instrument.

        Returns
        -------
        Currency

        """
        return self.settlement_currency

    cpdef Currency get_cost_currency(self):
        """
        Return the currency used for PnL calculations for the instrument.

        - Standard linear instruments = quote_currency
        - Inverse instruments = underlying (base currency)
        - Quanto instruments = settlement_currency

        Returns
        -------
        Currency

        """
        if self.is_inverse:
            return self.underlying
        elif self.is_quanto:
            return self.settlement_currency
        else:
            return self.quote_currency

    cpdef Money notional_value(
        self,
        Quantity quantity,
        Price price,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the notional value.

        Result will be in quote currency for standard instruments, underlying
        currency for inverse instruments, or settlement currency for quanto
        instruments.

        Parameters
        ----------
        quantity : Quantity
            The total quantity.
        price : Price
            The price for the calculation.
        use_quote_for_inverse : bool
            For inverse instruments only: if True, treats the quantity as already representing
            notional value in quote currency and returns it directly without calculation.
            This is useful when quantity already represents a USD value that doesn't need
            conversion (e.g., for display purposes). Has no effect on linear or quanto instruments.

        Returns
        -------
        Money

        """
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")

        if self.is_inverse:
            if use_quote_for_inverse:
                # Quantity is notional in quote currency
                return Money(quantity, self.quote_currency)

            return Money(
                quantity.as_f64_c() * float(self.multiplier) * (1.0 / price.as_f64_c()),
                self.underlying,
            )
        elif self.is_quanto:
            return Money(
                quantity.as_f64_c() * float(self.multiplier) * price.as_f64_c(),
                self.settlement_currency,
            )
        else:
            return Money(
                quantity.as_f64_c() * float(self.multiplier) * price.as_f64_c(),
                self.quote_currency,
            )

    @property
    def activation_utc(self) -> pd.Timestamp:
        """
        Return the contract activation timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.activation_ns, tz=pytz.utc)

    @property
    def expiration_utc(self) -> pd.Timestamp:
        """
        Return the contract expiration timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.expiration_ns, tz=pytz.utc)

    @staticmethod
    cdef CryptoFuture from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str max_q = values["max_quantity"]
        cdef str min_q = values["min_quantity"]
        cdef str max_n = values["max_notional"]
        cdef str min_n = values["min_notional"]
        cdef str max_p = values["max_price"]
        cdef str min_p = values["min_price"]
        return CryptoFuture(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            underlying=Currency.from_str_c(values["underlying"]),
            quote_currency=Currency.from_str_c(values["quote_currency"]),
            settlement_currency=Currency.from_str_c(values["settlement_currency"]),
            is_inverse=values["is_inverse"],
            activation_ns=values["activation_ns"],
            expiration_ns=values["expiration_ns"],
            price_precision=values["price_precision"],
            size_precision=values["size_precision"],
            price_increment=Price.from_str_c(values["price_increment"]),
            size_increment=Quantity.from_str_c(values["size_increment"]),
            multiplier=Quantity.from_str_c(values["multiplier"]),
            max_quantity=Quantity.from_str_c(max_q) if max_q is not None else None,
            min_quantity=Quantity.from_str_c(min_q) if min_q is not None else None,
            max_notional=Money.from_str_c(max_n) if max_n is not None else None,
            min_notional=Money.from_str_c(min_n) if min_n is not None else None,
            max_price=Price.from_str_c(max_p) if max_p is not None else None,
            min_price=Price.from_str_c(min_p) if min_p is not None else None,
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values["info"],
        )

    @staticmethod
    cdef dict to_dict_c(CryptoFuture obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "CryptoFuture",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "underlying": obj.underlying.code,
            "quote_currency": obj.quote_currency.code,
            "settlement_currency": obj.settlement_currency.code,
            "is_inverse": obj.is_inverse,
            "activation_ns": obj.activation_ns,
            "expiration_ns": obj.expiration_ns,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "lot_size": str(obj.lot_size),
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_notional": str(obj.max_notional) if obj.max_notional is not None else None,
            "min_notional": str(obj.min_notional) if obj.min_notional is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    cdef CryptoFuture from_pyo3_c(pyo3_instrument):
        return CryptoFuture(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            underlying=Currency.from_str_c(pyo3_instrument.underlying.code),
            quote_currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
            settlement_currency=Currency.from_str_c(pyo3_instrument.settlement_currency.code),
            is_inverse=pyo3_instrument.is_inverse,
            activation_ns=pyo3_instrument.activation_ns,
            expiration_ns=pyo3_instrument.expiration_ns,
            price_precision=pyo3_instrument.price_precision,
            size_precision=pyo3_instrument.size_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            size_increment=Quantity.from_raw_c(pyo3_instrument.size_increment.raw, pyo3_instrument.size_precision),
            multiplier=Quantity.from_raw_c(pyo3_instrument.multiplier.raw, pyo3_instrument.multiplier.precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision),
            max_quantity=Quantity.from_raw_c(pyo3_instrument.max_quantity.raw,pyo3_instrument.max_quantity.precision) if pyo3_instrument.max_quantity is not None else None,
            min_quantity=Quantity.from_raw_c(pyo3_instrument.min_quantity.raw, pyo3_instrument.min_quantity.precision) if pyo3_instrument.min_quantity is not None else None,
            max_notional=Money.from_str_c(str(pyo3_instrument.max_notional)) if pyo3_instrument.max_notional is not None else None,
            min_notional=Money.from_str_c(str(pyo3_instrument.min_notional)) if pyo3_instrument.min_notional is not None else None,
            max_price=Price.from_raw_c(pyo3_instrument.max_price.raw, pyo3_instrument.max_price.precision) if pyo3_instrument.max_price is not None else None,
            min_price=Price.from_raw_c(pyo3_instrument.min_price.raw, pyo3_instrument.min_price.precision) if pyo3_instrument.min_price is not None else None,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )


    @staticmethod
    def from_dict(dict values) -> CryptoFuture:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        CryptoFuture

        """
        return CryptoFuture.from_dict_c(values)

    @staticmethod
    def to_dict(CryptoFuture obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return CryptoFuture.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_instrument):
        """
        Return legacy Cython crypto future instrument converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_instrument : nautilus_pyo3.CryptoFuture
            The pyo3 Rust option contract instrument to convert from.

        Returns
        -------
        CryptoFuture

        """
        return CryptoFuture.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2426">
<source>nautilus_trader/model/instruments/crypto_option.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd
import pytz

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.rust.model cimport OptionKind
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.functions cimport instrument_class_from_str
from nautilus_trader.model.functions cimport instrument_class_to_str
from nautilus_trader.model.functions cimport option_kind_from_str
from nautilus_trader.model.functions cimport option_kind_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.base cimport Price
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Quantity


cdef class CryptoOption(Instrument):
    """
    Represents an option instrument with crypto assets as underlying and for settlement.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    underlying : Currency
        The underlying asset.
    quote_currency : Currency
        The contract quote currency.
    settlement_currency : Currency
        The settlement currency.
    is_inverse : bool
        If the instrument costing is inverse (quantity expressed in quote currency units).
    option_kind : OptionKind
        The kind of option (PUT | CALL).
    strike_price : Price
        The option strike price.
    activation_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract activation.
    expiration_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract expiration.
    price_precision : int
        The price decimal precision.
    size_precision : int
        The trading size decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    size_increment : Quantity
        The minimum size increment.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    multiplier : Quantity, default 1
        The contract multiplier.
    lot_size : Quantity, default 1
        The rounded lot unit size (standard/board).
    max_quantity : Quantity, optional
        The maximum allowable order quantity.
    min_quantity : Quantity, optional
        The minimum allowable order quantity.
    max_notional : Money, optional
        The maximum allowable order notional value.
    min_notional : Money, optional
        The minimum allowable order notional value.
    max_price : Price, optional
        The maximum allowable quoted price.
    min_price : Price, optional
        The minimum allowable quoted price.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).
    ValueError
        If `lot size` is not positive (> 0).
    ValueError
        If `max_quantity` is not positive (> 0).
    ValueError
        If `min_quantity` is negative (< 0).
    ValueError
        If `max_notional` is not positive (> 0).
    ValueError
        If `min_notional` is negative (< 0).
    ValueError
        If `max_price` is not positive (> 0).
    ValueError
        If `min_price` is negative (< 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        Currency underlying not None,
        Currency quote_currency not None,
        Currency settlement_currency not None,
        bint is_inverse,
        OptionKind option_kind,
        Price strike_price not None,
        uint64_t activation_ns,
        uint64_t expiration_ns,
        int price_precision,
        int size_precision,
        Price price_increment not None,
        Quantity size_increment not None,
        uint64_t ts_event,
        uint64_t ts_init,
        Quantity multiplier = Quantity.from_int_c(1),
        Quantity lot_size = Quantity.from_int_c(1),
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        Money max_notional: Money | None = None,
        Money min_notional: Money | None = None,
        Price max_price: Price | None = None,
        Price min_price: Price | None = None,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=AssetClass.CRYPTOCURRENCY,
            instrument_class=InstrumentClass.OPTION,
            quote_currency=quote_currency,
            is_inverse=is_inverse,
            price_precision=price_precision,
            size_precision=size_precision,
            price_increment=price_increment,
            size_increment=size_increment,
            multiplier=multiplier,
            lot_size=lot_size,
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=max_notional,
            min_notional=min_notional,
            max_price=max_price,
            min_price=min_price,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.underlying = underlying
        self.settlement_currency = settlement_currency
        self.option_kind = option_kind
        self.strike_price = strike_price
        self.activation_ns = activation_ns
        self.expiration_ns = expiration_ns

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}"
            f"(id={self.id.to_str()}, "
            f"raw_symbol={self.raw_symbol}, "
            f"asset_class={asset_class_to_str(self.asset_class)}, "
            f"instrument_class={instrument_class_to_str(self.instrument_class)}, "
            f"is_inverse={self.is_inverse}, "
            f"underlying={self.underlying}, "
            f"quote_currency={self.quote_currency}, "
            f"option_kind={option_kind_to_str(self.option_kind)}, "
            f"strike_price={self.strike_price}, "
            f"activation={format_iso8601(self.activation_utc, nanos_precision=False)}, "
            f"expiration={format_iso8601(self.expiration_utc, nanos_precision=False)}, "
            f"price_precision={self.price_precision}, "
            f"price_increment={self.price_increment}, "
            f"size_precision={self.size_precision}, "
            f"size_increment={self.size_increment}, "
            f"multiplier={self.multiplier}, "
            f"lot_size={self.lot_size}, "
            f"margin_init={self.margin_init}, "
            f"margin_maint={self.margin_maint}, "
            f"maker_fee={self.maker_fee}, "
            f"taker_fee={self.taker_fee}, "
            f"info={self.info})"
        )

    cpdef Currency get_base_currency(self):
        """
        Return the instruments base currency (underlying).

        Returns
        -------
        Currency

        """
        return self.underlying

    cpdef Currency get_settlement_currency(self):
        """
        Return the currency used to settle a trade of the instrument.

        Returns
        -------
        Currency

        """
        return self.settlement_currency

    cpdef Currency get_cost_currency(self):
        """
        Return the currency used for PnL calculations for the instrument.

        - Standard linear instruments = quote_currency
        - Inverse instruments = underlying (base currency)

        Returns
        -------
        Currency

        """
        if self.is_inverse:
            return self.underlying
        else:
            return self.quote_currency

    cpdef Money notional_value(
        self,
        Quantity quantity,
        Price price,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the notional value.

        Result will be in quote currency for standard instruments, or underlying
        currency for inverse instruments.

        Parameters
        ----------
        quantity : Quantity
            The total quantity.
        price : Price
            The price for the calculation.
        use_quote_for_inverse : bool
            For inverse instruments only: if True, treats the quantity as already representing
            notional value in quote currency and returns it directly without calculation.
            This is useful when quantity already represents a USD value that doesn't need
            conversion (e.g., for display purposes). Has no effect on linear instruments.

        Returns
        -------
        Money

        """
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")

        if self.is_inverse:
            if use_quote_for_inverse:
                # Quantity is notional in quote currency
                return Money(quantity, self.quote_currency)

            return Money(quantity.as_f64_c() * float(self.multiplier) * (1.0 / price.as_f64_c()), self.underlying)
        else:
            return Money(quantity.as_f64_c() * float(self.multiplier) * price.as_f64_c(), self.quote_currency)

    @property
    def activation_utc(self) -> pd.Timestamp:
        """
        Return the contract activation timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.activation_ns, tz=pytz.utc)

    @property
    def expiration_utc(self) -> pd.Timestamp:
        """
        Return the contract expiration timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.expiration_ns, tz=pytz.utc)

    @staticmethod
    cdef CryptoOption from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str max_q = values["max_quantity"]
        cdef str min_q = values["min_quantity"]
        cdef str max_n = values["max_notional"]
        cdef str min_n = values["min_notional"]
        cdef str max_p = values["max_price"]
        cdef str min_p = values["min_price"]
        return CryptoOption(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            underlying=Currency.from_str_c(values["underlying"]),
            quote_currency=Currency.from_str_c(values["quote_currency"]),
            settlement_currency=Currency.from_str_c(values["settlement_currency"]),
            is_inverse=values["is_inverse"],
            option_kind=option_kind_from_str(values["option_kind"]),
            strike_price=Price.from_str(values["strike_price"]),
            activation_ns=values["activation_ns"],
            expiration_ns=values["expiration_ns"],
            price_precision=values["price_precision"],
            size_precision=values["size_precision"],
            price_increment=Price.from_str_c(values["price_increment"]),
            size_increment=Quantity.from_str_c(values["size_increment"]),
            multiplier=Quantity.from_str(values["multiplier"]),
            max_quantity=Quantity.from_str_c(max_q) if max_q is not None else None,
            min_quantity=Quantity.from_str_c(min_q) if min_q is not None else None,
            max_notional=Money.from_str_c(max_n) if max_n is not None else None,
            min_notional=Money.from_str_c(min_n) if min_n is not None else None,
            max_price=Price.from_str_c(max_p) if max_p is not None else None,
            min_price=Price.from_str_c(min_p) if min_p is not None else None,
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values.get("info"),
        )

    @staticmethod
    cdef dict to_dict_c(CryptoOption obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "CryptoOption",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "underlying": obj.underlying.code,
            "quote_currency": obj.quote_currency.code,
            "settlement_currency": obj.settlement_currency.code,
            "is_inverse": obj.is_inverse,
            "option_kind": option_kind_to_str(obj.option_kind),
            "strike_price": str(obj.strike_price),
            "activation_ns": obj.activation_ns,
            "expiration_ns": obj.expiration_ns,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "lot_size": str(obj.lot_size),
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_notional": str(obj.max_notional) if obj.max_notional is not None else None,
            "min_notional": str(obj.min_notional) if obj.min_notional is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    cdef CryptoOption from_pyo3_c(pyo3_instrument):
        Condition.not_none(pyo3_instrument, "pyo3_instrument")
        return CryptoOption(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            underlying=Currency.from_str_c(pyo3_instrument.underlying.code),
            quote_currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
            settlement_currency=Currency.from_str_c(pyo3_instrument.settlement_currency.code),
            is_inverse=pyo3_instrument.is_inverse,
            option_kind=option_kind_from_str(str(pyo3_instrument.option_kind)),
            strike_price=Price.from_raw_c(pyo3_instrument.strike_price.raw, pyo3_instrument.strike_price.precision),
            activation_ns=pyo3_instrument.activation_ns,
            expiration_ns=pyo3_instrument.expiration_ns,
            price_precision=pyo3_instrument.price_precision,
            size_precision=pyo3_instrument.size_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            size_increment=Quantity.from_raw_c(pyo3_instrument.size_increment.raw, pyo3_instrument.size_precision),
            multiplier=Quantity.from_raw_c(pyo3_instrument.multiplier.raw, pyo3_instrument.multiplier.precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision),
            max_quantity=Quantity.from_raw_c(pyo3_instrument.max_quantity.raw,pyo3_instrument.max_quantity.precision) if pyo3_instrument.max_quantity is not None else None,
            min_quantity=Quantity.from_raw_c(pyo3_instrument.min_quantity.raw, pyo3_instrument.min_quantity.precision) if pyo3_instrument.min_quantity is not None else None,
            max_notional=Money.from_str_c(str(pyo3_instrument.max_notional)) if pyo3_instrument.max_notional is not None else None,
            min_notional=Money.from_str_c(str(pyo3_instrument.min_notional)) if pyo3_instrument.min_notional is not None else None,
            max_price=Price.from_raw_c(pyo3_instrument.max_price.raw, pyo3_instrument.max_price.precision) if pyo3_instrument.max_price is not None else None,
            min_price=Price.from_raw_c(pyo3_instrument.min_price.raw, pyo3_instrument.min_price.precision) if pyo3_instrument.min_price is not None else None,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            info=pyo3_instrument.info,
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
        )

    @staticmethod
    def from_dict(dict values) -> CryptoOption:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        CryptoOption

        """
        return CryptoOption.from_dict_c(values)

    @staticmethod
    def to_dict(CryptoOption obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return CryptoOption.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_instrument) -> CryptoOption:
        """
        Return legacy Cython option contract instrument converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_instrument : nautilus_pyo3.CryptoOption
            The pyo3 Rust option contract instrument to convert from.

        Returns
        -------
        CryptoOption

        """
        return CryptoOption.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2428">
<source>nautilus_trader/model/instruments/crypto_perpetual.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class CryptoPerpetual(Instrument):
    """
    Represents a crypto perpetual futures contract instrument (a.k.a. perpetual swap).

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the instrument.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    base_currency : Currency, optional
        The base currency.
    quote_currency : Currency
        The quote currency.
    settlement_currency : Currency
        The settlement currency.
    is_inverse : bool
        If the instrument costing is inverse (quantity expressed in quote currency units).
    price_precision : int
        The price decimal precision.
    size_precision : int
        The trading size decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    size_increment : Quantity
        The minimum size increment.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    multiplier : Quantity, default 1
        The contract multiplier.
    lot_size : Quantity, default 1
        The rounded lot unit size (standard/board).
    max_quantity : Quantity, optional
        The maximum allowable order quantity.
    min_quantity : Quantity, optional
        The minimum allowable order quantity.
    max_notional : Money, optional
        The maximum allowable order notional value.
    min_notional : Money, optional
        The minimum allowable order notional value.
    max_price : Price, optional
        The maximum allowable quoted price.
    min_price : Price, optional
        The minimum allowable quoted price.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).
    ValueError
        If `price_precision` is not equal to price_increment.precision.
    ValueError
        If `size_increment` is not equal to size_increment.precision.
    ValueError
        If `multiplier` is not positive (> 0).
    ValueError
        If `max_quantity` is not positive (> 0).
    ValueError
        If `min_quantity` is negative (< 0).
    ValueError
        If `max_notional` is not positive (> 0).
    ValueError
        If `min_notional` is negative (< 0).
    ValueError
        If `max_price` is not positive (> 0).
    ValueError
        If `min_price` is negative (< 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        Currency base_currency not None,
        Currency quote_currency not None,
        Currency settlement_currency not None,
        bint is_inverse,
        int price_precision,
        int size_precision,
        Price price_increment not None,
        Quantity size_increment not None,
        uint64_t ts_event,
        uint64_t ts_init,
        multiplier=Quantity.from_int_c(1),
        lot_size=Quantity.from_int_c(1),
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        Money max_notional: Money | None = None,
        Money min_notional: Money | None = None,
        Price max_price: Price | None = None,
        Price min_price: Price | None = None,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=AssetClass.CRYPTOCURRENCY,
            instrument_class=InstrumentClass.SWAP,
            quote_currency=quote_currency,
            is_inverse=is_inverse,
            price_precision=price_precision,
            size_precision=size_precision,
            price_increment=price_increment,
            size_increment=size_increment,
            multiplier=multiplier,
            lot_size=lot_size,
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=max_notional,
            min_notional=min_notional,
            max_price=max_price,
            min_price=min_price,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.base_currency = base_currency
        self.settlement_currency = settlement_currency
        if settlement_currency != base_currency and settlement_currency != quote_currency:
            self.is_quanto = True
        else:
            self.is_quanto = False

    cpdef Currency get_base_currency(self):
        """
        Return the instruments base currency.

        Returns
        -------
        Currency

        """
        return self.base_currency

    cpdef Currency get_settlement_currency(self):
        """
        Return the currency used to settle a trade of the instrument.

        Returns
        -------
        Currency

        """
        return self.settlement_currency

    cpdef Currency get_cost_currency(self):
        """
        Return the currency used for PnL calculations for the instrument.

        - Standard linear instruments = quote_currency
        - Inverse instruments = base_currency
        - Quanto instruments = settlement_currency

        Returns
        -------
        Currency

        """
        if self.is_inverse:
            return self.base_currency
        elif self.is_quanto:
            return self.settlement_currency
        else:
            return self.quote_currency

    cpdef Money notional_value(
        self,
        Quantity quantity,
        Price price,
        bint use_quote_for_inverse=False,
    ):
        """
        Calculate the notional value.

        Result will be in quote currency for standard instruments, base
        currency for inverse instruments, or settlement currency for quanto
        instruments.

        Parameters
        ----------
        quantity : Quantity
            The total quantity.
        price : Price
            The price for the calculation.
        use_quote_for_inverse : bool
            For inverse instruments only: if True, treats the quantity as already representing
            notional value in quote currency and returns it directly without calculation.
            This is useful when quantity already represents a USD value that doesn't need
            conversion (e.g., for display purposes). Has no effect on linear or quanto instruments.

        Returns
        -------
        Money

        """
        Condition.not_none(quantity, "quantity")
        Condition.not_none(price, "price")

        if self.is_inverse:
            if use_quote_for_inverse:
                # Quantity is notional in quote currency
                return Money(quantity, self.quote_currency)

            return Money(
                quantity.as_f64_c() * float(self.multiplier) * (1.0 / price.as_f64_c()),
                self.base_currency,
            )
        elif self.is_quanto:
            return Money(
                quantity.as_f64_c() * float(self.multiplier) * price.as_f64_c(),
                self.settlement_currency,
            )
        else:
            return Money(
                quantity.as_f64_c() * float(self.multiplier) * price.as_f64_c(),
                self.quote_currency,
            )

    @staticmethod
    cdef CryptoPerpetual from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str max_q = values["max_quantity"]
        cdef str min_q = values["min_quantity"]
        cdef str max_n = values["max_notional"]
        cdef str min_n = values["min_notional"]
        cdef str max_p = values["max_price"]
        cdef str min_p = values["min_price"]
        return CryptoPerpetual(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            base_currency=Currency.from_str_c(values["base_currency"]),
            quote_currency=Currency.from_str_c(values["quote_currency"]),
            settlement_currency=Currency.from_str_c(values["settlement_currency"]),
            is_inverse=values["is_inverse"],
            price_precision=values["price_precision"],
            size_precision=values["size_precision"],
            price_increment=Price.from_str_c(values["price_increment"]),
            size_increment=Quantity.from_str_c(values["size_increment"]),
            multiplier=Quantity.from_str_c(values["multiplier"]),
            max_quantity=Quantity.from_str_c(max_q) if max_q is not None else None,
            min_quantity=Quantity.from_str_c(min_q) if min_q is not None else None,
            max_notional=Money.from_str_c(max_n) if max_n is not None else None,
            min_notional=Money.from_str_c(min_n) if min_n is not None else None,
            max_price=Price.from_str_c(max_p) if max_p is not None else None,
            min_price=Price.from_str_c(min_p) if min_p is not None else None,
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values["info"],
        )

    @staticmethod
    cdef dict to_dict_c(CryptoPerpetual obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "CryptoPerpetual",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "base_currency": obj.base_currency.code,
            "quote_currency": obj.quote_currency.code,
            "settlement_currency": obj.settlement_currency.code,
            "is_inverse": obj.is_inverse,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "lot_size": str(obj.lot_size),
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_notional": str(obj.max_notional) if obj.max_notional is not None else None,
            "min_notional": str(obj.min_notional) if obj.min_notional is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    def from_dict(dict values) -> CryptoPerpetual:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        CryptoPerpetual

        """
        return CryptoPerpetual.from_dict_c(values)

    @staticmethod
    def to_dict(CryptoPerpetual obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return CryptoPerpetual.to_dict_c(obj)

    @staticmethod
    cdef CryptoPerpetual from_pyo3_c(pyo3_instrument):
        return CryptoPerpetual(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            base_currency=Currency.from_str_c(pyo3_instrument.base_currency.code),
            quote_currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
            settlement_currency=Currency.from_str_c(pyo3_instrument.settlement_currency.code),
            is_inverse=pyo3_instrument.is_inverse,
            price_precision=pyo3_instrument.price_precision,
            size_precision=pyo3_instrument.size_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            size_increment=Quantity.from_raw_c(pyo3_instrument.size_increment.raw, pyo3_instrument.size_precision),
            multiplier=Quantity.from_raw_c(pyo3_instrument.multiplier.raw, pyo3_instrument.multiplier.precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision),
            max_quantity=Quantity.from_raw_c(pyo3_instrument.max_quantity.raw,pyo3_instrument.max_quantity.precision) if pyo3_instrument.max_quantity is not None else None,
            min_quantity=Quantity.from_raw_c(pyo3_instrument.min_quantity.raw,pyo3_instrument.min_quantity.precision) if pyo3_instrument.min_quantity is not None else None,
            max_notional=Money.from_str_c(str(pyo3_instrument.max_notional)) if pyo3_instrument.max_notional is not None else None,
            min_notional=Money.from_str_c(str(pyo3_instrument.min_notional)) if pyo3_instrument.min_notional is not None else None,
            max_price=Price.from_raw_c(pyo3_instrument.max_price.raw,pyo3_instrument.max_price.precision) if pyo3_instrument.max_price is not None else None,
            min_price=Price.from_raw_c(pyo3_instrument.min_price.raw,pyo3_instrument.min_price.precision) if pyo3_instrument.min_price is not None else None,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_pyo3(pyo3_instrument):
        return CryptoPerpetual.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2430">
<source>nautilus_trader/model/instruments/currency_pair.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport CurrencyType
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class CurrencyPair(Instrument):
    """
    Represents a generic currency pair instrument in a spot/cash market.

    Can represent both Fiat FX and Cryptocurrency pairs.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the instrument.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    base_currency : Currency
        The base currency.
    quote_currency : Currency
        The quote currency.
    price_precision : int
        The price decimal precision.
    size_precision : int
        The trading size decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    size_increment : Quantity
        The minimum size increment.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    multiplier : Quantity, default 1
        The contract multiplier.
    lot_size : Quantity, optional
        The rounded lot unit size.
    max_quantity : Quantity, optional
        The maximum allowable order quantity.
    min_quantity : Quantity, optional
        The minimum allowable order quantity.
    max_notional : Money, optional
        The maximum allowable order notional value.
    min_notional : Money, optional
        The minimum allowable order notional value.
    max_price : Price, optional
        The maximum allowable quoted price.
    min_price : Price, optional
        The minimum allowable quoted price.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `tick_scheme_name` is not a valid string.
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).
    ValueError
        If `price_precision` is not equal to price_increment.precision.
    ValueError
        If `size_increment` is not equal to size_increment.precision.
    ValueError
        If `lot_size` is not positive (> 0).
    ValueError
        If `max_quantity` is not positive (> 0).
    ValueError
        If `min_quantity` is negative (< 0).
    ValueError
        If `max_notional` is not positive (> 0).
    ValueError
        If `min_notional` is negative (< 0).
    ValueError
        If `max_price` is not positive (> 0).
    ValueError
        If `min_price` is negative (< 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        Currency base_currency not None,
        Currency quote_currency not None,
        int price_precision,
        int size_precision,
        Price price_increment not None,
        Quantity size_increment not None,
        uint64_t ts_event,
        uint64_t ts_init,
        multiplier=Quantity.from_int_c(1),
        Quantity lot_size: Quantity | None = None,
        Quantity max_quantity: Quantity | None = None,
        Quantity min_quantity: Quantity | None = None,
        Money max_notional: Money | None = None,
        Money min_notional: Money | None = None,
        Price max_price: Price | None = None,
        Price min_price: Price | None = None,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        # Determine asset class
        if (
            base_currency.currency_type == CurrencyType.CRYPTO
            or quote_currency.currency_type == CurrencyType.CRYPTO
        ):
            asset_class = AssetClass.CRYPTOCURRENCY
        else:
            asset_class = AssetClass.FX
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=asset_class,
            instrument_class=InstrumentClass.SPOT,
            quote_currency=quote_currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=size_precision,
            price_increment=price_increment,
            size_increment=size_increment,
            multiplier=multiplier,
            lot_size=lot_size,
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=max_notional,
            min_notional=min_notional,
            max_price=max_price,
            min_price=min_price,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.base_currency = base_currency

    cpdef Currency get_base_currency(self):
        """
        Return the instruments base currency.

        Returns
        -------
        Currency

        """
        return self.base_currency

    @staticmethod
    cdef CurrencyPair from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef str lot_s = values["lot_size"]
        cdef str max_q = values["max_quantity"]
        cdef str min_q = values["min_quantity"]
        cdef str max_n = values["max_notional"]
        cdef str min_n = values["min_notional"]
        cdef str max_p = values["max_price"]
        cdef str min_p = values["min_price"]
        return CurrencyPair(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            base_currency=Currency.from_str_c(values["base_currency"]),
            quote_currency=Currency.from_str_c(values["quote_currency"]),
            price_precision=values["price_precision"],
            size_precision=values["size_precision"],
            price_increment=Price.from_str_c(values["price_increment"]),
            size_increment=Quantity.from_str_c(values["size_increment"]),
            multiplier=Quantity.from_str_c(values["multiplier"]),
            lot_size=Quantity.from_str_c(lot_s) if lot_s is not None else None,
            max_quantity=Quantity.from_str_c(max_q) if max_q is not None else None,
            min_quantity=Quantity.from_str_c(min_q) if min_q is not None else None,
            max_notional=Money.from_str_c(max_n) if max_n is not None else None,
            min_notional=Money.from_str_c(min_n) if min_n is not None else None,
            max_price=Price.from_str_c(max_p) if max_p is not None else None,
            min_price=Price.from_str_c(min_p) if min_p is not None else None,
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values["info"],
        )

    @staticmethod
    cdef dict to_dict_c(CurrencyPair obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "CurrencyPair",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "base_currency": obj.base_currency.code,
            "quote_currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "lot_size": str(obj.lot_size) if obj.lot_size is not None else None,
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_notional": str(obj.max_notional) if obj.max_notional is not None else None,
            "min_notional": str(obj.min_notional) if obj.min_notional is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    def from_dict(dict values) -> CurrencyPair:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        CurrencyPair

        """
        return CurrencyPair.from_dict_c(values)

    @staticmethod
    def to_dict(CurrencyPair obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return CurrencyPair.to_dict_c(obj)

    @staticmethod
    cdef CurrencyPair from_pyo3_c(pyo3_instrument):
        return CurrencyPair(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            base_currency=Currency.from_str_c(pyo3_instrument.base_currency.code),
            quote_currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
            price_precision=pyo3_instrument.price_precision,
            size_precision=pyo3_instrument.size_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            size_increment=Quantity.from_raw_c(pyo3_instrument.size_increment.raw, pyo3_instrument.size_precision),
            multiplier=Quantity.from_raw_c(pyo3_instrument.multiplier.raw, pyo3_instrument.multiplier.precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision) if pyo3_instrument.lot_size is not None else None,
            max_quantity=Quantity.from_raw_c(pyo3_instrument.max_quantity.raw, pyo3_instrument.max_quantity.precision) if pyo3_instrument.max_quantity is not None else None,
            min_quantity=Quantity.from_raw_c(pyo3_instrument.min_quantity.raw, pyo3_instrument.min_quantity.precision) if pyo3_instrument.min_quantity is not None else None,
            max_notional=Money.from_str_c(str(pyo3_instrument.max_notional)) if pyo3_instrument.max_notional is not None else None,
            min_notional=Money.from_str_c(str(pyo3_instrument.min_notional)) if pyo3_instrument.min_notional is not None else None,
            max_price=Price.from_raw_c(pyo3_instrument.max_price.raw,pyo3_instrument.max_price.precision) if pyo3_instrument.max_price is not None else None,
            min_price=Price.from_raw_c(pyo3_instrument.min_price.raw,pyo3_instrument.min_price.precision) if pyo3_instrument.min_price is not None else None,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_pyo3(pyo3_instrument):
        return CurrencyPair.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2432">
<source>nautilus_trader/model/instruments/equity.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class Equity(Instrument):
    """
    Represents a generic equity instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    currency : Currency
        The futures contract currency.
    price_precision : int
        The price decimal precision.
    price_increment : Decimal
        The minimum price increment (tick size).
    lot_size : Quantity
        The rounded lot unit size (standard/board).
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    isin : str, optional
        The instruments International Securities Identification Number (ISIN).
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `lot_size` is not positive (> 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).
    ValueError
        If `isin` is not ``None`` and not a valid string.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        Currency currency not None,
        int price_precision,
        Price price_increment not None,
        Quantity lot_size not None,
        uint64_t ts_event,
        uint64_t ts_init,
        max_quantity: Quantity | None = None,
        min_quantity: Quantity | None = None,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str isin: str | None = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        if isin is not None:
            Condition.valid_string(isin, "isin")
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=AssetClass.EQUITY,
            instrument_class=InstrumentClass.SPOT,
            quote_currency=currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=0,  # No fractional units
            price_increment=price_increment,
            size_increment=Quantity.from_int_c(1),
            multiplier=Quantity.from_int_c(1),
            lot_size=lot_size,
            max_quantity=max_quantity,
            min_quantity=min_quantity,
            max_notional=None,
            min_notional=None,
            max_price=None,
            min_price=None,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.isin = isin

    @staticmethod
    cdef Equity from_dict_c(dict values):
        Condition.not_none(values, "values")
        return Equity(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            currency=Currency.from_str_c(values["currency"]),
            price_precision=values["price_precision"],
            price_increment=Price.from_str(values["price_increment"]),
            lot_size=Quantity.from_str(values["lot_size"]),
            isin=values.get("isin"),  # Can be None,
            margin_init=Decimal(values.get("margin_init", 0)) if values.get("margin_init") is not None else None,
            margin_maint=Decimal(values.get("margin_maint", 0)) if values.get("margin_maint") is not None else None,
            maker_fee=Decimal(values.get("maker_fee", 0)) if values.get("maker_fee") is not None else None,
            taker_fee=Decimal(values.get("taker_fee", 0))  if values.get("taker_fee") is not None else None,
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values["info"],
        )

    @staticmethod
    cdef dict to_dict_c(Equity obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "Equity",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "lot_size": str(obj.lot_size),
            "isin": obj.isin,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    cdef Equity from_pyo3_c(pyo3_instrument):
        return Equity(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
            price_precision=pyo3_instrument.price_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision) if pyo3_instrument.lot_size is not None else Quantity.from_int_c(1),
            max_quantity=Quantity.from_raw_c(pyo3_instrument.max_quantity.raw, pyo3_instrument.max_quantity.precision) if pyo3_instrument.max_quantity is not None else None,
            min_quantity=Quantity.from_raw_c(pyo3_instrument.min_quantity.raw, pyo3_instrument.min_quantity.precision) if pyo3_instrument.min_quantity is not None else None,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            isin=pyo3_instrument.isin,
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_dict(dict values) -> Instrument:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        Equity

        """
        return Equity.from_dict_c(values)

    @staticmethod
    def to_dict(Instrument obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return Equity.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_instrument) -> Equity:
        """
        Return legacy Cython equity instrument converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_instrument : nautilus_pyo3.Equity
            The pyo3 Rust equity instrument to convert from.

        Returns
        -------
        Equity

        """
        return Equity.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2434">
<source>nautilus_trader/model/instruments/futures_contract.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd
import pytz

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.functions cimport instrument_class_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class FuturesContract(Instrument):
    """
    Represents a generic deliverable futures contract instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    asset_class : AssetClass
        The futures contract asset class.
    currency : Currency
        The futures contract currency.
    price_precision : int
        The price decimal precision.
    price_increment : Decimal
        The minimum price increment (tick size).
    multiplier : Quantity
        The contract multiplier.
    lot_size : Quantity
        The rounded lot unit size (standard/board).
    underlying : str
        The underlying asset.
    activation_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract activation.
    expiration_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract expiration.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    exchange : str, optional
        The exchange ISO 10383 Market Identifier Code (MIC) where the instrument trades.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `multiplier` is not positive (> 0).
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `tick_size` is not positive (> 0).
    ValueError
        If `lot_size` is not positive (> 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).
    ValueError
        If `exchange` is not ``None`` and not a valid string.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        AssetClass asset_class,
        Currency currency not None,
        int price_precision,
        Price price_increment not None,
        Quantity multiplier not None,
        Quantity lot_size not None,
        str underlying,
        uint64_t activation_ns,
        uint64_t expiration_ns,
        uint64_t ts_event,
        uint64_t ts_init,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str exchange = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        if exchange is not None:
            Condition.valid_string(exchange, "exchange")
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=asset_class,
            instrument_class=InstrumentClass.FUTURE,
            quote_currency=currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=0,  # No fractional units
            price_increment=price_increment,
            size_increment=Quantity.from_int_c(1),
            multiplier=multiplier,
            lot_size=lot_size,
            max_quantity=None,
            min_quantity=Quantity.from_int_c(1),
            max_notional=None,
            min_notional=None,
            max_price=None,
            min_price=None,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.exchange = exchange
        self.underlying = underlying
        self.activation_ns = activation_ns
        self.expiration_ns = expiration_ns

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}"
            f"(id={self.id.to_str()}, "
            f"raw_symbol={self.raw_symbol}, "
            f"asset_class={asset_class_to_str(self.asset_class)}, "
            f"instrument_class={instrument_class_to_str(self.instrument_class)}, "
            f"exchange={self.exchange}, "
            f"quote_currency={self.quote_currency}, "
            f"underlying={self.underlying}, "
            f"activation={format_iso8601(self.activation_utc, nanos_precision=False)}, "
            f"expiration={format_iso8601(self.expiration_utc, nanos_precision=False)}, "
            f"price_precision={self.price_precision}, "
            f"price_increment={self.price_increment}, "
            f"multiplier={self.multiplier}, "
            f"lot_size={self.lot_size}, "
            f"margin_init={self.margin_init}, "
            f"margin_maint={self.margin_maint}, "
            f"maker_fee={self.maker_fee}, "
            f"taker_fee={self.taker_fee}, "
            f"info={self.info})"
        )

    @property
    def activation_utc(self) -> pd.Timestamp:
        """
        Return the contract activation timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.activation_ns, tz=pytz.utc)

    @property
    def expiration_utc(self) -> pd.Timestamp:
        """
        Return the contract expiration timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.expiration_ns, tz=pytz.utc)

    @staticmethod
    cdef FuturesContract from_dict_c(dict values):
        Condition.not_none(values, "values")
        return FuturesContract(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            asset_class=asset_class_from_str(values["asset_class"]),
            currency=Currency.from_str_c(values["currency"]),
            price_precision=values["price_precision"],
            price_increment=Price.from_str(values["price_increment"]),
            multiplier=Quantity.from_str(values["multiplier"]),
            lot_size=Quantity.from_str(values["lot_size"]),
            underlying=values["underlying"],
            activation_ns=values["activation_ns"],
            expiration_ns=values["expiration_ns"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            exchange=values["exchange"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values.get("info"),
        )

    @staticmethod
    cdef dict to_dict_c(FuturesContract obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "FuturesContract",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "asset_class": asset_class_to_str(obj.asset_class),
            "currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "lot_size": str(obj.lot_size),
            "underlying": obj.underlying,
            "activation_ns": obj.activation_ns,
            "expiration_ns": obj.expiration_ns,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "exchange": obj.exchange,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    cdef FuturesContract from_pyo3_c(pyo3_instrument):
        return FuturesContract(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            asset_class=asset_class_from_str(str(pyo3_instrument.asset_class)),
            currency=Currency.from_str_c(pyo3_instrument.currency.code),
            price_precision=pyo3_instrument.price_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            multiplier=Quantity.from_raw_c(pyo3_instrument.multiplier.raw, pyo3_instrument.multiplier.precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision),
            underlying=pyo3_instrument.underlying,
            activation_ns=pyo3_instrument.activation_ns,
            expiration_ns=pyo3_instrument.expiration_ns,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            exchange=pyo3_instrument.exchange,
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_dict(dict values) -> FuturesContract:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        FuturesContract

        """
        return FuturesContract.from_dict_c(values)

    @staticmethod
    def to_dict(FuturesContract obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return FuturesContract.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_instrument) -> FuturesContract:
        """
        Return legacy Cython futures contract instrument converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_instrument : nautilus_pyo3.FuturesContract
            The pyo3 Rust futures contract instrument to convert from.

        Returns
        -------
        FuturesContract

        """
        return FuturesContract.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2436">
<source>nautilus_trader/model/instruments/futures_spread.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd
import pytz

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.functions cimport instrument_class_from_str
from nautilus_trader.model.functions cimport instrument_class_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class FuturesSpread(Instrument):
    """
    Represents a generic deliverable futures spread instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    asset_class : AssetClass
        The futures spread asset class.
    currency : Currency
        The futures spread currency.
    price_precision : int
        The price decimal precision.
    price_increment : Decimal
        The minimum price increment (tick size).
    multiplier : Quantity
        The contract multiplier.
    lot_size : Quantity
        The rounded lot unit size (standard/board).
    underlying : str
        The underlying asset.
    strategy_type : str
        The strategy type for the spread.
    activation_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract activation.
    expiration_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract expiration.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    exchange : str, optional
        The exchange ISO 10383 Market Identifier Code (MIC) where the instrument trades.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `strategy_type` is not a valid string.
    ValueError
        If `multiplier` is not positive (> 0).
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `tick_size` is not positive (> 0).
    ValueError
        If `lot_size` is not positive (> 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).
    ValueError
        If `exchange` is not ``None`` and not a valid string.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        AssetClass asset_class,
        Currency currency not None,
        int price_precision,
        Price price_increment not None,
        Quantity multiplier not None,
        Quantity lot_size not None,
        str underlying,
        str strategy_type,
        uint64_t activation_ns,
        uint64_t expiration_ns,
        uint64_t ts_event,
        uint64_t ts_init,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str exchange = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        Condition.valid_string(strategy_type, "strategy_type")
        if exchange is not None:
            Condition.valid_string(exchange, "exchange")
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=asset_class,
            instrument_class=InstrumentClass.FUTURES_SPREAD,
            quote_currency=currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=0,  # No fractional units
            price_increment=price_increment,
            size_increment=Quantity.from_int_c(1),
            multiplier=multiplier,
            lot_size=lot_size,
            max_quantity=None,
            min_quantity=Quantity.from_int_c(1),
            max_notional=None,
            min_notional=None,
            max_price=None,
            min_price=None,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.exchange = exchange
        self.underlying = underlying
        self.strategy_type = strategy_type
        self.activation_ns = activation_ns
        self.expiration_ns = expiration_ns

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}"
            f"(id={self.id.to_str()}, "
            f"raw_symbol={self.raw_symbol}, "
            f"asset_class={asset_class_to_str(self.asset_class)}, "
            f"instrument_class={instrument_class_to_str(self.instrument_class)}, "
            f"exchange={self.exchange}, "
            f"quote_currency={self.quote_currency}, "
            f"underlying={self.underlying}, "
            f"strategy_type={self.strategy_type}, "
            f"activation={format_iso8601(self.activation_utc, nanos_precision=False)}, "
            f"expiration={format_iso8601(self.expiration_utc, nanos_precision=False)}, "
            f"price_precision={self.price_precision}, "
            f"price_increment={self.price_increment}, "
            f"multiplier={self.multiplier}, "
            f"lot_size={self.lot_size}, "
            f"margin_init={self.margin_init}, "
            f"margin_maint={self.margin_maint}, "
            f"maker_fee={self.maker_fee}, "
            f"taker_fee={self.taker_fee}, "
            f"info={self.info})"
        )

    @property
    def activation_utc(self) -> pd.Timestamp:
        """
        Return the contract activation timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.activation_ns, tz=pytz.utc)

    @property
    def expiration_utc(self) -> pd.Timestamp:
        """
        Return the contract expiration timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.expiration_ns, tz=pytz.utc)

    cpdef bint is_spread(self):
        """
        Return whether the instrument is a spread instrument.

        Returns
        -------
        bool

        """
        return True

    @staticmethod
    cdef FuturesSpread from_dict_c(dict values):
        Condition.not_none(values, "values")
        return FuturesSpread(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            asset_class=asset_class_from_str(values["asset_class"]),
            currency=Currency.from_str_c(values["currency"]),
            price_precision=values["price_precision"],
            price_increment=Price.from_str(values["price_increment"]),
            multiplier=Quantity.from_str(values["multiplier"]),
            lot_size=Quantity.from_str(values["lot_size"]),
            underlying=values["underlying"],
            strategy_type=values["strategy_type"],
            activation_ns=values["activation_ns"],
            expiration_ns=values["expiration_ns"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            exchange=values["exchange"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values.get("info"),
        )

    @staticmethod
    cdef dict to_dict_c(FuturesSpread obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "FuturesSpread",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "asset_class": asset_class_to_str(obj.asset_class),
            "currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "lot_size": str(obj.lot_size),
            "underlying": obj.underlying,
            "strategy_type": obj.strategy_type,
            "activation_ns": obj.activation_ns,
            "expiration_ns": obj.expiration_ns,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "exchange": obj.exchange,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    cdef FuturesSpread from_pyo3_c(pyo3_instrument):
        return FuturesSpread(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            asset_class=asset_class_from_str(str(pyo3_instrument.asset_class)),
            currency=Currency.from_str_c(pyo3_instrument.currency.code),
            price_precision=pyo3_instrument.price_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            multiplier=Quantity.from_raw_c(pyo3_instrument.multiplier.raw, pyo3_instrument.multiplier.precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision),
            underlying=pyo3_instrument.underlying,
            strategy_type=pyo3_instrument.strategy_type,
            activation_ns=pyo3_instrument.activation_ns,
            expiration_ns=pyo3_instrument.expiration_ns,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            exchange=pyo3_instrument.exchange,
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_dict(dict values) -> FuturesSpread:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        FuturesSpread

        """
        return FuturesSpread.from_dict_c(values)

    @staticmethod
    def to_dict(FuturesSpread obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return FuturesSpread.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_instrument) -> FuturesSpread:
        """
        Return legacy Cython futures spread instrument converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_instrument : nautilus_pyo3.FuturesSpread
            The pyo3 Rust futures spread instrument to convert from.

        Returns
        -------
        FuturesSpread

        """
        return FuturesSpread.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2438">
<source>nautilus_trader/model/instruments/index.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal
from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class IndexInstrument(Instrument):
    """
    Represents a **spot index** instrument (also known as a **cash index**).

    A spot index is calculated from its underlying constituents.
    It is **not directly tradable**. To gain exposure you would typically use
    index futures, ETFs, or CFDs.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    currency : Currency
        The futures contract currency.
    price_precision : int
        The price decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    size_precision : int
        The trading size decimal precision.
    size_increment : Quantity
        The minimum size increment.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `size_precision` is negative (< 0).
    ValueError
        If `price_increment` is not positive (> 0).
    ValueError
        If `size_increment` is not positive (> 0).
    ValueError
        If `price_precision` is not equal to price_increment.precision.
    ValueError
        If `size_increment` is not equal to size_increment.precision.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        Currency currency not None,
        int price_precision,
        int size_precision,
        Price price_increment not None,
        Quantity size_increment not None,
        uint64_t ts_event,
        uint64_t ts_init,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=AssetClass.INDEX,
            instrument_class=InstrumentClass.SPOT,
            quote_currency=currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=size_precision,
            price_increment=price_increment,
            size_increment=size_increment,
            multiplier=Quantity.from_int_c(1),
            margin_init=Decimal(0),
            margin_maint=Decimal(0),
            maker_fee=Decimal(0),
            taker_fee=Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

    @staticmethod
    cdef IndexInstrument from_dict_c(dict values):
        Condition.not_none(values, "values")
        return IndexInstrument(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            currency=Currency.from_str_c(values["currency"]),
            price_precision=values["price_precision"],
            price_increment=Price.from_str(values["price_increment"]),
            size_precision=values["size_precision"],
            size_increment=Quantity.from_str(values["size_increment"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values["info"],
        )

    @staticmethod
    cdef dict to_dict_c(IndexInstrument obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "IndexInstrument",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    cdef IndexInstrument from_pyo3_c(pyo3_instrument):
        return IndexInstrument(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.id.symbol.value),
            currency=Currency.from_str_c(pyo3_instrument.quote_currency.code),
            price_precision=pyo3_instrument.price_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            size_precision=pyo3_instrument.size_precision,
            size_increment=Quantity.from_raw_c(pyo3_instrument.size_increment.raw, pyo3_instrument.size_precision),
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_dict(dict values) -> Instrument:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        IndexInstrument

        """
        return IndexInstrument.from_dict_c(values)

    @staticmethod
    def to_dict(Instrument obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return IndexInstrument.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_instrument) -> IndexInstrument:
        """
        Return legacy Cython index instrument converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_instrument : nautilus_pyo3.IndexInstrument
            The pyo3 Rust index instrument to convert from.

        Returns
        -------
        IndexInstrument

        """
        return IndexInstrument.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2440">
<source>nautilus_trader/model/instruments/option_contract.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd
import pytz

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.rust.model cimport OptionKind
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.functions cimport instrument_class_from_str
from nautilus_trader.model.functions cimport instrument_class_to_str
from nautilus_trader.model.functions cimport option_kind_from_str
from nautilus_trader.model.functions cimport option_kind_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.base cimport Price
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Quantity


cdef class OptionContract(Instrument):
    """
    Represents a generic option contract instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    asset_class : AssetClass
        The option contract asset class.
    currency : Currency
        The option contract currency.
    price_precision : int
        The price decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    multiplier : Quantity
        The option multiplier.
    lot_size : Quantity
        The rounded lot unit size (standard/board).
    underlying : str
        The underlying asset.
    option_kind : OptionKind
        The kind of option (PUT | CALL).
    strike_price : Price
        The option strike price.
    activation_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract activation.
    expiration_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract expiration.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    exchange : str, optional
        The exchange ISO 10383 Market Identifier Code (MIC) where the instrument trades.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `multiplier` is not positive (> 0).
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `tick_size` is not positive (> 0).
    ValueError
        If `lot_size` is not positive (> 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).
    ValueError
        If `exchange` is not ``None`` and not a valid string.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        AssetClass asset_class,
        Currency currency not None,
        int price_precision,
        Price price_increment not None,
        Quantity multiplier not None,
        Quantity lot_size not None,
        str underlying,
        OptionKind option_kind,
        Price strike_price not None,
        uint64_t activation_ns,
        uint64_t expiration_ns,
        uint64_t ts_event,
        uint64_t ts_init,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str exchange = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        if exchange is not None:
            Condition.valid_string(exchange, "exchange")
        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=asset_class,
            instrument_class=InstrumentClass.OPTION,
            quote_currency=currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=0,  # No fractional contracts
            price_increment=price_increment,
            size_increment=Quantity.from_int_c(1),
            multiplier=multiplier,
            lot_size=lot_size,
            max_quantity=None,
            min_quantity=Quantity.from_int_c(1),
            max_notional=None,
            min_notional=None,
            max_price=None,
            min_price=None,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.exchange = exchange
        self.underlying = underlying
        self.option_kind = option_kind
        self.strike_price = strike_price
        self.activation_ns = activation_ns
        self.expiration_ns = expiration_ns

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}"
            f"(id={self.id.to_str()}, "
            f"raw_symbol={self.raw_symbol}, "
            f"asset_class={asset_class_to_str(self.asset_class)}, "
            f"instrument_class={instrument_class_to_str(self.instrument_class)}, "
            f"exchange={self.exchange}, "
            f"underlying={self.underlying}, "
            f"option_kind={option_kind_to_str(self.option_kind)}, "
            f"strike_price={self.strike_price}, "
            f"quote_currency={self.quote_currency}, "
            f"activation={format_iso8601(self.activation_utc, nanos_precision=False)}, "
            f"expiration={format_iso8601(self.expiration_utc, nanos_precision=False)}, "
            f"price_precision={self.price_precision}, "
            f"price_increment={self.price_increment}, "
            f"multiplier={self.multiplier}, "
            f"lot_size={self.lot_size}, "
            f"margin_init={self.margin_init}, "
            f"margin_maint={self.margin_maint}, "
            f"maker_fee={self.maker_fee}, "
            f"taker_fee={self.taker_fee}, "
            f"info={self.info})"
        )

    @property
    def activation_utc(self) -> pd.Timestamp:
        """
        Return the contract activation timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.activation_ns, tz=pytz.utc)

    @property
    def expiration_utc(self) -> pd.Timestamp:
        """
        Return the contract expiration timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.expiration_ns, tz=pytz.utc)

    @staticmethod
    cdef OptionContract from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OptionContract(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            asset_class=asset_class_from_str(values["asset_class"]),
            currency=Currency.from_str_c(values["currency"]),
            price_precision=values["price_precision"],
            price_increment=Price.from_str(values["price_increment"]),
            multiplier=Quantity.from_str(values["multiplier"]),
            lot_size=Quantity.from_str(values["lot_size"]),
            underlying=values["underlying"],
            option_kind=option_kind_from_str(values["option_kind"]),
            activation_ns=values["activation_ns"],
            expiration_ns=values["expiration_ns"],
            strike_price=Price.from_str(values["strike_price"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            exchange=values["exchange"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values.get("info"),
        )

    @staticmethod
    cdef dict to_dict_c(OptionContract obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OptionContract",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "asset_class": asset_class_to_str(obj.asset_class),
            "option_kind": option_kind_to_str(obj.option_kind),
            "strike_price": str(obj.strike_price),
            "currency": obj.quote_currency.code,
            "underlying": str(obj.underlying),
            "activation_ns": obj.activation_ns,
            "expiration_ns": obj.expiration_ns,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "lot_size": str(obj.lot_size),
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "exchange": obj.exchange,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    cdef OptionContract from_pyo3_c(pyo3_instrument):
        Condition.not_none(pyo3_instrument, "pyo3_instrument")
        return OptionContract(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            asset_class=asset_class_from_str(str(pyo3_instrument.asset_class)),
            currency=Currency.from_str_c(pyo3_instrument.currency.code),
            price_precision=pyo3_instrument.price_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            multiplier=Quantity.from_raw_c(pyo3_instrument.multiplier.raw, pyo3_instrument.multiplier.precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision),
            underlying=pyo3_instrument.underlying,
            option_kind=option_kind_from_str(str(pyo3_instrument.option_kind)),
            strike_price=Price.from_raw_c(pyo3_instrument.strike_price.raw, pyo3_instrument.strike_price.precision),
            activation_ns=pyo3_instrument.activation_ns,
            expiration_ns=pyo3_instrument.expiration_ns,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            exchange=pyo3_instrument.exchange,
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_dict(dict values) -> OptionContract:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        OptionContract

        """
        return OptionContract.from_dict_c(values)

    @staticmethod
    def to_dict(OptionContract obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OptionContract.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_instrument) -> OptionContract:
        """
        Return legacy Cython option contract instrument converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_instrument : nautilus_pyo3.OptionContract
            The pyo3 Rust option contract instrument to convert from.

        Returns
        -------
        OptionContract

        """
        return OptionContract.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2442">
<source>nautilus_trader/model/instruments/option_spread.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd
import pytz

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport format_iso8601
from nautilus_trader.core.rust.model cimport AssetClass
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.rust.model cimport OptionKind
from nautilus_trader.model.functions cimport asset_class_from_str
from nautilus_trader.model.functions cimport asset_class_to_str
from nautilus_trader.model.functions cimport instrument_class_from_str
from nautilus_trader.model.functions cimport instrument_class_to_str
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.base cimport Price
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Quantity


cdef class OptionSpread(Instrument):
    """
    Represents a generic option spread instrument.

    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    raw_symbol : Symbol
        The raw/local/native symbol for the instrument, assigned by the venue.
    asset_class : AssetClass
        The option spread asset class.
    currency : Currency
        The option spread currency.
    price_precision : int
        The price decimal precision.
    price_increment : Price
        The minimum price increment (tick size).
    multiplier : Quantity
        The option multiplier.
    lot_size : Quantity
        The rounded lot unit size (standard/board).
    underlying : str
        The underlying asset.
    strategy_type : str
        The strategy type of the spread.
    activation_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract activation.
    expiration_ns : uint64_t
        UNIX timestamp (nanoseconds) for contract expiration.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    margin_init : Decimal, optional
        The initial (order) margin requirement in percentage of order value.
    margin_maint : Decimal, optional
        The maintenance (position) margin in percentage of position value.
    maker_fee : Decimal, optional
        The fee rate for liquidity makers as a percentage of order value.
    taker_fee : Decimal, optional
        The fee rate for liquidity takers as a percentage of order value.
    exchange : str, optional
        The exchange ISO 10383 Market Identifier Code (MIC) where the instrument trades.
    tick_scheme_name : str, optional
        The name of the tick scheme.
    info : dict[str, object], optional
        The additional instrument information.

    Raises
    ------
    ValueError
        If `strategy_type` is not a valid string.
    ValueError
        If `multiplier` is not positive (> 0).
    ValueError
        If `price_precision` is negative (< 0).
    ValueError
        If `tick_size` is not positive (> 0).
    ValueError
        If `lot_size` is not positive (> 0).
    ValueError
        If `margin_init` is negative (< 0).
    ValueError
        If `margin_maint` is negative (< 0).
    ValueError
        If `exchange` is not ``None`` and not a valid string.

    """

    def __init__(
        self,
        InstrumentId instrument_id not None,
        Symbol raw_symbol not None,
        AssetClass asset_class,
        Currency currency not None,
        int price_precision,
        Price price_increment not None,
        Quantity multiplier not None,
        Quantity lot_size not None,
        str underlying,
        str strategy_type,
        uint64_t activation_ns,
        uint64_t expiration_ns,
        uint64_t ts_event,
        uint64_t ts_init,
        margin_init: Decimal | None = None,
        margin_maint: Decimal | None = None,
        maker_fee: Decimal | None = None,
        taker_fee: Decimal | None = None,
        str exchange = None,
        str tick_scheme_name = None,
        dict info = None,
    ) -> None:
        Condition.valid_string(strategy_type, "strategy_type")

        if exchange is not None:
            Condition.valid_string(exchange, "exchange")

        super().__init__(
            instrument_id=instrument_id,
            raw_symbol=raw_symbol,
            asset_class=asset_class,
            instrument_class=InstrumentClass.OPTION_SPREAD,
            quote_currency=currency,
            is_inverse=False,
            price_precision=price_precision,
            size_precision=0,  # No fractional contracts
            price_increment=price_increment,
            size_increment=Quantity.from_int_c(1),
            multiplier=multiplier,
            lot_size=lot_size,
            max_quantity=None,
            min_quantity=Quantity.from_int_c(1),
            max_notional=None,
            min_notional=None,
            max_price=None,
            min_price=None,
            margin_init=margin_init or Decimal(0),
            margin_maint=margin_maint or Decimal(0),
            maker_fee=maker_fee or Decimal(0),
            taker_fee=taker_fee or Decimal(0),
            ts_event=ts_event,
            ts_init=ts_init,
            tick_scheme_name=tick_scheme_name,
            info=info,
        )

        self.exchange = exchange
        self.underlying = underlying
        self.strategy_type = strategy_type
        self.activation_ns = activation_ns
        self.expiration_ns = expiration_ns

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}"
            f"(id={self.id.to_str()}, "
            f"raw_symbol={self.raw_symbol}, "
            f"asset_class={asset_class_to_str(self.asset_class)}, "
            f"instrument_class={instrument_class_to_str(self.instrument_class)}, "
            f"exchange={self.exchange}, "
            f"currency={self.quote_currency}, "
            f"underlying={self.underlying}, "
            f"strategy_type={self.strategy_type}, "
            f"activation={format_iso8601(self.activation_utc, nanos_precision=False)}, "
            f"expiration={format_iso8601(self.expiration_utc, nanos_precision=False)}, "
            f"price_precision={self.price_precision}, "
            f"price_increment={self.price_increment}, "
            f"multiplier={self.multiplier}, "
            f"lot_size={self.lot_size}, "
            f"margin_init={self.margin_init}, "
            f"margin_maint={self.margin_maint}, "
            f"maker_fee={self.maker_fee}, "
            f"taker_fee={self.taker_fee}, "
            f"info={self.info})"
        )

    @property
    def activation_utc(self) -> pd.Timestamp:
        """
        Return the contract activation timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.activation_ns, tz=pytz.utc)

    @property
    def expiration_utc(self) -> pd.Timestamp:
        """
        Return the contract expiration timestamp (UTC).

        Returns
        -------
        pd.Timestamp
            tz-aware UTC.

        """
        return pd.Timestamp(self.expiration_ns, tz=pytz.utc)

    cpdef bint is_spread(self):
        """
        Return whether the instrument is a spread instrument.

        Returns
        -------
        bool

        """
        return True

    @staticmethod
    cdef OptionSpread from_dict_c(dict values):
        Condition.not_none(values, "values")
        return OptionSpread(
            instrument_id=InstrumentId.from_str_c(values["id"]),
            raw_symbol=Symbol(values["raw_symbol"]),
            asset_class=asset_class_from_str(values["asset_class"]),
            currency=Currency.from_str_c(values["currency"]),
            price_precision=values["price_precision"],
            price_increment=Price.from_str(values["price_increment"]),
            multiplier=Quantity.from_str(values["multiplier"]),
            lot_size=Quantity.from_str(values["lot_size"]),
            underlying=values["underlying"],
            strategy_type=values["strategy_type"],
            activation_ns=values["activation_ns"],
            expiration_ns=values["expiration_ns"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
            margin_init=Decimal(values["margin_init"]),
            margin_maint=Decimal(values["margin_maint"]),
            maker_fee=Decimal(values["maker_fee"]),
            taker_fee=Decimal(values["taker_fee"]),
            exchange=values["exchange"],
            tick_scheme_name=values.get("tick_scheme_name"),
            info=values.get("info"),
        )

    @staticmethod
    cdef dict to_dict_c(OptionSpread obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "OptionSpread",
            "id": obj.id.to_str(),
            "raw_symbol": obj.raw_symbol.to_str(),
            "asset_class": asset_class_to_str(obj.asset_class),
            "strategy_type": obj.strategy_type,
            "currency": obj.quote_currency.code,
            "price_precision": obj.price_precision,
            "price_increment": str(obj.price_increment),
            "size_precision": obj.size_precision,
            "size_increment": str(obj.size_increment),
            "multiplier": str(obj.multiplier),
            "max_quantity": str(obj.max_quantity) if obj.max_quantity is not None else None,
            "min_quantity": str(obj.min_quantity) if obj.min_quantity is not None else None,
            "max_price": str(obj.max_price) if obj.max_price is not None else None,
            "min_price": str(obj.min_price) if obj.min_price is not None else None,
            "lot_size": str(obj.lot_size),
            "underlying": str(obj.underlying),
            "activation_ns": obj.activation_ns,
            "expiration_ns": obj.expiration_ns,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
            "margin_init": str(obj.margin_init),
            "margin_maint": str(obj.margin_maint),
            "maker_fee": str(obj.maker_fee),
            "taker_fee": str(obj.taker_fee),
            "exchange": obj.exchange,
            "tick_scheme_name": obj.tick_scheme_name,
            "info": obj.info,
        }

    @staticmethod
    cdef OptionSpread from_pyo3_c(pyo3_instrument):
        Condition.not_none(pyo3_instrument, "pyo3_instrument")
        return OptionSpread(
            instrument_id=InstrumentId.from_str_c(pyo3_instrument.id.value),
            raw_symbol=Symbol(pyo3_instrument.raw_symbol.value),
            asset_class=asset_class_from_str(str(pyo3_instrument.asset_class)),
            currency=Currency.from_str_c(pyo3_instrument.currency.code),
            price_precision=pyo3_instrument.price_precision,
            price_increment=Price.from_raw_c(pyo3_instrument.price_increment.raw, pyo3_instrument.price_precision),
            multiplier=Quantity.from_raw_c(pyo3_instrument.multiplier.raw, pyo3_instrument.multiplier.precision),
            lot_size=Quantity.from_raw_c(pyo3_instrument.lot_size.raw, pyo3_instrument.lot_size.precision),
            underlying=pyo3_instrument.underlying,
            strategy_type=pyo3_instrument.strategy_type,
            activation_ns=pyo3_instrument.activation_ns,
            expiration_ns=pyo3_instrument.expiration_ns,
            margin_init=Decimal(pyo3_instrument.margin_init),
            margin_maint=Decimal(pyo3_instrument.margin_maint),
            maker_fee=Decimal(pyo3_instrument.maker_fee),
            taker_fee=Decimal(pyo3_instrument.taker_fee),
            exchange=pyo3_instrument.exchange,
            ts_event=pyo3_instrument.ts_event,
            ts_init=pyo3_instrument.ts_init,
            info=pyo3_instrument.info,
        )

    @staticmethod
    def from_dict(dict values) -> OptionSpread:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        OptionSpread

        """
        return OptionSpread.from_dict_c(values)

    @staticmethod
    def to_dict(OptionSpread obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return OptionSpread.to_dict_c(obj)

    @staticmethod
    def from_pyo3(pyo3_instrument) -> OptionSpread:
        """
        Return legacy Cython option spread instrument converted from the given pyo3 Rust object.

        Parameters
        ----------
        pyo3_instrument : nautilus_pyo3.OptionSpread
            The pyo3 Rust option spread instrument to convert from.

        Returns
        -------
        OptionSpread

        """
        return OptionSpread.from_pyo3_c(pyo3_instrument)

</document_content>
</document>
<document index="2444">
<source>nautilus_trader/model/instruments/synthetic.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import msgspec

from cpython.mem cimport PyMem_Free
from cpython.mem cimport PyMem_Malloc
from libc.math cimport isnan
from libc.stdint cimport uint8_t
from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.data cimport Data
from nautilus_trader.core.rust.core cimport CVec
from nautilus_trader.core.rust.model cimport ERROR_PRICE
from nautilus_trader.core.rust.model cimport Price_t
from nautilus_trader.core.rust.model cimport SyntheticInstrument_API
from nautilus_trader.core.rust.model cimport symbol_new
from nautilus_trader.core.rust.model cimport synthetic_instrument_calculate
from nautilus_trader.core.rust.model cimport synthetic_instrument_change_formula
from nautilus_trader.core.rust.model cimport synthetic_instrument_components_count
from nautilus_trader.core.rust.model cimport synthetic_instrument_components_to_cstr
from nautilus_trader.core.rust.model cimport synthetic_instrument_drop
from nautilus_trader.core.rust.model cimport synthetic_instrument_formula_to_cstr
from nautilus_trader.core.rust.model cimport synthetic_instrument_id
from nautilus_trader.core.rust.model cimport synthetic_instrument_is_valid_formula
from nautilus_trader.core.rust.model cimport synthetic_instrument_new
from nautilus_trader.core.rust.model cimport synthetic_instrument_price_increment
from nautilus_trader.core.rust.model cimport synthetic_instrument_price_precision
from nautilus_trader.core.rust.model cimport synthetic_instrument_ts_event
from nautilus_trader.core.rust.model cimport synthetic_instrument_ts_init
from nautilus_trader.core.string cimport cstr_to_pybytes
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.core.string cimport pybytes_to_cstr
from nautilus_trader.core.string cimport pystr_to_cstr
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Symbol
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.objects cimport Price


cdef class SyntheticInstrument(Data):
    """
    Represents a synthetic instrument with prices derived from component instruments using a
    formula.

    The `id` for the synthetic will become `{symbol}.{SYNTH}`.

    Parameters
    ----------
    symbol : Symbol
        The symbol for the synthetic instrument.
    price_precision : uint8_t
        The price precision for the synthetic instrument.
    components : list[InstrumentId]
        The component instruments for the synthetic instrument.
    formula : str
        The derivation formula for the synthetic instrument.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.

    Raises
    ------
    ValueError
        If `price_precision` is greater than 9.
    OverflowError
        If `price_precision` is negative (< 0).
    ValueError
        If the `components` list does not contain at least 2 instrument IDs.
    ValueError
        If the `formula` is not a valid string.
    ValueError
        If the `formula` is not a valid expression.

    Warnings
    --------
    All component instruments should already be defined and exist in the cache prior to defining
    a new synthetic instrument.

    """

    def __init__(
        self,
        Symbol symbol not None,
        uint8_t price_precision,
        list components not None,
        str formula not None,
        uint64_t ts_event,
        uint64_t ts_init,
    ) -> None:
        Condition.is_true(price_precision <= 9, f"invalid `price_precision` greater than max 9, was {price_precision}")
        Condition.is_true(len(components) >= 2, "There must be at least two component instruments")
        Condition.list_type(components, InstrumentId, "components")
        Condition.valid_string(formula, "formula")

        comp_bytes = msgspec.json.encode([c.value for c in components])

        if not synthetic_instrument_is_valid_formula(pystr_to_cstr(formula), pybytes_to_cstr(comp_bytes)):
            raise ValueError(f"invalid `formula`, was '{formula}'")

        self._mem = synthetic_instrument_new(
            symbol._mem,
            price_precision,
            pybytes_to_cstr(comp_bytes),
            pystr_to_cstr(formula),
            ts_event,
            ts_init,
        )
        self.id = InstrumentId(symbol, Venue("SYNTH"))

    def __del__(self) -> None:
        if self._mem._0 != NULL:
            synthetic_instrument_drop(self._mem)

    # TODO: It's currently not safe to pickle synthetic instruments
    # def __getstate__(self):
    #     return (
    #         self.id.symbol.value,
    #         self.price_precision,
    #         msgspec.json.encode([c.value for c in self.components]),
    #         self.formula,
    #         self.ts_event,
    #         self.ts_init,
    #     )
    #
    # def __setstate__(self, state):
    #     self._mem = synthetic_instrument_new(
    #         symbol_new(pystr_to_cstr(state[0])),
    #         state[1],
    #         pybytes_to_cstr(state[2]),
    #         pystr_to_cstr(state[3]),
    #         state[4],
    #         state[5],
    #     )

    def __eq__(self, SyntheticInstrument other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    # @property
    # def id(self) -> InstrumentId:
    #     """
    #     Return the synthetic instruments ID.
    #
    #     Returns
    #     -------
    #     InstrumentId
    #
    #     """
    #     return InstrumentId.from_mem_c(synthetic_instrument_id(&self._mem))

    @property
    def price_precision(self) -> int:
        """
        Return the precision for the synthetic instrument.

        Returns
        -------
        int

        """
        return synthetic_instrument_price_precision(&self._mem)

    @property
    def price_increment(self) -> Price:
        """
        Return the minimum price increment (tick size) for the synthetic instrument.

        Returns
        -------
        Price

        """
        return Price.from_mem_c(synthetic_instrument_price_increment(&self._mem))

    @property
    def components(self) -> list[InstrumentId]:
        """
        Return the components of the synthetic instrument.

        Returns
        -------
        list[InstrumentId]

        """
        cdef bytes components_bytes = cstr_to_pybytes(synthetic_instrument_components_to_cstr(&self._mem))
        return [InstrumentId.from_str_c(c) for c in msgspec.json.decode(components_bytes)]

    @property
    def formula(self) -> str:
        """
        Return the synthetic instrument internal derivation formula.

        Returns
        -------
        str

        """
        return cstr_to_pystr(synthetic_instrument_formula_to_cstr(&self._mem))

    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.

        Returns
        -------
        int

        """
        return synthetic_instrument_ts_event(&self._mem)

    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        int

        """
        return synthetic_instrument_ts_init(&self._mem)

    cpdef void change_formula(self, str formula):
        """
        Change the internal derivation formula for the synthetic instrument.

        Parameters
        ----------
        formula : str
            The derivation formula to change to.

        Raises
        ------
        ValueError
            If the `formula` is not a valid string.
        ValueError
            If the `formula` is not a valid expression.

        """
        Condition.valid_string(formula, "formula")

        comp_bytes = msgspec.json.encode([c.value for c in self.components])

        if not synthetic_instrument_is_valid_formula(pystr_to_cstr(formula), pybytes_to_cstr(comp_bytes)):
            raise ValueError(f"invalid `formula`, was '{formula}'")

        synthetic_instrument_change_formula(&self._mem, pystr_to_cstr(formula))

    cpdef Price calculate(self, list[double] inputs):
        """
        Calculate the price of the synthetic instrument from the given `inputs`.

        Parameters
        ----------
        inputs : list[double]

        Returns
        -------
        Price

        Raises
        ------
        ValueError
            If `inputs` is empty, contains a NaN value, or length is different from components count.
        RuntimeError
            If an internal error occurs when calculating the price.

        """
        Condition.not_empty(inputs, "inputs")

        cdef uint64_t len_ = len(inputs)

        cdef uint64_t components_count = synthetic_instrument_components_count(&self._mem)
        if len_ != components_count:
            raise ValueError(
                f"error calculating {self.id} `SyntheticInstrument` price: "
                f"length of inputs ({len_}) not equal to components count ({components_count})",
            )

        cdef double value
        for value in inputs:
            if isnan(value):
                raise ValueError(f"NaN detected in inputs {inputs}")

        # Create a C doubles buffer
        cdef double* data = <double *>PyMem_Malloc(len_ * sizeof(double))
        if not data:
            raise MemoryError()

        cdef uint64_t i
        for i in range(len_):
            data[i] = <double>inputs[i]

        # Create CVec
        cdef CVec* cvec = <CVec *>PyMem_Malloc(1 * sizeof(CVec))
        if not cvec:
            raise MemoryError()

        cvec.ptr = data
        cvec.len = len_
        cvec.cap = len_

        cdef Price_t mem = synthetic_instrument_calculate(&self._mem, cvec)
        if mem.precision == ERROR_PRICE.precision:
            raise RuntimeError(
                f"error calculating {self.id} `SyntheticInstrument` price from {inputs}",
            )

        cdef Price price = Price.from_mem_c(mem)

        PyMem_Free(cvec.ptr) # De-allocate buffer
        PyMem_Free(cvec) # De-allocate cvec

        return price

    @staticmethod
    cdef SyntheticInstrument from_dict_c(dict values):
        Condition.not_none(values, "values")
        return SyntheticInstrument(
            symbol=Symbol(values["symbol"]),
            price_precision=values["price_precision"],
            components=[InstrumentId.from_str_c(c) for c in values["components"]],
            formula=values["formula"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )

    @staticmethod
    cdef dict to_dict_c(SyntheticInstrument obj):
        Condition.not_none(obj, "obj")
        return {
            "type": "SyntheticInstrument",
            "symbol": obj.id.symbol.value,
            "price_precision": obj.price_precision,
            "components": [c.value for c in obj.components],
            "formula": obj.formula,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }

    @staticmethod
    def from_dict(dict values) -> SyntheticInstrument:
        """
        Return an instrument from the given initialization values.

        Parameters
        ----------
        values : dict[str, object]
            The values to initialize the instrument with.

        Returns
        -------
        SyntheticInstrument

        """
        return SyntheticInstrument.from_dict_c(values)

    @staticmethod
    def to_dict(SyntheticInstrument obj) -> dict[str, object]:
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return SyntheticInstrument.to_dict_c(obj)

</document_content>
</document>
<document index="2446">
<source>nautilus_trader/model/objects.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""Defines fundamental value objects for the trading domain."""

import decimal

import cython

from cpython.object cimport Py_EQ
from cpython.object cimport Py_GE
from cpython.object cimport Py_GT
from cpython.object cimport Py_LE
from cpython.object cimport Py_LT
from cpython.object cimport PyObject_RichCompareBool
from libc.math cimport isnan
from libc.stdint cimport int64_t
from libc.stdint cimport uint8_t
from libc.stdint cimport uint16_t
from libc.stdint cimport uint64_t
from libc.string cimport strcmp

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.core cimport precision_from_cstr
from nautilus_trader.core.rust.model cimport FIXED_PRECISION as RUST_FIXED_PRECISION
from nautilus_trader.core.rust.model cimport FIXED_SCALAR as RUST_FIXED_SCALAR
from nautilus_trader.core.rust.model cimport HIGH_PRECISION_MODE as RUST_HIGH_PRECISION_MODE
from nautilus_trader.core.rust.model cimport MONEY_MAX as RUST_MONEY_MAX
from nautilus_trader.core.rust.model cimport MONEY_MIN as RUST_MONEY_MIN
from nautilus_trader.core.rust.model cimport MONEY_RAW_MAX
from nautilus_trader.core.rust.model cimport MONEY_RAW_MIN
from nautilus_trader.core.rust.model cimport PRECISION_BYTES
from nautilus_trader.core.rust.model cimport PRECISION_BYTES as RUST_PRECISION_BYTES
from nautilus_trader.core.rust.model cimport PRICE_MAX as RUST_PRICE_MAX
from nautilus_trader.core.rust.model cimport PRICE_MIN as RUST_PRICE_MIN
from nautilus_trader.core.rust.model cimport PRICE_RAW_MAX
from nautilus_trader.core.rust.model cimport PRICE_RAW_MIN
from nautilus_trader.core.rust.model cimport QUANTITY_MAX as RUST_QUANTITY_MAX
from nautilus_trader.core.rust.model cimport QUANTITY_MIN as RUST_QUANTITY_MIN
from nautilus_trader.core.rust.model cimport QUANTITY_RAW_MAX
from nautilus_trader.core.rust.model cimport MoneyRaw
from nautilus_trader.core.rust.model cimport PriceRaw
from nautilus_trader.core.rust.model cimport QuantityRaw
from nautilus_trader.core.rust.model cimport currency_code_to_cstr
from nautilus_trader.core.rust.model cimport currency_exists
from nautilus_trader.core.rust.model cimport currency_from_cstr
from nautilus_trader.core.rust.model cimport currency_from_py
from nautilus_trader.core.rust.model cimport currency_hash
from nautilus_trader.core.rust.model cimport currency_register
from nautilus_trader.core.rust.model cimport currency_to_cstr
from nautilus_trader.core.rust.model cimport money_from_raw
from nautilus_trader.core.rust.model cimport money_new
from nautilus_trader.core.rust.model cimport price_from_raw
from nautilus_trader.core.rust.model cimport price_new
from nautilus_trader.core.rust.model cimport quantity_from_raw
from nautilus_trader.core.rust.model cimport quantity_new
from nautilus_trader.core.rust.model cimport quantity_saturating_sub
from nautilus_trader.core.string cimport cstr_to_pystr
from nautilus_trader.core.string cimport pystr_to_cstr
from nautilus_trader.core.string cimport ustr_to_pystr


# Value object valid range constants for Python
QUANTITY_MAX = RUST_QUANTITY_MAX
QUANTITY_MIN = RUST_QUANTITY_MIN
PRICE_MAX = RUST_PRICE_MAX
PRICE_MIN = RUST_PRICE_MIN
MONEY_MAX = RUST_MONEY_MAX
MONEY_MIN = RUST_MONEY_MIN

HIGH_PRECISION = bool(RUST_HIGH_PRECISION_MODE)
FIXED_PRECISION = RUST_FIXED_PRECISION
FIXED_SCALAR = RUST_FIXED_SCALAR
FIXED_PRECISION_BYTES = RUST_PRECISION_BYTES
FIXED_DECIMAL_SCALE = decimal.Decimal(10) ** FIXED_PRECISION


@cython.auto_pickle(True)
cdef class Quantity:
    """
    Represents a quantity with a non-negative value.

    Capable of storing either a whole number (no decimal places) of 'contracts'
    or 'shares' (instruments denominated in whole units) or a decimal value
    containing decimal places for instruments denominated in fractional units.

    Handles up to 16 decimals of precision (in high-precision mode).

    - ``QUANTITY_MAX`` = 34_028_236_692_093
    - ``QUANTITY_MIN`` = 0

    Parameters
    ----------
    value : integer, float, string, Decimal
        The value of the quantity.
    precision : uint8_t
        The precision for the quantity. Use a precision of 0 for whole numbers
        (no fractional units).

    Raises
    ------
    ValueError
        If `value` is greater than 34_028_236_692_093.
    ValueError
        If `value` is negative (< 0).
    ValueError
        If `precision` is greater than 16.
    OverflowError
        If `precision` is negative (< 0).

    References
    ----------
    https://www.onixs.biz/fix-dictionary/5.0.SP2/index.html#Qty
    """

    def __init__(self, double value, uint8_t precision) -> None:
        if precision > FIXED_PRECISION:
            raise ValueError(
                f"invalid `precision` greater than max {FIXED_PRECISION}, was {precision}"
            )
        if isnan(value):
            raise ValueError(
                f"invalid `value`, was {value:_}",
            )
        if value > RUST_QUANTITY_MAX:
            raise ValueError(
                f"invalid `value` greater than `QUANTITY_MAX` {RUST_QUANTITY_MAX:_}, was {value:_}",
            )
        if value < RUST_QUANTITY_MIN:
            raise ValueError(
                f"invalid `value` less than `QUANTITY_MIN` {RUST_QUANTITY_MIN:_}, was {value:_}",
            )

        self._mem = quantity_new(value, precision)

    def __getstate__(self):
        return self._mem.raw, self._mem.precision

    def __setstate__(self, state):
        self._mem = quantity_from_raw(state[0], state[1])

    def __eq__(self, other) -> bool:
        if other is None:
            return False
        return Quantity._compare(self, other, Py_EQ)

    def __lt__(self, other) -> bool:
        return Quantity._compare(self, other, Py_LT)

    def __le__(self, other) -> bool:
        return Quantity._compare(self, other, Py_LE)

    def __gt__(self, other) -> bool:
        return Quantity._compare(self, other, Py_GT)

    def __ge__(self, other) -> bool:
        return Quantity._compare(self, other, Py_GE)

    def __add__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) + float(b)
        return Quantity._extract_decimal(a) + Quantity._extract_decimal(b)

    def __radd__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) + float(b)
        return Quantity._extract_decimal(a) + Quantity._extract_decimal(b)

    def __sub__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) - float(b)
        return Quantity._extract_decimal(a) - Quantity._extract_decimal(b)

    def __rsub__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) - float(b)
        return Quantity._extract_decimal(a) - Quantity._extract_decimal(b)

    def __mul__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) * float(b)
        return Quantity._extract_decimal(a) * Quantity._extract_decimal(b)

    def __rmul__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) * float(b)
        return Quantity._extract_decimal(a) * Quantity._extract_decimal(b)

    def __truediv__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) / float(b)
        return Quantity._extract_decimal(a) / Quantity._extract_decimal(b)

    def __rtruediv__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) / float(b)
        return Quantity._extract_decimal(a) / Quantity._extract_decimal(b)

    def __floordiv__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) // float(b)
        return Quantity._extract_decimal(a) // Quantity._extract_decimal(b)

    def __rfloordiv__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) // float(b)
        return Quantity._extract_decimal(a) // Quantity._extract_decimal(b)

    def __mod__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) % float(b)
        return Quantity._extract_decimal(a) % Quantity._extract_decimal(b)

    def __rmod__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) % float(b)
        return Quantity._extract_decimal(a) % Quantity._extract_decimal(b)

    def __neg__(self) -> decimal.Decimal:
        return self.as_decimal().__neg__()

    def __pos__(self) -> decimal.Decimal:
        return self.as_decimal().__pos__()

    def __abs__(self) -> decimal.Decimal:
        return abs(self.as_decimal())

    def __round__(self, ndigits = None) -> decimal.Decimal:
        return round(self.as_decimal(), ndigits)

    def __float__(self) -> float:
        return self.as_f64_c()

    def __int__(self) -> int:
        return int(self.as_decimal())

    def __hash__(self) -> int:
        return hash(self._mem.raw)

    def __str__(self) -> str:
        return f"{self.as_decimal():.{self._mem.precision}f}"

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self})"

    @property
    def raw(self) -> QuantityRaw:
        """
        Return the raw memory representation of the quantity value.

        Returns
        -------
        int

        """
        return self._mem.raw

    @property
    def precision(self) -> int:
        """
        Return the precision for the quantity.

        Returns
        -------
        uint8_t

        """
        return self._mem.precision

    cdef bint eq(self, Quantity other):
        Condition.not_none(other, "other")
        return self._mem.raw == other._mem.raw

    cdef bint ne(self, Quantity other):
        Condition.not_none(other, "other")
        return self._mem.raw != other._mem.raw

    cdef bint lt(self, Quantity other):
        Condition.not_none(other, "other")
        return self._mem.raw < other._mem.raw

    cdef bint le(self, Quantity other):
        Condition.not_none(other, "other")
        return self._mem.raw <= other._mem.raw

    cdef bint gt(self, Quantity other):
        Condition.not_none(other, "other")
        return self._mem.raw > other._mem.raw

    cdef bint ge(self, Quantity other):
        Condition.not_none(other, "other")
        return self._mem.raw >= other._mem.raw

    cdef bint is_zero(self):
        return self._mem.raw == 0

    cdef bint is_negative(self):
        return self._mem.raw < 0

    cdef bint is_positive(self):
        return self._mem.raw > 0

    cdef Quantity add(self, Quantity other):
        return Quantity.from_raw_c(self._mem.raw + other._mem.raw, self._mem.precision)

    cdef Quantity sub(self, Quantity other):
        return Quantity.from_raw_c(self._mem.raw - other._mem.raw, self._mem.precision)

    cdef Quantity saturating_sub(self, Quantity other):
        return Quantity.from_mem_c(quantity_saturating_sub(self._mem, other._mem))

    cdef void add_assign(self, Quantity other):
        self._mem.raw += other._mem.raw
        if self._mem.precision == 0:
            self._mem.precision = other.precision

    cdef void sub_assign(self, Quantity other):
        self._mem.raw -= other._mem.raw
        if self._mem.precision == 0:
            self._mem.precision = other.precision

    cdef QuantityRaw raw_uint_c(self):
        return self._mem.raw

    cdef double as_f64_c(self):
        return self._mem.raw / RUST_FIXED_SCALAR

    @staticmethod
    cdef double raw_to_f64_c(QuantityRaw raw):
        return raw / RUST_FIXED_SCALAR

    @staticmethod
    def raw_to_f64(raw) -> float:
        return Quantity.raw_to_f64_c(raw)

    @staticmethod
    cdef Quantity from_mem_c(Quantity_t mem):
        cdef Quantity quantity = Quantity.__new__(Quantity)
        quantity._mem = mem
        return quantity

    @staticmethod
    cdef Quantity from_raw_c(QuantityRaw raw, uint8_t precision):
        cdef Quantity quantity = Quantity.__new__(Quantity)
        quantity._mem = quantity_from_raw(raw, precision)
        return quantity

    @staticmethod
    cdef object _extract_decimal(object obj):
        assert not isinstance(obj, float)  # Design-time error
        if hasattr(obj, "as_decimal"):
            return obj.as_decimal()
        else:
            return decimal.Decimal(obj)

    @staticmethod
    cdef bint _compare(a, b, int op):
        if isinstance(a, Quantity):
            a = <Quantity>a.as_decimal()
        elif isinstance(a, Price):
            a = <Price>a.as_decimal()

        if isinstance(b, Quantity):
            b = <Quantity>b.as_decimal()
        elif isinstance(b, Price):
            b = <Price>b.as_decimal()

        return PyObject_RichCompareBool(a, b, op)

    @staticmethod
    cdef Quantity zero_c(uint8_t precision):
        return Quantity(0, precision)

    @staticmethod
    cdef Quantity from_str_c(str value):
        value = value.replace('_', '')

        cdef uint8_t precision = precision_from_cstr(pystr_to_cstr(value))
        if precision > FIXED_PRECISION:
            raise ValueError(
                f"invalid `precision` greater than max {FIXED_PRECISION}, was {precision}"
            )

        decimal_value = decimal.Decimal(value)

        if decimal_value < 0:
            raise ValueError(
                f"invalid negative quantity, was {value}"
            )

        scaled = decimal_value * (10 ** precision)
        integral = scaled.to_integral_value(rounding=decimal.ROUND_HALF_EVEN)

        raw_py = int(integral) * (10 ** (FIXED_PRECISION - precision))
        if raw_py > QUANTITY_RAW_MAX:
            raise ValueError(
                f"invalid raw quantity value exceeds max {QUANTITY_RAW_MAX}, was {raw_py}"
            )

        cdef QuantityRaw raw = <QuantityRaw>(raw_py)
        return Quantity.from_raw_c(raw, precision)

    @staticmethod
    cdef Quantity from_int_c(QuantityRaw value):
        return Quantity(value, precision=0)

    @staticmethod
    def zero(uint8_t precision=0) -> Quantity:
        """
        Return a quantity with a value of zero.

        precision : uint8_t, default 0
            The precision for the quantity.

        Returns
        -------
        Quantity

        Raises
        ------
        ValueError
            If `precision` is greater than 16.
        OverflowError
            If `precision` is negative (< 0).

        Warnings
        --------
        The default precision is zero.

        """
        return Quantity.zero_c(precision)

    @staticmethod
    def from_raw(raw: int, uint8_t precision) -> Quantity:
        """
        Return a quantity from the given `raw` fixed-point integer and `precision`.

        Handles up to 16 decimals of precision (in high-precision mode).

        Parameters
        ----------
        raw : int
            The raw fixed-point quantity value.
        precision : uint8_t
            The precision for the quantity. Use a precision of 0 for whole numbers
            (no fractional units).

        Returns
        -------
        Quantity

        Raises
        ------
        ValueError
            If `precision` is greater than 16.
        OverflowError
            If `precision` is negative (< 0).

        Warnings
        --------
        Small `raw` values can produce a zero quantity depending on the `precision`.

        """
        if precision > FIXED_PRECISION:
            raise ValueError(
                f"invalid `precision` greater than max {FIXED_PRECISION}, was {precision}"
            )
        return Quantity.from_raw_c(raw, precision)

    @staticmethod
    def from_str(str value) -> Quantity:
        """
        Return a quantity parsed from the given string.

        Handles up to 16 decimals of precision (in high-precision mode).

        Parameters
        ----------
        value : str
            The value to parse.

        Returns
        -------
        Quantity

        Raises
        ------
        ValueError
            If inferred precision is greater than 16.
        ValueError
            If raw value is outside the valid representable range [0, `QUANTITY_RAW_MAX`].
        OverflowError
            If inferred precision is negative (< 0).

        Warnings
        --------
        The decimal precision will be inferred from the number of digits
        following the '.' point (if no point then precision zero).

        """
        Condition.not_none(value, "value")

        return Quantity.from_str_c(value)

    @staticmethod
    def from_int(value: int) -> Quantity:
        """
        Return a quantity from the given integer value.

        A precision of zero will be inferred.

        Parameters
        ----------
        value : int
            The value for the quantity.

        Returns
        -------
        Quantity

        """
        Condition.not_none(value, "value")

        return Quantity.from_int_c(value)

    @staticmethod
    def from_decimal(value: decimal.Decimal) -> Quantity:
        """
        Return a quantity from the given Decimal value.

        Handles up to 16 decimals of precision (in high-precision mode).

        Parameters
        ----------
        value : Decimal
            The Decimal value for the quantity.

        Returns
        -------
        Quantity

        Raises
        ------
        ValueError
            If inferred precision is greater than 16.
        ValueError
            If raw value is outside the valid representable range [0, `QUANTITY_RAW_MAX`].
        OverflowError
            If inferred precision is negative (< 0).

        Warnings
        --------
        The decimal precision will be inferred from the number of digits
        following the '.' point (if no point then precision zero).

        """
        Condition.not_none(value, "value")

        return Quantity.from_str_c(str(value))

    cpdef str to_formatted_str(self):
        """
        Return the formatted string representation of the quantity.

        Returns
        -------
        str

        """
        return f"{self.as_decimal():,.{self._mem.precision}f}".replace(",", "_")

    cpdef object as_decimal(self):
        """
        Return the value as a built-in `Decimal`.

        Returns
        -------
        Decimal

        """
        raw_decimal = decimal.Decimal(self._mem.raw)
        return raw_decimal / FIXED_DECIMAL_SCALE

    cpdef double as_double(self):
        """
        Return the value as a `double`.

        Returns
        -------
        double

        """
        return self.as_f64_c()


@cython.auto_pickle(True)
cdef class Price:
    """
    Represents a price in a market.

    The number of decimal places may vary. For certain asset classes, prices may
    have negative values. For example, prices for options instruments can be
    negative under certain conditions.

    Handles up to 16 decimals of precision (in high-precision mode).

    - ``PRICE_MAX`` = 17_014_118_346_046
    - ``PRICE_MIN`` = -17_014_118_346_046

    Parameters
    ----------
    value : integer, float, string or Decimal
        The value of the price.
    precision : uint8_t
        The precision for the price. Use a precision of 0 for whole numbers
        (no fractional units).

    Raises
    ------
    ValueError
        If `value` is greater than 17_014_118_346_046.
    ValueError
        If `value` is less than -17_014_118_346_046.
    ValueError
        If `precision` is greater than 16.
    OverflowError
        If `precision` is negative (< 0).

    References
    ----------
    https://www.onixs.biz/fix-dictionary/5.0.SP2/index.html#Price
    """

    def __init__(self, double value, uint8_t precision) -> None:
        if precision > FIXED_PRECISION:
            raise ValueError(
                f"invalid `precision` greater than max {FIXED_PRECISION}, was {precision}"
            )
        if isnan(value):
            raise ValueError(
                f"invalid `value`, was {value:_}",
            )
        if value > RUST_PRICE_MAX:
            raise ValueError(
                f"invalid `value` greater than `PRICE_MAX` {RUST_PRICE_MAX:_}, was {value:_}",
            )
        if value < RUST_PRICE_MIN:
            raise ValueError(
                f"invalid `value` less than `PRICE_MIX` {RUST_PRICE_MIN:_}, was {value:_}",
            )

        self._mem = price_new(value, precision)

    def __getstate__(self):
        return self._mem.raw, self._mem.precision

    def __setstate__(self, state):
        self._mem = price_from_raw(state[0], state[1])

    def __eq__(self, other) -> bool:
        if other is None:
            return False
        return Price._compare(self, other, Py_EQ)

    def __lt__(self, other) -> bool:
        return Price._compare(self, other, Py_LT)

    def __le__(self, other) -> bool:
        return Price._compare(self, other, Py_LE)

    def __gt__(self, other) -> bool:
        return Price._compare(self, other, Py_GT)

    def __ge__(self, other) -> bool:
        return Price._compare(self, other, Py_GE)

    def __add__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) + float(b)
        return Price._extract_decimal(a) + Price._extract_decimal(b)

    def __radd__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) + float(b)
        return Price._extract_decimal(a) + Price._extract_decimal(b)

    def __sub__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) - float(b)
        return Price._extract_decimal(a) - Price._extract_decimal(b)

    def __rsub__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) - float(b)
        return Price._extract_decimal(a) - Price._extract_decimal(b)

    def __mul__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) * float(b)
        return Price._extract_decimal(a) * Price._extract_decimal(b)

    def __rmul__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) * float(b)
        return Price._extract_decimal(a) * Price._extract_decimal(b)

    def __truediv__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) / float(b)
        return Price._extract_decimal(a) / Price._extract_decimal(b)

    def __rtruediv__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) / float(b)
        return Price._extract_decimal(a) / Price._extract_decimal(b)

    def __floordiv__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) // float(b)
        return Price._extract_decimal(a) // Price._extract_decimal(b)

    def __rfloordiv__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) // float(b)
        return Price._extract_decimal(a) // Price._extract_decimal(b)

    def __mod__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) % float(b)
        return Price._extract_decimal(a) % Price._extract_decimal(b)

    def __rmod__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) % float(b)
        return Price._extract_decimal(a) % Price._extract_decimal(b)

    def __neg__(self) -> decimal.Decimal:
        return self.as_decimal().__neg__()

    def __pos__(self) -> decimal.Decimal:
        return self.as_decimal().__pos__()

    def __abs__(self) -> decimal.Decimal:
        return abs(self.as_decimal())

    def __round__(self, ndigits = None) -> decimal.Decimal:
        return round(self.as_decimal(), ndigits)

    def __float__(self) -> float:
        return self.as_f64_c()

    def __int__(self) -> int:
        return int(self.as_decimal())

    def __hash__(self) -> int:
        return hash(self._mem.raw)

    def __str__(self) -> str:
        return f"{self.as_decimal():.{self._mem.precision}f}"

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self})"

    @property
    def raw(self) -> PriceRaw:
        """
        Return the raw memory representation of the price value.

        Returns
        -------
        int

        """
        return self._mem.raw

    @property
    def precision(self) -> int:
        """
        Return the precision for the price.

        Returns
        -------
        uint8_t

        """
        return self._mem.precision

    @staticmethod
    cdef Price from_mem_c(Price_t mem):
        cdef Price price = Price.__new__(Price)
        price._mem = mem
        return price

    @staticmethod
    cdef Price from_raw_c(PriceRaw raw, uint8_t precision):
        cdef Price price = Price.__new__(Price)
        price._mem = price_from_raw(raw, precision)
        return price

    @staticmethod
    cdef object _extract_decimal(object obj):
        assert not isinstance(obj, float)  # Design-time error
        if hasattr(obj, "as_decimal"):
            return obj.as_decimal()
        else:
            return decimal.Decimal(obj)

    @staticmethod
    cdef bint _compare(a, b, int op):
        if isinstance(a, Quantity):
            a = <Quantity>a.as_decimal()
        elif isinstance(a, Price):
            a = <Price>a.as_decimal()

        if isinstance(b, Quantity):
            b = <Quantity>b.as_decimal()
        elif isinstance(b, Price):
            b = <Price>b.as_decimal()

        return PyObject_RichCompareBool(a, b, op)

    @staticmethod
    cdef double raw_to_f64_c(PriceRaw raw):
        return raw / RUST_FIXED_SCALAR

    @staticmethod
    cdef Price from_str_c(str value):
        value = value.replace('_', '')

        cdef uint8_t precision = precision_from_cstr(pystr_to_cstr(value))
        if precision > FIXED_PRECISION:
            raise ValueError(
                f"invalid `precision` greater than max {FIXED_PRECISION}, was {precision}"
            )

        decimal_value = decimal.Decimal(value)
        scaled = decimal_value * (10 ** precision)
        integral = scaled.to_integral_value(rounding=decimal.ROUND_HALF_EVEN)

        raw_py = int(integral) * (10 ** (FIXED_PRECISION - precision))
        if raw_py < PRICE_RAW_MIN or raw_py > PRICE_RAW_MAX:
            raise ValueError(
                f"invalid raw price value outside range [{PRICE_RAW_MIN}, {PRICE_RAW_MAX}], was {raw_py}"
            )

        cdef PriceRaw raw = <PriceRaw>(raw_py)
        return Price.from_raw_c(raw, precision)

    @staticmethod
    cdef Price from_int_c(PriceRaw value):
        return Price(value, precision=0)

    cdef bint eq(self, Price other):
        Condition.not_none(other, "other")
        return self._mem.raw == other._mem.raw

    cdef bint ne(self, Price other):
        Condition.not_none(other, "other")
        return self._mem.raw != other._mem.raw

    cdef bint lt(self, Price other):
        Condition.not_none(other, "other")
        return self._mem.raw < other._mem.raw

    cdef bint le(self, Price other):
        Condition.not_none(other, "other")
        return self._mem.raw <= other._mem.raw

    cdef bint gt(self, Price other):
        Condition.not_none(other, "other")
        return self._mem.raw > other._mem.raw

    cdef bint ge(self, Price other):
        Condition.not_none(other, "other")
        return self._mem.raw >= other._mem.raw

    cdef bint is_zero(self):
        return self._mem.raw == 0

    cdef bint is_negative(self):
        return self._mem.raw < 0

    cdef bint is_positive(self):
        return self._mem.raw > 0

    cdef Price add(self, Price other):
        return Price.from_raw_c(self._mem.raw + other._mem.raw, self._mem.precision)

    cdef Price sub(self, Price other):
        return Price.from_raw_c(self._mem.raw - other._mem.raw, self._mem.precision)

    cdef void add_assign(self, Price other):
        self._mem.raw += other._mem.raw

    cdef void sub_assign(self, Price other):
        self._mem.raw -= other._mem.raw

    cdef PriceRaw raw_int_c(self):
        return self._mem.raw

    cdef double as_f64_c(self):
        return self._mem.raw / RUST_FIXED_SCALAR

    @staticmethod
    def from_raw(raw: int, uint8_t precision) -> Price:
        """
        Return a price from the given `raw` fixed-point integer and `precision`.

        Handles up to 16 decimals of precision (in high-precision mode).

        Parameters
        ----------
        raw : int
            The raw fixed-point price value.
        precision : uint8_t
            The precision for the price. Use a precision of 0 for whole numbers
            (no fractional units).

        Returns
        -------
        Price

        Raises
        ------
        ValueError
            If `precision` is greater than 16.
        OverflowError
            If `precision` is negative (< 0).

        Warnings
        --------
        Small `raw` values can produce a zero price depending on the `precision`.

        """
        if precision > FIXED_PRECISION:
            raise ValueError(
                f"invalid `precision` greater than max {FIXED_PRECISION}, was {precision}"
            )
        return Price.from_raw_c(raw, precision)

    @staticmethod
    def from_str(str value) -> Price:
        """
        Return a price parsed from the given string.

        Handles up to 16 decimals of precision (in high-precision mode).

        Parameters
        ----------
        value : str
            The value to parse.

        Returns
        -------
        Price

        Warnings
        --------
        The decimal precision will be inferred from the number of digits
        following the '.' point (if no point then precision zero).

        Raises
        ------
        ValueError
            If inferred precision is greater than 16.
        ValueError
            If raw value is outside the valid representable range [`PRICE_RAW_MIN`, `PRICE_RAW_MAX`].
        OverflowError
            If inferred precision is negative (< 0).

        """
        Condition.not_none(value, "value")

        return Price.from_str_c(value)

    @staticmethod
    def from_int(value: int) -> Price:
        """
        Return a price from the given integer value.

        A precision of zero will be inferred.

        Parameters
        ----------
        value : int
            The value for the price.

        Returns
        -------
        Price

        """
        Condition.not_none(value, "value")

        return Price.from_int_c(value)

    @staticmethod
    def from_decimal(value: decimal.Decimal) -> Price:
        """
        Return a price from the given Decimal value.

        Handles up to 16 decimals of precision (in high-precision mode).

        Parameters
        ----------
        value : Decimal
            The Decimal value for the price.

        Returns
        -------
        Price

        Raises
        ------
        ValueError
            If inferred precision is greater than 16.
        ValueError
            If raw value is outside the valid representable range [`PRICE_RAW_MIN`, `PRICE_RAW_MAX`].
        OverflowError
            If inferred precision is negative (< 0).

        Warnings
        --------
        The decimal precision will be inferred from the number of digits
        following the '.' point (if no point then precision zero).

        """
        Condition.not_none(value, "value")

        return Price.from_str_c(str(value))

    cpdef str to_formatted_str(self):
        """
        Return the formatted string representation of the price.

        Returns
        -------
        str

        """
        return f"{self.as_decimal():,.{self._mem.precision}f}".replace(",", "_")

    cpdef object as_decimal(self):
        """
        Return the value as a built-in `Decimal`.

        Returns
        -------
        Decimal

        """
        raw_decimal = decimal.Decimal(self._mem.raw)
        return raw_decimal / FIXED_DECIMAL_SCALE

    cpdef double as_double(self):
        """
        Return the value as a `double`.

        Returns
        -------
        double

        """
        return self.as_f64_c()


cdef class Money:
    """
    Represents an amount of money in a specified currency denomination.

    - ``MONEY_MAX`` = 17_014_118_346_046
    - ``MONEY_MIN`` = -17_014_118_346_046

    Parameters
    ----------
    value : integer, float, string or Decimal
        The amount of money in the currency denomination.
    currency : Currency
        The currency of the money.

    Raises
    ------
    ValueError
        If `value` is greater than 17_014_118_346_046.
    ValueError
        If `value` is less than -17_014_118_346_046.
    """

    def __init__(self, value, Currency currency not None) -> None:
        cdef double value_f64 = 0.0 if value is None else float(value)

        if isnan(value_f64):
            raise ValueError(
                f"invalid `value`, was {value:_}",
            )
        if value_f64 > RUST_MONEY_MAX:
            raise ValueError(
                f"invalid `value` greater than `MONEY_MAX` {RUST_MONEY_MAX:_}, was {value:_}",
            )
        if value_f64 < RUST_MONEY_MIN:
            raise ValueError(
                f"invalid `value` less than `MONEY_MIN` {RUST_MONEY_MIN:_}, was {value:_}",
            )

        self._mem = money_new(value_f64, currency._mem)

    def __getstate__(self):
        return self._mem.raw, self.currency_code_c()

    def __setstate__(self, state):
        cdef Currency currency = Currency.from_str_c(state[1])
        self._mem = money_from_raw(state[0], currency._mem)

    def __eq__(self, Money other) -> bool:
        if other is None:
            return False
        if self._mem.currency.code != other._mem.currency.code:
            Condition.is_true(self._mem.currency.code == other._mem.currency.code, f"currency {self.currency.code} != other.currency {other.currency.code}")
        return self._mem.raw == other._mem.raw

    def __lt__(self, Money other) -> bool:
        if other is None:
            return NotImplemented
        Condition.is_true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
        return self._mem.raw < other._mem.raw

    def __le__(self, Money other) -> bool:
        if other is None:
            return NotImplemented
        Condition.is_true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
        return self._mem.raw <= other._mem.raw

    def __gt__(self, Money other) -> bool:
        if other is None:
            return NotImplemented
        Condition.is_true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
        return self._mem.raw > other._mem.raw

    def __ge__(self, Money other) -> bool:
        if other is None:
            return NotImplemented
        Condition.is_true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
        return self._mem.raw >= other._mem.raw

    def __add__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) + float(b)
        return Money._extract_decimal(a) + Money._extract_decimal(b)

    def __radd__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) + float(b)
        return Money._extract_decimal(a) + Money._extract_decimal(b)

    def __sub__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) - float(b)
        return Money._extract_decimal(a) - Money._extract_decimal(b)

    def __rsub__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) - float(b)
        return Money._extract_decimal(a) - Money._extract_decimal(b)

    def __mul__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) * float(b)
        return Money._extract_decimal(a) * Money._extract_decimal(b)

    def __rmul__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) * float(b)
        return Money._extract_decimal(a) * Money._extract_decimal(b)

    def __truediv__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) / float(b)
        return Money._extract_decimal(a) / Money._extract_decimal(b)

    def __rtruediv__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) / float(b)
        return Money._extract_decimal(a) / Money._extract_decimal(b)

    def __floordiv__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) // float(b)
        return Money._extract_decimal(a) // Money._extract_decimal(b)

    def __rfloordiv__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) // float(b)
        return Money._extract_decimal(a) // Money._extract_decimal(b)

    def __mod__(a, b) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) % float(b)
        return Money._extract_decimal(a) % Money._extract_decimal(b)

    def __rmod__(b, a) -> decimal.Decimal | float:
        if isinstance(a, float) or isinstance(b, float):
            return float(a) % float(b)
        return Money._extract_decimal(a) % Money._extract_decimal(b)

    def __neg__(self) -> decimal.Decimal:
        return self.as_decimal().__neg__()

    def __pos__(self) -> decimal.Decimal:
        return self.as_decimal().__pos__()

    def __abs__(self) -> decimal.Decimal:
        return abs(self.as_decimal())

    def __round__(self, ndigits = None) -> decimal.Decimal:
        return round(self.as_decimal(), ndigits)

    def __float__(self) -> float:
        return self.as_f64_c()

    def __int__(self) -> int:
        return int(self.as_decimal())

    def __hash__(self) -> int:
        return hash((self._mem.raw, self.currency_code_c()))

    def __str__(self) -> str:
        return f"{self.as_decimal():.{self._mem.currency.precision}f} {self.currency_code_c()}"

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self.as_decimal():.{self._mem.currency.precision}f}, {self.currency_code_c()})"

    @property
    def raw(self) -> MoneyRaw:
        """
        Return the raw memory representation of the money amount.

        Returns
        -------
        int

        """
        return self._mem.raw

    @property
    def currency(self) -> Currency:
        """
        Return the currency for the money.

        Returns
        -------
        Currency

        """
        return Currency.from_str_c(self.currency_code_c())

    @staticmethod
    cdef double raw_to_f64_c(MoneyRaw raw):
        return raw / RUST_FIXED_SCALAR

    @staticmethod
    cdef Money from_raw_c(MoneyRaw raw, Currency currency):
        cdef Money money = Money.__new__(Money)
        money._mem = money_from_raw(raw, currency._mem)
        return money

    @staticmethod
    cdef object _extract_decimal(object obj):
        assert not isinstance(obj, float)  # Design-time error
        if hasattr(obj, "as_decimal"):
            return obj.as_decimal()
        else:
            return decimal.Decimal(obj)

    @staticmethod
    cdef Money from_str_c(str value):
        cdef list pieces = value.split(' ', maxsplit=1)

        if len(pieces) != 2:
            raise ValueError(f"The `Money` string value was malformed, was {value}")

        amount_str = pieces[0].replace('_', '')

        cdef Currency currency = Currency.from_str_c(pieces[1])
        cdef uint8_t precision = currency._mem.precision
        decimal_value = decimal.Decimal(amount_str)
        scaled = decimal_value * (10 ** precision)
        integral = scaled.to_integral_value(rounding=decimal.ROUND_HALF_EVEN)

        raw_py = int(integral) * (10 ** (FIXED_PRECISION - precision))
        if raw_py < MONEY_RAW_MIN or raw_py > MONEY_RAW_MAX:
            raise ValueError(
                f"invalid raw money value outside range [{MONEY_RAW_MIN}, {MONEY_RAW_MAX}], was {raw_py}"
            )

        cdef MoneyRaw raw = <MoneyRaw>(raw_py)
        return Money.from_raw_c(raw, currency)

    cdef str currency_code_c(self):
        return cstr_to_pystr(currency_code_to_cstr(&self._mem.currency))

    cdef bint is_zero(self):
        return self._mem.raw == 0

    cdef bint is_negative(self):
        return self._mem.raw < 0

    cdef bint is_positive(self):
        return self._mem.raw > 0

    cdef Money add(self, Money other):
        Condition.not_none(other, "other")
        Condition.is_true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
        return Money.from_raw_c(self._mem.raw + other._mem.raw, self.currency)

    cdef Money sub(self, Money other):
        Condition.not_none(other, "other")
        Condition.is_true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
        return Money.from_raw_c(self._mem.raw - other._mem.raw, self.currency)

    cdef void add_assign(self, Money other):
        Condition.not_none(other, "other")
        Condition.is_true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
        self._mem.raw += other._mem.raw

    cdef void sub_assign(self, Money other):
        Condition.not_none(other, "other")
        Condition.is_true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
        self._mem.raw -= other._mem.raw

    cdef MoneyRaw raw_int_c(self):
        return self._mem.raw

    cdef double as_f64_c(self):
        return self._mem.raw / RUST_FIXED_SCALAR

    @staticmethod
    def from_raw(raw: int, Currency currency) -> Money:
        """
        Return money from the given `raw` fixed-point integer and `currency`.

        Parameters
        ----------
        raw : int
            The raw fixed-point money amount.
        currency : Currency
            The currency of the money.

        Returns
        -------
        Money

        Warnings
        --------
        Small `raw` values can produce a zero money amount depending on the precision of the currency.

        """
        Condition.not_none(currency, "currency")
        return Money.from_raw_c(raw, currency)

    @staticmethod
    def from_str(str value) -> Money:
        """
        Return money parsed from the given string.

        Must be correctly formatted with a value and currency separated by a
        whitespace delimiter.

        Example: "1000000.00 USD".

        Parameters
        ----------
        value : str
            The value to parse.

        Returns
        -------
        Money

        Raises
        ------
        ValueError
            If inferred currency precision is greater than 16.
        ValueError
            If raw value is outside the valid representable range [`MONEY_RAW_MIN`, `MONEY_RAW_MAX`].
        OverflowError
            If inferred currency precision is negative (< 0).

        """
        Condition.not_none(value, "value")

        cdef tuple pieces = value.partition(' ')

        if len(pieces) != 3:
            raise ValueError(f"The `Money` string value was malformed, was {value}")

        return Money.from_str_c(value)

    @staticmethod
    def from_decimal(amount: decimal.Decimal, Currency currency not None) -> Money:
        """
        Return money from the given Decimal amount and currency.

        Handles up to 16 decimals of precision (in high-precision mode).

        Parameters
        ----------
        amount : Decimal
            The Decimal amount for the money.
        currency : Currency
            The currency of the money.

        Returns
        -------
        Money

        Raises
        ------
        ValueError
            If inferred currency precision is greater than 16.
        ValueError
            If raw value is outside the valid representable range [`MONEY_RAW_MIN`, `MONEY_RAW_MAX`].
        OverflowError
            If inferred currency precision is negative (< 0).

        Warnings
        --------
        The decimal precision will be inferred from the number of digits
        following the '.' point (if no point then precision zero).

        """
        Condition.not_none(amount, "amount")
        Condition.not_none(currency, "currency")

        return Money.from_str_c(f"{amount} {currency.code}")

    cpdef str to_formatted_str(self):
        """
        Return the formatted string representation of the money.

        Returns
        -------
        str

        """
        return f"{self.as_decimal():,.{self._mem.currency.precision}f} {self.currency_code_c()}".replace(",", "_")

    cpdef object as_decimal(self):
        """
        Return the value as a built-in `Decimal`.

        Returns
        -------
        Decimal

        """
        raw_decimal = decimal.Decimal(self._mem.raw)
        return raw_decimal / FIXED_DECIMAL_SCALE

    cpdef double as_double(self):
        """
        Return the value as a `double`.

        Returns
        -------
        double

        """
        return self.as_f64_c()


cdef class Currency:
    """
    Represents a medium of exchange in a specified denomination with a fixed
    decimal precision.

    Handles up to 16 decimals of precision (in high-precision mode).

    Parameters
    ----------
    code : str
        The currency code.
    precision : uint8_t
        The currency decimal precision.
    iso4217 : uint16
        The currency ISO 4217 code.
    name : str
        The currency name.
    currency_type : CurrencyType
        The currency type.

    Raises
    ------
    ValueError
        If `code` is not a valid string.
    OverflowError
        If `precision` is negative (< 0).
    ValueError
        If `precision` greater than 16.
    ValueError
        If `name` is not a valid string.
    """

    def __init__(
        self,
        str code,
        uint8_t precision,
        uint16_t iso4217,
        str name,
        CurrencyType currency_type,
    ) -> None:
        Condition.valid_string(code, "code")
        Condition.valid_string(name, "name")
        if precision > FIXED_PRECISION:
            raise ValueError(
                f"invalid `precision` greater than max {FIXED_PRECISION}, was {precision}"
            )

        self._mem = currency_from_py(
            pystr_to_cstr(code),
            precision,
            iso4217,
            pystr_to_cstr(name),
            currency_type,
        )

    def __getstate__(self):
        return (
            self.code,
            self._mem.precision,
            self._mem.iso4217,
            self.name,
            <CurrencyType>self._mem.currency_type,
        )

    def __setstate__(self, state):
        self._mem = currency_from_py(
            pystr_to_cstr(state[0]),
            state[1],
            state[2],
            pystr_to_cstr(state[3]),
            state[4],
        )

    def __eq__(self, Currency other) -> bool:
        if other is None:
            return False
        return strcmp(self._mem.code, other._mem.code) == 0

    def __hash__(self) -> int:
        return currency_hash(&self._mem)

    def __str__(self) -> str:
        return ustr_to_pystr(self._mem.code)

    def __repr__(self) -> str:
        return cstr_to_pystr(currency_to_cstr(&self._mem))

    @property
    def code(self) -> str:
        """
        Return the currency code.

        Returns
        -------
        str

        """
        return ustr_to_pystr(self._mem.code)

    @property
    def name(self) -> str:
        """
        Return the currency name.

        Returns
        -------
        str

        """
        return ustr_to_pystr(self._mem.name)

    @property
    def precision(self) -> int:
        """
        Return the currency decimal precision.

        Returns
        -------
        uint8

        """
        return self._mem.precision

    @property
    def iso4217(self) -> int:
        """
        Return the currency ISO 4217 code.

        Returns
        -------
        str

        """
        return self._mem.iso4217

    @property
    def currency_type(self) -> CurrencyType:
        """
        Return the currency type.

        Returns
        -------
        CurrencyType

        """
        return <CurrencyType>self._mem.currency_type

    cdef uint8_t get_precision(self):
        return self._mem.precision

    @staticmethod
    cdef void register_c(Currency currency, bint overwrite=False):
        cdef Currency existing = Currency.from_internal_map_c(currency.code)
        if existing is not None and not overwrite:
            return  # Already exists in internal map
        currency_register(currency._mem)

    @staticmethod
    cdef Currency from_internal_map_c(str code):
        cdef const char* code_ptr = pystr_to_cstr(code)
        if not currency_exists(code_ptr):
            return None
        cdef Currency currency = Currency.__new__(Currency)
        currency._mem = currency_from_cstr(code_ptr)
        return currency

    @staticmethod
    cdef Currency from_str_c(str code, bint strict=False):
        cdef Currency currency = Currency.from_internal_map_c(code)
        if currency is not None:
            return currency
        if strict:
            return None

        # Strict mode false with no currency found (very likely a crypto)
        currency = Currency(
            code=code,
            precision=8,
            iso4217=0,
            name=code,
            currency_type=CurrencyType.CRYPTO,
        )
        currency_register(currency._mem)

        return currency

    @staticmethod
    cdef bint is_fiat_c(str code):
        cdef Currency currency = Currency.from_internal_map_c(code)
        if currency is None:
            return False

        return <CurrencyType>currency._mem.currency_type == CurrencyType.FIAT

    @staticmethod
    cdef bint is_crypto_c(str code):
        cdef Currency currency = Currency.from_internal_map_c(code)
        if currency is None:
            return False

        return <CurrencyType>currency._mem.currency_type == CurrencyType.CRYPTO

    @staticmethod
    def register(Currency currency, bint overwrite=False):
        """
        Register the given `currency`.

        Will override the internal currency map.

        Parameters
        ----------
        currency : Currency
            The currency to register
        overwrite : bool
            If the currency in the internal currency map should be overwritten.

        """
        Condition.not_none(currency, "currency")

        return Currency.register_c(currency, overwrite)

    @staticmethod
    def from_internal_map(str code):
        """
        Return the currency with the given `code` from the built-in internal map (if found).

        Parameters
        ----------
        code : str
            The code of the currency.

        Returns
        -------
        Currency or ``None``

        """
        Condition.not_none(code, "code")

        return Currency.from_internal_map_c(code)

    @staticmethod
    def from_str(str code, bint strict=False):
        """
        Parse a currency from the given string (if found).

        Parameters
        ----------
        code : str
            The code of the currency.
        strict : bool, default False
            If not `strict` mode then an unknown currency will very likely
            be a Cryptocurrency, so for robustness will then return a new
            `Currency` object using the given `code` with a default `precision` of 8.

        Returns
        -------
        Currency or ``None``

        """
        return Currency.from_str_c(code, strict)

    @staticmethod
    def is_fiat(str code):
        """
        Return whether a currency with the given code is ``FIAT``.

        Parameters
        ----------
        code : str
            The code of the currency.

        Returns
        -------
        bool
            True if ``FIAT``, else False.

        Raises
        ------
        ValueError
            If `code` is not a valid string.

        """
        Condition.valid_string(code, "code")

        return Currency.is_fiat_c(code)

    @staticmethod
    def is_crypto(str code):
        """
        Return whether a currency with the given code is ``CRYPTO``.

        Parameters
        ----------
        code : str
            The code of the currency.

        Returns
        -------
        bool
            True if ``CRYPTO``, else False.

        Raises
        ------
        ValueError
            If `code` is not a valid string.

        """
        Condition.valid_string(code, "code")

        return Currency.is_crypto_c(code)


cdef class AccountBalance:
    """
    Represents an account balance denominated in a particular currency.

    Parameters
    ----------
    total : Money
        The total account balance.
    locked : Money
        The account balance locked (assigned to pending orders).
    free : Money
        The account balance free for trading.

    Raises
    ------
    ValueError
        If money currencies are not equal.
    ValueError
        If `total` - `locked` != `free`.
    """

    def __init__(
        self,
        Money total not None,
        Money locked not None,
        Money free not None,
    ) -> None:
        Condition.equal(total.currency, locked.currency, "total.currency", "locked.currency")
        Condition.equal(total.currency, free.currency, "total.currency", "free.currency")
        Condition.is_true(total.raw_int_c() - locked.raw_int_c() == free.raw_int_c(), f"`total` ({total}) - `locked` ({locked}) != `free` ({free})")

        self.total = total
        self.locked = locked
        self.free = free
        self.currency = total.currency

    def __eq__(self, AccountBalance other) -> bool:
        if other is None:
            return False
        return (
            self.total == other.total
            and self.locked == other.locked
            and self.free == other.free
        )

    def __hash__(self) -> int:
        return hash((self.total, self.locked, self.free))

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"total={self.total.to_formatted_str()}, "
            f"locked={self.locked.to_formatted_str()}, "
            f"free={self.free.to_formatted_str()})"
        )

    @staticmethod
    cdef AccountBalance from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef Currency currency = Currency.from_str_c(values["currency"])
        return AccountBalance(
            total=Money(values["total"], currency),
            locked=Money(values["locked"], currency),
            free=Money(values["free"], currency),
        )

    @staticmethod
    def from_dict(dict values) -> AccountBalance:
        """
        Return an account balance from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        AccountBalance

        """
        return AccountBalance.from_dict_c(values)

    cpdef AccountBalance copy(self):
        """
        Return a copy of this account balance.

        Returns
        -------
        AccountBalance

        """
        return AccountBalance(
            total=self.total,
            locked=self.locked,
            free=self.free,
        )

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return {
            "type": type(self).__name__,
            "total": f"{self.total.as_decimal():.{self.currency.precision}f}",
            "locked": f"{self.locked.as_decimal():.{self.currency.precision}f}",
            "free": f"{self.free.as_decimal():.{self.currency.precision}f}",
            "currency": self.currency.code,
        }


cdef class MarginBalance:
    """
    Represents a margin balance optionally associated with a particular instrument.

    Parameters
    ----------
    initial : Money
        The initial (order) margin requirement for the instrument.
    maintenance : Money
        The maintenance (position) margin requirement for the instrument.
    instrument_id : InstrumentId, optional
        The instrument ID associated with the margin.

    Raises
    ------
    ValueError
        If `margin_init` currency does not equal `currency`.
    ValueError
        If `margin_maint` currency does not equal `currency`.
    ValueError
        If any margin is negative (< 0).
    """

    def __init__(
        self,
        Money initial not None,
        Money maintenance not None,
        InstrumentId instrument_id = None,
    ) -> None:
        Condition.equal(initial.currency, maintenance.currency, "initial.currency", "maintenance.currency")
        Condition.is_true(initial.raw_int_c() >= 0, f"initial margin was negative ({initial})")
        Condition.is_true(maintenance.raw_int_c() >= 0, f"maintenance margin was negative ({maintenance})")

        self.initial = initial
        self.maintenance = maintenance
        self.currency = initial.currency
        self.instrument_id = instrument_id

    def __eq__(self, MarginBalance other) -> bool:
        if other is None:
            return False
        return (
            self.initial == other.initial
            and self.maintenance == other.maintenance
            and self.instrument_id == other.instrument_id
        )

    def __hash__(self) -> int:
        return hash((self.initial, self.maintenance, self.instrument_id))

    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"initial={self.initial.to_formatted_str()}, "
            f"maintenance={self.maintenance.to_formatted_str()}, "
            f"instrument_id={self.instrument_id.to_str() if self.instrument_id is not None else None})"
        )

    @staticmethod
    cdef MarginBalance from_dict_c(dict values):
        Condition.not_none(values, "values")
        cdef Currency currency = Currency.from_str_c(values["currency"])
        cdef str instrument_id_str = values.get("instrument_id")
        return MarginBalance(
            initial=Money(values["initial"], currency),
            maintenance=Money(values["maintenance"], currency),
            instrument_id=InstrumentId.from_str_c(instrument_id_str) if instrument_id_str is not None else None,
        )

    @staticmethod
    def from_dict(dict values) -> MarginBalance:
        """
        Return a margin balance from the given dict values.

        Parameters
        ----------
        values : dict[str, object]
            The values for initialization.

        Returns
        -------
        MarginAccountBalance

        """
        return MarginBalance.from_dict_c(values)

    cpdef MarginBalance copy(self):
        """
        Return a copy of this margin balance.

        Returns
        -------
        MarginBalance

        """
        return MarginBalance(
            initial=self.initial,
            maintenance=self.maintenance,
            instrument_id=self.instrument_id,
        )

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return {
            "type": type(self).__name__,
            "initial": f"{self.initial.as_decimal():.{self.currency.precision}f}",
            "maintenance": f"{self.maintenance.as_decimal():.{self.currency.precision}f}",
            "currency": self.currency.code,
            "instrument_id": self.instrument_id.to_str() if self.instrument_id is not None else None,
        }

</document_content>
</document>
<document index="2450">
<source>nautilus_trader/model/orders/base.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.core import nautilus_pyo3

# This needs to be a Python import so it can used in the FSM
from nautilus_trader.model.enums import order_status_to_str

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport FIXED_SCALAR
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport LiquiditySide
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.core.rust.model cimport PriceRaw
from nautilus_trader.core.rust.model cimport QuantityRaw
from nautilus_trader.model.events.order cimport OrderAccepted
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderCancelRejected
from nautilus_trader.model.events.order cimport OrderDenied
from nautilus_trader.model.events.order cimport OrderEmulated
from nautilus_trader.model.events.order cimport OrderEvent
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderModifyRejected
from nautilus_trader.model.events.order cimport OrderPendingCancel
from nautilus_trader.model.events.order cimport OrderPendingUpdate
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderReleased
from nautilus_trader.model.events.order cimport OrderSubmitted
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport order_side_to_pyo3
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_status_to_pyo3
from nautilus_trader.model.functions cimport order_type_to_pyo3
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport position_side_to_str
from nautilus_trader.model.functions cimport time_in_force_to_pyo3
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.identifiers cimport TradeId
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Quantity


STOP_ORDER_TYPES = {
    OrderType.STOP_MARKET,
    OrderType.STOP_LIMIT,
    OrderType.MARKET_IF_TOUCHED,
    OrderType.LIMIT_IF_TOUCHED,
}

LIMIT_ORDER_TYPES = {
    OrderType.LIMIT,
    OrderType.STOP_LIMIT,
    OrderType.LIMIT_IF_TOUCHED,
    OrderType.MARKET_TO_LIMIT,
}

CANCELLABLE_ORDER_STATUSES = {
    OrderStatus.ACCEPTED,
    OrderStatus.TRIGGERED,
    OrderStatus.PENDING_UPDATE,
    OrderStatus.PARTIALLY_FILLED,
}

LOCAL_ACTIVE_ORDER_STATUSES =  {
    OrderStatus.INITIALIZED,
    OrderStatus.EMULATED,
    OrderStatus.RELEASED,
}

# OrderStatus being used as trigger
cdef dict _ORDER_STATE_TABLE = {
    (OrderStatus.INITIALIZED, OrderStatus.DENIED): OrderStatus.DENIED,
    (OrderStatus.INITIALIZED, OrderStatus.EMULATED): OrderStatus.EMULATED,  # Emulated orders
    (OrderStatus.INITIALIZED, OrderStatus.RELEASED): OrderStatus.RELEASED,  # Emulated orders
    (OrderStatus.INITIALIZED, OrderStatus.SUBMITTED): OrderStatus.SUBMITTED,
    (OrderStatus.INITIALIZED, OrderStatus.REJECTED): OrderStatus.REJECTED,  # External orders
    (OrderStatus.INITIALIZED, OrderStatus.ACCEPTED): OrderStatus.ACCEPTED,  # External orders
    (OrderStatus.INITIALIZED, OrderStatus.CANCELED): OrderStatus.CANCELED,  # External orders
    (OrderStatus.INITIALIZED, OrderStatus.EXPIRED): OrderStatus.EXPIRED,  # External orders
    (OrderStatus.INITIALIZED, OrderStatus.TRIGGERED): OrderStatus.TRIGGERED,  # External orders
    (OrderStatus.EMULATED, OrderStatus.CANCELED): OrderStatus.CANCELED,  # Emulated orders
    (OrderStatus.EMULATED, OrderStatus.EXPIRED): OrderStatus.EXPIRED,  # Emulated orders
    (OrderStatus.EMULATED, OrderStatus.RELEASED): OrderStatus.RELEASED,  # Emulated orders
    (OrderStatus.RELEASED, OrderStatus.DENIED): OrderStatus.DENIED,  # Emulated orders
    (OrderStatus.RELEASED, OrderStatus.SUBMITTED): OrderStatus.SUBMITTED,  # Emulated orders
    (OrderStatus.RELEASED, OrderStatus.CANCELED): OrderStatus.CANCELED,  # Execution Algo
    (OrderStatus.SUBMITTED, OrderStatus.PENDING_UPDATE): OrderStatus.PENDING_UPDATE,
    (OrderStatus.SUBMITTED, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,
    (OrderStatus.SUBMITTED, OrderStatus.REJECTED): OrderStatus.REJECTED,
    (OrderStatus.SUBMITTED, OrderStatus.CANCELED): OrderStatus.CANCELED,  # FOK and IOC cases
    (OrderStatus.SUBMITTED, OrderStatus.ACCEPTED): OrderStatus.ACCEPTED,
    (OrderStatus.SUBMITTED, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,
    (OrderStatus.SUBMITTED, OrderStatus.FILLED): OrderStatus.FILLED,
    (OrderStatus.ACCEPTED, OrderStatus.REJECTED): OrderStatus.REJECTED,  # StopLimit order
    (OrderStatus.ACCEPTED, OrderStatus.PENDING_UPDATE): OrderStatus.PENDING_UPDATE,
    (OrderStatus.ACCEPTED, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,
    (OrderStatus.ACCEPTED, OrderStatus.CANCELED): OrderStatus.CANCELED,
    (OrderStatus.ACCEPTED, OrderStatus.TRIGGERED): OrderStatus.TRIGGERED,
    (OrderStatus.ACCEPTED, OrderStatus.EXPIRED): OrderStatus.EXPIRED,
    (OrderStatus.ACCEPTED, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,
    (OrderStatus.ACCEPTED, OrderStatus.FILLED): OrderStatus.FILLED,
    (OrderStatus.CANCELED, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,  # Real world possibility
    (OrderStatus.CANCELED, OrderStatus.FILLED): OrderStatus.FILLED,  # Real world possibility
    (OrderStatus.PENDING_UPDATE, OrderStatus.REJECTED): OrderStatus.REJECTED,  # Real world possibility
    (OrderStatus.PENDING_UPDATE, OrderStatus.ACCEPTED): OrderStatus.ACCEPTED,
    (OrderStatus.PENDING_UPDATE, OrderStatus.CANCELED): OrderStatus.CANCELED,
    (OrderStatus.PENDING_UPDATE, OrderStatus.EXPIRED): OrderStatus.EXPIRED,
    (OrderStatus.PENDING_UPDATE, OrderStatus.TRIGGERED): OrderStatus.TRIGGERED,
    (OrderStatus.PENDING_UPDATE, OrderStatus.SUBMITTED): OrderStatus.PENDING_UPDATE,  # Real world possibility
    (OrderStatus.PENDING_UPDATE, OrderStatus.PENDING_UPDATE): OrderStatus.PENDING_UPDATE,  # Allow multiple requests
    (OrderStatus.PENDING_UPDATE, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,
    (OrderStatus.PENDING_UPDATE, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,
    (OrderStatus.PENDING_UPDATE, OrderStatus.FILLED): OrderStatus.FILLED,
    (OrderStatus.PENDING_CANCEL, OrderStatus.REJECTED): OrderStatus.REJECTED,  # Real world possibility
    (OrderStatus.PENDING_CANCEL, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,  # Allow multiple requests
    (OrderStatus.PENDING_CANCEL, OrderStatus.CANCELED): OrderStatus.CANCELED,
    (OrderStatus.PENDING_CANCEL, OrderStatus.EXPIRED): OrderStatus.EXPIRED,
    (OrderStatus.PENDING_CANCEL, OrderStatus.ACCEPTED): OrderStatus.ACCEPTED,  # Allows failed cancel requests
    (OrderStatus.PENDING_CANCEL, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,
    (OrderStatus.PENDING_CANCEL, OrderStatus.FILLED): OrderStatus.FILLED,
    (OrderStatus.TRIGGERED, OrderStatus.REJECTED): OrderStatus.REJECTED,
    (OrderStatus.TRIGGERED, OrderStatus.PENDING_UPDATE): OrderStatus.PENDING_UPDATE,
    (OrderStatus.TRIGGERED, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,
    (OrderStatus.TRIGGERED, OrderStatus.CANCELED): OrderStatus.CANCELED,
    (OrderStatus.TRIGGERED, OrderStatus.EXPIRED): OrderStatus.EXPIRED,
    (OrderStatus.TRIGGERED, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,
    (OrderStatus.TRIGGERED, OrderStatus.FILLED): OrderStatus.FILLED,
    (OrderStatus.PARTIALLY_FILLED, OrderStatus.PENDING_UPDATE): OrderStatus.PENDING_UPDATE,
    (OrderStatus.PARTIALLY_FILLED, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,
    (OrderStatus.PARTIALLY_FILLED, OrderStatus.CANCELED): OrderStatus.CANCELED,
    (OrderStatus.PARTIALLY_FILLED, OrderStatus.EXPIRED): OrderStatus.EXPIRED,
    (OrderStatus.PARTIALLY_FILLED, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,
    (OrderStatus.PARTIALLY_FILLED, OrderStatus.FILLED): OrderStatus.FILLED,
}


cdef class Order:
    """
    The base class for all orders.

    Parameters
    ----------
    init : OrderInitialized
        The order initialized event.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(self, OrderInitialized init not None):
        Condition.positive(init.quantity, "init.quantity")

        self._events: list[OrderEvent] = [init]
        self._venue_order_ids: list[VenueOrderId] = []
        self._trade_ids: list[TradeId] = []
        self._commissions: dict[Currency, Money] = {}
        self._fsm = FiniteStateMachine(
            state_transition_table=_ORDER_STATE_TABLE,
            initial_state=OrderStatus.INITIALIZED,
            trigger_parser=order_status_to_str,
            state_parser=order_status_to_str,
        )
        self._previous_status = OrderStatus.INITIALIZED
        self._triggered_price = None  # Can be None

        # Identifiers
        self.trader_id = init.trader_id
        self.strategy_id = init.strategy_id
        self.instrument_id = init.instrument_id
        self.client_order_id = init.client_order_id
        self.venue_order_id = None  # Can be None
        self.position_id = None  # Can be None
        self.account_id = None  # Can be None
        self.last_trade_id = None  # Can be None

        # Properties
        self.side = init.side
        self.order_type = init.order_type
        self.quantity = init.quantity
        self.time_in_force = init.time_in_force
        self.liquidity_side = LiquiditySide.NO_LIQUIDITY_SIDE
        self.is_post_only = init.post_only
        self.is_reduce_only = init.reduce_only
        self.is_quote_quantity = init.quote_quantity
        self.emulation_trigger = init.emulation_trigger
        self.trigger_instrument_id = init.trigger_instrument_id
        self.contingency_type = init.contingency_type
        self.order_list_id = init.order_list_id  # Can be None
        self.linked_order_ids = init.linked_order_ids  # Can be None
        self.parent_order_id = init.parent_order_id  # Can be None
        self.exec_algorithm_id = init.exec_algorithm_id  # Can be None
        self.exec_algorithm_params = init.exec_algorithm_params  # Can be None
        self.exec_spawn_id = init.exec_spawn_id  # Can be None
        self.tags = init.tags

        # Execution
        self.filled_qty = Quantity.zero_c(self.quantity._mem.precision)
        self.leaves_qty = init.quantity
        self.overfill_qty = Quantity.zero_c(self.quantity._mem.precision)
        self.avg_px = 0.0  # No fills yet
        self.slippage = 0.0

        # Timestamps
        self.init_id = init.id
        self.ts_init = init.ts_init
        self.ts_submitted = 0
        self.ts_accepted = 0
        self.ts_closed = 0
        self.ts_last = init.ts_init

    def __eq__(self, Order other) -> bool:
        if other is None:
            return False
        return self.client_order_id == other.client_order_id

    def __hash__(self) -> int:
        return hash(self.client_order_id)

    def __repr__(self) -> str:
        cdef ClientOrderId coi
        cdef str contingency_str = "" if self.contingency_type == ContingencyType.NO_CONTINGENCY else f", contingency_type={contingency_type_to_str(self.contingency_type)}"
        cdef str linked_order_ids_str = "" if self.linked_order_ids is None else f", linked_order_ids=[{', '.join([coi.to_str() for coi in self.linked_order_ids])}]" if self.linked_order_ids is not None else None  # noqa
        cdef str parent_order_id_str = "" if self.parent_order_id is None else f", parent_order_id={self.parent_order_id.to_str()}"
        cdef str exec_algorithm_id_str = "" if self.exec_algorithm_id is None else f", exec_algorithm_id={self.exec_algorithm_id.to_str()}"
        cdef str exec_algorithm_params_str = "" if self.exec_algorithm_params is None else f", exec_algorithm_params={self.exec_algorithm_params}"
        cdef str exec_spawn_id_str = "" if self.exec_spawn_id is None else f", exec_spawn_id={self.exec_spawn_id.to_str()}"
        return (
            f"{type(self).__name__}("
            f"{self.info()}, "
            f"status={self._fsm.state_string_c()}, "
            f"client_order_id={self.client_order_id.to_str()}, "
            f"venue_order_id={self.venue_order_id}, "  # Can be None (no whitespace before contingency_str)
            f"position_id={self.position_id}"  # Can be None (no whitespace before contingency_str)
            f"{contingency_str}"
            f"{linked_order_ids_str}"
            f"{parent_order_id_str}"
            f"{exec_algorithm_id_str}"
            f"{exec_algorithm_params_str}"
            f"{exec_spawn_id_str}"
            f", tags={self.tags})"
        )

    cpdef str status_string(self):
        """
        Return the orders current status as a string.

        Returns
        -------
        str

        """
        return self.status_string_c()

    cpdef str side_string(self):
        """
        Return the orders side as a string.

        Returns
        -------
        str

        """
        return self.side_string_c()

    cpdef str type_string(self):
        """
        Return the orders type as a string.

        Returns
        -------
        str

        """
        return self.type_string_c()

    cpdef str tif_string(self):
        """
        Return the orders time in force as a string.

        Returns
        -------
        str

        """
        return self.tif_string_c()

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        raise NotImplementedError("method `info` must be implemented in the subclass")  # pragma: no cover

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        raise NotImplementedError("method `to_dict` must be implemented in the subclass")  # pragma: no cover

    cpdef void set_quote_quantity(self, bint value):
        self.is_quote_quantity = value

    cdef void set_activated_c(self, Price activation_price):
        raise NotImplementedError("method `set_activated` must be implemented in the subclass")  # pragma: no cover

    cdef void set_triggered_price_c(self, Price triggered_price):
        Condition.not_none(triggered_price, "triggered_price")
        self._triggered_price = triggered_price

    cdef Price get_triggered_price_c(self):
        return self._triggered_price

    cdef OrderStatus status_c(self):
        return <OrderStatus>self._fsm.state

    cdef OrderInitialized init_event_c(self):
        return self._events[0]  # Guaranteed to contain the initialized event

    cdef OrderEvent last_event_c(self):
        return self._events[-1]  # Guaranteed to contain the initialized event

    cdef list events_c(self):
        return self._events.copy()

    cdef list venue_order_ids_c(self):
        return self._venue_order_ids.copy()

    cdef list trade_ids_c(self):
        return self._trade_ids.copy()

    cdef int event_count_c(self):
        return len(self._events)

    cdef str status_string_c(self):
        return self._fsm.state_string_c()

    cdef str type_string_c(self):
        return order_type_to_str(self.order_type)

    cdef str side_string_c(self):
        return order_side_to_str(self.side)

    cdef str tif_string_c(self):
        return time_in_force_to_str(self.time_in_force)

    cdef bint has_price_c(self):
        raise NotImplementedError("method `has_price_c` must be implemented in subclass")  # pragma: no cover

    cdef bint has_activation_price_c(self):
        return False

    cdef bint has_trigger_price_c(self):
        raise NotImplementedError("method `has_trigger_price_c` must be implemented in subclass")  # pragma: no cover

    cdef bint is_buy_c(self):
        return self.side == OrderSide.BUY

    cdef bint is_sell_c(self):
        return self.side == OrderSide.SELL

    cdef bint is_passive_c(self):
        return self.order_type != OrderType.MARKET

    cdef bint is_aggressive_c(self):
        return self.order_type == OrderType.MARKET

    cdef bint is_emulated_c(self):
        return self._fsm.state == OrderStatus.EMULATED

    cdef bint is_active_local_c(self):
        return self._fsm.state in LOCAL_ACTIVE_ORDER_STATUSES

    cdef bint is_primary_c(self):
        return self.exec_algorithm_id is not None and self.exec_spawn_id == self.client_order_id

    cdef bint is_spawned_c(self):
        return self.exec_algorithm_id is not None and self.exec_spawn_id != self.client_order_id

    cdef bint is_contingency_c(self):
        return self.contingency_type != ContingencyType.NO_CONTINGENCY

    cdef bint is_parent_order_c(self):
        return self.contingency_type == ContingencyType.OTO

    cdef bint is_child_order_c(self):
        return self.parent_order_id is not None

    cdef bint is_open_c(self):
        if self.emulation_trigger != TriggerType.NO_TRIGGER:
            return False
        return (
            self._fsm.state == OrderStatus.ACCEPTED
            or self._fsm.state == OrderStatus.TRIGGERED
            or self._fsm.state == OrderStatus.PENDING_CANCEL
            or self._fsm.state == OrderStatus.PENDING_UPDATE
            or self._fsm.state == OrderStatus.PARTIALLY_FILLED
        )

    cdef bint is_canceled_c(self):
        return self._fsm.state == OrderStatus.CANCELED

    cdef bint is_closed_c(self):
        return (
            self._fsm.state == OrderStatus.DENIED
            or self._fsm.state == OrderStatus.REJECTED
            or self._fsm.state == OrderStatus.CANCELED
            or self._fsm.state == OrderStatus.EXPIRED
            or self._fsm.state == OrderStatus.FILLED
        )

    cdef bint is_inflight_c(self):
        return (
            self._fsm.state == OrderStatus.SUBMITTED
            or self._fsm.state == OrderStatus.PENDING_CANCEL
            or self._fsm.state == OrderStatus.PENDING_UPDATE
        )

    cdef bint is_pending_update_c(self):
        return self._fsm.state == OrderStatus.PENDING_UPDATE

    cdef bint is_pending_cancel_c(self):
        return self._fsm.state == OrderStatus.PENDING_CANCEL

    def to_own_book_order(self) -> nautilus_pyo3.OwnBookOrder:
        """
        Returns an own/user order representation of this order.

        Returns
        -------
        nautilus_pyo3.OwnBookOrder

        """
        if not self.has_price_c():
            raise TypeError(f"Cannot initialize {self.type_string_c()} order as `nautilus_pyo3.OwnBookOrder`, no price")

        cdef Price price = self.price
        return nautilus_pyo3.OwnBookOrder(
            trader_id=nautilus_pyo3.TraderId(self.trader_id.value),
            client_order_id=nautilus_pyo3.ClientOrderId(self.client_order_id.value),
            venue_order_id=nautilus_pyo3.VenueOrderId(self.venue_order_id.value) if self.venue_order_id else None,
            side=order_side_to_pyo3(self.side),
            price=nautilus_pyo3.Price(price.as_f64_c(), price._mem.precision),
            size=nautilus_pyo3.Quantity(self.leaves_qty.as_f64_c(), self.leaves_qty._mem.precision),
            order_type=order_type_to_pyo3(self.order_type),
            time_in_force=time_in_force_to_pyo3(self.time_in_force),
            status=order_status_to_pyo3(<OrderStatus>self._fsm.state),
            ts_last=self.ts_last,
            ts_accepted=self.ts_accepted,
            ts_submitted=self.ts_submitted,
            ts_init=self.ts_init,
        )

    @property
    def symbol(self):
        """
        Return the orders ticker symbol.

        Returns
        -------
        Symbol

        """
        return self.instrument_id.symbol

    @property
    def venue(self):
        """
        Return the orders trading venue.

        Returns
        -------
        Venue

        """
        return self.instrument_id.venue

    @property
    def status(self):
        """
        Return the orders current status.

        Returns
        -------
        OrderStatus

        """
        return self.status_c()

    @property
    def init_event(self):
        """
        Return the initialization event for the order.

        Returns
        -------
        OrderInitialized

        """
        return self.init_event_c()

    @property
    def last_event(self):
        """
        Return the last event applied to the order.

        Returns
        -------
        OrderEvent

        """
        return self.last_event_c()

    @property
    def events(self):
        """
        Return the order events.

        Returns
        -------
        list[OrderEvent]

        """
        return self.events_c()

    @property
    def venue_order_ids(self):
        """
        Return the venue order IDs.

        Returns
        -------
        list[VenueOrderId]

        """
        return self.venue_order_ids_c().copy()

    @property
    def trade_ids(self):
        """
        Return the trade match IDs.

        Returns
        -------
        list[TradeId]

        """
        return self.trade_ids_c()

    @property
    def event_count(self):
        """
        Return the count of events applied to the order.

        Returns
        -------
        int

        """
        return self.event_count_c()

    @property
    def has_price(self):
        """
        Return whether the order has a `price` property.

        Returns
        -------
        bool

        """
        return self.has_price_c()

    @property
    def has_trigger_price(self):
        """
        Return whether the order has a `trigger_price` property.

        Returns
        -------
        bool

        """
        return self.has_trigger_price_c()

    @property
    def has_activation_price(self):
        """
        Return whether the order has a `activation_price` property.

        Returns
        -------
        bool

        """
        return self.has_activation_price_c()

    @property
    def is_buy(self):
        """
        Return whether the order side is ``BUY``.

        Returns
        -------
        bool

        """
        return self.is_buy_c()

    @property
    def is_sell(self):
        """
        Return whether the order side is ``SELL``.

        Returns
        -------
        bool

        """
        return self.is_sell_c()

    @property
    def is_passive(self):
        """
        Return whether the order is passive (`order_type` **not** ``MARKET``).

        Returns
        -------
        bool

        """
        return self.is_passive_c()

    @property
    def is_aggressive(self):
        """
        Return whether the order is aggressive (`order_type` is ``MARKET``).

        Returns
        -------
        bool

        """
        return self.is_aggressive_c()

    @property
    def is_emulated(self):
        """
        Return whether the order is emulated and held in the local system.

        Returns
        -------
        bool

        """
        return self.is_emulated_c()

    @property
    def is_active_local(self):
        """
        Return whether the order is active and held in the local system.

        An order is considered active local when its status is any of:
        - ``INITIALIZED``
        - ``EMULATED``
        - ``RELEASED``

        Returns
        -------
        bool

        """
        return self.is_active_local_c()

    @property
    def is_primary(self):
        """
        Return whether the order is the primary for an execution algorithm sequence.

        Returns
        -------
        bool

        """
        return self.is_primary_c()

    @property
    def is_spawned(self):
        """
        Return whether the order was spawned as part of an execution algorithm sequence.

        Returns
        -------
        bool

        """
        return self.is_spawned_c()

    @property
    def is_contingency(self):
        """
        Return whether the order has a contingency (`contingency_type` is not ``NO_CONTINGENCY``).

        Returns
        -------
        bool

        """
        return self.is_contingency_c()

    @property
    def is_parent_order(self):
        """
        Return whether the order has **at least** one child order.

        Returns
        -------
        bool

        """
        return self.is_parent_order_c()

    @property
    def is_child_order(self):
        """
        Return whether the order has a parent order.

        Returns
        -------
        bool

        """
        return self.is_child_order_c()

    @property
    def is_inflight(self):
        """
        Return whether the order is in-flight (order request sent to the trading venue).

        An order is considered in-flight when its status is any of:
        - ``SUBMITTED``
        - ``PENDING_UPDATE``
        - ``PENDING_CANCEL``

        Returns
        -------
        bool

        Warnings
        --------
        An emulated order is never considered in-flight.

        """
        return self.is_inflight_c()

    @property
    def is_open(self):
        """
        Return whether the order is open at the trading venue.

        An order is considered open when its status is any of:
        - ``ACCEPTED``
        - ``TRIGGERED``
        - ``PENDING_UPDATE``
        - ``PENDING_CANCEL``
        - ``PARTIALLY_FILLED``

        Returns
        -------
        bool

        Warnings
        --------
        An emulated order is never considered open.

        """
        return self.is_open_c()

    @property
    def is_canceled(self):
        """
        Return whether current `status` is ``CANCELED``.

        Returns
        -------
        bool

        """
        return self.is_canceled_c()

    @property
    def is_closed(self):
        """
        Return whether the order is closed (lifecycle completed).

        An order is considered closed when its status can no longer change.
        The possible statuses of closed orders include;

        - ``DENIED``
        - ``REJECTED``
        - ``CANCELED``
        - ``EXPIRED``
        - ``FILLED``

        Returns
        -------
        bool

        """
        return self.is_closed_c()

    @property
    def is_pending_update(self):
        """
        Return whether the current `status` is ``PENDING_UPDATE``.

        Returns
        -------
        bool

        """
        return self.is_pending_update_c()

    @property
    def is_pending_cancel(self):
        """
        Return whether the current `status` is ``PENDING_CANCEL``.

        Returns
        -------
        bool

        """
        return self.is_pending_cancel_c()

    @staticmethod
    cdef OrderSide opposite_side_c(OrderSide side):
        if side == OrderSide.BUY:
            return OrderSide.SELL
        elif side == OrderSide.SELL:
            return OrderSide.BUY
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `OrderSide`, was {order_side_to_str(side)}",  # pragma: no cover (design-time error)
            )

    @staticmethod
    cdef OrderSide closing_side_c(PositionSide position_side):
        if position_side == PositionSide.LONG:
            return OrderSide.SELL
        elif position_side == PositionSide.SHORT:
            return OrderSide.BUY
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `PositionSide`, was {position_side_to_str(position_side)}",  # pragma: no cover (design-time error)  # noqa
            )

    @staticmethod
    def opposite_side(OrderSide side) -> OrderSide:
        """
        Return the opposite order side from the given side.

        Parameters
        ----------
        side : OrderSide {``BUY``, ``SELL``}
            The original order side.

        Returns
        -------
        OrderSide

        Raises
        ------
        ValueError
            If `side` is invalid.

        """
        return Order.opposite_side_c(side)

    @staticmethod
    def closing_side(PositionSide position_side) -> OrderSide:
        """
        Return the order side needed to close a position with the given side.

        Parameters
        ----------
        position_side : PositionSide {``LONG``, ``SHORT``}
            The side of the position to close.

        Returns
        -------
        OrderSide

        Raises
        ------
        ValueError
            If `position_side` is ``FLAT`` or invalid.

        """
        return Order.closing_side_c(position_side)

    cpdef signed_decimal_qty(self):
        """
        Return a signed decimal representation of the remaining quantity.

         - If the order is a BUY, the value is positive (e.g. Decimal('10.25'))
         - If the order is a SELL, the value is negative (e.g. Decimal('-10.25'))

        Returns
        -------
        Decimal

        """
        if self.side == OrderSide.BUY:
            return Decimal(f"{self.leaves_qty.as_f64_c():.{self.leaves_qty._mem.precision}}")
        elif self.side == OrderSide.SELL:
            return -Decimal(f"{self.leaves_qty.as_f64_c():.{self.leaves_qty._mem.precision}}")
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `OrderSide`, was {order_side_to_str(self.side)}",  # pragma: no cover (design-time error)
            )

    cpdef bint would_reduce_only(self, PositionSide position_side, Quantity position_qty):
        """
        Whether the current order would only reduce the given position if applied
        in full.

        Parameters
        ----------
        position_side : PositionSide {``FLAT``, ``LONG``, ``SHORT``}
            The side of the position to check against.
        position_qty : Quantity
            The quantity of the position to check against.

        Returns
        -------
        bool

        """
        Condition.not_none(position_qty, "position_qty")

        if position_side == PositionSide.FLAT:
            return False  # Would increase position

        if self.side == OrderSide.BUY:
            if position_side == PositionSide.LONG:
                return False  # Would increase position
            elif position_side == PositionSide.SHORT and self.leaves_qty._mem.raw > position_qty._mem.raw:
                return False  # Would increase position
        elif self.side == OrderSide.SELL:
            if position_side == PositionSide.SHORT:
                return False  # Would increase position
            elif position_side == PositionSide.LONG and self.leaves_qty._mem.raw > position_qty._mem.raw:
                return False  # Would increase position

        return True  # Would reduce only

    cpdef list commissions(self):
        """
        Return the total commissions generated by the order.

        Returns
        -------
        list[Money]

        """
        return sorted(self._commissions.values())

    cpdef void apply(self, OrderEvent event):
        """
        Apply the given order event to the order.

        Parameters
        ----------
        event : OrderEvent
            The order event to apply.

        Raises
        ------
        ValueError
            If `self.client_order_id` is not equal to `event.client_order_id`.
        ValueError
            If `self.venue_order_id` and `event.venue_order_id` are both not ``None``, and are not equal.
        InvalidStateTrigger
            If `event` is not a valid trigger from the current `order.status`.
        KeyError
            If `event` is `OrderFilled` and `event.trade_id` already applied to the order.

        """
        Condition.not_none(event, "event")
        Condition.equal(event.client_order_id, self.client_order_id, "event.client_order_id", "self.client_order_id")
        if self.venue_order_id is not None and event.venue_order_id is not None and not isinstance(event, OrderUpdated):
            Condition.equal(self.venue_order_id, event.venue_order_id, "self.venue_order_id", "event.venue_order_id")

        cdef OrderStatus previous_status = <OrderStatus>self._fsm.state

        # Handle event (FSM can raise InvalidStateTrigger)
        if isinstance(event, OrderInitialized):
            pass  # Do nothing else
        elif isinstance(event, OrderDenied):
            self._fsm.trigger(OrderStatus.DENIED)
            self._denied(event)
        elif isinstance(event, OrderEmulated):
            self._fsm.trigger(OrderStatus.EMULATED)
            # self._emulated(event)
        elif isinstance(event, OrderReleased):
            self._fsm.trigger(OrderStatus.RELEASED)
            self.emulation_trigger = TriggerType.NO_TRIGGER
            # self._released(event)
        elif isinstance(event, OrderSubmitted):
            self._fsm.trigger(OrderStatus.SUBMITTED)
            self._submitted(event)
        elif isinstance(event, OrderRejected):
            self._fsm.trigger(OrderStatus.REJECTED)
            self._rejected(event)
        elif isinstance(event, OrderAccepted):
            self._fsm.trigger(OrderStatus.ACCEPTED)
            self._accepted(event)
        elif isinstance(event, OrderPendingUpdate):
            self._fsm.trigger(OrderStatus.PENDING_UPDATE)
        elif isinstance(event, OrderPendingCancel):
            self._fsm.trigger(OrderStatus.PENDING_CANCEL)
        elif isinstance(event, OrderModifyRejected):
            if self._fsm.state == OrderStatus.PENDING_UPDATE:
                self._fsm.trigger(self._previous_status)
        elif isinstance(event, OrderCancelRejected):
            if self._fsm.state == OrderStatus.PENDING_CANCEL:
                self._fsm.trigger(self._previous_status)
        elif isinstance(event, OrderUpdated):
            if self._fsm.state == OrderStatus.PENDING_UPDATE:
                self._fsm.trigger(self._previous_status)
            self._updated(event)
        elif isinstance(event, OrderTriggered):
            Condition.is_true(
                (
                    self.order_type == OrderType.STOP_LIMIT
                    or self.order_type == OrderType.TRAILING_STOP_LIMIT
                    or self.order_type == OrderType.LIMIT_IF_TOUCHED
                ),
                "can only trigger STOP_LIMIT, TRAILING_STOP_LIMIT and LIMIT_IF_TOUCHED orders",
            )
            self._fsm.trigger(OrderStatus.TRIGGERED)
            self._triggered(event)
        elif isinstance(event, OrderCanceled):
            self._fsm.trigger(OrderStatus.CANCELED)
            self._canceled(event)
        elif isinstance(event, OrderExpired):
            self._fsm.trigger(OrderStatus.EXPIRED)
            self._expired(event)
        elif isinstance(event, OrderFilled):
            # Check identifiers
            if self.venue_order_id is None:
                self.venue_order_id = event.venue_order_id
            else:
                Condition.not_in(event.trade_id, self._trade_ids, "event.trade_id", "_trade_ids")
            # Fill order
            self._filled(event)
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `OrderEvent`, was {type(event)}",  # pragma: no cover (design-time error)
            )

        # Update previous status and events last as FSM may raise `InvalidStateTrigger`
        if previous_status != OrderStatus.PENDING_UPDATE and previous_status != OrderStatus.PENDING_CANCEL:
            self._previous_status = previous_status

        self._events.append(event)
        self.ts_last = event.ts_event

    cdef Quantity calculate_overfill_c(self, Quantity fill_qty):
        cdef QuantityRaw potential_filled_raw = self.filled_qty._mem.raw + fill_qty._mem.raw

        if potential_filled_raw > self.quantity._mem.raw:
            return Quantity.from_raw_c(
                potential_filled_raw - self.quantity._mem.raw,
                fill_qty._mem.precision,
            )
        return Quantity.zero_c(fill_qty._mem.precision)

    cdef bint is_duplicate_fill_c(self, OrderFilled fill):
        cdef OrderEvent event
        for event in self._events:
            if not isinstance(event, OrderFilled):
                continue

            if (
                event.trade_id == fill.trade_id
                and event.order_side == fill.order_side
                and event.last_px == fill.last_px
                and event.last_qty == fill.last_qty
            ):
                return True

        return False

    def is_duplicate_fill(self, OrderFilled fill) -> bool:
        """
        Return whether a fill with matching trade_id, side, qty, and price already exists.

        Parameters
        ----------
        fill : OrderFilled
            The fill event to check.

        Returns
        -------
        bool

        """
        return self.is_duplicate_fill_c(fill)

    cdef void _denied(self, OrderDenied event):
        self.ts_closed = event.ts_event

    cdef void _submitted(self, OrderSubmitted event):
        self.account_id = event.account_id
        self.ts_submitted = event.ts_event

    cdef void _rejected(self, OrderRejected event):
        self.ts_closed = event.ts_event

    cdef void _accepted(self, OrderAccepted event):
        self.venue_order_id = event.venue_order_id
        self.ts_accepted = event.ts_event

    cdef void _updated(self, OrderUpdated event):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `_updated` must be implemented in the subclass")  # pragma: no cover

    cdef void _triggered(self, OrderTriggered event):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `_triggered` must be implemented in the subclass")  # pragma: no cover

    cdef void _canceled(self, OrderCanceled event):
        self.ts_closed = event.ts_event

    cdef void _expired(self, OrderExpired event):
        self.ts_closed = event.ts_event

    cdef void _filled(self, OrderFilled fill):
        if self.filled_qty._mem.raw + fill.last_qty._mem.raw < self.quantity._mem.raw:
            self._fsm.trigger(OrderStatus.PARTIALLY_FILLED)
        else:
            self._fsm.trigger(OrderStatus.FILLED)
            self.ts_closed = fill.ts_event

        self.venue_order_id = fill.venue_order_id
        self.position_id = fill.position_id
        self.strategy_id = fill.strategy_id
        self._trade_ids.append(fill.trade_id)
        self.last_trade_id = fill.trade_id
        if self.ts_accepted == 0:
            # Set ts_accepted to time of first fill if not previously set
            self.ts_accepted = fill.ts_event

        cdef QuantityRaw raw_filled_qty = self.filled_qty._mem.raw + fill.last_qty._mem.raw

        # Using `PriceRaw` as temporary hack to access int128_t so that negative values can be represented
        cdef PriceRaw raw_leaves_qty = self.quantity._mem.raw - raw_filled_qty

        if raw_leaves_qty < 0:
            self.overfill_qty = self.overfill_qty.add(
                Quantity.from_raw_c(-raw_leaves_qty, fill.last_qty._mem.precision)
            )
            raw_leaves_qty = 0  # Clamp to zero

        self.filled_qty.add_assign(fill.last_qty)
        self.leaves_qty = Quantity.from_raw_c(<QuantityRaw>raw_leaves_qty, fill.last_qty._mem.precision)
        self.avg_px = self._calculate_avg_px(fill.last_qty.as_f64_c(), fill.last_px.as_f64_c())
        self.liquidity_side = fill.liquidity_side
        self._set_slippage()

        # Calculate cumulative commission
        cdef Currency currency = fill.commission.currency
        cdef Money commissions = self._commissions.get(currency)
        cdef double total_commissions = commissions.as_f64_c() if commissions is not None else 0.0
        self._commissions[currency] = Money(total_commissions + fill.commission.as_f64_c(), currency)

    cdef double _calculate_avg_px(self, double last_qty, double last_px):
        if self.avg_px == 0.0:
            return last_px

        # Use previous filled quantity (before current fill) to avoid double-counting
        # self.filled_qty already includes last_qty at this point
        cdef double filled_qty_f64 = self.filled_qty.as_f64_c()
        cdef double prev_filled_qty = filled_qty_f64 - last_qty
        if filled_qty_f64 > 0:  # Protect divide by zero
            return ((self.avg_px * prev_filled_qty) + (last_px * last_qty)) / filled_qty_f64

    cdef void _set_slippage(self):
        pass  # Optionally implement

    @staticmethod
    cdef void _hydrate_initial_events(Order original, Order transformed):
        cdef list original_events = original.events_c()

        cdef OrderEvent event
        for event in reversed(original_events):
            # Insert each event to the beginning of the events list in reverse
            # to preserve correct order of events.
            transformed._events.insert(0, event)

</document_content>
</document>
<document index="2452">
<source>nautilus_trader/model/orders/limit.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.datetime cimport unix_nanos_to_iso8601
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_from_str
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_from_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_from_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trigger_type_from_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class LimitOrder(Order):
    """
    Represents a `Limit` order.

    A Limit order is an order to BUY (or SELL) at a specified price or better.
    The Limit order ensures that if the order fills, it will not fill at a price
    less favorable than your limit price, but it does not guarantee a fill.

    - A `Limit-On-Open (LOO)` order can be represented using a time in force of ``AT_THE_OPEN``.
    - A `Limit-On-Close (LOC)` order can be represented using a time in force of ``AT_THE_CLOSE``.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    price : Price
        The order limit price.
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
        The order time in force.
    expire_time_ns : uint64_t, default 0 (no expiry)
        UNIX timestamp (nanoseconds) when the order will expire.
    post_only : bool, default False
        If the order will only provide liquidity (make a market).
    reduce_only : bool, default False
        If the order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    display_qty : Quantity, optional
        The quantity of the order to display on the public book (iceberg).
    emulation_trigger : TriggerType, default ``NO_TRIGGER``
        The type of market price trigger to use for local order emulation.
        - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
        - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
        Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
    trigger_instrument_id : InstrumentId, optional
        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
    ValueError
        If `display_qty` is negative (< 0) or greater than `quantity`.

    References
    ----------
    https://www.interactivebrokers.com/en/trading/orders/limit.php
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        Price price not None,
        UUID4 init_id not None,
        uint64_t ts_init,
        TimeInForce time_in_force = TimeInForce.GTC,
        uint64_t expire_time_ns = 0,
        bint post_only = False,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        if time_in_force == TimeInForce.GTD:
            # Must have an expire time
            Condition.is_true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
        else:
            # Should not have an expire time
            Condition.is_true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
        Condition.is_true(
            display_qty is None or 0 <= display_qty <= quantity,
            fail_msg="`display_qty` was negative or greater than `quantity`",
        )

        # Set options
        cdef dict options = {
            "price": str(price),
            "display_qty": str(display_qty) if display_qty is not None else None,
            "expire_time_ns": expire_time_ns,
        }

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.LIMIT,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=post_only,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options=options,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

        self.price = price
        self.expire_time_ns = expire_time_ns
        self.display_qty = display_qty

    cdef void _updated(self, OrderUpdated event):
        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
            self._venue_order_ids.append(self.venue_order_id)
            self.venue_order_id = event.venue_order_id

        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)

        if event.price is not None:
            self.price = event.price

    cdef void _set_slippage(self):
        if self.side == OrderSide.BUY:
            self.slippage = self.avg_px - self.price.as_f64_c()
        elif self.side == OrderSide.SELL:
            self.slippage = self.price.as_f64_c() - self.avg_px
    cdef bint has_price_c(self):
        return True

    cdef bint has_trigger_price_c(self):
        return False

    @property
    def expire_time(self):
        """
        Return the expire time for the order (UTC).

        Returns
        -------
        datetime or ``None``

        """
        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {unix_nanos_to_iso8601(self.expire_time_ns, nanos_precision=False)}"
        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)} @ {self.price.to_formatted_str()} "
            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
            f"{emulation_str}"
        )

    @staticmethod
    cdef LimitOrder from_pyo3_c(pyo3_order):
        return LimitOrder(
            trader_id=TraderId(str(pyo3_order.trader_id)),
            strategy_id=StrategyId(str(pyo3_order.strategy_id)),
            instrument_id=InstrumentId.from_str_c(str(pyo3_order.instrument_id)),
            client_order_id=ClientOrderId(str(pyo3_order.client_order_id)),
            order_side=order_side_from_str(str(pyo3_order.side)),
            quantity=Quantity.from_raw_c(pyo3_order.quantity.raw, pyo3_order.quantity.precision),
            price=Price.from_raw_c(pyo3_order.price.raw, pyo3_order.price.precision),
            init_id=UUID4.from_str_c(str(pyo3_order.init_id)),
            ts_init=pyo3_order.ts_init,
            time_in_force=time_in_force_from_str(str(pyo3_order.time_in_force)),
            expire_time_ns=int(pyo3_order.expire_time_ns) if pyo3_order.expire_time_ns is not None else 0,
            post_only=pyo3_order.is_post_only,
            reduce_only=pyo3_order.is_reduce_only,
            quote_quantity=pyo3_order.is_quote_quantity,
            display_qty=Quantity.from_str_c(pyo3_order.display_qty) if pyo3_order.display_qty is not None else None,
            emulation_trigger=trigger_type_from_str(str(pyo3_order.emulation_trigger)) if pyo3_order.emulation_trigger is not None else TriggerType.NO_TRIGGER,
            trigger_instrument_id=InstrumentId.from_str_c(str(pyo3_order.trigger_instrument_id)) if pyo3_order.trigger_instrument_id is not None else None,
            contingency_type=contingency_type_from_str(str(pyo3_order.contingency_type)) if pyo3_order.contingency_type is not None else ContingencyType.NO_CONTINGENCY,
            order_list_id=OrderListId(str(pyo3_order.order_list_id)) if pyo3_order.order_list_id is not None else None,
            linked_order_ids=[ClientOrderId(str(o)) for o in pyo3_order.linked_order_ids] if pyo3_order.linked_order_ids is not None else None,
            parent_order_id=ClientOrderId(str(pyo3_order.parent_order_id)) if pyo3_order.parent_order_id is not None else None,
            exec_algorithm_id=ExecAlgorithmId(str(pyo3_order.exec_algorithm_id)) if pyo3_order.exec_algorithm_id is not None else None,
            exec_algorithm_params=pyo3_order.exec_algorithm_params,
            exec_spawn_id=ClientOrderId(str(pyo3_order.exec_spawn_id)) if pyo3_order.exec_spawn_id is not None else None,
            tags=pyo3_order.tags if pyo3_order.tags is not None else None,
        )

    @staticmethod
    def from_pyo3(pyo3_order):
        return LimitOrder.from_pyo3_c(pyo3_order)

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "price": str(self.price),
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "status": self._fsm.state_string_c(),
            "is_post_only": self.is_post_only,
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef LimitOrder create_c(OrderInitialized init):
        """
        Return a `Limit` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        LimitOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``LIMIT``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.LIMIT, "init.order_type", "OrderType")

        cdef str display_qty_str = init.options.get("display_qty")

        return LimitOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            price=Price.from_str_c(init.options["price"]),
            init_id=init.id,
            ts_init=init.ts_init,
            time_in_force=init.time_in_force,
            expire_time_ns=init.options["expire_time_ns"],
            post_only=init.post_only,
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
            emulation_trigger=init.emulation_trigger,
            trigger_instrument_id=init.trigger_instrument_id,
            contingency_type=init.contingency_type,
            order_list_id=init.order_list_id,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(OrderInitialized init):
        return LimitOrder.create_c(init)

    @staticmethod
    cdef LimitOrder transform(Order order, uint64_t ts_init, Price price = None):
        """
        Transform the given order to a `limit` order.

        All existing events will be prepended to the orders internal events
        prior to the new `OrderInitialized` event.

        Parameters
        ----------
        order : Order
            The order to transform from.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the object was initialized.
        price : Price, optional
            The price to assign to the order (will override any existing price on `order`).

        Returns
        -------
        LimitOrder

        Raises
        ------
        ValueError
            If `price` is ``None`` and `order` does not have a `price` attribute.

        """
        Condition.not_none(order, "order")
        Condition.is_true(price or hasattr(order, "price"), "`order` has no price")

        cdef LimitOrder transformed = LimitOrder(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            order_side=order.side,
            quantity=order.quantity,
            price=price or order.price,
            time_in_force=order.time_in_force,
            expire_time_ns=order.expire_time_ns if hasattr(order, "expire_time_ns") else 0,
            init_id=UUID4(),
            ts_init=ts_init,
            post_only=order.is_post_only if hasattr(order, "is_post_only") else False,
            reduce_only=order.is_reduce_only,
            quote_quantity=order.is_quote_quantity,
            display_qty=order.display_qty if hasattr(order, "display_qty") else None,
            contingency_type=order.contingency_type,
            order_list_id=order.order_list_id,
            linked_order_ids=order.linked_order_ids,
            parent_order_id=order.parent_order_id,
            exec_algorithm_id=order.exec_algorithm_id,
            exec_algorithm_params=order.exec_algorithm_params,
            exec_spawn_id=order.exec_spawn_id,
            tags=order.tags,
        )
        transformed.liquidity_side = order.liquidity_side
        cdef Price triggered_price = order.get_triggered_price_c()
        if triggered_price:
            transformed.set_triggered_price_c(triggered_price)

        # Use original order initialization timestamp
        transformed.ts_init = order.ts_init

        Order._hydrate_initial_events(original=order, transformed=transformed)

        return transformed

    @staticmethod
    def transform_py(Order order, uint64_t ts_init, Price price = None) -> LimitOrder:
        return LimitOrder.transform(order, ts_init, price)

</document_content>
</document>
<document index="2454">
<source>nautilus_trader/model/orders/limit_if_touched.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.datetime cimport unix_nanos_to_iso8601
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trigger_type_from_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class LimitIfTouchedOrder(Order):
    """
    Represents a `Limit-If-Touched` (LIT) conditional order.

    A Limit-If-Touched (LIT) is an order to BUY (or SELL) an instrument at a
    specified price or better, below (or above) the market. This order is held
    in the system until the trigger price is touched. A LIT order is similar to
    a Stop-Limit order, except that a LIT SELL order is placed above the current
    market price, and a Stop-Limit SELL order is placed below.

    Using a LIT order helps to ensure that, if the order does execute, the order
    will not execute at a price less favorable than the limit price.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    price : Price
        The order price (LIMIT).
    trigger_price : Price
        The order trigger price (STOP).
    trigger_type : TriggerType
        The order trigger type.
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
        The order time in force.
    expire_time_ns : uint64_t, default 0 (no expiry)
        UNIX timestamp (nanoseconds) when the order will expire.
    post_only : bool, default False
        If the ``LIMIT`` order will only provide liquidity (once triggered).
    reduce_only : bool, default False
        If the ``LIMIT`` order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    display_qty : Quantity, optional
        The quantity of the ``LIMIT`` order to display on the public book (iceberg).
    emulation_trigger : TriggerType, default ``NO_TRIGGER``
        The type of market price trigger to use for local order emulation.
        - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
        - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
        Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
    trigger_instrument_id : InstrumentId, optional
        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `trigger_type` is ``NO_TRIGGER``.
    ValueError
        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
    ValueError
        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
    ValueError
        If `display_qty` is negative (< 0) or greater than `quantity`.

    References
    ----------
    https://www.interactivebrokers.com/en/trading/orders/lit.php
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        Price price not None,
        Price trigger_price not None,
        TriggerType trigger_type,
        UUID4 init_id not None,
        uint64_t ts_init,
        TimeInForce time_in_force = TimeInForce.GTC,
        uint64_t expire_time_ns = 0,
        bint post_only = False,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")

        if time_in_force == TimeInForce.GTD:
            # Must have an expire time
            Condition.is_true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
        else:
            # Should not have an expire time
            Condition.is_true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
        Condition.is_true(
            display_qty is None or 0 <= display_qty <= quantity,
            fail_msg="`display_qty` was negative or greater than `quantity`",
        )

        # Set options
        cdef dict options = {
            "price": str(price),
            "trigger_price": str(trigger_price),
            "trigger_type": trigger_type_to_str(trigger_type),
            "expire_time_ns": expire_time_ns,
            "display_qty": str(display_qty) if display_qty is not None else None,
        }

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.LIMIT_IF_TOUCHED,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=post_only,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options=options,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

        self.price = price
        self.trigger_price = trigger_price
        self.trigger_type = trigger_type
        self.expire_time_ns = expire_time_ns
        self.display_qty = display_qty
        self.is_triggered = False
        self.ts_triggered = 0

    cdef void _updated(self, OrderUpdated event):
        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
            self._venue_order_ids.append(self.venue_order_id)
            self.venue_order_id = event.venue_order_id
        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
        if event.price is not None:
            self.price = event.price
        if event.trigger_price is not None:
            self.trigger_price = event.trigger_price

    cdef void _triggered(self, OrderTriggered event):
        self.is_triggered = True
        self.ts_triggered = event.ts_event

    cdef void _set_slippage(self):
        if self.side == OrderSide.BUY:
            self.slippage = self.avg_px - self.price.as_f64_c()
        elif self.side == OrderSide.SELL:
            self.slippage = self.price.as_f64_c() - self.avg_px

    cdef bint has_price_c(self):
        return True

    cdef bint has_trigger_price_c(self):
        return True

    @property
    def expire_time(self):
        """
        Return the expire time for the order (UTC).

        Returns
        -------
        datetime or ``None``

        """
        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {unix_nanos_to_iso8601(self.expire_time_ns, nanos_precision=False)}"
        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)} @ {self.trigger_price.to_formatted_str()}-STOP"
            f"[{trigger_type_to_str(self.trigger_type)}] {self.price.to_formatted_str()}-LIMIT "
            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
            f"{emulation_str}"
        )

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "price": str(self.price),
            "trigger_price": str(self.trigger_price),
            "trigger_type": trigger_type_to_str(self.trigger_type),
            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "status": self._fsm.state_string_c(),
            "is_post_only": self.is_post_only,
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef LimitIfTouchedOrder create_c(OrderInitialized init):
        """
        Return a `Limit-If-Touched` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        LimitIfTouchedOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``LIMIT_IF_TOUCHED``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.LIMIT_IF_TOUCHED, "init.order_type", "OrderType")

        cdef str display_qty_str = init.options.get("display_qty")

        return LimitIfTouchedOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            price=Price.from_str_c(init.options["price"]),
            trigger_price=Price.from_str_c(init.options["trigger_price"]),
            trigger_type=trigger_type_from_str(init.options["trigger_type"]),
            time_in_force=init.time_in_force,
            expire_time_ns=init.options["expire_time_ns"],
            init_id=init.id,
            ts_init=init.ts_init,
            post_only=init.post_only,
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
            emulation_trigger=init.emulation_trigger,
            trigger_instrument_id=init.trigger_instrument_id,
            contingency_type=init.contingency_type,
            order_list_id=init.order_list_id,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(init):
        return LimitIfTouchedOrder.create_c(init)

</document_content>
</document>
<document index="2456">
<source>nautilus_trader/model/orders/list.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.orders.base cimport Order


cdef class OrderList:
    """
    Represents a list of bulk or related contingent orders.

    All orders must be for the same instrument ID.

    Parameters
    ----------
    order_list_id : OrderListId
        The order list ID.
    orders : list[Order]
        The contained orders list.

    Raises
    ------
    ValueError
        If `orders` is empty.
    ValueError
        If `orders` contains a type other than `Order`.
    ValueError
        If orders contain different instrument IDs (must all be the same instrument).

    """

    def __init__(
        self,
        OrderListId order_list_id not None,
        list orders not None,
    ) -> None:
        Condition.not_empty(orders, "orders")
        Condition.list_type(orders, Order, "orders")
        cdef Order first = orders[0]
        cdef Order order
        for order in orders:
            # First condition check avoids creating an f-string for performance reasons
            if order.instrument_id != first.instrument_id:
                Condition.is_true(
                    order.instrument_id == first.instrument_id,
                    f"order.instrument_id {order.instrument_id} != instrument_id {first.instrument_id}; "
                    "all orders in the list must be for the same instrument ID",
                )

        self.id = order_list_id
        self.instrument_id = first.instrument_id
        self.strategy_id = first.strategy_id
        self.orders = orders
        self.first = first
        self.ts_init = first.ts_init

    def __eq__(self, OrderList other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __len__(self) -> int:
        return len(self.orders)

    def __repr__(self) -> str:
        return (
            f"OrderList("
            f"id={self.id.to_str()}, "
            f"instrument_id={self.instrument_id}, "
            f"strategy_id={self.strategy_id}, "
            f"orders={self.orders})"
        )

</document_content>
</document>
<document index="2458">
<source>nautilus_trader/model/orders/market.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_from_str
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_from_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_from_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class MarketOrder(Order):
    """
    Represents a `Market` order.

    A Market order is an order to BUY (or SELL) at the market bid or offer price.
    A market order may increase the likelihood of a fill and the speed of
    execution, but unlike the Limit order - a Market order provides no price
    protection and may fill at a price far lower/higher than the top-of-book
    bid/ask.

    - A `Market-On-Open (MOO)` order can be represented using a time in force of ``AT_THE_OPEN``.
    - A `Market-On-Close (MOC)` order can be represented using a time in force of ``AT_THE_CLOSE``.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
        The order time in force.
    reduce_only : bool, default False
        If the order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `time_in_force` is ``GTD``.

    References
    ----------
    https://www.interactivebrokers.com/en/trading/orders/market.php
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        UUID4 init_id not None,
        uint64_t ts_init,
        TimeInForce time_in_force = TimeInForce.GTC,
        bint reduce_only = False,
        bint quote_quantity = False,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        Condition.not_equal(time_in_force, TimeInForce.GTD, "time_in_force", "GTD")

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.MARKET,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=False,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options={},
            emulation_trigger=TriggerType.NO_TRIGGER,
            trigger_instrument_id=None,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

    cdef void _updated(self, OrderUpdated event):
        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)

    cdef bint has_price_c(self):
        return False

    cdef bint has_trigger_price_c(self):
        return False

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)} "
            f"{time_in_force_to_str(self.time_in_force)}"
        )

    @staticmethod
    cdef MarketOrder from_pyo3_c(pyo3_order):
        return MarketOrder(
            trader_id=TraderId(str(pyo3_order.trader_id)),
            strategy_id=StrategyId(str(pyo3_order.strategy_id)),
            instrument_id=InstrumentId.from_str_c(str(pyo3_order.instrument_id)),
            client_order_id=ClientOrderId(str(pyo3_order.client_order_id)),
            order_side=order_side_from_str(str(pyo3_order.side)),
            quantity=Quantity.from_raw_c(pyo3_order.quantity.raw, pyo3_order.quantity.precision),
            init_id=UUID4.from_str_c(str(pyo3_order.init_id)),
            ts_init=pyo3_order.ts_init,
            time_in_force=time_in_force_from_str(str(pyo3_order.time_in_force)),
            reduce_only=pyo3_order.is_reduce_only,
            quote_quantity=pyo3_order.is_quote_quantity,
            contingency_type=contingency_type_from_str(str(pyo3_order.contingency_type)) if pyo3_order.contingency_type is not None else ContingencyType.NO_CONTINGENCY,
            order_list_id=OrderListId(str(pyo3_order.order_list_id)) if pyo3_order.order_list_id is not None else None,
            linked_order_ids=[ClientOrderId(str(o)) for o in pyo3_order.linked_order_ids] if pyo3_order.linked_order_ids is not None else None,
            parent_order_id=ClientOrderId(str(pyo3_order.parent_order_id)) if pyo3_order.parent_order_id is not None else None,
            exec_algorithm_id=ExecAlgorithmId(str(pyo3_order.exec_algorithm_id)) if pyo3_order.exec_algorithm_id is not None else None,
            exec_algorithm_params=pyo3_order.exec_algorithm_params,
            exec_spawn_id=ClientOrderId(str(pyo3_order.exec_spawn_id)) if pyo3_order.exec_spawn_id is not None else None,
            tags=pyo3_order.tags if pyo3_order.tags is not None else None,
        )

    @staticmethod
    def from_pyo3(pyo3_order):
        return MarketOrder.from_pyo3_c(pyo3_order)

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
            "status": self._fsm.state_string_c(),
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef MarketOrder create_c(OrderInitialized init):
        """
        Return a `market` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        MarketOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``MARKET``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.MARKET, "init.order_type", "OrderType")

        return MarketOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            time_in_force=init.time_in_force,
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            init_id=init.id,
            ts_init=init.ts_init,
            contingency_type=init.contingency_type,
            order_list_id=init.order_list_id,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(init):
        return MarketOrder.create_c(init)

    @staticmethod
    cdef MarketOrder transform(Order order, uint64_t ts_init):
        """
        Transform the given order to a `market` order.

        All existing events will be prepended to the orders internal events
        prior to the new `OrderInitialized` event.

        Parameters
        ----------
        order : Order
            The order to transform from.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the object was initialized.

        Returns
        -------
        MarketOrder

        """
        Condition.not_none(order, "order")

        cdef list original_events = order.events_c()
        cdef MarketOrder transformed = MarketOrder(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            order_side=order.side,
            quantity=order.quantity,
            time_in_force=order.time_in_force if order.time_in_force != TimeInForce.GTD else TimeInForce.GTC,
            reduce_only=order.is_reduce_only,
            quote_quantity=order.is_quote_quantity,
            init_id=UUID4(),
            ts_init=ts_init,
            contingency_type=order.contingency_type,
            order_list_id=order.order_list_id,
            linked_order_ids=order.linked_order_ids,
            parent_order_id=order.parent_order_id,
            exec_algorithm_id=order.exec_algorithm_id,
            exec_algorithm_params=order.exec_algorithm_params,
            exec_spawn_id=order.exec_spawn_id,
            tags=order.tags,
        )

        # Use original order initialization timestamp
        transformed.ts_init = order.ts_init

        Order._hydrate_initial_events(original=order, transformed=transformed)

        return transformed

    @staticmethod
    def transform_py(Order order, uint64_t ts_init) -> MarketOrder:
        return MarketOrder.transform(order, ts_init)

</document_content>
</document>
<document index="2460">
<source>nautilus_trader/model/orders/market_if_touched.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.datetime cimport unix_nanos_to_iso8601
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trigger_type_from_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class MarketIfTouchedOrder(Order):
    """
    Represents a `Market-If-Touched` (MIT) conditional order.

    A Market-If-Touched (MIT) is an order to BUY (or SELL) an instrument below
    (or above) the market. This order is held in the system until the trigger
    price is touched, and is then submitted as a market order. An MIT order is
    similar to a Stop-Order, except that an MIT SELL order is placed above the
    current market price, and a stop SELL order is placed below.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    trigger_price : Price
        The order trigger price (STOP).
    trigger_type : TriggerType
        The order trigger type.
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
        The order time in force.
    expire_time_ns : uint64_t, default 0 (no expiry)
        UNIX timestamp (nanoseconds) when the order will expire.
    reduce_only : bool, default False
        If the order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    emulation_trigger : TriggerType, default ``NO_TRIGGER``
        The type of market price trigger to use for local order emulation.
        - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
        - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
        Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
    trigger_instrument_id : InstrumentId, optional
        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `trigger_type` is ``NO_TRIGGER``.
    ValueError
        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
    ValueError
        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.

    References
    ----------
    https://www.interactivebrokers.com/en/trading/orders/mit.php
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        Price trigger_price not None,
        TriggerType trigger_type,
        UUID4 init_id not None,
        uint64_t ts_init,
        TimeInForce time_in_force = TimeInForce.GTC,
        uint64_t expire_time_ns = 0,
        bint reduce_only = False,
        bint quote_quantity = False,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")

        if time_in_force == TimeInForce.GTD:
            # Must have an expire time
            Condition.is_true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
        else:
            # Should not have an expire time
            Condition.is_true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")

        # Set options
        cdef dict options = {
            "trigger_price": str(trigger_price),
            "trigger_type": trigger_type_to_str(trigger_type),
            "expire_time_ns": expire_time_ns,
        }

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.MARKET_IF_TOUCHED,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=False,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options=options,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

        self.trigger_price = trigger_price
        self.trigger_type = trigger_type
        self.expire_time_ns = expire_time_ns

    cdef void _updated(self, OrderUpdated event):
        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
            self._venue_order_ids.append(self.venue_order_id)
            self.venue_order_id = event.venue_order_id
        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
        if event.trigger_price is not None:
            self.trigger_price = event.trigger_price

    cdef void _set_slippage(self):
        if self.side == OrderSide.BUY:
            self.slippage = self.avg_px - self.trigger_price.as_f64_c()
        elif self.side == OrderSide.SELL:
            self.slippage = self.trigger_price.as_f64_c() - self.avg_px

    cdef bint has_price_c(self):
        return False

    cdef bint has_trigger_price_c(self):
        return True

    @property
    def expire_time(self):
        """
        Return the expire time for the order (UTC).

        Returns
        -------
        datetime or ``None``

        """
        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {unix_nanos_to_iso8601(self.expire_time_ns, nanos_precision=False)}"
        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)} @ {self.trigger_price.to_formatted_str()}"
            f"[{trigger_type_to_str(self.trigger_type)}] "
            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
            f"{emulation_str}"
        )

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "trigger_price": str(self.trigger_price),
            "trigger_type": trigger_type_to_str(self.trigger_type),
            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "status": self._fsm.state_string_c(),
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef MarketIfTouchedOrder create_c(OrderInitialized init):
        """
        Return a `Market-If-Touched` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        StopMarketOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``MARKET_IF_TOUCHED``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.MARKET_IF_TOUCHED, "init.order_type", "OrderType")

        return MarketIfTouchedOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            trigger_price=Price.from_str_c(init.options["trigger_price"]),
            trigger_type=trigger_type_from_str(init.options["trigger_type"]),
            time_in_force=init.time_in_force,
            expire_time_ns=init.options["expire_time_ns"],
            init_id=init.id,
            ts_init=init.ts_init,
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            emulation_trigger=init.emulation_trigger,
            trigger_instrument_id=init.trigger_instrument_id,
            contingency_type=init.contingency_type,
            order_list_id=init.order_list_id,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(init):
        return MarketIfTouchedOrder.create_c(init)

</document_content>
</document>
<document index="2462">
<source>nautilus_trader/model/orders/market_to_limit.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.datetime cimport unix_nanos_to_iso8601
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class MarketToLimitOrder(Order):
    """
    Represents a `Market-To-Limit` (MTL) order.

    A Market-to-Limit (MTL) order is submitted as a market order to execute at
    the current best market price. If the order is only partially filled, the
    remainder of the order is canceled and re-submitted as a Limit order with
    the limit price equal to the price at which the filled portion of the order
    executed.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
        The order time in force.
    expire_time_ns : uint64_t, default 0 (no expiry)
        UNIX timestamp (nanoseconds) when the order will expire.
    reduce_only : bool, default False
        If the order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    display_qty : Quantity, optional
        The quantity of the limit order to display on the public book (iceberg).
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.

    References
    ----------
    https://www.interactivebrokers.com/en/trading/orders/mtl.php
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        UUID4 init_id not None,
        uint64_t ts_init,
        TimeInForce time_in_force = TimeInForce.GTC,
        uint64_t expire_time_ns = 0,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")

        if time_in_force == TimeInForce.GTD:
            # Must have an expire time
            Condition.is_true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
        else:
            # Should not have an expire time
            Condition.is_true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")

        # Set options
        cdef dict options = {
            "display_qty": str(display_qty) if display_qty is not None else None,
            "expire_time_ns": expire_time_ns,
        }

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.MARKET_TO_LIMIT,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=False,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options=options,
            emulation_trigger=TriggerType.NO_TRIGGER,
            trigger_instrument_id=None,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

        self.price = None
        self.expire_time_ns = expire_time_ns
        self.display_qty = display_qty

    cdef void _updated(self, OrderUpdated event):
        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
            self._venue_order_ids.append(self.venue_order_id)
            self.venue_order_id = event.venue_order_id
        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
        if event.price is not None:
            self.price = event.price

    cdef void _set_slippage(self):
        if self.side == OrderSide.BUY:
            self.slippage = self.avg_px - self.price.as_f64_c()
        elif self.side == OrderSide.SELL:
            self.slippage = self.price.as_f64_c() - self.avg_px

    cdef bint has_price_c(self):
        return self.price is not None

    cdef bint has_trigger_price_c(self):
        return False

    @property
    def expire_time(self):
        """
        Return the expire time for the order (UTC).

        Returns
        -------
        datetime or ``None``

        """
        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {unix_nanos_to_iso8601(self.expire_time_ns, nanos_precision=False)}"
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)} @ {self.price.to_formatted_str() if self.price else None} "
            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
        )

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "price": str(self.price),
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "status": self._fsm.state_string_c(),
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef MarketToLimitOrder create_c(OrderInitialized init):
        """
        Return a `Market-To-Limit` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        MarketToLimitOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``MARKET_TO_LIMIT``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.MARKET_TO_LIMIT, "init.order_type", "OrderType")

        cdef str display_qty_str = init.options.get("display_qty")

        return MarketToLimitOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            time_in_force=init.time_in_force,
            expire_time_ns=init.options["expire_time_ns"],
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
            init_id=init.id,
            ts_init=init.ts_init,
            order_list_id=init.order_list_id,
            contingency_type=init.contingency_type,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(init):
        return MarketToLimitOrder.create_c(init)

</document_content>
</document>
<document index="2464">
<source>nautilus_trader/model/orders/stop_limit.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.datetime cimport unix_nanos_to_iso8601
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_from_str
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_from_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_from_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trigger_type_from_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class StopLimitOrder(Order):
    """
    Represents a `Stop-Limit` conditional order.

    A Stop-Limit order is an instruction to submit a BUY (or SELL) limit order
    when the specified stop trigger price is attained or penetrated. The
    order has two basic components: the stop price and the limit price. When a
    trade has occurred at or through the stop price, the order becomes executable
    and enters the market as a limit order, which is an order to BUY (or SELL)
    at a specified price or better.

    A Stop-Limit eliminates the price risk associated with a stop order where
    the execution price cannot be guaranteed, but exposes the trader to the
    risk that the order may never fill, even if the stop price is reached.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    price : Price
        The order price (LIMIT).
    trigger_price : Price
        The order trigger price (STOP).
    trigger_type : TriggerType
        The order trigger type.
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
        The order time in force.
    expire_time_ns : uint64_t, default 0 (no expiry)
        UNIX timestamp (nanoseconds) when the order will expire.
    post_only : bool, default False
        If the ``LIMIT`` order will only provide liquidity (once triggered).
    reduce_only : bool, default False
        If the ``LIMIT`` order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    display_qty : Quantity, optional
        The quantity of the ``LIMIT`` order to display on the public book (iceberg).
    emulation_trigger : EmulationTrigger, default ``NO_TRIGGER``
        The emulation trigger for the order.
    trigger_instrument_id : InstrumentId, optional
        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `trigger_type` is ``NO_TRIGGER``.
    ValueError
        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
    ValueError
        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
    ValueError
        If `display_qty` is negative (< 0) or greater than `quantity`.

    References
    ----------
    https://www.interactivebrokers.com/en/trading/orders/stop-limit.php
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        Price price not None,
        Price trigger_price not None,
        TriggerType trigger_type,
        UUID4 init_id not None,
        uint64_t ts_init,
        TimeInForce time_in_force = TimeInForce.GTC,
        uint64_t expire_time_ns = 0,
        bint post_only = False,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")

        if time_in_force == TimeInForce.GTD:
            # Must have an expire time
            Condition.is_true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
        else:
            # Should not have an expire time
            Condition.is_true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
        Condition.is_true(
            display_qty is None or 0 <= display_qty <= quantity,
            fail_msg="`display_qty` was negative or greater than `quantity`",
        )

        # Set options
        cdef dict options = {
            "price": str(price),
            "trigger_price": str(trigger_price),
            "trigger_type": trigger_type_to_str(trigger_type),
            "expire_time_ns": expire_time_ns,
            "display_qty": str(display_qty) if display_qty is not None else None,
        }

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.STOP_LIMIT,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=post_only,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options=options,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

        self.price = price
        self.trigger_price = trigger_price
        self.trigger_type = trigger_type
        self.expire_time_ns = expire_time_ns
        self.display_qty = display_qty
        self.is_triggered = False
        self.ts_triggered = 0

    cdef void _updated(self, OrderUpdated event):
        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
            self._venue_order_ids.append(self.venue_order_id)
            self.venue_order_id = event.venue_order_id
        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
        if event.price is not None:
            self.price = event.price
        if event.trigger_price is not None:
            self.trigger_price = event.trigger_price

    cdef void _triggered(self, OrderTriggered event):
        self.is_triggered = True
        self.ts_triggered = event.ts_event

    cdef void _set_slippage(self):
        if self.side == OrderSide.BUY:
            self.slippage = self.avg_px - self.price.as_f64_c()
        elif self.side == OrderSide.SELL:
            self.slippage = self.price.as_f64_c() - self.avg_px

    cdef bint has_price_c(self):
        return True

    cdef bint has_trigger_price_c(self):
        return True

    @property
    def expire_time(self):
        """
        Return the expire time for the order (UTC).

        Returns
        -------
        datetime or ``None``

        """
        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {unix_nanos_to_iso8601(self.expire_time_ns, nanos_precision=False)}"
        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)} @ {self.trigger_price.to_formatted_str()}-STOP"
            f"[{trigger_type_to_str(self.trigger_type)}] {self.price.to_formatted_str()}-LIMIT "
            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
            f"{emulation_str}"
        )

    @staticmethod
    cdef StopLimitOrder from_pyo3_c(pyo3_order):
        return StopLimitOrder(
            trader_id=TraderId(str(pyo3_order.trader_id)),
            strategy_id=StrategyId(str(pyo3_order.strategy_id)),
            instrument_id=InstrumentId.from_str_c(str(pyo3_order.instrument_id)),
            client_order_id=ClientOrderId(str(pyo3_order.client_order_id)),
            order_side=order_side_from_str(str(pyo3_order.side)),
            quantity=Quantity.from_raw_c(pyo3_order.quantity.raw, pyo3_order.quantity.precision),
            price=Price.from_raw_c(pyo3_order.price.raw, pyo3_order.price.precision),
            trigger_price=Price.from_raw_c(pyo3_order.trigger_price.raw, pyo3_order.trigger_price.precision),
            trigger_type=trigger_type_from_str(str(pyo3_order.trigger_type)),
            init_id=UUID4.from_str_c(str(pyo3_order.init_id)),
            ts_init=pyo3_order.ts_init,
            time_in_force=time_in_force_from_str(str(pyo3_order.time_in_force)),
            expire_time_ns=pyo3_order.expire_time if pyo3_order.expire_time is not None else 0,
            post_only=pyo3_order.is_post_only,
            reduce_only=pyo3_order.is_reduce_only,
            quote_quantity=pyo3_order.is_quote_quantity,
            display_qty=Quantity.from_raw_c(pyo3_order.display_qty.raw, pyo3_order.display_qty.precision) if pyo3_order.display_qty is not None else None,
            emulation_trigger=trigger_type_from_str(str(pyo3_order.emulation_trigger)),
            trigger_instrument_id=InstrumentId.from_str_c(str(pyo3_order.trigger_instrument_id)) if pyo3_order.trigger_instrument_id is not None else None,
            contingency_type=contingency_type_from_str(str(pyo3_order.contingency_type)) if pyo3_order.contingency_type is not None else ContingencyType.NO_CONTINGENCY,
            order_list_id=OrderListId(str(pyo3_order.order_list_id)) if pyo3_order.order_list_id is not None else None,
            linked_order_ids=[ClientOrderId(str(o)) for o in pyo3_order.linked_order_ids] if pyo3_order.linked_order_ids is not None else None,
            parent_order_id=ClientOrderId(str(pyo3_order.parent_order_id)) if pyo3_order.parent_order_id is not None else None,
            exec_algorithm_id=ExecAlgorithmId(str(pyo3_order.exec_algorithm_id)) if pyo3_order.exec_algorithm_id is not None else None,
            exec_algorithm_params=pyo3_order.exec_algorithm_params,
            exec_spawn_id=ClientOrderId(str(pyo3_order.exec_spawn_id)) if pyo3_order.exec_spawn_id is not None else None,
            tags=pyo3_order.tags if pyo3_order.tags is not None else None,
        )

    @staticmethod
    def from_pyo3(pyo3_order):
        return StopLimitOrder.from_pyo3_c(pyo3_order)

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "price": str(self.price),
            "trigger_price": str(self.trigger_price),
            "trigger_type": trigger_type_to_str(self.trigger_type),
            "init_id": str(self.init_id),
            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "status": self._fsm.state_string_c(),
            "is_post_only": self.is_post_only,
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef StopLimitOrder create_c(OrderInitialized init):
        """
        Return a `Stop-Limit` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        StopLimitOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``STOP_LIMIT``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.STOP_LIMIT, "init.order_type", "OrderType")

        cdef str display_qty_str = init.options.get("display_qty")

        return StopLimitOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            price=Price.from_str_c(init.options["price"]),
            trigger_price=Price.from_str_c(init.options["trigger_price"]),
            trigger_type=trigger_type_from_str(init.options["trigger_type"]),
            time_in_force=init.time_in_force,
            expire_time_ns=init.options["expire_time_ns"],
            init_id=init.id,
            ts_init=init.ts_init,
            post_only=init.post_only,
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
            emulation_trigger=init.emulation_trigger,
            trigger_instrument_id=init.trigger_instrument_id,
            contingency_type=init.contingency_type,
            order_list_id=init.order_list_id,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(init):
        return StopLimitOrder.create_c(init)

</document_content>
</document>
<document index="2466">
<source>nautilus_trader/model/orders/stop_market.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.datetime cimport unix_nanos_to_iso8601
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trigger_type_from_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class StopMarketOrder(Order):
    """
    Represents a `Stop-Market` conditional order.

    A Stop-Market order is an instruction to submit a BUY (or SELL) market order
    if and when the specified stop trigger price is attained or penetrated.
    A Stop-Market order is not guaranteed a specific execution price and may execute
    significantly away from its stop price.

    A SELL Stop-Market order is always placed below the current market price,
    and is typically used to limit a loss or protect a profit on a long position.

    A BUY Stop-Market order is always placed above the current market price,
    and is typically used to limit a loss or protect a profit on a short position.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    trigger_price : Price
        The order trigger price (STOP).
    trigger_type : TriggerType
        The order trigger type.
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
        The order time in force.
    expire_time_ns : uint64_t, default 0 (no expiry)
        UNIX timestamp (nanoseconds) when the order will expire.
    reduce_only : bool, default False
        If the order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    emulation_trigger : TriggerType, default ``NO_TRIGGER``
        The type of market price trigger to use for local order emulation.
        - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
        - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
        Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
    trigger_instrument_id : InstrumentId, optional
        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `trigger_type` is ``NO_TRIGGER``.
    ValueError
        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
    ValueError
        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.

    References
    ----------
    https://www.interactivebrokers.com/en/trading/orders/stop.php
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        Price trigger_price not None,
        TriggerType trigger_type,
        UUID4 init_id not None,
        uint64_t ts_init,
        TimeInForce time_in_force = TimeInForce.GTC,
        uint64_t expire_time_ns = 0,
        bint reduce_only = False,
        bint quote_quantity = False,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")

        if time_in_force == TimeInForce.GTD:
            # Must have an expire time
            Condition.is_true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
        else:
            # Should not have an expire time
            Condition.is_true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")

        # Set options
        cdef dict options = {
            "trigger_price": str(trigger_price),
            "trigger_type": trigger_type_to_str(trigger_type),
            "expire_time_ns": expire_time_ns,
        }

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.STOP_MARKET,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=False,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options=options,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

        self.trigger_price = trigger_price
        self.trigger_type = trigger_type
        self.expire_time_ns = expire_time_ns

    cdef void _updated(self, OrderUpdated event):
        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
            self._venue_order_ids.append(self.venue_order_id)
            self.venue_order_id = event.venue_order_id
        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
        if event.trigger_price is not None:
            self.trigger_price = event.trigger_price

    cdef void _set_slippage(self):
        if self.side == OrderSide.BUY:
            self.slippage = self.avg_px - self.trigger_price.as_f64_c()
        elif self.side == OrderSide.SELL:
            self.slippage = self.trigger_price.as_f64_c() - self.avg_px

    cdef bint has_price_c(self):
        return False

    cdef bint has_trigger_price_c(self):
        return True

    @property
    def expire_time(self):
        """
        Return the expire time for the order (UTC).

        Returns
        -------
        datetime or ``None``

        """
        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {unix_nanos_to_iso8601(self.expire_time_ns, nanos_precision=False)}"
        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)} @ {self.trigger_price.to_formatted_str()}"
            f"[{trigger_type_to_str(self.trigger_type)}] "
            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
            f"{emulation_str}"
        )

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "trigger_price": str(self.trigger_price),
            "trigger_type": trigger_type_to_str(self.trigger_type),
            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "status": self._fsm.state_string_c(),
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef StopMarketOrder create_c(OrderInitialized init):
        """
        Return a `Stop-Market` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        StopMarketOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``STOP_MARKET``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.STOP_MARKET, "init.order_type", "OrderType")
        return StopMarketOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            trigger_price=Price.from_str_c(init.options["trigger_price"]),
            trigger_type=trigger_type_from_str(init.options["trigger_type"]),
            init_id=init.id,
            ts_init=init.ts_init,
            time_in_force=init.time_in_force,
            expire_time_ns=init.options["expire_time_ns"] if init.options["expire_time_ns"] is not None else 0,
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            emulation_trigger=init.emulation_trigger,
            trigger_instrument_id=init.trigger_instrument_id,
            contingency_type=init.contingency_type,
            order_list_id=init.order_list_id,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(init):
        return StopMarketOrder.create_c(init)

</document_content>
</document>
<document index="2468">
<source>nautilus_trader/model/orders/trailing_stop_limit.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.datetime cimport unix_nanos_to_iso8601
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trailing_offset_type_from_str
from nautilus_trader.model.functions cimport trailing_offset_type_to_str
from nautilus_trader.model.functions cimport trigger_type_from_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class TrailingStopLimitOrder(Order):
    """
    Represents a `Trailing-Stop-Limit` conditional order.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    price : Price or ``None``
        The order price (LIMIT). If ``None`` then will typically default to the
        delta of market price and `limit_offset`.
    trigger_price : Price or ``None``
        The order trigger price (STOP). If ``None`` then will typically default
        to the delta of market price and `trailing_offset`.
    trigger_type : TriggerType
        The order trigger type.
    limit_offset : Decimal
        The trailing offset for the order price (LIMIT).
    trailing_offset : Decimal
        The trailing offset for the order trigger price (STOP).
    trailing_offset_type : TrailingOffsetType
        The order trailing offset type.
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    activation_price : Price, optional
        The price for the order to become active. If ``None`` then the order will be activated right after the order is accepted.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
        The order time in force.
    expire_time_ns : uint64_t, default 0 (no expiry)
        UNIX timestamp (nanoseconds) when the order will expire.
    post_only : bool, default False
        If the ``LIMIT`` order will only provide liquidity (once triggered).
    reduce_only : bool, default False
        If the ``LIMIT`` order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    display_qty : Quantity, optional
        The quantity of the ``LIMIT`` order to display on the public book (iceberg).
    emulation_trigger : TriggerType, default ``NO_TRIGGER``
        The type of market price trigger to use for local order emulation.
        - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
        - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
        Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
    trigger_instrument_id : InstrumentId, optional
        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `trigger_type` is ``NO_TRIGGER``.
    ValueError
        If `trailing_offset_type` is ``NO_TRAILING_OFFSET``.
    ValueError
        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
    ValueError
        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
    ValueError
        If `display_qty` is negative (< 0) or greater than `quantity`.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        Price price: Price | None,
        Price trigger_price: Price | None,
        TriggerType trigger_type,
        limit_offset: Decimal,
        trailing_offset: Decimal,
        TrailingOffsetType trailing_offset_type,
        UUID4 init_id not None,
        uint64_t ts_init,
        Price activation_price: Price | None = None,
        TimeInForce time_in_force = TimeInForce.GTC,
        uint64_t expire_time_ns = 0,
        bint post_only = False,
        bint reduce_only = False,
        bint quote_quantity = False,
        Quantity display_qty = None,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
        Condition.not_equal(trailing_offset_type, TrailingOffsetType.NO_TRAILING_OFFSET, "trailing_offset_type", "NO_TRAILING_OFFSET")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")

        if time_in_force == TimeInForce.GTD:
            # Must have an expire time
            Condition.is_true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
        else:
            # Should not have an expire time
            Condition.is_true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
        Condition.is_true(
            display_qty is None or 0 <= display_qty <= quantity,
            fail_msg="`display_qty` was negative or greater than `quantity`",
        )

        # Set options
        cdef dict options = {
            "price": str(price) if price is not None else None,
            "activation_price": str(activation_price) if activation_price is not None else None,
            "trigger_price": str(trigger_price) if trigger_price is not None else None,
            "trigger_type": trigger_type_to_str(trigger_type),
            "limit_offset": str(limit_offset),
            "trailing_offset": str(trailing_offset),
            "trailing_offset_type": trailing_offset_type_to_str(trailing_offset_type),
            "expire_time_ns": expire_time_ns,
            "display_qty": str(display_qty) if display_qty is not None else None,
        }

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.TRAILING_STOP_LIMIT,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=post_only,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options=options,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

        self.price = price
        self.activation_price = activation_price
        self.trigger_price = trigger_price
        self.trigger_type = trigger_type
        self.limit_offset = limit_offset
        self.trailing_offset = trailing_offset
        self.trailing_offset_type = trailing_offset_type
        self.expire_time_ns = expire_time_ns
        self.display_qty = display_qty
        self.is_activated = False
        self.is_triggered = False
        self.ts_triggered = 0

    cdef void _updated(self, OrderUpdated event):
        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
            self._venue_order_ids.append(self.venue_order_id)
            self.venue_order_id = event.venue_order_id
        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
        if event.price is not None:
            self.price = event.price
        if event.trigger_price is not None:
            self.trigger_price = event.trigger_price

    cdef void _triggered(self, OrderTriggered event):
        self.is_triggered = True
        self.ts_triggered = event.ts_event

    cdef void _set_slippage(self):
        if self.side == OrderSide.BUY:
            self.slippage = self.avg_px - self.price.as_f64_c()
        elif self.side == OrderSide.SELL:
            self.slippage = self.price.as_f64_c() - self.avg_px

    cdef void set_activated_c(self, Price activation_price):
        # NOTE: In current design, 'activated' is not considered a state change,
        # 'activated' is just included in ACCEPTED state.

        Condition.is_false(self.is_activated, "set_activated() is invoked when already activated", RuntimeError)
        if self.activation_price is None:
            Condition.not_none(activation_price, "activation_price")
            self.activation_price = activation_price
        else:
            Condition.none(activation_price, "activation_price")

        self.is_activated = True

    cdef bint has_price_c(self):
        return self.price is not None

    cdef bint has_activation_price_c(self):
        return self.activation_price is not None

    cdef bint has_trigger_price_c(self):
        return self.trigger_price is not None

    @property
    def expire_time(self):
        """
        Return the expire time for the order (UTC).

        Returns
        -------
        datetime or ``None``

        """
        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {unix_nanos_to_iso8601(self.expire_time_ns, nanos_precision=False)}"
        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)}[{trigger_type_to_str(self.trigger_type)}] "
            f"{'@ ' + self.activation_price.to_formatted_str() + '-ACTIVATION ' if self.activation_price else ''}"
            f"{'@ ' + self.trigger_price.to_formatted_str() + '-STOP ' if self.trigger_price else ''}"
            f"[{trigger_type_to_str(self.trigger_type)}] {self.price.to_formatted_str() if self.price else None}-LIMIT "
            f"{self.trailing_offset}-TRAILING_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
            f"{self.limit_offset}-LIMIT_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
            f"{emulation_str}"
        )

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "price": str(self.price) if self.price is not None else None,
            "activation_price": str(self.activation_price) if self.activation_price is not None else None,
            "trigger_price": str(self.trigger_price) if self.trigger_price is not None else None,
            "trigger_type": trigger_type_to_str(self.trigger_type),
            "limit_offset": str(self.limit_offset),
            "trailing_offset": str(self.trailing_offset),
            "trailing_offset_type": trailing_offset_type_to_str(self.trailing_offset_type),
            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "status": self._fsm.state_string_c(),
            "is_post_only": self.is_post_only,
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef TrailingStopLimitOrder create_c(OrderInitialized init):
        """
        Return a `Trailing-Stop-Limit` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        TrailingStopLimitOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``TRAILING_STOP_LIMIT``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.TRAILING_STOP_LIMIT, "init.order_type", "OrderType")

        cdef str price_str = init.options.get("price")
        cdef str activation_price_str = init.options.get("activation_price")
        cdef str trigger_price_str = init.options.get("trigger_price")
        cdef str display_qty_str = init.options.get("display_qty")

        return TrailingStopLimitOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            price=Price.from_str_c(price_str) if price_str is not None else None,
            activation_price=Price.from_str_c(activation_price_str) if activation_price_str is not None else None,
            trigger_price=Price.from_str_c(trigger_price_str) if trigger_price_str is not None else None,
            trigger_type=trigger_type_from_str(init.options["trigger_type"]),
            limit_offset=Decimal(init.options["limit_offset"]),
            trailing_offset=Decimal(init.options["trailing_offset"]),
            trailing_offset_type=trailing_offset_type_from_str(init.options["trailing_offset_type"]),
            time_in_force=init.time_in_force,
            expire_time_ns=init.options["expire_time_ns"],
            init_id=init.id,
            ts_init=init.ts_init,
            post_only=init.post_only,
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
            emulation_trigger=init.emulation_trigger,
            trigger_instrument_id=init.trigger_instrument_id,
            contingency_type=init.contingency_type,
            order_list_id=init.order_list_id,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(init):
        return TrailingStopLimitOrder.create_c(init)

</document_content>
</document>
<document index="2470">
<source>nautilus_trader/model/orders/trailing_stop_market.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.datetime cimport unix_nanos_to_iso8601
from nautilus_trader.core.rust.model cimport ContingencyType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.functions cimport contingency_type_to_str
from nautilus_trader.model.functions cimport liquidity_side_to_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport time_in_force_to_str
from nautilus_trader.model.functions cimport trailing_offset_type_from_str
from nautilus_trader.model.functions cimport trailing_offset_type_to_str
from nautilus_trader.model.functions cimport trigger_type_from_str
from nautilus_trader.model.functions cimport trigger_type_to_str
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport OrderListId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order


cdef class TrailingStopMarketOrder(Order):
    """
    Represents a `Trailing-Stop-Market` conditional order.

    Parameters
    ----------
    trader_id : TraderId
        The trader ID associated with the order.
    strategy_id : StrategyId
        The strategy ID associated with the order.
    instrument_id : InstrumentId
        The order instrument ID.
    client_order_id : ClientOrderId
        The client order ID.
    order_side : OrderSide {``BUY``, ``SELL``}
        The order side.
    quantity : Quantity
        The order quantity (> 0).
    trigger_price : Price or ``None``
        The order trigger price (STOP). If ``None`` then will typically default
        to the delta of market price and `trailing_offset`.
    trigger_type : TriggerType
        The order trigger type.
    trailing_offset : Decimal
        The trailing offset for the trigger price (STOP).
    trailing_offset_type : TrailingOffsetType
        The order trailing offset type.
    init_id : UUID4
        The order initialization event ID.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    activation_price : Price, optional
        The price for the order to become active. If ``None`` then the order will be activated right after the order is accepted.
    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
        The order time in force.
    expire_time_ns : uint64_t, default 0 (no expiry)
        UNIX timestamp (nanoseconds) when the order will expire.
    reduce_only : bool, default False
        If the order carries the 'reduce-only' execution instruction.
    quote_quantity : bool, default False
        If the order quantity is denominated in the quote currency.
    emulation_trigger : TriggerType, default ``NO_TRIGGER``
        The type of market price trigger to use for local order emulation.
        - ``NO_TRIGGER`` (default): Disables local emulation; orders are sent directly to the venue.
        - ``DEFAULT`` (the same as ``BID_ASK``): Enables local order emulation by triggering orders based on bid/ask prices.
        Additional trigger types are available. See the "Emulated Orders" section in the documentation for more details.
    trigger_instrument_id : InstrumentId, optional
        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
        The order contingency type.
    order_list_id : OrderListId, optional
        The order list ID associated with the order.
    linked_order_ids : list[ClientOrderId], optional
        The order linked client order ID(s).
    parent_order_id : ClientOrderId, optional
        The order parent client order ID.
    exec_algorithm_id : ExecAlgorithmId, optional
        The execution algorithm ID for the order.
    exec_algorithm_params : dict[str, Any], optional
        The execution algorithm parameters for the order.
    exec_spawn_id : ClientOrderId, optional
        The execution algorithm spawning primary client order ID.
    tags : list[str], optional
        The custom user tags for the order.

    Raises
    ------
    ValueError
        If `order_side` is ``NO_ORDER_SIDE``.
    ValueError
        If `quantity` is not positive (> 0).
    ValueError
        If `trigger_type` is ``NO_TRIGGER``.
    ValueError
        If `trailing_offset_type` is ``NO_TRAILING_OFFSET``.
    ValueError
        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
    ValueError
        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
    """

    def __init__(
        self,
        TraderId trader_id not None,
        StrategyId strategy_id not None,
        InstrumentId instrument_id not None,
        ClientOrderId client_order_id not None,
        OrderSide order_side,
        Quantity quantity not None,
        Price trigger_price: Price | None,
        TriggerType trigger_type,
        trailing_offset: Decimal,
        TrailingOffsetType trailing_offset_type,
        UUID4 init_id not None,
        uint64_t ts_init,
        Price activation_price: Price | None = None,
        TimeInForce time_in_force = TimeInForce.GTC,
        uint64_t expire_time_ns = 0,
        bint reduce_only = False,
        bint quote_quantity = False,
        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
        InstrumentId trigger_instrument_id = None,
        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
        OrderListId order_list_id = None,
        list linked_order_ids = None,
        ClientOrderId parent_order_id = None,
        ExecAlgorithmId exec_algorithm_id = None,
        dict exec_algorithm_params = None,
        ClientOrderId exec_spawn_id = None,
        list[str] tags = None,
    ):
        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
        Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
        Condition.not_equal(trailing_offset_type, TrailingOffsetType.NO_TRAILING_OFFSET, "trailing_offset_type", "NO_TRAILING_OFFSET")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")

        if time_in_force == TimeInForce.GTD:
            # Must have an expire time
            Condition.is_true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
        else:
            # Should not have an expire time
            Condition.is_true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")

        # Set options
        cdef dict options = {
            "activation_price": str(activation_price) if activation_price is not None else None,
            "trigger_price": str(trigger_price) if trigger_price is not None else None,
            "trigger_type": trigger_type_to_str(trigger_type),
            "trailing_offset": str(trailing_offset),
            "trailing_offset_type": trailing_offset_type_to_str(trailing_offset_type),
            "expire_time_ns": expire_time_ns,
        }

        # Create initialization event
        cdef OrderInitialized init = OrderInitialized(
            trader_id=trader_id,
            strategy_id=strategy_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_side=order_side,
            order_type=OrderType.TRAILING_STOP_MARKET,
            quantity=quantity,
            time_in_force=time_in_force,
            post_only=False,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            options=options,
            emulation_trigger=emulation_trigger,
            trigger_instrument_id=trigger_instrument_id,
            contingency_type=contingency_type,
            order_list_id=order_list_id,
            linked_order_ids=linked_order_ids,
            parent_order_id=parent_order_id,
            exec_algorithm_id=exec_algorithm_id,
            exec_algorithm_params=exec_algorithm_params,
            exec_spawn_id=exec_spawn_id,
            tags=tags,
            event_id=init_id,
            ts_init=ts_init,
        )
        super().__init__(init=init)

        self.activation_price = activation_price
        self.trigger_price = trigger_price
        self.trigger_type = trigger_type
        self.trailing_offset = trailing_offset
        self.trailing_offset_type = trailing_offset_type
        self.expire_time_ns = expire_time_ns
        self.is_activated = False


    cdef void _updated(self, OrderUpdated event):
        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
            self._venue_order_ids.append(self.venue_order_id)
            self.venue_order_id = event.venue_order_id
        if event.quantity is not None:
            self.quantity = event.quantity
            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
        if event.trigger_price is not None:
            self.trigger_price = event.trigger_price

    cdef void _set_slippage(self):
        if self.trigger_price is None:
            return  # Prevents an attribute error below

        if self.side == OrderSide.BUY:
            self.slippage = self.avg_px - self.trigger_price.as_f64_c()
        elif self.side == OrderSide.SELL:
            self.slippage = self.trigger_price.as_f64_c() - self.avg_px

    cdef void set_activated_c(self, Price activation_price):
        # NOTE: In current design, 'activated' is not considered a state change,
        # 'activated' is just included in ACCEPTED state.

        Condition.is_false(self.is_activated, "set_activated() is invoked when already activated", RuntimeError)
        if self.activation_price is None:
            Condition.not_none(activation_price, "activation_price")
            self.activation_price = activation_price
        else:
            Condition.none(activation_price, "activation_price")

        self.is_activated = True

    cdef bint has_price_c(self):
        return False

    cdef bint has_activation_price_c(self):
        return self.activation_price is not None

    cdef bint has_trigger_price_c(self):
        return self.trigger_price is not None

    @property
    def expire_time(self):
        """
        Return the expire time for the order (UTC).

        Returns
        -------
        datetime or ``None``

        """
        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)

    cpdef str info(self):
        """
        Return a summary description of the order.

        Returns
        -------
        str

        """
        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {unix_nanos_to_iso8601(self.expire_time_ns, nanos_precision=False)}"
        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
        return (
            f"{order_side_to_str(self.side)} {self.quantity.to_formatted_str()} {self.instrument_id} "
            f"{order_type_to_str(self.order_type)}[{trigger_type_to_str(self.trigger_type)}] "
            f"{'@ ' + self.activation_price.to_formatted_str() + '-ACTIVATION ' if self.activation_price else ''}"
            f"{'@ ' + self.trigger_price.to_formatted_str() + '-STOP ' if self.trigger_price else ''}"
            f"{self.trailing_offset}-TRAILING_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
            f"{emulation_str}"
        )

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        cdef ClientOrderId o
        return {
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "client_order_id": self.client_order_id.to_str(),
            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
            "position_id": self.position_id.to_str() if self.position_id is not None else None,
            "account_id": self.account_id.to_str() if self.account_id is not None else None,
            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
            "type": order_type_to_str(self.order_type),
            "side": order_side_to_str(self.side),
            "quantity": str(self.quantity),
            "activation_price": str(self.activation_price) if self.activation_price is not None else None,
            "trigger_price": str(self.trigger_price) if self.trigger_price is not None else None,
            "trigger_type": trigger_type_to_str(self.trigger_type),
            "trailing_offset": str(self.trailing_offset),
            "trailing_offset_type": trailing_offset_type_to_str(self.trailing_offset_type),
            "expire_time_ns": self.expire_time_ns if self.expire_time_ns > 0 else None,
            "time_in_force": time_in_force_to_str(self.time_in_force),
            "filled_qty": str(self.filled_qty),
            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
            "avg_px": self.avg_px if self.filled_qty.as_f64_c() > 0.0 else None,
            "slippage": self.slippage if self.filled_qty.as_f64_c() > 0.0 else None,
            "commissions": [str(c) for c in self.commissions()] if self._commissions else None,
            "status": self._fsm.state_string_c(),
            "is_reduce_only": self.is_reduce_only,
            "is_quote_quantity": self.is_quote_quantity,
            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
            "contingency_type": contingency_type_to_str(self.contingency_type),
            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
            "linked_order_ids": [o.to_str() for o in self.linked_order_ids] if self.linked_order_ids is not None else None,  # noqa
            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
            "exec_algorithm_params": self.exec_algorithm_params,
            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
            "tags": self.tags,
            "init_id": str(self.init_id),
            "ts_init": self.ts_init,
            "ts_last": self.ts_last,
        }

    @staticmethod
    cdef TrailingStopMarketOrder create_c(OrderInitialized init):
        """
        Return a `Trailing-Stop-Market` order from the given initialized event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        TrailingStopMarketOrder

        Raises
        ------
        ValueError
            If `init.order_type` is not equal to ``TRAILING_STOP_MARKET``.

        """
        Condition.not_none(init, "init")
        Condition.equal(init.order_type, OrderType.TRAILING_STOP_MARKET, "init.order_type", "OrderType")

        cdef str activation_price_str = init.options.get("activation_price")
        cdef str trigger_price_str = init.options.get("trigger_price")

        return TrailingStopMarketOrder(
            trader_id=init.trader_id,
            strategy_id=init.strategy_id,
            instrument_id=init.instrument_id,
            client_order_id=init.client_order_id,
            order_side=init.side,
            quantity=init.quantity,
            activation_price=Price.from_str_c(activation_price_str) if activation_price_str is not None else None,
            trigger_price=Price.from_str_c(trigger_price_str) if trigger_price_str is not None else None,
            trigger_type=trigger_type_from_str(init.options["trigger_type"]),
            trailing_offset=Decimal(init.options["trailing_offset"]),
            trailing_offset_type=trailing_offset_type_from_str(init.options["trailing_offset_type"]),
            time_in_force=init.time_in_force,
            expire_time_ns=init.options["expire_time_ns"],
            init_id=init.id,
            ts_init=init.ts_init,
            reduce_only=init.reduce_only,
            quote_quantity=init.quote_quantity,
            emulation_trigger=init.emulation_trigger,
            trigger_instrument_id=init.trigger_instrument_id,
            contingency_type=init.contingency_type,
            order_list_id=init.order_list_id,
            linked_order_ids=init.linked_order_ids,
            parent_order_id=init.parent_order_id,
            exec_algorithm_id=init.exec_algorithm_id,
            exec_algorithm_params=init.exec_algorithm_params,
            exec_spawn_id=init.exec_spawn_id,
            tags=init.tags,
        )

    @staticmethod
    def create(init):
        return TrailingStopMarketOrder.create_c(init)

</document_content>
</document>
<document index="2472">
<source>nautilus_trader/model/orders/unpacker.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.limit cimport LimitOrder
from nautilus_trader.model.orders.limit_if_touched cimport LimitIfTouchedOrder
from nautilus_trader.model.orders.market cimport MarketOrder
from nautilus_trader.model.orders.market_if_touched cimport MarketIfTouchedOrder
from nautilus_trader.model.orders.market_to_limit cimport MarketToLimitOrder
from nautilus_trader.model.orders.stop_limit cimport StopLimitOrder
from nautilus_trader.model.orders.stop_market cimport StopMarketOrder
from nautilus_trader.model.orders.trailing_stop_limit cimport TrailingStopLimitOrder
from nautilus_trader.model.orders.trailing_stop_market cimport TrailingStopMarketOrder


cdef class OrderUnpacker:
    """
    Provides a means of unpacking orders from value dictionaries.
    """

    @staticmethod
    cdef Order unpack_c(dict values):
        Condition.not_none(values, "values")

        return OrderUnpacker.from_init_c(OrderInitialized.from_dict_c(values))

    @staticmethod
    cdef Order from_init_c(OrderInitialized init):
        if init.order_type == OrderType.MARKET:
            return MarketOrder.create_c(init=init)
        elif init.order_type == OrderType.LIMIT:
            return LimitOrder.create_c(init=init)
        elif init.order_type == OrderType.STOP_MARKET:
            return StopMarketOrder.create_c(init=init)
        elif init.order_type == OrderType.STOP_LIMIT:
            return StopLimitOrder.create_c(init=init)
        elif init.order_type == OrderType.MARKET_TO_LIMIT:
            return MarketToLimitOrder.create_c(init=init)
        elif init.order_type == OrderType.MARKET_IF_TOUCHED:
            return MarketIfTouchedOrder.create_c(init=init)
        elif init.order_type == OrderType.LIMIT_IF_TOUCHED:
            return LimitIfTouchedOrder.create_c(init=init)
        elif init.order_type == OrderType.TRAILING_STOP_MARKET:
            return TrailingStopMarketOrder.create_c(init=init)
        elif init.order_type == OrderType.TRAILING_STOP_LIMIT:
            return TrailingStopLimitOrder.create_c(init=init)
        else:
            raise RuntimeError("invalid `OrderType`")  # pragma: no cover (design-time error)

    @staticmethod
    def unpack(dict values) -> Order:
        """
        Return an order unpacked from the given values.

        Parameters
        ----------
        values : dict[str, object]

        Returns
        -------
        Order

        """
        return OrderUnpacker.unpack_c(values)

    @staticmethod
    def from_init(OrderInitialized init) -> Order:
        """
        Return an order initialized from the given event.

        Parameters
        ----------
        init : OrderInitialized
            The event to initialize with.

        Returns
        -------
        Order

        """
        return OrderUnpacker.from_init_c(init)

</document_content>
</document>
<document index="2474">
<source>nautilus_trader/model/position.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from libc.math cimport fabs
from libc.math cimport fmin

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.position cimport PositionAdjusted
from nautilus_trader.model.events.position cimport PositionAdjustmentType
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport position_side_to_str
from nautilus_trader.model.identifiers cimport TradeId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class Position:
    """
    Represents a position in a market.

    The position ID may be assigned at the trading venue, or can be system
    generated depending on a strategies OMS (Order Management System) settings.

    Parameters
    ----------
    instrument : Instrument
        The trading instrument for the position.
    fill : OrderFilled
        The order fill event which opened the position.

    Raises
    ------
    ValueError
        If `instrument.id` is not equal to `fill.instrument_id`.
    ValueError
        If `fill.position_id` is ``None``.
    """

    def __init__(
        self,
        Instrument instrument not None,
        OrderFilled fill not None,
    ) -> None:
        Condition.equal(instrument.id, fill.instrument_id, "instrument.id", "fill.instrument_id")
        Condition.not_none(fill.position_id, "fill.position_id")

        self._events: list[OrderFilled] = []
        self._adjustments: list = []
        self._trade_ids: list[TradeId] = []
        self._buy_qty = Quantity.zero_c(precision=instrument.size_precision)
        self._sell_qty = Quantity.zero_c(precision=instrument.size_precision)
        self._commissions = {}

        # Identifiers
        self.trader_id = fill.trader_id
        self.strategy_id = fill.strategy_id
        self.instrument_id = fill.instrument_id
        self.id = fill.position_id
        self.account_id = fill.account_id
        self.opening_order_id = fill.client_order_id
        self.closing_order_id = None

        # Properties
        self.entry = fill.order_side
        self.side = Position.side_from_order_side(fill.order_side)
        self.signed_qty = 0.0
        self.quantity = Quantity.zero_c(precision=instrument.size_precision)
        self.peak_qty = Quantity.zero_c(precision=instrument.size_precision)
        self.ts_init = fill.ts_init
        self.ts_opened = fill.ts_event
        self.ts_last = fill.ts_event
        self.ts_closed = 0
        self.duration_ns = 0
        self.avg_px_open = fill.last_px.as_f64_c()
        self.avg_px_close = 0.0
        self.price_precision = instrument.price_precision
        self.size_precision = instrument.size_precision
        self.multiplier = instrument.multiplier
        self.is_inverse = instrument.is_inverse
        self.is_spot_currency = isinstance(instrument, CurrencyPair)
        self.instrument_class = instrument.instrument_class
        self.quote_currency = instrument.quote_currency
        self.base_currency = instrument.get_base_currency()  # Can be None
        self.settlement_currency = instrument.get_cost_currency()  # TBD handling quanto

        self.realized_return = 0.0
        self.realized_pnl = None

        self.apply(fill)

    def __eq__(self, Position other) -> bool:
        if other is None:
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self.info()}, id={self.id})"

    def purge_events_for_order(self, ClientOrderId client_order_id) -> None:
        """
        Purge all order events for the given client order ID.

        After purging, the position is rebuilt from remaining fills. If no fills
        remain, the position is reset to an empty shell with all history cleared
        (including timestamps), making it eligible for immediate cache cleanup.

        Parameters
        ----------
        client_order_id : ClientOrderId
            The client order ID for the events to purge.

        """
        Condition.not_none(client_order_id, "client_order_id")

        cdef list[OrderFilled] remaining_events = [
            event for event in self._events
            if event.client_order_id != client_order_id
        ]

        # Preserve non-commission adjustments (funding, manual adjustments, etc.)
        # Commission adjustments will be automatically re-created when fills are replayed
        cdef list preserved_adjustments = [
            adj for adj in self._adjustments
            if adj.adjustment_type != PositionAdjustmentType.COMMISSION
        ]

        self._events.clear()
        self._trade_ids.clear()
        self._adjustments.clear()

        # If no fills remain, reset to flat state clearing all history
        if not remaining_events:
            self._buy_qty = Quantity.zero_c(precision=self.size_precision)
            self._sell_qty = Quantity.zero_c(precision=self.size_precision)
            self._commissions = {}
            self.signed_qty = 0.0
            self.quantity = Quantity.zero_c(precision=self.size_precision)
            self.side = PositionSide.FLAT
            self.avg_px_close = 0.0
            self.realized_pnl = None
            self.realized_return = 0.0
            self.ts_opened = 0
            self.ts_last = 0
            self.ts_closed = 0
            self.duration_ns = 0
            return

        self.side = PositionSide.FLAT
        self.signed_qty = 0.0

        # Reapply all remaining fills to reconstruct state
        cdef OrderFilled event
        for event in remaining_events:
            self.apply(event)

        # Reapply preserved adjustments to maintain full state
        cdef PositionAdjusted adjustment
        for adjustment in preserved_adjustments:
            self.apply_adjustment(adjustment)

    cpdef str info(self):
        """
        Return a summary description of the position.

        Returns
        -------
        str

        """
        cdef str quantity = " " if self.quantity._mem.raw == 0 else f" {self.quantity.to_formatted_str()} "
        return f"{position_side_to_str(self.side)}{quantity}{self.instrument_id}"

    cpdef dict to_dict(self):
        """
        Return a dictionary representation of this object.

        Returns
        -------
        dict[str, object]

        """
        return {
            "position_id": self.id.to_str(),
            "trader_id": self.trader_id.to_str(),
            "strategy_id": self.strategy_id.to_str(),
            "instrument_id": self.instrument_id.to_str(),
            "account_id": self.account_id.to_str(),
            "opening_order_id": self.opening_order_id.to_str(),
            "closing_order_id": self.closing_order_id.to_str() if self.closing_order_id is not None else None,
            "entry": order_side_to_str(self.entry),
            "side": position_side_to_str(self.side),
            "signed_qty": self.signed_qty,
            "quantity": str(self.quantity),
            "peak_qty": str(self.peak_qty),
            "ts_init": self.ts_init,
            "ts_opened": self.ts_opened,
            "ts_last": self.ts_last,
            "ts_closed": self.ts_closed if self.ts_closed > 0 else None,
            "duration_ns": self.duration_ns if self.duration_ns > 0 else None,
            "avg_px_open": self.avg_px_open,
            "avg_px_close": self.avg_px_close if self.avg_px_close > 0 else None,
            "quote_currency": self.quote_currency.code,
            "base_currency": self.base_currency.code if self.base_currency is not None else None,
            "settlement_currency": self.settlement_currency.code,
            "commissions": sorted([str(c) for c in self.commissions()]),
            "realized_return": round(self.realized_return, 5),
            "realized_pnl": str(self.realized_pnl),
        }

    cdef list client_order_ids_c(self):
        # Note the inner set {}
        return sorted(list({fill.client_order_id for fill in self._events}))

    cdef list venue_order_ids_c(self):
        # Note the inner set {}
        return sorted(list({fill.venue_order_id for fill in self._events}))

    cdef list trade_ids_c(self):
        # Checked for duplicate before appending to events
        return [fill.trade_id for fill in self._events]

    cdef list events_c(self):
        return self._events.copy()

    cdef list adjustments_c(self):
        return self._adjustments.copy()

    cdef OrderFilled last_event_c(self):
        return self._events[-1] if self._events else None

    cdef TradeId last_trade_id_c(self):
        return self._events[-1].trade_id if self._events else None

    cdef bint has_trade_id_c(self, TradeId trade_id):
        Condition.not_none(trade_id, "trade_id")
        return trade_id in self._trade_ids

    cdef int event_count_c(self):
        return len(self._events)

    cdef bint is_open_c(self):
        return self.side != PositionSide.FLAT

    cdef bint is_closed_c(self):
        return self.side == PositionSide.FLAT

    cdef bint is_long_c(self):
        return self.side == PositionSide.LONG

    cdef bint is_short_c(self):
        return self.side == PositionSide.SHORT

    @property
    def symbol(self):
        """
        Return the positions ticker symbol.

        Returns
        -------
        Symbol

        """
        return self.instrument_id.symbol

    @property
    def venue(self):
        """
        Return the positions trading venue.

        Returns
        -------
        Venue

        """
        return self.instrument_id.venue

    @property
    def client_order_ids(self):
        """
        Return the client order IDs associated with the position.

        Returns
        -------
        list[ClientOrderId]

        Notes
        -----
        Guaranteed not to contain duplicate IDs.

        """
        return self.client_order_ids_c()

    @property
    def venue_order_ids(self):
        """
        Return the venue order IDs associated with the position.

        Returns
        -------
        list[VenueOrderId]

        Notes
        -----
        Guaranteed not to contain duplicate IDs.

        """
        return self.venue_order_ids_c()

    @property
    def trade_ids(self):
        """
        Return the trade match IDs associated with the position.

        Returns
        -------
        list[TradeId]

        """
        return self.trade_ids_c()

    @property
    def events(self):
        """
        Return the order fill events for the position.

        Returns
        -------
        list[Event]

        """
        return self.events_c()

    @property
    def adjustments(self):
        """
        Return the position adjustment events.

        Returns
        -------
        list[PositionAdjusted]

        """
        return self.adjustments_c()

    @property
    def last_event(self):
        """
        Return the last order fill event (if any after purging).

        Returns
        -------
        OrderFilled or ``None``

        """
        return self.last_event_c()

    @property
    def last_trade_id(self):
        """
        Return the last trade match ID for the position (if any after purging).

        Returns
        -------
        TradeId or ``None``

        """
        return self.last_trade_id_c()

    @property
    def event_count(self):
        """
        Return the count of order fill events applied to the position.

        Returns
        -------
        int

        """
        return self.event_count_c()

    @property
    def is_open(self):
        """
        Return whether the position side is **not** ``FLAT``.

        Returns
        -------
        bool

        """
        return self.is_open_c()

    @property
    def is_closed(self):
        """
        Return whether the position side is ``FLAT``.

        Returns
        -------
        bool

        """
        return self.is_closed_c()

    @property
    def is_long(self):
        """
        Return whether the position side is ``LONG``.

        Returns
        -------
        bool

        """
        return self.is_long_c()

    @property
    def is_short(self):
        """
        Return whether the position side is ``SHORT``.

        Returns
        -------
        bool

        """
        return self.is_short_c()

    @staticmethod
    cdef PositionSide side_from_order_side_c(OrderSide side):
        if side == OrderSide.BUY:
            return PositionSide.LONG
        elif side == OrderSide.SELL:
            return PositionSide.SHORT
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `OrderSide`, was {side}",  # pragma: no cover (design-time error)
            )


    @staticmethod
    def side_from_order_side(OrderSide side):
        """
        Return the position side resulting from the given order side (from ``FLAT``).

        Parameters
        ----------
        side : OrderSide {``BUY``, ``SELL``}
            The order side

        Returns
        -------
        PositionSide

        """
        return Position.side_from_order_side_c(side)

    cpdef OrderSide closing_order_side(self):
        """
        Return the closing order side for the position.

        If the position is ``FLAT`` then will return ``NO_ORDER_SIDE``.

        Returns
        -------
        OrderSide

        """
        if self.side == PositionSide.LONG:
            return OrderSide.SELL
        elif self.side == PositionSide.SHORT:
            return OrderSide.BUY
        else:
            return OrderSide.NO_ORDER_SIDE

    cpdef signed_decimal_qty(self):
        """
        Return a signed decimal representation of the position quantity.

         - If the position is LONG, the value is positive (e.g. Decimal('10.25'))
         - If the position is SHORT, the value is negative (e.g. Decimal('-10.25'))
         - If the position is FLAT, the value is zero (e.g. Decimal('0'))

        Returns
        -------
        Decimal

        """
        return Decimal(f"{self.signed_qty:.{self.size_precision}f}")

    cpdef bint is_opposite_side(self, OrderSide side):
        """
        Return a value indicating whether the given order side is opposite to
        the current position side.

        Parameters
        ----------
        side : OrderSide {``BUY``, ``SELL``}

        Returns
        -------
        bool
            True if side is opposite, else False.

        """
        return self.side != Position.side_from_order_side_c(side)

    cpdef void apply(self, OrderFilled fill):
        """
        Applies the given order fill event to the position.

        If the position is FLAT prior to applying `fill`, the position state is reset
        (clearing existing events, commissions, etc.) before processing the new fill.

        Parameters
        ----------
        fill : OrderFilled
            The order fill event to apply.

        Raises
        ------
        KeyError
            If `fill.trade_id` already applied to the position.

        """
        Condition.not_none(fill, "fill")
        self._check_duplicate_trade_id(fill)

        # Reopening position after close, reset to initial state
        if self.side == PositionSide.FLAT:
            self._events.clear()
            self._trade_ids.clear()
            self._adjustments.clear()
            self._buy_qty = Quantity.zero_c(precision=self.size_precision)
            self._sell_qty = Quantity.zero_c(precision=self.size_precision)
            self._commissions = {}
            self.opening_order_id = fill.client_order_id
            self.closing_order_id = None
            self.peak_qty = Quantity.zero_c(precision=self.size_precision)
            self.ts_init = fill.ts_init
            self.ts_opened = fill.ts_event
            self.ts_closed = 0
            self.duration_ns = 0
            self.avg_px_open = fill.last_px.as_f64_c()
            self.avg_px_close = 0.0
            self.realized_return = 0.0
            self.realized_pnl = None

        self._events.append(fill)
        self._trade_ids.append(fill.trade_id)

        # Accumulate commission in its currency
        cdef Currency currency = fill.commission.currency
        cdef Money commissions = self._commissions.get(currency)
        cdef double total_commissions = commissions.as_f64_c() if commissions is not None else 0.0
        self._commissions[currency] = Money(total_commissions + fill.commission.as_f64_c(), currency)

        if fill.order_side == OrderSide.BUY:
            self._handle_buy_order_fill(fill)
        elif fill.order_side == OrderSide.SELL:
            self._handle_sell_order_fill(fill)
        else:
            raise ValueError(  # pragma: no cover (design-time error)
                f"invalid `OrderSide`, was {fill.order_side}",  # pragma: no cover (design-time error)
            )

        # For CurrencyPair instruments, create adjustment event when commission is in base currency
        if (
            self.is_spot_currency
            and self.base_currency is not None
            and fill.commission is not None
            and fill.commission.currency == self.base_currency
        ):
            adjustment = PositionAdjusted(
                self.trader_id,
                self.strategy_id,
                self.instrument_id,
                self.id,
                self.account_id,
                PositionAdjustmentType.COMMISSION,
                fill.commission.as_decimal(),
                None,
                str(fill.client_order_id),
                UUID4(),
                fill.ts_event,
                fill.ts_init,
            )
            self.apply_adjustment(adjustment)

        # Update quantity, peak quantity, and position side
        self.quantity = Quantity(abs(self.signed_qty), self.size_precision)
        if self.quantity._mem.raw > self.peak_qty._mem.raw:
            self.peak_qty = self.quantity

        if self.signed_qty > 0.0:
            self.entry = OrderSide.BUY
            self.side = PositionSide.LONG
        elif self.signed_qty < 0.0:
            self.entry = OrderSide.SELL
            self.side = PositionSide.SHORT
        else:
            # Position closed
            self.side = PositionSide.FLAT
            self.closing_order_id = fill.client_order_id
            self.ts_closed = fill.ts_event
            self.duration_ns = self.ts_closed - self.ts_opened

        self.ts_last = fill.ts_event

    cpdef void apply_adjustment(self, PositionAdjusted adjustment):
        """
        Applies a position adjustment event.

        This method handles adjustments to position quantity or realized PnL that occur
        outside of normal order fills, such as:
        - Commission adjustments in base currency (crypto spot markets)
        - Funding payments (perpetual futures)

        The adjustment event is stored in the position's adjustment history for full audit trail.

        Parameters
        ----------
        adjustment : PositionAdjusted
            The position adjustment event to apply.

        """
        Condition.not_none(adjustment, "adjustment")

        # Apply quantity change if present
        if adjustment.quantity_change is not None:
            self.signed_qty += float(adjustment.quantity_change)

            self.quantity = Quantity(abs(self.signed_qty), self.size_precision)

            if self.quantity._mem.raw > self.peak_qty._mem.raw:
                self.peak_qty = self.quantity

        # Apply PnL change if present
        cdef double current_pnl

        if adjustment.pnl_change is not None:
            current_pnl = self.realized_pnl.as_f64_c() if self.realized_pnl is not None else 0.0
            self.realized_pnl = Money(
                current_pnl + adjustment.pnl_change.as_f64_c(),
                self.settlement_currency,
            )

        # Update position state based on new signed quantity
        if self.signed_qty > 0.0:
            self.side = PositionSide.LONG
            if self.entry == OrderSide.NO_ORDER_SIDE:
                self.entry = OrderSide.BUY
        elif self.signed_qty < 0.0:
            self.side = PositionSide.SHORT
            if self.entry == OrderSide.NO_ORDER_SIDE:
                self.entry = OrderSide.SELL
        else:
            self.side = PositionSide.FLAT

        self._adjustments.append(adjustment)
        self.ts_last = adjustment.ts_event

    cpdef Money notional_value(self, Price price):
        """
        Return the current notional value of the position, using a reference
        price for the calculation (e.g., bid, ask, mid, last, or mark).

        - For a standard (non-inverse) instrument, the notional is returned in the quote currency.
        - For an inverse instrument, the notional is returned in the base currency, with
          the calculation scaled by 1 / price.

        Parameters
        ----------
        price : Price
            The reference price for the calculation. This could be the last, mid, bid, ask,
            a mark-to-market price, or any other suitably representative value.

        Returns
        -------
        Money
            Denominated in quote currency for standard instruments, or base currency if inverse.

        """
        Condition.not_none(price, "price")

        if self.is_inverse:
            return Money(
                self.quantity.as_f64_c() * self.multiplier.as_f64_c() * (1.0 / price.as_f64_c()),
                self.base_currency,
            )
        else:
            return Money(
                self.quantity.as_f64_c() * self.multiplier.as_f64_c() * price.as_f64_c(),
                self.quote_currency,
            )

    cpdef Money calculate_pnl(
        self,
        double avg_px_open,
        double avg_px_close,
        Quantity quantity,
    ):
        """
        Return a calculated PnL in the instrument's settlement currency.

        Parameters
        ----------
        avg_px_open : double
            The average open price.
        avg_px_close : double
            The average close price.
        quantity : Quantity
            The quantity for the calculation.

        Returns
        -------
        Money
            Denominated in settlement currency.

        """
        cdef double pnl = self._calculate_pnl(
            avg_px_open=avg_px_open,
            avg_px_close=avg_px_close,
            quantity=quantity.as_f64_c(),
        )

        return Money(pnl, self.settlement_currency)

    cpdef Money unrealized_pnl(self, Price price):
        """
        Return the unrealized PnL for the position, using a reference
        price for the calculation (e.g., bid, ask, mid, last, or mark).

        Parameters
        ----------
        price : Price
            The reference price for the calculation. This could be the last, mid, bid, ask,
            a mark-to-market price, or any other suitably representative value.

        Returns
        -------
        Money
            Denominated in settlement currency.

        """
        Condition.not_none(price, "price")

        if self.side == PositionSide.FLAT:
            return Money(0, self.settlement_currency)

        cdef double pnl = self._calculate_pnl(
            avg_px_open=self.avg_px_open,
            avg_px_close=price.as_f64_c(),
            quantity=self.quantity.as_f64_c(),
        )

        return Money(pnl, self.settlement_currency)

    cpdef Money total_pnl(self, Price price):
        """
        Return the total PnL for the position, using a reference
        price for the calculation (e.g., bid, ask, mid, last, or mark).

        Parameters
        ----------
        price : Price
            The reference price for the calculation. This could be the last, mid, bid, ask,
            a mark-to-market price, or any other suitably representative value.

        Returns
        -------
        Money
            Denominated in settlement currency.

        """
        Condition.not_none(price, "price")

        cdef double realized_pnl = self.realized_pnl.as_f64_c() if self.realized_pnl is not None else 0.0
        return Money(realized_pnl + self.unrealized_pnl(price).as_f64_c(), self.settlement_currency)

    cpdef list commissions(self):
        """
        Return the total commissions generated by the position.

        Returns
        -------
        list[Money]

        """
        return list(self._commissions.values())

    cdef void _check_duplicate_trade_id(self, OrderFilled fill):
        # Check all previous fills for matching trade ID and composite key
        cdef:
            OrderFilled p_fill
        for p_fill in self._events:
            if fill.trade_id != p_fill.trade_id:
                continue
            if (
                fill.order_side == p_fill.order_side
                and fill.last_px == p_fill.last_px
                and fill.last_qty == p_fill.last_qty
            ):
                raise KeyError(f"Duplicate {fill.trade_id!r} in events {fill} {p_fill}")

    cdef void _handle_buy_order_fill(self, OrderFilled fill):
        cdef:
            double realized_pnl
            double last_px
            double last_qty
            Quantity last_qty_obj

        # Handle case where commission could be None or not settlement currency
        if fill.commission.currency == self.settlement_currency:
            realized_pnl = -fill.commission.as_f64_c()
        else:
            realized_pnl = 0.0

        last_px = fill.last_px.as_f64_c()
        last_qty = fill.last_qty.as_f64_c()
        last_qty_obj = fill.last_qty

        # LONG POSITION
        if self.signed_qty > 0:
            self.avg_px_open = self._calculate_avg_px_open_px(last_px, last_qty)
        # SHORT POSITION
        elif self.signed_qty < 0:
            self.avg_px_close = self._calculate_avg_px_close_px(last_px, last_qty)
            self.realized_return = self._calculate_return(self.avg_px_open, self.avg_px_close)
            realized_pnl += self._calculate_pnl(self.avg_px_open, last_px, last_qty)

        if self.realized_pnl is None:
            self.realized_pnl = Money(realized_pnl, self.settlement_currency)
        else:
            self.realized_pnl = Money(self.realized_pnl.as_f64_c() + realized_pnl, self.settlement_currency)

        self._buy_qty.add_assign(last_qty_obj)
        self.signed_qty += last_qty
        self.signed_qty = round(self.signed_qty, self.size_precision)

    cdef void _handle_sell_order_fill(self, OrderFilled fill):
        cdef:
            double realized_pnl
            double last_px
            double last_qty
            Quantity last_qty_obj

        # Handle case where commission could be None or not settlement currency
        if fill.commission.currency == self.settlement_currency:
            realized_pnl = -fill.commission.as_f64_c()
        else:
            realized_pnl = 0.0

        last_px = fill.last_px.as_f64_c()
        last_qty = fill.last_qty.as_f64_c()
        last_qty_obj = fill.last_qty

        # SHORT POSITION
        if self.signed_qty < 0:
            self.avg_px_open = self._calculate_avg_px_open_px(last_px, last_qty)
        # LONG POSITION
        elif self.signed_qty > 0:
            self.avg_px_close = self._calculate_avg_px_close_px(last_px, last_qty)
            self.realized_return = self._calculate_return(self.avg_px_open, self.avg_px_close)
            realized_pnl += self._calculate_pnl(self.avg_px_open, last_px, last_qty)

        if self.realized_pnl is None:
            self.realized_pnl = Money(realized_pnl, self.settlement_currency)
        else:
            self.realized_pnl = Money(self.realized_pnl.as_f64_c() + realized_pnl, self.settlement_currency)

        self._sell_qty.add_assign(last_qty_obj)
        self.signed_qty -= last_qty
        self.signed_qty = round(self.signed_qty, self.size_precision)

    cdef double _calculate_avg_px_open_px(self, double last_px, double last_qty):
        return self._calculate_avg_px(self.quantity.as_f64_c(), self.avg_px_open, last_px, last_qty)

    cdef double _calculate_avg_px_close_px(self, double last_px, double last_qty):
        if not self.avg_px_close:
            return last_px
        close_qty = self._sell_qty if self.side == PositionSide.LONG else self._buy_qty
        return self._calculate_avg_px(close_qty.as_f64_c(), self.avg_px_close, last_px, last_qty)

    cdef double _calculate_avg_px(
        self,
        double qty,
        double avg_px,
        double last_px,
        double last_qty,
    ):
        cdef double start_cost = avg_px * qty
        cdef double event_cost = last_px * last_qty
        return (start_cost + event_cost) / (qty + last_qty)

    cdef double _calculate_points(self, double avg_px_open, double avg_px_close):
        if self.side == PositionSide.LONG:
            return avg_px_close - avg_px_open
        elif self.side == PositionSide.SHORT:
            return avg_px_open - avg_px_close
        else:
            return 0.0  # FLAT

    cdef double _calculate_points_inverse(self, double avg_px_open, double avg_px_close):
        cdef double EPSILON = 1e-15

        # Defensive check for zero or near-zero prices
        if fabs(avg_px_open) < EPSILON or fabs(avg_px_close) < EPSILON:
            return 0.0

        if self.side == PositionSide.LONG:
            return (1.0 / avg_px_open) - (1.0 / avg_px_close)
        elif self.side == PositionSide.SHORT:
            return (1.0 / avg_px_close) - (1.0 / avg_px_open)
        else:
            return 0.0  # FLAT

    cdef double _calculate_return(self, double avg_px_open, double avg_px_close):
        # Defensive check for zero open price
        if avg_px_open == 0.0:
            return 0.0

        return self._calculate_points(avg_px_open, avg_px_close) / avg_px_open

    cdef double _calculate_pnl(
        self,
        double avg_px_open,
        double avg_px_close,
        double quantity,
    ):
        # Only book open quantity towards PnL (limit to actual position size)
        quantity = fmin(quantity, fabs(self.signed_qty))

        if self.is_inverse:
            # In base currency
            return quantity * self.multiplier.as_f64_c() * self._calculate_points_inverse(avg_px_open, avg_px_close)
        else:
            # In quote currency
            return quantity * self.multiplier.as_f64_c() * self._calculate_points(avg_px_open, avg_px_close)

</document_content>
</document>
<document index="2478">
<source>nautilus_trader/model/tick_scheme/base.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from libc.math cimport ceil as cceil
from libc.math cimport floor as cfloor
from libc.math cimport round as cround

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.model.objects cimport Price


cdef class TickScheme:
    """
    Represents an instrument tick scheme.

    Maps the valid prices available for an instrument.

    Parameters
    ----------
    name : str
        The name of the tick scheme.
    min_tick : Price
        The minimum possible tick `Price`.
    max_tick: Price
        The maximum possible tick `Price`.

    Raises
    ------
    ValueError
        If `name` is not a valid string.
    """

    def __init__(
        self,
        str name not None,
        Price min_tick not None,
        Price max_tick not None,
    ):
        Condition.valid_string(name, "name")

        self.name = name
        self.min_price = min_tick
        self.max_price = max_tick

    cpdef Price next_ask_price(self, double value, int n=0):
        """
        Return the price `n` ask ticks away from value.

        If a given price is between two ticks, n=0 will find the nearest ask tick (inclusive).

        Parameters
        ----------
        value : double
            The reference value.
        n : int, default 0
            The number of ticks to move.

        Returns
        -------
        Price

        """
        raise NotImplementedError()  # pragma: no cover

    cpdef Price next_bid_price(self, double value, int n=0):
        """
        Return the price `n` bid ticks away from value.

        If a given price is between two ticks, n=0 will find the nearest bid tick (inclusive).

        Parameters
        ----------
        value : double
            The reference value.
        n : int, default 0
            The number of ticks to move.

        Returns
        -------
        Price

        """
        raise NotImplementedError()  # pragma: no cover


cpdef double round_down(double value, double base):
    """
    Returns a value rounded down to a specific number of decimal places.

    If value is already on the boundary, returns the same value (price-inclusive).
    """
    if base <= 0:
        raise ValueError(f"base must be positive, was {base}")

    cdef double base_multiple = value / base
    cdef double rounded_multiple = cround(base_multiple)

    # Check if we're already on a tick boundary (within floating point precision)
    if is_close(base_multiple, rounded_multiple):
        return value
    else:
        # Round down to previous boundary using floor
        return cfloor(base_multiple) * base


cpdef double round_up(double value, double base):
    """
    Returns a value rounded up to a specific number of decimal places.

    If value is already on the boundary, returns the same value (price-inclusive).
    """
    if base <= 0:
        raise ValueError(f"base must be positive, was {base}")

    cdef double base_multiple = value / base
    cdef double rounded_multiple = cround(base_multiple)

    # Check if we're already on a tick boundary (within floating point precision)
    if is_close(base_multiple, rounded_multiple):
        return value
    else:
        # Round up to next boundary using ceil
        return cceil(base_multiple) * base


cdef dict[str, TickScheme] TICK_SCHEMES = {}

cpdef void register_tick_scheme(TickScheme tick_scheme):
    Condition.not_none(tick_scheme, "tick_scheme")

    global TICK_SCHEMES
    Condition.not_in(tick_scheme.name, TICK_SCHEMES, "name", "TICK_SCHEMES")
    TICK_SCHEMES[tick_scheme.name] = tick_scheme


cpdef TickScheme get_tick_scheme(str name):
    Condition.valid_string(name, "name")
    Condition.is_in(name, TICK_SCHEMES, "name", "TICK_SCHEMES")
    return TICK_SCHEMES[name]


cpdef list list_tick_schemes():
    return list(TICK_SCHEMES)

</document_content>
</document>
<document index="2481">
<source>nautilus_trader/model/tick_scheme/implementations/fixed.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.core.rust.model cimport FIXED_PRECISION
from nautilus_trader.core.rust.model cimport PRICE_RAW_MAX
from nautilus_trader.core.rust.model cimport PRICE_RAW_MIN
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.tick_scheme.base cimport TickScheme
from nautilus_trader.model.tick_scheme.base cimport is_close
from nautilus_trader.model.tick_scheme.base cimport register_tick_scheme
from nautilus_trader.model.tick_scheme.base cimport round_down
from nautilus_trader.model.tick_scheme.base cimport round_up


cdef class FixedTickScheme(TickScheme):
    """
    Represents a fixed precision tick scheme such as for Forex or Crypto.

    Parameters
    ----------
    name : str
        The name of the tick scheme.
    price_precision: int
        The instrument price precision.
    min_tick : Price
        The minimum possible tick `Price`.
    max_tick: Price
        The maximum possible tick `Price`.
    increment : float, optional
        The tick increment.

    Raises
    ------
    ValueError
        If `name` is not a valid string.
    """

    def __init__(
        self,
        str name not None,
        int price_precision,
        Price min_tick not None,
        Price max_tick not None,
        increment: float | None = None,
    ):
        super().__init__(name=name, min_tick=min_tick, max_tick=max_tick)
        self.price_precision = price_precision

        if increment is not None:
            self.increment = Price.from_str(str(increment))
        elif price_precision == 0:
            self.increment = Price.from_int(1)
        else:
            self.increment = Price.from_str("0." + "1".zfill(price_precision))

        self._increment = self.increment.as_f64_c()
        self._min_price = min_tick.as_f64_c()
        self._max_price = max_tick.as_f64_c()

    cpdef Price next_ask_price(self, double value, int n=0):
        """
        Return the price `n` ask ticks away from value.

        If a given price is between two ticks, n=0 will find the nearest ask tick.

        Parameters
        ----------
        value : double
            The reference value.
        n : int, default 0
            The number of ticks to move.

        Returns
        -------
        Price

        """
        if n < 0:
            raise ValueError(f"n must be >= 0, was {n}")

        if value < self._min_price or value > self._max_price:
            return None

        cdef double rounded = round_up(value=value, base=self._increment) + (n * self._increment)

        if (rounded < self._min_price and not is_close(rounded, self._min_price)) or \
           (rounded > self._max_price and not is_close(rounded, self._max_price)):
            return None

        return Price(rounded, precision=self.price_precision)

    cpdef Price next_bid_price(self, double value, int n=0):
        """
        Return the price `n` bid ticks away from value.

        If a given price is between two ticks, n=0 will find the nearest bid tick.

        Parameters
        ----------
        value : double
            The reference value.
        n : int, default 0
            The number of ticks to move.

        Returns
        -------
        Price

        """
        if n < 0:
            raise ValueError(f"n must be >= 0, was {n}")

        if value < self._min_price:
            return None

        cdef double rounded = round_down(value=value, base=self._increment) - (n * self._increment)

        if (rounded < self._min_price and not is_close(rounded, self._min_price)) or \
           (rounded > self._max_price and not is_close(rounded, self._max_price)):
            return None

        return Price(rounded, precision=self.price_precision)


# Most FOREX pairs
FOREX_5DECIMAL_TICK_SCHEME = FixedTickScheme(
    name="FOREX_5DECIMAL",
    price_precision=5,
    min_tick=Price.from_str_c("0.00001"),
    max_tick=Price.from_str_c("9.99999"),
)

# JPY denominated FOREX pairs
FOREX_3DECIMAL_TICK_SCHEME = FixedTickScheme(
    name="FOREX_3DECIMAL",
    price_precision=3,
    min_tick=Price.from_str_c("0.001"),
    max_tick=Price.from_str_c("999.999"),
)

# Generate fixed precision tick schemes for all valid precisions
for precision in range(FIXED_PRECISION + 1):
    tick_scheme = FixedTickScheme(
        name=f"FIXED_PRECISION_{precision}",
        price_precision=precision,
        min_tick=Price.from_raw_c(PRICE_RAW_MIN, precision),
        max_tick=Price.from_raw_c(PRICE_RAW_MAX, precision),
    )

    register_tick_scheme(tick_scheme)

</document_content>
</document>
<document index="2483">
<source>nautilus_trader/model/tick_scheme/implementations/tiered.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import numpy as np

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.tick_scheme.base cimport TickScheme


cdef class TieredTickScheme(TickScheme):
    """
    Represents a tick scheme where tick levels change based on price level, such as various financial exchanges.

    Parameters
    ----------
    name : str
        The name of the tick scheme.
    tiers : list[tuple(start, stop, step)]
        The tiers for the tick scheme. Should be a list of (start, stop, step) tuples.
    max_ticks_per_tier : int, default 100
        The maximum number of ticks per tier.

    Raises
    ------
    ValueError
        If `name` is not a valid string.
    """

    def __init__(
        self,
        str name not None,
        list tiers not None,
        int price_precision,
        int max_ticks_per_tier=100,
    ):
        self.price_precision = price_precision
        self.tiers = self._validate_tiers(tiers)
        self.max_ticks_per_tier = max_ticks_per_tier
        self.ticks = self._build_ticks()
        super().__init__(name, min(self.ticks), max(self.ticks))
        self.tick_count = len(self.ticks)

    @staticmethod
    def _validate_tiers(list tiers):
        for i, x in enumerate(tiers):
            if len(x) != 3:
                raise ValueError("Mappings should be list of tuples like [(start, stop, increment), ...]")
            start, stop, incr = x

            if start >= stop:
                raise ValueError(f"Tier {i}: Start should be less than stop (start={start}, stop={stop})")

            if incr <= 0:
                raise ValueError(f"Tier {i}: Increment must be positive (incr={incr})")

            if incr > (stop - start):
                raise ValueError(f"Tier {i}: Increment should be less than tier range (start={start}, stop={stop}, incr={incr})")

        return tiers

    cpdef _build_ticks(self):
        # Expand mappings into the full tick values
        cdef list all_ticks = []
        for start, stop, step in self.tiers:
            if stop == np.inf:
                stop = start + ((self.max_ticks_per_tier + 1) * step)

            ticks = [Price(x, self.price_precision) for x in np.arange(start, stop, step)]

            if len(ticks) > self.max_ticks_per_tier+1:
                print(f"{self.name}: too many ticks for tier ({start=}, {stop=}, {step=}, trimming to {self.max_ticks_per_tier} (from {len(ticks)})")
                ticks = ticks[:self.max_ticks_per_tier]

            all_ticks.extend(ticks)

        return np.asarray(all_ticks)

    cpdef int find_tick_index(self, double value):
        cdef int idx = self.ticks.searchsorted(value)

        if idx == 0:
            return 0

        cdef double prev_value = self.ticks[idx - 1].as_double()

        if abs(value - prev_value) < 1e-10:
            return idx - 1

        return idx

    cpdef Price next_ask_price(self, double value, int n=0):
        """
        Return the price `n` ask ticks away from value.

        If a given price is between two ticks, n=0 will find the nearest ask tick.

        Parameters
        ----------
        value : double
            The reference value.
        n : int, default 0
            The number of ticks to move.

        Returns
        -------
        Price

        """
        if n < 0:
            raise ValueError(f"n must be >= 0, was {n}")

        if value > self.max_price.as_double():
            return None

        cdef int idx = self.find_tick_index(value)

        if idx + n >= self.tick_count:
            return None

        return self.ticks[idx + n]

    cpdef Price next_bid_price(self, double value, int n=0):
        """
        Return the price `n` bid ticks away from value.

        If a given price is between two ticks, n=0 will find the nearest bid tick.

        Parameters
        ----------
        value : double
            The reference value.
        n : int, default 0
            The number of ticks to move.

        Returns
        -------
        Price

        """
        if n < 0:
            raise ValueError(f"n must be >= 0, was {n}")

        if value < self.min_price.as_double() or value > self.max_price.as_double():
            return None

        cdef int idx = self.find_tick_index(value)

        cdef double tick_value
        if idx < self.tick_count:
            tick_value = self.ticks[idx].as_double()
            if abs(value - tick_value) < 1e-10:
                if idx - n < 0:
                    return None
                return self.ticks[idx - n]

        if idx - 1 - n < 0:
            return None

        return self.ticks[idx - 1 - n]


TOPIX100_TICK_SCHEME = TieredTickScheme(
    name="TOPIX100",
    tiers=[
        (0.1, 1_000, 0.1),
        (1_000, 3_000, 0.5),
        (3_000, 10_000, 1),
        (10_000, 30_000, 5),
        (30_000, 100_000, 10),
        (100_000, 300_000, 50),
        (300_000, 1_000_000, 100),
        (1_000_000, 3_000_000, 500),
        (3_000_000, 10_000_000, 1_000),
        (10_000_000, 30_000_000, 5_000),
        (30_000_000, np.inf, 10_000),
    ],
    price_precision=4,
    max_ticks_per_tier=10_000,
)

</document_content>
</document>
<document index="2496">
<source>nautilus_trader/persistence/wranglers.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import random
from copy import copy

import numpy as np
import pandas as pd

from nautilus_trader.model.enums import book_action_from_str
from nautilus_trader.model.enums import order_side_from_str

from libc.stdint cimport int64_t
from libc.stdint cimport uint8_t
from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport as_utc_index
from nautilus_trader.core.rust.model cimport FIXED_SCALAR
from nautilus_trader.core.rust.model cimport AggressorSide
from nautilus_trader.core.rust.model cimport BookAction
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport PriceRaw
from nautilus_trader.core.rust.model cimport QuantityRaw
from nautilus_trader.core.rust.model cimport RecordFlag
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport BookOrder
from nautilus_trader.model.data cimport OrderBookDelta
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.identifiers cimport TradeId
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


BAR_PRICES = ("open", "high", "low", "close")
BAR_COLUMNS = (*BAR_PRICES, "volume")


def preprocess_bar_data(data: pd.DataFrame, is_raw: bool):
    """
    Preprocess financial bar data to a standardized format.

    Ensures the DataFrame index is labeled as "timestamp", converts the index to UTC, removes time zone awareness,
    drops rows with NaN values in critical columns, and optionally scales the data.

    Parameters
    ----------
        data : pd.DataFrame
            The input DataFrame containing financial bar data.
        is_raw : bool
            A flag to determine whether the data should be scaled. If True, scales the data back by FIXED_SCALAR.

    Returns
    -------
        pd.DataFrame: The preprocessed DataFrame with a cleaned and standardized structure.

    """
    # Ensure index is timestamp
    if data.index.name != "timestamp":
        data.index.name = "timestamp"

    # Standardize index to UTC and remove time zone awareness
    data = as_utc_index(data)
    data.index = data.index.tz_localize(None).astype("datetime64[ns]")

    # Drop rows with NaN values in critical columns
    data = data.dropna(subset=BAR_COLUMNS)

    # Scale data if raw (we have to do this now to accommodate high_precision mode)
    if is_raw:
        data[list(BAR_COLUMNS)] = data[list(BAR_COLUMNS)] / FIXED_SCALAR

    return data


def calculate_bar_price_offsets(num_records, timestamp_is_close: bool, offset_interval_ms: int, random_seed=None):
    """
    Calculate and potentially randomize the time offsets for bar prices based on the closeness of the timestamp.

    Parameters
    ----------
        num_records : int
            The number of records for which offsets are to be generated.
        timestamp_is_close : bool
            A flag indicating whether the timestamp is close to the trading time.
        offset_interval_ms : int
            The offset interval in milliseconds to be applied.
        random_seed : Optional[int]
            The seed for random number generation to ensure reproducibility.

    Returns
    -------
        dict: A dictionary with arrays of offsets for open, high, low, and close prices. If random_seed is provided,
              high and low offsets are randomized.
    """
    # Initialize offsets
    offsets = {
        "open": np.full(num_records, np.timedelta64((-3 if timestamp_is_close else 0) * offset_interval_ms, "ms")),
        "high": np.full(num_records, np.timedelta64((-2 if timestamp_is_close else 1) * offset_interval_ms, "ms")),
        "low": np.full(num_records, np.timedelta64((-1 if timestamp_is_close else 2) * offset_interval_ms, "ms")),
        "close": np.full(num_records, np.timedelta64((0 if timestamp_is_close else 3) * offset_interval_ms, "ms")),
    }

    # Randomize high and low if seed is given
    if random_seed is not None:
        local_random = random.Random(random_seed)
        for i in range(num_records):
            if local_random.getrandbits(1):  # With a 50% chance, swap high and low
                offsets["high"][i], offsets["low"][i] = offsets["low"][i], offsets["high"][i]

    return offsets


def calculate_volume_quarter(volume: np.ndarray, precision: int, size_increment: float):
    """
    Convert raw volume data to quarter precision.

    Parameters
    ----------
    volume : np.ndarray
        An array of volume data to be processed.
    precision : int
        The decimal precision to which the volume data is rounded.

    Returns
    -------
    np.ndarray
        The volume data adjusted to quarter precision.

    """
    # Convert volume to quarter precision (respect minimum size increment)
    return np.round(np.maximum(volume / 4.0, size_increment), precision)


def align_bid_ask_bar_data(bid_data: pd.DataFrame, ask_data: pd.DataFrame):
    """
    Merge bid and ask data into a single DataFrame with prefixed column names.

    Parameters
    ----------
    bid_data : pd.DataFrame
        The DataFrame containing bid data.
    ask_data : pd.DataFrame
        The DataFrame containing ask data.

    Returns
    pd.DataFrame
        A merged DataFrame with columns prefixed by 'bid_' for bid data and 'ask_' for ask data, joined on their indexes.

    """
    bid_prefixed = bid_data.add_prefix("bid_")
    ask_prefixed = ask_data.add_prefix("ask_")
    merged_data = pd.merge(bid_prefixed, ask_prefixed, left_index=True, right_index=True, how="inner")
    return merged_data


def prepare_event_and_init_timestamps(
    index: pd.DatetimeIndex,
    ts_init_delta: int,
):
    Condition.type(index, pd.DatetimeIndex, "index")
    Condition.not_negative(ts_init_delta, "ts_init_delta")
    ts_events = index.view(np.uint64)
    ts_inits = ts_events + ts_init_delta
    return ts_events, ts_inits


cdef class OrderBookDeltaDataWrangler:
    """
    Provides a means of building lists of Nautilus `OrderBookDelta` objects.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the data wrangler.

    """

    def __init__(self, Instrument instrument not None):
        self.instrument = instrument

    def process(self, data: pd.DataFrame, ts_init_delta: int=0, bint is_raw=False):
        """
        Process the given order book dataset into Nautilus `OrderBookDelta` objects.

        Parameters
        ----------
        data : pd.DataFrame
            The data to process.
        ts_init_delta : int
            The difference in nanoseconds between the data timestamps and the
            `ts_init` value. Can be used to represent/simulate latency between
            the data source and the Nautilus system.
        is_raw : bool, default False
            If the data is scaled to Nautilus fixed-point values.

        Raises
        ------
        ValueError
            If `data` is empty.

        """
        Condition.not_none(data, "data")
        Condition.is_false(data.empty, "data.empty")

        data = as_utc_index(data)
        ts_events, ts_inits = prepare_event_and_init_timestamps(data.index, ts_init_delta)

        if is_raw:
            data["price"] /= FIXED_SCALAR
            data["size"] /= FIXED_SCALAR

        cdef list[OrderBookDelta] deltas
        deltas = list(map(
            self._build_delta,
            data["action"].apply(book_action_from_str),
            data["side"].apply(order_side_from_str),
            data["price"],
            data["size"],
            data["order_id"],
            data["flags"],
            data["sequence"],
            ts_events,
            ts_inits,
        ))

        cdef:
            OrderBookDelta first
            OrderBookDelta clear
        if deltas and deltas[0].flags & RecordFlag.F_SNAPSHOT:
            first = deltas[0]
            clear = OrderBookDelta.clear(
                first.instrument_id,
                first.sequence,
                first.ts_event,
                first.ts_init,
            )
            deltas.insert(0, clear)

        return deltas

    # cpdef method for Python wrap() (called with map)
    cpdef OrderBookDelta _build_delta(
        self,
        BookAction action,
        OrderSide side,
        double price,
        double size,
        uint64_t order_id,
        uint8_t flags,
        uint64_t sequence,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        cdef BookOrder order = BookOrder(
            side,
            Price(price, self.instrument.price_precision),
            Quantity(size, self.instrument.size_precision),
            order_id,
        )
        return OrderBookDelta(
            self.instrument.id,
            action,
            order,
            flags,
            sequence,
            ts_event,
            ts_init,
        )


cdef class QuoteTickDataWrangler:
    """
    Provides a means of building lists of Nautilus `QuoteTick` objects.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the data wrangler.
    """

    def __init__(self, Instrument instrument not None):
        self.instrument = instrument

    def process(
        self,
        data: pd.DataFrame,
        default_volume: float=1_000_000.0,
        ts_init_delta: int=0,
    ):
        """
        Process the given tick dataset into Nautilus `QuoteTick` objects.

        Expects columns ['bid_price', 'ask_price'] with 'timestamp' index.
        Note: The 'bid_size' and 'ask_size' columns are optional, will then use
        the `default_volume`.

        Parameters
        ----------
        data : pd.DataFrame
            The tick data to process.
        default_volume : float
            The default volume for each tick (if not provided).
        ts_init_delta : int
            The difference in nanoseconds between the data timestamps and the
            `ts_init` value. Can be used to represent/simulate latency between
            the data source and the Nautilus system. Cannot be negative.

        Returns
        -------
        list[QuoteTick]

        """
        Condition.is_false(data.empty, "data.empty")
        Condition.not_none(default_volume, "default_volume")

        data = as_utc_index(data)

        columns = {
            "bid": "bid_price",
            "ask": "ask_price",
        }
        data.rename(columns=columns, inplace=True)

        if "bid_size" not in data.columns:
            data["bid_size"] = float(default_volume)
        if "ask_size" not in data.columns:
            data["ask_size"] = float(default_volume)

        ts_events, ts_inits = prepare_event_and_init_timestamps(data.index, ts_init_delta)

        return list(map(
            self._build_tick,
            data["bid_price"],
            data["ask_price"],
            data["bid_size"],
            data["ask_size"],
            ts_events,
            ts_inits,
        ))

    def process_bar_data(
        self,
        bid_data: pd.DataFrame,
        ask_data: pd.DataFrame,
        default_volume: float = 1_000_000.0,
        ts_init_delta: int = 0,
        offset_interval_ms: int = 100,
        bint timestamp_is_close: bool = True,
        random_seed: int | None = None,
        bint is_raw: bool = False,
        bint sort_data: bool = True,
    ):
        """
        Process the given bar datasets into Nautilus `QuoteTick` objects.

        Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
        Note: The 'volume' column is optional, will then use the `default_volume`.

        Parameters
        ----------
        bid_data : pd.DataFrame
            The bid bar data.
        ask_data : pd.DataFrame
            The ask bar data.
        default_volume : float
            The volume per tick if not available from the data.
        ts_init_delta : int
            The difference in nanoseconds between the data timestamps and the
            `ts_init` value. Can be used to represent/simulate latency between
            the data source and the Nautilus system.
        offset_interval_ms : int, default 100
            The number of milliseconds to offset each tick for the bar timestamps.
            If `timestamp_is_close` then will use negative offsets,
            otherwise will use positive offsets (see also `timestamp_is_close`).
        random_seed : int, optional
            The random seed for shuffling order of high and low ticks from bar
            data. If random_seed is ``None`` then won't shuffle.
        is_raw : bool, default False
            If the data is scaled to Nautilus fixed-point values.
        timestamp_is_close : bool, default True
            If bar timestamps are at the close.
            If True, then open, high, low timestamps are offset before the close timestamp.
            If False, then high, low, close timestamps are offset after the open timestamp.
        sort_data : bool, default True
            If the data should be sorted by timestamp.

        """
        Condition.type(bid_data, pd.DataFrame, "bid_data")
        Condition.type(ask_data, pd.DataFrame, "ask_data")
        Condition.is_false(bid_data.empty, "bid_data.empty")
        Condition.is_false(ask_data.empty, "ask_data.empty")
        Condition.type(bid_data.index, pd.DatetimeIndex, "bid_data.index")
        Condition.type(ask_data.index, pd.DatetimeIndex, "ask_data.index")
        Condition.not_none(default_volume, "default_volume")
        for col in BAR_PRICES:
            Condition.is_in(col, bid_data.columns, col, "bid_data.columns")
            Condition.is_in(col, ask_data.columns, col, "ask_data.columns")
        if random_seed is not None:
            Condition.type(random_seed, int, "random_seed")

        # Add default volume if not present
        if "volume" not in bid_data:
            bid_data.loc[:, "volume"] = float(default_volume * 4.0) / (FIXED_SCALAR if is_raw else 1.0)
        if "volume" not in ask_data:
            ask_data.loc[:, "volume"] = float(default_volume * 4.0) / (FIXED_SCALAR if is_raw else 1.0)

        # Standardize and preprocess data
        bid_data = preprocess_bar_data(bid_data, is_raw)
        ask_data = preprocess_bar_data(ask_data, is_raw)

        merged_data = align_bid_ask_bar_data(bid_data, ask_data)
        offsets = calculate_bar_price_offsets(len(merged_data), timestamp_is_close, offset_interval_ms, random_seed)
        ticks_final = self._create_quote_ticks_array(merged_data, is_raw, self.instrument, offsets, ts_init_delta)

        # Sort data by timestamp, if required
        if sort_data:
            sorted_indices = np.argsort(ticks_final["timestamp"])
            ticks_final = ticks_final[sorted_indices]

        ts_events = ticks_final["timestamp"].view(np.uint64)
        ts_inits = ts_events + ts_init_delta

        return QuoteTick.from_raw_arrays_to_list_c(
            self.instrument.id,
            self.instrument.price_precision,
            self.instrument.size_precision,
            ticks_final["bid_price_raw"],
            ticks_final["ask_price_raw"],
            ticks_final["bid_size_raw"],
            ticks_final["ask_size_raw"],
            ts_events,
            ts_inits,
        )

    def _create_quote_ticks_array(
        self,
        merged_data,
        is_raw,
        instrument: Instrument,
        offsets,
        ts_init_delta,
    ):
        dtype = [
            ("bid_price_raw", np.double), ("ask_price_raw", np.double),
            ("bid_size_raw", np.double), ("ask_size_raw", np.double),
            ("timestamp", "datetime64[ns]")
        ]

        size_precision = instrument.size_precision
        size_increment = float(instrument.size_increment)
        merged_data.loc[:, "bid_volume"] = calculate_volume_quarter(merged_data["bid_volume"], size_precision, size_increment)
        merged_data.loc[:, "ask_volume"] = calculate_volume_quarter(merged_data["ask_volume"], size_precision, size_increment)

        # Convert to record array
        records = merged_data.to_records()

        # Create structured array
        total_records = len(records) * 4  # For open, high, low, close
        tick_data = np.empty(total_records, dtype=dtype)

        for i, price_key in enumerate(BAR_PRICES):
            start_index = i * len(records)
            end_index = start_index + len(records)

            tick_data["bid_price_raw"][start_index:end_index] = records[f"bid_{price_key}"].astype(np.double)
            tick_data["ask_price_raw"][start_index:end_index] = records[f"ask_{price_key}"].astype(np.double)
            tick_data["bid_size_raw"][start_index:end_index] = records["bid_volume"].astype(np.double)
            tick_data["ask_size_raw"][start_index:end_index] = records["ask_volume"].astype(np.double)
            tick_data["timestamp"][start_index:end_index] = records["timestamp"] + offsets[price_key]

        return tick_data

    # cpdef method for Python wrap() (called with map)
    cpdef QuoteTick _build_tick(
        self,
        double bid,
        double ask,
        double bid_size,
        double ask_size,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        return QuoteTick(
            self.instrument.id,
            Price(bid, self.instrument.price_precision),
            Price(ask, self.instrument.price_precision),
            Quantity(bid_size, self.instrument.size_precision),
            Quantity(ask_size, self.instrument.size_precision),
            ts_event,
            ts_init,
        )


cdef class TradeTickDataWrangler:
    """
    Provides a means of building lists of Nautilus `TradeTick` objects.

    Parameters
    ----------
    instrument : Instrument
        The instrument for the data wrangler.
    """

    def __init__(self, Instrument instrument not None):
        self.instrument = instrument

    def process(self, data: pd.DataFrame, ts_init_delta: int=0, bint is_raw=False):
        """
        Process the given trade tick dataset into Nautilus `TradeTick` objects.

        Parameters
        ----------
        data : pd.DataFrame
            The data to process.
        ts_init_delta : int
            The difference in nanoseconds between the data timestamps and the
            `ts_init` value. Can be used to represent/simulate latency between
            the data source and the Nautilus system.
        is_raw : bool, default False
            If the data is scaled to Nautilus fixed-point values.

        Returns
        -------
        list[TradeTick]

        Raises
        ------
        ValueError
            If `data` is empty.

        """
        Condition.not_none(data, "data")
        Condition.is_false(data.empty, "data.empty")

        data = as_utc_index(data)
        ts_events, ts_inits = prepare_event_and_init_timestamps(data.index, ts_init_delta)

        if is_raw:
            data["price"] /= FIXED_SCALAR
            data["quantity"] /= FIXED_SCALAR

        return list(map(
            self._build_tick,
            data["price"],
            data["quantity"],
            self._create_side_if_not_exist(data),
            data["trade_id"].astype(str),
            ts_events,
            ts_inits,
        ))

    def process_bar_data(
        self,
        data: pd.DataFrame,
        ts_init_delta: int = 0,
        offset_interval_ms: int = 100,
        bint timestamp_is_close: bool = True,
        random_seed: int | None = None,
        bint is_raw: bool = False,
        bint sort_data: bool = True,
    ):
        """
        Process the given bar datasets into Nautilus `TradeTick` objects.

        Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
        Note: The 'volume' column is optional, will then use the `default_volume`.

        Parameters
        ----------
        data : pd.DataFrame
            The trade bar data.
        ts_init_delta : int
            The difference in nanoseconds between the data timestamps and the
            `ts_init` value. Can be used to represent/simulate latency between
            the data source and the Nautilus system.
        offset_interval_ms : int, default 100
            The number of milliseconds to offset each tick for the bar timestamps.
            If `timestamp_is_close` then will use negative offsets,
            otherwise will use positive offsets (see also `timestamp_is_close`).
        random_seed : int, optional
            The random seed for shuffling order of high and low ticks from bar
            data. If random_seed is ``None`` then won't shuffle.
        is_raw : bool, default False
            If the data is scaled to Nautilus fixed-point.
        timestamp_is_close : bool, default True
            If bar timestamps are at the close.
            If True, then open, high, low timestamps are offset before the close timestamp.
            If False, then high, low, close timestamps are offset after the open timestamp.
        sort_data : bool, default True
            If the data should be sorted by timestamp.

        Returns
        -------
        list[TradeTick]

        Raises
        ------
        ValueError
            If `data` is empty.

        """
        Condition.type(data, pd.DataFrame, "data")
        Condition.is_false(data.empty, "data.empty")
        Condition.type(data.index, pd.DatetimeIndex, "data.index")
        for col in BAR_COLUMNS:
            Condition.is_in(col, data.columns, col, "data.columns")
        if random_seed is not None:
            Condition.type(random_seed, int, "random_seed")

        # Standardize and preprocess data
        data = preprocess_bar_data(data, is_raw)
        size_precision = self.instrument.size_precision
        size_increment = float(self.instrument.size_increment)
        data.loc[:, "volume"] = calculate_volume_quarter(data["volume"], size_precision, size_increment)
        data.loc[:, "trade_id"] = data.index.view(np.uint64).astype(str)

        records = data.to_records()
        offsets = calculate_bar_price_offsets(len(records), timestamp_is_close, offset_interval_ms, random_seed)
        ticks_final = self._create_trade_ticks_array(records, offsets)

        # Sort data by timestamp, if required
        if sort_data:
            sorted_indices = np.argsort(ticks_final["timestamp"])
            ticks_final = ticks_final[sorted_indices]

        ts_events = ticks_final["timestamp"].view(np.uint64)
        ts_inits = ts_events + ts_init_delta

        cdef uint8_t[:] aggressor_sides = np.full(len(ts_events), AggressorSide.NO_AGGRESSOR, dtype=np.uint8)

        return TradeTick.from_raw_arrays_to_list(
            self.instrument.id,
            self.instrument.price_precision,
            self.instrument.size_precision,
            ticks_final["price"],
            ticks_final["size"],
            aggressor_sides,
            ts_events.astype(str).tolist(),
            ts_events,
            ts_inits,
        )

    def _create_trade_ticks_array(
        self,
        records,
        offsets,
    ):
        dtype = [("price", np.double), ("size", np.double), ("timestamp", "datetime64[ns]")]
        tick_data = np.empty(len(records) * 4, dtype=dtype)
        for i, price_key in enumerate(BAR_PRICES):
            start_index = i * len(records)
            end_index = start_index + len(records)
            tick_data["price"][start_index:end_index] = records[price_key].astype(np.double)
            tick_data["size"][start_index:end_index] = records["volume"].astype(np.double)
            tick_data["timestamp"][start_index:end_index] = records["timestamp"] + offsets[price_key]

        return tick_data

    def _create_side_if_not_exist(self, data):
        if "side" in data.columns:
            return data["side"].apply(lambda x: AggressorSide.BUYER if str(x).upper() == "BUY" else AggressorSide.SELLER)
        elif "buyer_maker" in data.columns:
            return data["buyer_maker"].apply(lambda x: AggressorSide.SELLER if x is True else AggressorSide.BUYER)
        else:
            return [AggressorSide.NO_AGGRESSOR] * len(data)

    # cpdef method for Python wrap() (called with map)
    cpdef TradeTick _build_tick(
        self,
        double price,
        double size,
        AggressorSide aggressor_side,
        str trade_id,
        uint64_t ts_event,
        uint64_t ts_init,
    ):
        return TradeTick(
            self.instrument.id,
            Price(price, self.instrument.price_precision),
            Quantity(size, self.instrument.size_precision),
            aggressor_side,
            TradeId(trade_id),
            ts_event,
            ts_init,
        )


cdef class BarDataWrangler:
    """
    Provides a means of building lists of Nautilus `Bar` objects.

    Parameters
    ----------
    bar_type : BarType
        The bar type for the wrangler.
    instrument : Instrument
        The instrument for the wrangler.
    """

    def __init__(
        self,
        BarType bar_type not None,
        Instrument instrument not None,
    ):
        Condition.not_none(bar_type, "bar_type")
        Condition.not_none(instrument, "instrument")

        self.bar_type = bar_type
        self.instrument = instrument

    def process(
        self,
        data: pd.DataFrame,
        default_volume: float=1_000_000.0,
        ts_init_delta: int=0,
    ):
        """
        Process the given bar dataset into Nautilus `Bar` objects.

        Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
        Note: The 'volume' column is optional, if one does not exist then will use the `default_volume`.

        Parameters
        ----------
        data : pd.DataFrame
            The data to process.
        default_volume : float
            The default volume for each bar (if not provided).
        ts_init_delta : int
            The difference in nanoseconds between the data timestamps and the
            `ts_init` value. Can be used to represent/simulate latency between
            the data source and the Nautilus system.

        Returns
        -------
        list[Bar]

        Raises
        ------
        ValueError
            If `data` is empty.

        """
        Condition.not_none(data, "data")
        Condition.is_false(data.empty, "data.empty")
        Condition.not_none(default_volume, "default_volume")

        data = as_utc_index(data)

        if "volume" not in data:
            data["volume"] = float(default_volume)

        ts_events, ts_inits = prepare_event_and_init_timestamps(data.index, ts_init_delta)

        return list(map(
            self._build_bar,
            data.values,
            ts_events,
            ts_inits
        ))

    # cpdef method for Python wrap() (called with map)
    cpdef Bar _build_bar(self, double[:] values, uint64_t ts_event, uint64_t ts_init):
        # Build a bar from the given index and values. The function expects the
        # values to be an ndarray with 5 elements [open, high, low, close, volume].
        return Bar(
            bar_type=self.bar_type,
            open=Price(values[0], self.instrument.price_precision),
            high=Price(values[1], self.instrument.price_precision),
            low=Price(values[2], self.instrument.price_precision),
            close=Price(values[3], self.instrument.price_precision),
            volume=Quantity(values[4], self.instrument.size_precision),
            ts_event=ts_event,
            ts_init=ts_init,
        )

</document_content>
</document>
<document index="2502">
<source>nautilus_trader/portfolio/base.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price


cdef class PortfolioFacade:
    """
    Provides a read-only facade for a `Portfolio`.
    """

# -- QUERIES --------------------------------------------------------------------------------------

    cpdef Account account(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `account` must be implemented in the subclass")  # pragma: no cover

    cpdef dict balances_locked(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `balances_locked` must be implemented in the subclass")  # pragma: no cover

    cpdef dict margins_init(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `margins_init` must be implemented in the subclass")  # pragma: no cover

    cpdef dict margins_maint(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `margins_maint` must be implemented in the subclass")  # pragma: no cover

    cpdef dict realized_pnls(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `realized_pnls` must be implemented in the subclass")  # pragma: no cover

    cpdef dict unrealized_pnls(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `unrealized_pnls` must be implemented in the subclass")  # pragma: no cover

    cpdef dict total_pnls(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `total_pnls` must be implemented in the subclass")  # pragma: no cover

    cpdef dict net_exposures(self, Venue venue):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `net_exposure` must be implemented in the subclass")  # pragma: no cover

    cpdef Money realized_pnl(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `realized_pnl` must be implemented in the subclass")  # pragma: no cover

    cpdef Money unrealized_pnl(self, InstrumentId instrument_id, Price price=None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `unrealized_pnl` must be implemented in the subclass")  # pragma: no cover

    cpdef Money total_pnl(self, InstrumentId instrument_id, Price price=None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `total_pnl` must be implemented in the subclass")  # pragma: no cover

    cpdef Money net_exposure(self, InstrumentId instrument_id, Price price=None):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `next_exposure` must be implemented in the subclass")  # pragma: no cover

    cpdef object net_position(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `net_position` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_net_long(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_net_long` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_net_short(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_net_short` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_flat(self, InstrumentId instrument_id):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_flat` must be implemented in the subclass")  # pragma: no cover

    cpdef bint is_completely_flat(self):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `is_completely_flat` must be implemented in the subclass")  # pragma: no cover

</document_content>
</document>
<document index="2505">
<source>nautilus_trader/portfolio/portfolio.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
The `Portfolio` facilitates the management of trading operations.

The intended use case is for a single ``Portfolio`` instance per running system,
a fleet of trading strategies will organize around a portfolio with the help
of the `Trader`` class.

The portfolio can satisfy queries for account information, margin balances,
total risk exposures and total net positions.
"""

import pickle
import warnings
from collections import defaultdict
from decimal import Decimal

from nautilus_trader.analysis import AvgLoser
from nautilus_trader.analysis import AvgWinner
from nautilus_trader.analysis import Expectancy
from nautilus_trader.analysis import LongRatio
from nautilus_trader.analysis import MaxLoser
from nautilus_trader.analysis import MaxWinner
from nautilus_trader.analysis import MinLoser
from nautilus_trader.analysis import MinWinner
from nautilus_trader.analysis import PortfolioAnalyzer
from nautilus_trader.analysis import ProfitFactor
from nautilus_trader.analysis import ReturnsAverage
from nautilus_trader.analysis import ReturnsAverageLoss
from nautilus_trader.analysis import ReturnsAverageWin
from nautilus_trader.analysis import ReturnsVolatility
from nautilus_trader.analysis import RiskReturnRatio
from nautilus_trader.analysis import SharpeRatio
from nautilus_trader.analysis import SortinoRatio
from nautilus_trader.analysis import WinRate
from nautilus_trader.core import nautilus_pyo3
from nautilus_trader.portfolio.config import PortfolioConfig

from libc.stdint cimport uint64_t

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.accounting.factory cimport AccountFactory
from nautilus_trader.accounting.manager cimport AccountsManager
from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport Logger
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.rust.core cimport NANOSECONDS_IN_MILLISECOND
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.core.rust.model cimport PriceType
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.events.account cimport AccountState
from nautilus_trader.model.events.order cimport OrderAccepted
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderEvent
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.events.position cimport PositionEvent
from nautilus_trader.model.functions cimport position_side_to_str
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport Venue
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.betting cimport BettingInstrument
from nautilus_trader.model.instruments.betting cimport order_side_to_bet_side
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.position cimport Position
from nautilus_trader.portfolio.base cimport PortfolioFacade


cdef tuple[OrderEvent] _UPDATE_ORDER_EVENTS = (
    OrderAccepted,
    OrderCanceled,
    OrderExpired,
    OrderRejected,
    OrderUpdated,
    OrderFilled,
)


cdef class Portfolio(PortfolioFacade):
    """
    Provides a trading portfolio.

    Currently there is a limitation of one account per ``ExecutionClient``
    instance.

    Parameters
    ----------
    msgbus : MessageBus
        The message bus for the engine.
    cache : CacheFacade
        The read-only cache for the portfolio.
    clock : Clock
        The clock for the portfolio.
    config : PortfolioConfig
       The configuration for the instance.

    Raises
    ------
    TypeError
        If `config` is not of type `PortfolioConfig`.
    """

    def __init__(
        self,
        MessageBus msgbus not None,
        CacheFacade cache not None,
        Clock clock not None,
        config: PortfolioConfig | None = None,
    ) -> None:
        if config is None:
            config = PortfolioConfig()

        Condition.type(config, PortfolioConfig, "config")

        self._clock = clock
        self._log = Logger(name=type(self).__name__)
        self._msgbus = msgbus
        self._cache = cache
        self._accounts = AccountsManager(
            cache=cache,
            clock=clock,
            logger=self._log,
        )

        # Configuration
        self._config: PortfolioConfig = config
        self._debug: bool = config.debug
        self._use_mark_prices: bool = config.use_mark_prices
        self._use_mark_xrates: bool = config.use_mark_xrates
        self._convert_to_account_base_currency: bool = config.convert_to_account_base_currency
        self._log_price: str = "mark price" if config.use_mark_prices else "quote, trade, or bar price"
        self._log_xrate: str = "mark" if config.use_mark_xrates else "data to calculate"

        if config.min_account_state_logging_interval_ms:
            interval_ns = config.min_account_state_logging_interval_ms * NANOSECONDS_IN_MILLISECOND
            self._min_account_state_logging_interval_ns = interval_ns

        self._unrealized_pnls: dict[InstrumentId, Money] = {}
        self._realized_pnls: dict[InstrumentId, Money] = {}
        self._snapshot_sum_per_position: dict[PositionId, Money] = {}
        self._snapshot_last_per_position: dict[PositionId, Money] = {}
        self._snapshot_processed_counts: dict[PositionId, int] = {}
        self._net_positions: dict[InstrumentId, Decimal] = {}
        self._bet_positions: dict[InstrumentId, object] = {}
        self._index_bet_positions: dict[InstrumentId, set[PositionId]] = defaultdict(set)
        self._pending_calcs: set[InstrumentId] = set()
        self._bar_close_prices: dict[InstrumentId, Price] = {}
        self._last_account_state_log_ts: dict[AccountId, uint64_t] = {}

        self.analyzer = PortfolioAnalyzer()

        # Register default statistics
        self.analyzer.register_statistic(MaxWinner())
        self.analyzer.register_statistic(AvgWinner())
        self.analyzer.register_statistic(MinWinner())
        self.analyzer.register_statistic(MinLoser())
        self.analyzer.register_statistic(AvgLoser())
        self.analyzer.register_statistic(MaxLoser())
        self.analyzer.register_statistic(Expectancy())
        self.analyzer.register_statistic(WinRate())
        self.analyzer.register_statistic(ReturnsVolatility())
        self.analyzer.register_statistic(ReturnsAverage())
        self.analyzer.register_statistic(ReturnsAverageLoss())
        self.analyzer.register_statistic(ReturnsAverageWin())
        self.analyzer.register_statistic(SharpeRatio())
        self.analyzer.register_statistic(SortinoRatio())
        self.analyzer.register_statistic(ProfitFactor())
        self.analyzer.register_statistic(RiskReturnRatio())
        self.analyzer.register_statistic(LongRatio())

        # Register endpoints
        self._msgbus.register(endpoint="Portfolio.update_account", handler=self.update_account)
        self._msgbus.register(endpoint="Portfolio.update_order", handler=self.update_order)
        self._msgbus.register(endpoint="Portfolio.update_position", handler=self.update_position)

        # Required subscriptions
        self._msgbus.subscribe(topic="events.order.*", handler=self.on_order_event, priority=10)
        self._msgbus.subscribe(topic="events.position.*", handler=self.on_position_event, priority=10)

        if config.use_mark_prices:
            self._msgbus.subscribe(topic="data.mark_prices.*", handler=self.update_mark_price, priority=10)
        else:
            self._msgbus.subscribe(topic="data.quotes.*", handler=self.update_quote_tick, priority=10)

        if config.bar_updates:
            self._msgbus.subscribe(topic="data.bars.*EXTERNAL", handler=self.update_bar, priority=10)

        self.initialized = False

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void set_use_mark_prices(self, bint value):
        """
        Set the `use_mark_prices` setting with the given `value`.

        Parameters
        ----------
        value : bool
            The value to set.

        """
        self._use_mark_prices = value

    cpdef void set_use_mark_xrates(self, bint value):
        """
        Set the `use_mark_xrates` setting with the given `value`.

        Parameters
        ----------
        value : bool
            The value to set.

        """
        self._use_mark_xrates = value

    cpdef void set_specific_venue(self, Venue venue):
        """
        Set a specific venue for the portfolio.

        Parameters
        ----------
        venue : Venue
            The specific venue to set.

        """
        Condition.not_none(venue, "venue")

        warnings.warn(
            "set_specific_venue() on Portfolio is deprecated and will be removed in a future version; "
            "call cache.set_specific_venue(venue) instead",
            UserWarning,
        )

        self._cache.set_specific_venue(venue)

    cpdef void initialize_orders(self):
        """
        Initialize the portfolios orders.

        Performs all account calculations for the current orders state.
        """
        cdef list all_orders_open = self._cache.orders_open()
        cdef set instruments = set()
        cdef Order order

        for order in all_orders_open:
            instruments.add(order.instrument_id)

        # Update initial (order) margins to initialize portfolio
        cdef bint initialized = True

        cdef:
            Order o
            list orders_open
            bint result
        for instrument_id in instruments:
            instrument = self._cache.instrument(instrument_id)

            if instrument is None:
                self._log.error(
                    f"Cannot update initial (order) margin: "
                    f"no instrument found for {instrument_id}",
                )
                initialized = False
                break

            account = self._cache.account_for_venue(instrument.id.venue)

            if account is None:
                self._log.error(
                    f"Cannot update initial (order) margin: "
                    f"no account registered for {instrument.id.venue}",
                )
                initialized = False
                break

            orders_open = self._cache.orders_open(
                venue=None,  # Faster query filtering
                instrument_id=instrument.id,
            )
            result = self._accounts.update_orders(
                account=account,
                instrument=instrument,
                orders_open=[o for o in orders_open if o.is_passive_c()],
                ts_event=account.last_event_c().ts_event,
            )

            if not result:
                initialized = False

        cdef int open_count = len(all_orders_open)
        self._log.info(
            f"Initialized {open_count} open order{'' if open_count == 1 else 's'}",
            color=LogColor.BLUE if open_count else LogColor.NORMAL,
        )
        self.initialized = initialized

    cpdef void initialize_positions(self):
        """
        Initialize the portfolios positions.

        Performs all account calculations for the current position state.
        """
        # Clean slate
        self._realized_pnls.clear()
        self._unrealized_pnls.clear()

        cdef list all_positions_open = self._cache.positions_open()
        cdef set instruments = set()
        cdef Position position

        for position in all_positions_open:
            instruments.add(position.instrument_id)

        cdef bint initialized = True

        # Update maintenance (position) margins to initialize portfolio
        cdef:
            InstrumentId instrument_id
            Instrument instrument
            list positions_open
            Account account
            bint result
        for instrument_id in instruments:
            positions_open = self._cache.positions_open(
                venue=None,  # Faster query filtering
                instrument_id=instrument_id,
            )
            self._update_net_position(
                instrument_id=instrument_id,
                positions_open=positions_open,
            )

            self._realized_pnls[instrument_id] = self._calculate_realized_pnl(instrument_id)
            self._unrealized_pnls[instrument_id] = self._calculate_unrealized_pnl(instrument_id)
            account = self._cache.account_for_venue(instrument_id.venue)

            if account is None:
                self._log.error(
                    f"Cannot update maintenance (position) margin: "
                    f"no account registered for {instrument_id.venue}",
                )
                initialized = False
                break

            if account.type != AccountType.MARGIN:
                continue

            instrument = self._cache.instrument(instrument_id)

            if instrument is None:
                self._log.error(
                    f"Cannot update maintenance (position) margin: "
                    f"no instrument found for {instrument_id}",
                )
                initialized = False
                break

            result = self._accounts.update_positions(
                account=account,
                instrument=instrument,
                positions_open=self._cache.positions_open(
                    venue=None,  # Faster query filtering
                    instrument_id=instrument_id,
                ),
                ts_event=account.last_event_c().ts_event,
            )

            if not result:
                initialized = False

        cdef int open_count = len(all_positions_open)
        self._log.info(
            f"Initialized {open_count} open position{'' if open_count == 1 else 's'}",
            color=LogColor.BLUE if open_count else LogColor.NORMAL,
        )
        self.initialized = initialized

    cpdef void update_quote_tick(self, QuoteTick tick):
        """
        Update the portfolio with the given quote tick.

        Clears the cached unrealized PnL for the associated instrument, and
        performs any initialization calculations which may have been pending
        an update.

        Parameters
        ----------
        quote_tick : QuoteTick
            The quote tick to update with.

        """
        Condition.not_none(tick, "tick")

        self._update_instrument_id(tick.instrument_id)

    cpdef void update_mark_price(self, object mark_price):
        """
        TBD
        """
        # TODO: Feature is WIP
        self._log.warning("Mark price updates not yet supported")

    cpdef void update_bar(self, Bar bar):
        """
        Update the portfolio with the given bar.

        Clears the cached unrealized PnL for the associated instrument, and
        performs any initialization calculations which may have been pending
        an update.

        Parameters
        ----------
        bar : Bar
            The bar to update with.

        """
        Condition.not_none(bar, "bar")

        cdef InstrumentId instrument_id = bar.bar_type.instrument_id
        self._bar_close_prices[instrument_id] = bar.close
        self._update_instrument_id(instrument_id)

    cpdef void update_account(self, AccountState event):
        """
        Apply the given account state.

        Parameters
        ----------
        event : AccountState
            The account state to apply.

        """
        Condition.not_none(event, "event")

        self._update_account(event)

        self._msgbus.publish_c(
            topic=f"events.account.{event.account_id}",
            msg=event,
        )

    cpdef void update_order(self, OrderEvent event):
        """
        Update the portfolio with the given order.

        Parameters
        ----------
        event : OrderEvent
            The event to update with.

        """
        Condition.not_none(event, "event")

        if event.account_id is None:
            return  # No account assigned yet

        cdef Account account = self._cache.account(event.account_id)

        if account is None:
            self._log.error(
                f"Cannot update order: "
                f"no account registered for {event.account_id}",
            )
            return  # No account registered

        if not account.calculate_account_state:
            return  # Nothing to calculate

        if not isinstance(event, _UPDATE_ORDER_EVENTS):
            return  # No change to account state

        cdef Order order = self._cache.order(event.client_order_id)

        if order is None:
            self._log.error(
                f"Cannot update order: "
                f"{repr(event.client_order_id)} not found in the cache",
            )
            return  # No order found

        if isinstance(event, OrderRejected) and order.order_type != OrderType.STOP_LIMIT:
            return  # No change to account state

        cdef Instrument instrument = self._cache.instrument(event.instrument_id)

        if instrument is None:
            self._log.error(
                f"Cannot update order: "
                f"no instrument found for {event.instrument_id}",
            )
            return  # No instrument found

        if self._debug:
            self._log.debug(f"Updating with {order!r}", LogColor.MAGENTA)

        if isinstance(event, OrderFilled):
            self._accounts.update_balances(
                account=account,
                instrument=instrument,
                fill=event,
            )

            if isinstance(instrument, BettingInstrument):
                position_id = event.position_id or PositionId(instrument.id.value)
                bet_position = self._bet_positions.get(position_id)

                if bet_position is None:
                    bet_position = nautilus_pyo3.BetPosition()
                    self._bet_positions[position_id] = bet_position
                    self._index_bet_positions[instrument.id].add(position_id)

                bet = nautilus_pyo3.Bet(
                    price=event.last_px.as_decimal(),
                    stake=event.last_qty.as_decimal(),
                    side=order_side_to_bet_side(order_side=event.order_side),
                )
                if self._debug:
                    self._log.debug(f"Applying {bet} to {bet_position}", LogColor.MAGENTA)

                bet_position.add_bet(bet)

                if self._debug:
                    self._log.debug(f"{bet_position}", LogColor.MAGENTA)

            self._unrealized_pnls[event.instrument_id] = self._calculate_unrealized_pnl(
                instrument_id=event.instrument_id,
            )

        cdef list orders_open = self._cache.orders_open(
            venue=None,  # Faster query filtering
            instrument_id=event.instrument_id,
        )

        cdef:
            Order o
        cdef bint result = self._accounts.update_orders(
            account=account,
            instrument=instrument,
            orders_open=[o for o in orders_open if o.is_passive_c()],
            ts_event=event.ts_event,
        )

        if not result:
            self._log.debug(f"Added pending calculation for {instrument.id}")
            self._pending_calcs.add(instrument.id)
        elif account.is_cash_account or not isinstance(event, OrderFilled):
            # Only update account state for other than fill events (these will be updated on position update)
            self._update_account(self._accounts.generate_account_state(account, event.ts_event))

        self._log.debug(f"Updated from {event}")

    cpdef void update_position(self, PositionEvent event):
        """
        Update the portfolio with the given position event.

        Parameters
        ----------
        event : PositionEvent
            The event to update with.

        """
        Condition.not_none(event, "event")

        cdef list positions_open = self._cache.positions_open(
            venue=None,  # Faster query filtering
            instrument_id=event.instrument_id,
        )
        self._update_net_position(
            instrument_id=event.instrument_id,
            positions_open=positions_open,
        )

        # Invalidate cached PnLs - they will be recalculated on next request
        self._realized_pnls.pop(event.instrument_id, None)
        self._unrealized_pnls.pop(event.instrument_id, None)

        cdef Account account = self._cache.account(event.account_id)

        if account is None:
            self._log.error(
                f"Cannot update position: "
                f"no account registered for {event.account_id}",
            )
            return  # No account registered

        if account.type != AccountType.MARGIN or not account.calculate_account_state:
            return  # Nothing to calculate

        cdef Instrument instrument = self._cache.instrument(event.instrument_id)

        if instrument is None:
            self._log.error(
                f"Cannot update position: "
                f"no instrument found for {event.instrument_id}",
            )
            return  # No instrument found

        cdef bint result = self._accounts.update_positions(
            account=account,
            instrument=instrument,
            positions_open=positions_open,
            ts_event=event.ts_event,
        )

        if result:
            account_state = self._accounts.generate_account_state(account, event.ts_event)
            self._update_account(account_state)

    cpdef void on_order_event(self, OrderEvent event):
        """
        Actions to be performed on receiving an order event.

        Parameters
        ----------
        event : OrderEvent
            The event received.

        """
        Condition.not_none(event, "event")

        if event.account_id is None:
            return  # No account assigned for event

        if not isinstance(event, _UPDATE_ORDER_EVENTS):
            return  # No change to account state

        if isinstance(event, OrderFilled):
            return  # Will publish account event when position event is received

        cdef Account account = self._cache.account(event.account_id)
        if account is None:
            return  # No account registered

        cdef AccountState account_state = account.last_event_c()

        self._msgbus.publish_c(
            topic=f"events.account.{account.id}",
            msg=account_state,
        )

    cpdef void on_position_event(self, PositionEvent event):
        """
        Actions to be performed on receiving a position event.

        Parameters
        ----------
        event : PositionEvent
            The event received.

        """
        Condition.not_none(event, "event")

        if event.account_id is None:
            return  # No account assigned for event

        cdef Account account = self._cache.account(event.account_id)
        if account is None:
            return  # No account registered

        cdef AccountState account_state = account.last_event_c()

        self._msgbus.publish_c(
            topic=f"events.account.{account.id}",
            msg=account_state,
        )

    def _reset(self) -> None:
        self._net_positions.clear()
        self._bet_positions.clear()
        self._index_bet_positions.clear()
        self._realized_pnls.clear()
        self._unrealized_pnls.clear()
        self._pending_calcs.clear()
        self._snapshot_sum_per_position.clear()
        self._snapshot_last_per_position.clear()
        self._snapshot_processed_counts.clear()
        self.analyzer.reset()

        self.initialized = False

    def reset(self) -> None:
        """
        Reset the portfolio.

        All stateful fields are reset to their initial value.

        """
        self._log.debug(f"RESETTING")
        self._reset()
        self._log.info("READY")

    def dispose(self) -> None:
        """
        Dispose of the portfolio.

        All stateful fields are reset to their initial value.

        """
        self._log.debug(f"DISPOSING")
        self._reset()
        self._log.info("DISPOSED")

    cdef void _ensure_snapshot_pnls_cached_for(self, InstrumentId instrument_id):
        # Performance: This method maintains an incremental cache of snapshot PnLs
        # It only unpickles new snapshots that haven't been processed yet
        # Tracks sum and last PnL per position for efficient NETTING OMS support

        # Get all position IDs that have snapshots for this instrument
        cdef set[PositionId] snapshot_position_ids = self._cache.position_snapshot_ids(instrument_id)

        if not snapshot_position_ids:
            return  # Nothing to process

        cdef bint rebuild = False

        cdef:
            PositionId position_id
            list position_id_snapshots
            int prev_count
            int curr_count

        # Detect purge/reset (count regression) to trigger full rebuild
        for position_id in snapshot_position_ids:
            position_id_snapshots = self._cache.position_snapshot_bytes(position_id)
            curr_count = len(position_id_snapshots)
            prev_count = self._snapshot_processed_counts.get(position_id, 0)
            if prev_count > curr_count:
                rebuild = True
                break

        cdef:
            Position snapshot
            Money sum_pnl = None
            Money last_pnl = None

        if rebuild:
            # Full rebuild: process all snapshots from scratch
            for position_id in snapshot_position_ids:
                position_id_snapshots = self._cache.position_snapshot_bytes(position_id)
                curr_count = len(position_id_snapshots)

                if curr_count:
                    for s in position_id_snapshots:
                        snapshot = pickle.loads(s)
                        if snapshot.realized_pnl is not None:
                            if sum_pnl is None:
                                sum_pnl = snapshot.realized_pnl
                            elif sum_pnl.currency == snapshot.realized_pnl.currency:
                                # Accumulate all snapshot PnLs
                                sum_pnl = Money(
                                    sum_pnl.as_double() + snapshot.realized_pnl.as_double(),
                                    sum_pnl.currency
                                )
                            # Always update last to the most recent snapshot
                            last_pnl = snapshot.realized_pnl

                # Update tracking structures
                if sum_pnl is not None:
                    self._snapshot_sum_per_position[position_id] = sum_pnl
                    self._snapshot_last_per_position[position_id] = last_pnl
                else:
                    self._snapshot_sum_per_position.pop(position_id, None)
                    self._snapshot_last_per_position.pop(position_id, None)
                self._snapshot_processed_counts[position_id] = curr_count
        else:
            # Incremental path: only process new snapshots
            for position_id in snapshot_position_ids:
                position_id_snapshots = self._cache.position_snapshot_bytes(position_id)
                curr_count = len(position_id_snapshots)
                if curr_count == 0:
                    continue
                prev_count = self._snapshot_processed_counts.get(position_id, 0)
                if prev_count >= curr_count:
                    continue

                sum_pnl = self._snapshot_sum_per_position.get(position_id)
                last_pnl = self._snapshot_last_per_position.get(position_id)

                # Process only new snapshots
                for idx in range(prev_count, curr_count):
                    snapshot = pickle.loads(position_id_snapshots[idx])

                    if snapshot.realized_pnl is not None:
                        if sum_pnl is None:
                            sum_pnl = snapshot.realized_pnl
                        elif sum_pnl.currency == snapshot.realized_pnl.currency:
                            # Add to running sum
                            sum_pnl = Money(
                                sum_pnl.as_double() + snapshot.realized_pnl.as_double(),
                                sum_pnl.currency
                            )
                        # Update last to most recent
                        last_pnl = snapshot.realized_pnl

                # Update tracking structures
                if sum_pnl is not None:
                    self._snapshot_sum_per_position[position_id] = sum_pnl
                    self._snapshot_last_per_position[position_id] = last_pnl
                else:
                    self._snapshot_sum_per_position.pop(position_id, None)
                    self._snapshot_last_per_position.pop(position_id, None)
                self._snapshot_processed_counts[position_id] = curr_count

        # Prune stale entries (positions that no longer have snapshots)
        cdef list[PositionId] stale_ids = []

        cdef PositionId stale_position_id
        for stale_position_id in self._snapshot_processed_counts:
            if stale_position_id not in snapshot_position_ids:
                stale_ids.append(stale_position_id)

        for stale_position_id in stale_ids:
            self._snapshot_processed_counts.pop(stale_position_id, None)
            self._snapshot_sum_per_position.pop(stale_position_id, None)
            self._snapshot_last_per_position.pop(stale_position_id, None)

# -- QUERIES --------------------------------------------------------------------------------------

    cpdef Account account(self, Venue venue):
        """
        Return the account for the given venue (if found).

        Parameters
        ----------
        venue : Venue
            The venue for the account.

        Returns
        -------
        Account or ``None``

        """
        Condition.not_none(venue, "venue")
        Condition.not_none(self._cache, "self._cache")

        cdef Account account = self._cache.account_for_venue(venue)

        if account is None:
            self._log.error(
                f"Cannot get account: "
                f"no account registered for {venue}",
            )

        return account

    cpdef dict balances_locked(self, Venue venue):
        """
        Return the balances locked for the given venue (if found).

        Parameters
        ----------
        venue : Venue
            The venue for the margin.

        Returns
        -------
        dict[Currency, Money] or ``None``

        """
        Condition.not_none(venue, "venue")

        cdef Account account = self._cache.account_for_venue(venue)

        if account is None:
            self._log.error(
                f"Cannot get balances locked: "
                f"no account registered for {venue}",
            )
            return None

        return account.balances_locked()

    cpdef dict margins_init(self, Venue venue):
        """
        Return the initial (order) margins for the given venue (if found).

        Parameters
        ----------
        venue : Venue
            The venue for the margin.

        Returns
        -------
        dict[Currency, Money] or ``None``

        """
        Condition.not_none(venue, "venue")

        cdef Account account = self._cache.account_for_venue(venue)

        if account is None:
            self._log.error(
                f"Cannot get initial (order) margins: "
                f"no account registered for {venue}",
            )
            return None

        if account.is_cash_account:
            return None

        return account.margins_init()

    cpdef dict margins_maint(self, Venue venue):
        """
        Return the maintenance (position) margins for the given venue (if found).

        Parameters
        ----------
        venue : Venue
            The venue for the margin.

        Returns
        -------
        dict[Currency, Money] or ``None``

        """
        Condition.not_none(venue, "venue")

        cdef Account account = self._cache.account_for_venue(venue)

        if account is None:
            self._log.error(
                f"Cannot get maintenance (position) margins: "
                f"no account registered for {venue}",
            )
            return None

        if account.is_cash_account:
            return None

        return account.margins_maint()

    cpdef dict realized_pnls(self, Venue venue):
        """
        Return the realized PnLs for the given venue (if found).

        If no positions exist for the venue or if any lookups fail internally,
        an empty dictionary is returned.

        Parameters
        ----------
        venue : Venue
            The venue for the realized PnLs.

        Returns
        -------
        dict[Currency, Money]

        """
        Condition.not_none(venue, "venue")

        cdef list positions = self._cache.positions(venue)

        if not positions:
            return {}  # Nothing to calculate

        cdef set[InstrumentId] instrument_ids = {p.instrument_id for p in positions}
        cdef dict[Currency, double] realized_pnls = {}  # type: dict[Currency, 0.0]
        cdef:
            InstrumentId instrument_id
            Money pnl
        for instrument_id in instrument_ids:
            pnl = self._realized_pnls.get(instrument_id)

            if pnl is not None:
                # PnL already calculated
                realized_pnls[pnl.currency] = realized_pnls.get(pnl.currency, 0.0) + pnl.as_f64_c()
                continue

            # Calculate PnL
            pnl = self._calculate_realized_pnl(instrument_id)

            if pnl is None:
                continue  # Error logged in `_calculate_realized_pnl`

            realized_pnls[pnl.currency] = realized_pnls.get(pnl.currency, 0.0) + pnl.as_f64_c()

        return {k: Money(v, k) for k, v in realized_pnls.items()}

    cpdef dict unrealized_pnls(self, Venue venue):
        """
        Return the unrealized PnLs for the given venue (if found).

        Parameters
        ----------
        venue : Venue
            The venue for the unrealized PnLs.

        Returns
        -------
        dict[Currency, Money]

        """
        Condition.not_none(venue, "venue")

        cdef list positions_open = self._cache.positions_open(venue)

        if not positions_open:
            return {}  # Nothing to calculate

        cdef set[InstrumentId] instrument_ids = {p.instrument_id for p in positions_open}
        cdef dict[Currency, double] unrealized_pnls = {}  # type: dict[Currency, 0.0]
        cdef:
            InstrumentId instrument_id
            Money pnl
        for instrument_id in instrument_ids:
            pnl = self._unrealized_pnls.get(instrument_id)

            if pnl is not None:
                # PnL already calculated
                unrealized_pnls[pnl.currency] = unrealized_pnls.get(pnl.currency, 0.0) + pnl.as_f64_c()
                continue

            # Calculate PnL
            pnl = self._calculate_unrealized_pnl(instrument_id)

            if pnl is None:
                continue  # Error logged in `_calculate_unrealized_pnl`

            unrealized_pnls[pnl.currency] = unrealized_pnls.get(pnl.currency, 0.0) + pnl.as_f64_c()

        return {k: Money(v, k) for k, v in unrealized_pnls.items()}

    cpdef dict total_pnls(self, Venue venue):
        """
        Return the total PnLs for the given venue (if found).

        Parameters
        ----------
        venue : Venue
            The venue for the total PnLs.

        Returns
        -------
        dict[Currency, Money]

        """
        Condition.not_none(venue, "venue")

        cdef dict realized = self.realized_pnls(venue)
        cdef dict unrealized = self.unrealized_pnls(venue)
        cdef dict[Currency, double] total_pnls = {}

        cdef:
            Currency currency
            Money amount

        # Sum realized PnLs
        for currency, amount in realized.items():
            total_pnls[currency] = amount._mem.raw

        # Add unrealized PnLs
        for currency, amount in unrealized.items():
            total_pnls[currency] = total_pnls.get(currency, 0) + amount._mem.raw

        return {k: Money.from_raw_c(v, k) for k, v in total_pnls.items()}

    cpdef dict net_exposures(self, Venue venue):
        """
        Return the net exposures for the given venue (if found).

        Parameters
        ----------
        venue : Venue
            The venue for the market value.

        Returns
        -------
        dict[Currency, Money] or ``None``

        """
        Condition.not_none(venue, "venue")

        cdef Account account = self._cache.account_for_venue(venue)

        if account is None:
            self._log.error(
                f"Cannot calculate net exposures: "
                f"no account registered for {venue}",
            )
            return None  # Cannot calculate

        cdef list positions_open = self._cache.positions_open(venue)

        if not positions_open:
            return {}  # Nothing to calculate

        cdef dict net_exposures = {}  # type: dict[Currency, float]

        cdef:
            Position position
            Instrument instrument
            Price price
            Currency settlement_currency
            double xrate
            double net_exposure
            double total_net_exposure
        for position in positions_open:
            instrument = self._cache.instrument(position.instrument_id)

            if instrument is None:
                self._log.error(
                    f"Cannot calculate net exposures: "
                    f"no instrument for {position.instrument_id}",
                )
                return None  # Cannot calculate

            if position.side == PositionSide.FLAT:
                self._log.error(
                    f"Cannot calculate net exposures: "
                    f"position is flat for {position.instrument_id}",
                )
                continue  # Nothing to calculate

            price = self._get_price(position)

            if price is None:
                self._log.error(
                    f"Cannot calculate net exposures: "
                    f"no {self._log_price} for {position.instrument_id}",
                )
                continue  # Cannot calculate

            xrate_result = self._calculate_xrate_to_base(
                instrument=instrument,
                account=account,
                side=position.entry,
            )

            if not xrate_result:
                self._log.error(
                    f"Cannot calculate net exposures: "
                    f"no {self._log_xrate} exchange rate for {instrument.get_cost_currency()}/{account.base_currency}",
                )
                return None  # Cannot calculate

            xrate = xrate_result  # Cast to double

            if self._convert_to_account_base_currency and account.base_currency is not None:
                settlement_currency = account.base_currency
            else:
                settlement_currency = instrument.get_cost_currency()

            if isinstance(instrument, BettingInstrument):
                bet_position = self._bet_positions.get(position.id)
                net_exposure = float(bet_position.exposure) * xrate
            else:
                net_exposure = instrument.notional_value(position.quantity, price).as_f64_c()
                net_exposure = round(net_exposure * xrate, settlement_currency.get_precision())

            total_net_exposure = net_exposures.get(settlement_currency, 0.0)
            total_net_exposure += net_exposure

            net_exposures[settlement_currency] = total_net_exposure

        return {k: Money(v, k) for k, v in net_exposures.items()}

    cpdef Money realized_pnl(self, InstrumentId instrument_id):
        """
        Return the realized PnL for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the realized PnL.

        Returns
        -------
        Money or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef Money pnl = self._realized_pnls.get(instrument_id)

        if pnl is not None:
            return pnl

        pnl = self._calculate_realized_pnl(instrument_id)
        self._realized_pnls[instrument_id] = pnl

        return pnl

    cpdef Money unrealized_pnl(self, InstrumentId instrument_id, Price price=None):
        """
        Return the unrealized PnL for the given instrument ID (if found).

        - If `price` is provided, a fresh calculation is performed without using or
          updating the cache.
        - If `price` is omitted, the method returns the cached PnL if available, or
          computes and caches it if not.

        Returns `None` if the calculation fails (e.g., the account or instrument cannot
        be found), or zero-valued `Money` if no positions are open. Otherwise, it returns
        a `Money` object (usually in the account’s base currency or the instrument’s
        settlement currency).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the unrealized PnL.
        price : Price, optional
            The reference price for the calculation. This could be the last, mid, bid, ask,
            a mark-to-market price, or any other suitably representative value.

        Returns
        -------
        Money or ``None``
            The unrealized PnL or None if the calculation cannot be performed.

        """
        Condition.not_none(instrument_id, "instrument_id")

        if price is not None:
            return self._calculate_unrealized_pnl(instrument_id, price)

        cdef Money pnl = self._unrealized_pnls.get(instrument_id)

        if pnl is not None:
            return pnl

        pnl = self._calculate_unrealized_pnl(instrument_id, price)
        self._unrealized_pnls[instrument_id] = pnl

        return pnl

    cpdef Money total_pnl(self, InstrumentId instrument_id, Price price=None):
        """
        Return the total PnL for the given instrument ID (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the total PnL.
        price : Price, optional
            The reference price for the calculation. This could be the last, mid, bid, ask,
            a mark-to-market price, or any other suitably representative value.

        Returns
        -------
        Money or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef Money realized = self.realized_pnl(instrument_id)
        cdef Money unrealized = self.unrealized_pnl(instrument_id, price)

        if realized is None and unrealized is None:
            return None

        if realized is None:
            return unrealized

        if unrealized is None:
            return realized

        return Money.from_raw_c(realized._mem.raw + unrealized._mem.raw, realized.currency)

    cpdef Money net_exposure(self, InstrumentId instrument_id, Price price=None):
        """
        Return the net exposure for the given instrument (if found).

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the calculation.
        price : Price, optional
            The reference price for the calculation. This could be the last, mid, bid, ask,
            a mark-to-market price, or any other suitably representative value.

        Returns
        -------
        Money or ``None``

        """
        Condition.not_none(instrument_id, "instrument_id")

        cdef Account account = self._cache.account_for_venue(instrument_id.venue)

        if account is None:
            self._log.error(
                f"Cannot calculate net exposure: "
                f"no account registered for {instrument_id.venue}",
            )
            return None  # Cannot calculate

        cdef instrument = self._cache.instrument(instrument_id)

        if instrument is None:
            self._log.error(
                f"Cannot calculate net exposure: "
                f"no instrument for {instrument_id}",
            )
            return None  # Cannot calculate

        if self._debug:
            self._log.debug(
                f"Calculating net exposure for instrument {instrument_id} with {account}", LogColor.MAGENTA,
            )

        cdef list positions_open = self._cache.positions_open(
            venue=None,  # Faster query filtering
            instrument_id=instrument_id,
        )

        if not positions_open:
            return Money(0, instrument.get_cost_currency())

        cdef double net_exposure = 0.0

        cdef:
            Position position
            double xrate
            Money notional_value
        for position in positions_open:
            price = price or self._get_price(position)

            if price is None and not isinstance(instrument, BettingInstrument):
                self._log.error(
                    f"Cannot calculate net exposure: "
                    f"no {self._log_price} for {position.instrument_id}",
                )
                continue  # Cannot calculate

            if self._debug:
                self._log.debug(f"Price for exposure calculation: {price}", LogColor.MAGENTA)

            xrate_result = self._calculate_xrate_to_base(
                instrument=instrument,
                account=account,
                side=position.entry,
            )

            if not xrate_result:
                self._log.error(
                    f"Cannot calculate net exposure: "
                    f"no {self._log_xrate} exchange rate for {instrument.get_cost_currency()}/{account.base_currency}",
                )
                return None  # Cannot calculate

            xrate = xrate_result  # Cast to double

            if self._debug:
                self._log.debug(f"Calculating net exposure for {position}")

            if isinstance(instrument, BettingInstrument):
                bet_position = self._bet_positions.get(position.id)

                if self._debug:
                    self._log.debug(f"{bet_position}", LogColor.MAGENTA)

                net_exposure += float(bet_position.exposure) * xrate if bet_position else 0.0
            else:
                notional_value = instrument.notional_value(position.quantity, price)

                if self._debug:
                    self._log.debug(f"Notional value: {notional_value}", LogColor.MAGENTA)

                net_exposure += notional_value.as_f64_c() * xrate

        if self._convert_to_account_base_currency and account.base_currency is not None:
            return Money(net_exposure, account.base_currency)
        else:
            return Money(net_exposure, instrument.get_cost_currency())

    cpdef object net_position(self, InstrumentId instrument_id):
        """
        Return the total net position for the given instrument ID.
        If no positions for instrument_id then will return `Decimal('0')`.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the query.

        Returns
        -------
        Decimal

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._net_position(instrument_id)

    cpdef bint is_net_long(self, InstrumentId instrument_id):
        """
        Return a value indicating whether the portfolio is net long the given
        instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the query.

        Returns
        -------
        bool
            True if net long, else False.

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._net_position(instrument_id) > 0.0

    cpdef bint is_net_short(self, InstrumentId instrument_id):
        """
        Return a value indicating whether the portfolio is net short the given
        instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the query.

        Returns
        -------
        bool
            True if net short, else False.

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._net_position(instrument_id) < 0.0

    cpdef bint is_flat(self, InstrumentId instrument_id):
        """
        Return a value indicating whether the portfolio is flat for the given
        instrument ID.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument query filter.

        Returns
        -------
        bool
            True if net flat, else False.

        """
        Condition.not_none(instrument_id, "instrument_id")

        return self._net_position(instrument_id) == 0.0

    cpdef bint is_completely_flat(self):
        """
        Return a value indicating whether the portfolio is completely flat.

        Returns
        -------
        bool
            True if net flat across all instruments, else False.

        """
        for net_position in self._net_positions.values():
            if net_position != Decimal(0):
                return False

        return True

# -- INTERNAL -------------------------------------------------------------------------------------

    cdef void _update_account(self, AccountState event):
        cdef Account account = self._cache.account(event.account_id)

        if account is None:
            # Generate account
            account = AccountFactory.create_c(event)
            self._cache.add_account(account)
        else:
            account.apply(event)
            self._cache.update_account(account)

        cdef bint should_log = True
        cdef uint64_t ts_last_logged

        if self._min_account_state_logging_interval_ns:
            ts_last_logged = self._last_account_state_log_ts.get(event.account_id, 0)

            if (not ts_last_logged) or (event.ts_init - ts_last_logged) >= self._min_account_state_logging_interval_ns:
                self._last_account_state_log_ts[event.account_id] = event.ts_init
            else:
                should_log = False

        if should_log:
            self._log.info(f"Updated {event}")

    cdef void _update_net_position(self, InstrumentId instrument_id, list positions_open):
        net_position = Decimal(0)
        cdef Position position

        for position in positions_open:
            net_position += position.signed_decimal_qty()

        existing_position: Decimal = self._net_positions.get(instrument_id, Decimal(0))

        if existing_position != net_position:
            self._net_positions[instrument_id] = net_position
            self._log.info(f"{instrument_id} net_position={net_position}")

    cdef void _update_instrument_id(self, InstrumentId instrument_id):
        self._unrealized_pnls.pop(instrument_id, None)

        if self.initialized:
            return

        if instrument_id not in self._pending_calcs:
            return

        cdef Account account = self._cache.account_for_venue(instrument_id.venue)

        if account is None:
            self._log.error(
                f"Cannot update: no account registered for {instrument_id.venue}",
            )
            return  # No account registered

        cdef Instrument instrument = self._cache.instrument(instrument_id)

        if instrument is None:
            self._log.error(
                f"Cannot update: no instrument found for {instrument_id}",
            )
            return  # No instrument found

        cdef list orders_open = self._cache.orders_open(
            venue=None,  # Faster query filtering
            instrument_id=instrument_id,
        )

        # Initialize initial (order) margin
        cdef Order o
        cdef bint result_init = self._accounts.update_orders(
            account=account,
            instrument=instrument,
            orders_open=[o for o in orders_open if o.is_passive_c()],
            ts_event=account.last_event_c().ts_event,
        )
        cdef bint result_maint = False

        if account.is_margin_account:
            positions_open = self._cache.positions_open(
                venue=None,  # Faster query filtering
                instrument_id=instrument_id,
            )

            # Initialize maintenance (position) margin
            result_maint = self._accounts.update_positions(
                account=account,
                instrument=instrument,
                positions_open=positions_open,
                ts_event=account.last_event_c().ts_event,
            )

        # Calculate unrealized PnL
        cdef Money result_unrealized_pnl = self._calculate_unrealized_pnl(instrument_id)

        # Check portfolio initialization
        if result_init and (account.is_cash_account or (result_maint and result_unrealized_pnl is not None)):
            self._pending_calcs.discard(instrument_id)

            if not self._pending_calcs:
                self.initialized = True

    cdef object _net_position(self, InstrumentId instrument_id):
        return self._net_positions.get(instrument_id, Decimal(0))

    cdef Money _calculate_realized_pnl(self, InstrumentId instrument_id):
        cdef Account account = self._cache.account_for_venue(instrument_id.venue)

        if account is None:
            self._log.error(
                f"Cannot calculate realized PnL: "
                f"no account registered for {instrument_id.venue}",
            )
            return None  # Cannot calculate

        cdef Instrument instrument = self._cache.instrument(instrument_id)

        if instrument is None:
            self._log.error(
                f"Cannot calculate realized PnL: "
                f"no instrument for {instrument_id}",
            )
            return None  # Cannot calculate

        if self._debug:
            self._log.debug(
                f"Calculating realized PnL for instrument {instrument_id} with {account}", LogColor.MAGENTA,
            )

        cdef Currency currency

        if self._convert_to_account_base_currency and account.base_currency is not None:
            currency = account.base_currency
        else:
            currency = instrument.get_cost_currency()

        self._ensure_snapshot_pnls_cached_for(instrument_id)

        cdef:
            list[Position] positions
            double total_pnl = 0.0
            double xrate
            Position position
            double pnl

        positions = self._cache.positions(
            venue=None,  # Faster query filtering
            instrument_id=instrument_id,
        )

        if self._debug:
            self._log.debug(f"Found {len(positions)} positions for {instrument_id}")

        # Build set of active position IDs for quick lookup
        cdef set[PositionId] active_position_ids = {p.id for p in positions}
        cdef set[PositionId] snapshot_ids = self._cache.position_snapshot_ids(instrument_id)
        cdef set[PositionId] processed_ids = set()

        cdef:
            PositionId position_id
            Money sum_pnl
            Money last_pnl
            double contribution

        # Apply the 3-case combination rule for positions with snapshots
        for position_id in snapshot_ids:
            sum_pnl = self._snapshot_sum_per_position.get(position_id)
            if sum_pnl is None:
                continue  # No PnL for this position

            contribution = 0.0

            if position_id not in active_position_ids:
                # Case 1: Position NOT in cache - add sum of all snapshots
                contribution = sum_pnl.as_double()
                # Mark as fully processed since position doesn't exist
                processed_ids.add(position_id)
            else:
                # Position is in cache - find it
                position = None

                for p in positions:
                    if p.id == position_id:
                        position = p
                        break

                if position is None:
                    continue  # Should not happen

                if position.is_open_c():
                    # Case 2: Position OPEN - add sum (prior cycles) + position's realized PnL
                    contribution = sum_pnl.as_double()
                    # Position's PnL will be added in the positions loop below
                    # Do NOT mark as processed - we still need to add current PnL
                else:
                    # Case 3: Position CLOSED
                    # If last snapshot equals current position realized PnL, subtract it here;
                    # when we add the position realized below, net effect is `sum`.
                    # If not equal (new closed cycle not snapshotted), include full `sum` here
                    # and add the position realized below (net `sum + realized`).
                    last_pnl = self._snapshot_last_per_position.get(position_id)

                    if (
                        last_pnl is not None
                        and position.realized_pnl is not None
                        and last_pnl.currency == position.realized_pnl.currency
                        and last_pnl == position.realized_pnl
                    ):
                        contribution = sum_pnl.as_double() - last_pnl.as_double()
                    else:
                        contribution = sum_pnl.as_double()
                    # Position's PnL will be added in the positions loop below
                    # Do NOT mark as processed - we still need to add current PnL

            # Add contribution with currency conversion if needed
            if sum_pnl.currency == currency:
                total_pnl += contribution
            else:
                xrate = self._cache.get_xrate(
                    venue=account.id.get_issuer(),
                    from_currency=sum_pnl.currency,
                    to_currency=currency,
                    price_type=PriceType.MID,
                )
                if xrate == 0:
                    return None  # Cannot convert currency
                total_pnl += contribution * xrate

        # Second: Add realized PnL from active positions
        for position in positions:
            if position.instrument_id != instrument_id:
                continue  # Nothing to calculate

            # Skip positions that were already processed via snapshots
            if position.id in processed_ids:
                continue  # Already handled in snapshot logic

            if position.realized_pnl is None:
                continue  # No PnL to add

            if self._debug:
                self._log.debug(f"Adding realized PnL for {position}")

            # Add position's realized PnL
            if isinstance(instrument, BettingInstrument):
                bet_position = self._bet_positions.get(position.id)

                if bet_position is None:
                    self._log.debug(
                        f"Cannot calculate unrealized PnL: no `BetPosition` for {position.id}",
                    )
                    return None  # Cannot calculate

                pnl = float(bet_position.realized_pnl)
            else:
                pnl = position.realized_pnl.as_f64_c()

            if self._convert_to_account_base_currency and account.base_currency is not None:
                xrate_result = self._calculate_xrate_to_base(
                    instrument=instrument,
                    account=account,
                    side=position.entry,
                )

                if not xrate_result:
                    self._log.debug(
                        f"Cannot calculate unrealized PnL: "
                        f"no {self._log_xrate} exchange rate yet for {instrument.get_cost_currency()}/{account.base_currency}",
                    )
                    self._pending_calcs.add(instrument.id)
                    return None  # Cannot calculate

                xrate = xrate_result  # Cast to double
                pnl = round(pnl * xrate, currency.get_precision())

            total_pnl += pnl

        return Money(total_pnl, currency)

    cdef Money _calculate_unrealized_pnl(self, InstrumentId instrument_id, Price price=None):
        cdef Account account = self._cache.account_for_venue(instrument_id.venue)

        if account is None:
            self._log.error(
                f"Cannot calculate unrealized PnL: "
                f"no account registered for {instrument_id.venue}",
            )
            return None  # Cannot calculate

        cdef Instrument instrument = self._cache.instrument(instrument_id)

        if instrument is None:
            self._log.error(
                f"Cannot calculate unrealized PnL: "
                f"no instrument for {instrument_id}",
            )
            return None  # Cannot calculate

        if self._debug:
            self._log.debug(
                f"Calculating unrealized PnL for instrument {instrument_id} with {account}", LogColor.MAGENTA,
            )

        cdef Currency currency

        if self._convert_to_account_base_currency and account.base_currency is not None:
            currency = account.base_currency
        else:
            currency = instrument.get_cost_currency()

        cdef list positions_open = self._cache.positions_open(
            venue=None,  # Faster query filtering
            instrument_id=instrument_id,
        )

        if not positions_open:
            return Money(0, currency)

        cdef double total_pnl = 0.0

        cdef:
            Position position
            double pnl
            double xrate
        for position in positions_open:
            if position.instrument_id != instrument_id:
                continue  # Nothing to calculate

            if position.side == PositionSide.FLAT:
                continue  # Nothing to calculate

            price = price or self._get_price(position)

            if price is None:
                self._log.debug(
                    f"Cannot calculate unrealized PnL: no {self._log_price} for {instrument_id}",
                )
                self._pending_calcs.add(instrument.id)
                return None  # Cannot calculate

            if self._debug:
                self._log.debug(f"Calculating unrealized PnL for {position}")

            if isinstance(instrument, BettingInstrument):
                bet_position = self._bet_positions.get(position.id)

                if bet_position is None:
                    self._log.debug(
                        f"Cannot calculate unrealized PnL: no `BetPosition` for {position.id}",
                    )
                    return None  # Cannot calculate

                pnl = float(bet_position.unrealized_pnl(price.as_decimal()))
            else:
                pnl = position.unrealized_pnl(price).as_f64_c()

            if self._debug:
                self._log.debug(
                    f"Unrealized PnL for {instrument.id}: {pnl} {currency}", LogColor.MAGENTA,
                )

            if self._convert_to_account_base_currency and account.base_currency is not None:
                xrate_result = self._calculate_xrate_to_base(
                    instrument=instrument,
                    account=account,
                    side=position.entry,
                )

                if not xrate_result:
                    self._log.debug(
                        f"Cannot calculate unrealized PnL: "
                        f"no {self._log_xrate} exchange rate for {instrument.get_cost_currency()}/{account.base_currency}",
                    )
                    self._pending_calcs.add(instrument.id)
                    return None  # Cannot calculate

                xrate = xrate_result  # Cast to double
                pnl = round(pnl * xrate, currency.get_precision())

            total_pnl += pnl

        return Money(total_pnl, currency)

    cdef Price _get_price(self, Position position):
        cdef PriceType price_type

        if self._use_mark_prices:
            price_type = PriceType.MARK
        elif position.side == PositionSide.FLAT:
            price_type = PriceType.LAST
        elif position.side == PositionSide.LONG:
            price_type = PriceType.BID
        elif position.side == PositionSide.SHORT:
            price_type = PriceType.ASK
        else:  # pragma: no cover (design-time error)
            raise RuntimeError(
                f"invalid `PositionSide`, was {position_side_to_str(position.side)}",
            )

        cdef InstrumentId instrument_id = position.instrument_id

        return self._cache.price(
            instrument_id=instrument_id,
            price_type=price_type,
        ) or self._cache.price(
            instrument_id=instrument_id,
            price_type=PriceType.LAST,
        ) or self._bar_close_prices.get(instrument_id)

    cdef _calculate_xrate_to_base(self, Account account, Instrument instrument, OrderSide side):
        if not self._convert_to_account_base_currency or account.base_currency is None:
            return 1.0  # No conversion needed

        if self._use_mark_xrates:
            return self._cache.get_mark_xrate(
                from_currency=instrument.get_cost_currency(),
                to_currency=account.base_currency,
            )

        return self._cache.get_xrate(
            venue=instrument.id.venue,
            from_currency=instrument.get_cost_currency(),
            to_currency=account.base_currency,
            price_type=PriceType.BID if side == OrderSide.BUY else PriceType.ASK,
        )

</document_content>
</document>
<document index="2511">
<source>nautilus_trader/risk/engine.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

import pandas as pd

from nautilus_trader.risk.config import RiskEngineConfig

from libc.stdint cimport uint64_t

from nautilus_trader.accounting.accounts.base cimport Account
from nautilus_trader.accounting.accounts.cash cimport CashAccount
from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.component cimport CMD
from nautilus_trader.common.component cimport EVT
from nautilus_trader.common.component cimport RECV
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport Component
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport Throttler
from nautilus_trader.common.messages cimport TradingStateChanged
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.datetime cimport unix_nanos_to_dt
from nautilus_trader.core.message cimport Command
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.model cimport AccountType
from nautilus_trader.core.rust.model cimport InstrumentClass
from nautilus_trader.core.rust.model cimport OrderSide
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport OrderType
from nautilus_trader.core.rust.model cimport PositionSide
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TradingState
from nautilus_trader.core.rust.model cimport TrailingOffsetType
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.execution.messages cimport TradingCommand
from nautilus_trader.execution.trailing cimport TrailingStopCalculator
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.events.order cimport OrderCancelRejected
from nautilus_trader.model.events.order cimport OrderDenied
from nautilus_trader.model.events.order cimport OrderModifyRejected
from nautilus_trader.model.functions cimport order_type_to_str
from nautilus_trader.model.functions cimport trading_state_to_str
from nautilus_trader.model.functions cimport trailing_offset_type_to_str
from nautilus_trader.model.identifiers cimport ComponentId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.instruments.base cimport NEGATIVE_PRICE_INSTRUMENT_CLASSES
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
from nautilus_trader.model.objects cimport Currency
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.list cimport OrderList
from nautilus_trader.model.position cimport Position
from nautilus_trader.portfolio.base cimport PortfolioFacade


cdef class RiskEngine(Component):
    """
    Provides a high-performance risk engine.

    The `RiskEngine` is responsible for global strategy and portfolio risk
    within the platform. This includes both pre-trade risk checks and post-trade
    risk monitoring.

    Possible trading states:
     - ``ACTIVE`` (trading is enabled).
     - ``REDUCING`` (only new orders or updates which reduce an open position are allowed).
     - ``HALTED`` (all trading commands except cancels are denied).

    Parameters
    ----------
    portfolio : PortfolioFacade
        The portfolio for the engine.
    msgbus : MessageBus
        The message bus for the engine.
    cache : Cache
        The cache for the engine.
    clock : Clock
        The clock for the engine.
    config : RiskEngineConfig, optional
        The configuration for the instance.

    Raises
    ------
    TypeError
        If `config` is not of type `RiskEngineConfig`.
    """

    def __init__(
        self,
        PortfolioFacade portfolio not None,
        MessageBus msgbus not None,
        Cache cache not None,
        Clock clock not None,
        config: RiskEngineConfig | None = None,
    ) -> None:
        if config is None:
            config = RiskEngineConfig()

        Condition.type(config, RiskEngineConfig, "config")

        super().__init__(
            clock=clock,
            component_id=ComponentId("RiskEngine"),
            msgbus=msgbus,
            config=config,
        )

        self._portfolio = portfolio
        self._cache = cache

        # Configuration
        self.trading_state = TradingState.ACTIVE  # Start active by default
        self.is_bypassed = config.bypass
        self.debug = config.debug
        self._log_state()

        # Counters
        self.command_count = 0
        self.event_count = 0

        # Throttlers
        pieces = config.max_order_submit_rate.split("/")
        order_submit_rate_limit = int(pieces[0])
        order_submit_rate_interval = pd.to_timedelta(pieces[1])
        self._order_submit_throttler = Throttler(
            name="ORDER_SUBMIT_THROTTLER",
            limit=order_submit_rate_limit,
            interval=order_submit_rate_interval,
            output_send=self._send_to_execution,
            output_drop=self._deny_new_order,
            clock=clock,
        )

        self._log.info(
            f"Set MAX_ORDER_SUBMIT_RATE: "
            f"{order_submit_rate_limit}/{str(order_submit_rate_interval).replace('0 days ', '')}",
            color=LogColor.BLUE,
        )

        pieces = config.max_order_modify_rate.split("/")
        order_modify_rate_limit = int(pieces[0])
        order_modify_rate_interval = pd.to_timedelta(pieces[1])
        self._order_modify_throttler = Throttler(
            name="ORDER_MODIFY_THROTTLER",
            limit=order_modify_rate_limit,
            interval=order_modify_rate_interval,
            output_send=self._send_to_execution,
            output_drop=self._deny_modify_order,
            clock=clock,
        )

        self._log.info(
            f"Set MAX_ORDER_MODIFY_RATE: "
            f"{order_modify_rate_limit}/{str(order_modify_rate_interval).replace('0 days ', '')}",
            color=LogColor.BLUE,
        )

        # Risk settings
        self._max_notional_per_order: dict[InstrumentId, Decimal] = {}

        # Configure
        self._initialize_risk_checks(config)

        # Register endpoints
        self._msgbus.register(endpoint="RiskEngine.execute", handler=self.execute)
        self._msgbus.register(endpoint="RiskEngine.process", handler=self.process)

        # Required subscriptions
        self._msgbus.subscribe(topic="events.order.*", handler=self._handle_event, priority=10)
        self._msgbus.subscribe(topic="events.position.*", handler=self._handle_event, priority=10)

    def _initialize_risk_checks(self, config: RiskEngineConfig):
        cdef dict max_notional_config = config.max_notional_per_order

        for instrument_id, value in max_notional_config.items():
            self.set_max_notional_per_order(InstrumentId.from_str_c(instrument_id), Decimal(value))

# -- COMMANDS -------------------------------------------------------------------------------------

    cpdef void execute(self, Command command):
        """
        Execute the given command.

        Parameters
        ----------
        command : Command
            The command to execute.

        """
        Condition.not_none(command, "command")

        self._execute_command(command)

    cpdef void process(self, Event event):
        """
        Process the given event.

        Parameters
        ----------
        event : Event
            The event to process.

        """
        Condition.not_none(event, "event")

        self._handle_event(event)

    cpdef void set_trading_state(self, TradingState state):
        """
        Set the trading state for the engine.

        Parameters
        ----------
        state : TradingState
            The state to set.

        """
        if state == self.trading_state:
            self._log.warning(
                f"No change to trading state: "
                f"already set to {trading_state_to_str(self.trading_state)}",
            )
            return

        self.trading_state = state

        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef TradingStateChanged event = TradingStateChanged(
            trader_id=self.trader_id,
            state=self.trading_state,
            config=self._config,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

        self._msgbus.publish_c(topic="events.risk", msg=event)
        self._log_state()

    cpdef void _log_state(self):
        cdef LogColor color = LogColor.BLUE

        if self.trading_state == TradingState.REDUCING:
            color = LogColor.YELLOW
        elif self.trading_state == TradingState.HALTED:
            color = LogColor.RED

        self._log.info(
            f"TradingState is {trading_state_to_str(self.trading_state)}",
            color=color,
        )

        if self.is_bypassed:
            self._log.info(
                "PRE-TRADE RISK CHECKS BYPASSED. This is not recommended for live trading",
                color=LogColor.RED,
            )

    cpdef void set_max_notional_per_order(self, InstrumentId instrument_id, new_value):
        """
        Set the maximum notional value per order for the given instrument ID.

        Passing a new_value of ``None`` will disable the pre-trade risk max
        notional check.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument ID for the max notional.
        new_value : integer, float, string or Decimal
            The max notional value to set.

        Raises
        ------
        decimal.InvalidOperation
            If `new_value` not a valid input for `decimal.Decimal`.
        ValueError
            If `new_value` is not ``None`` and not positive.

        """
        if new_value is not None:
            new_value = Decimal(new_value)
            Condition.type(new_value, Decimal, "new_value")
            Condition.positive(new_value, "new_value")

        old_value: Decimal = self._max_notional_per_order.get(instrument_id)
        self._max_notional_per_order[instrument_id] = new_value

        cdef str new_value_str = f"{new_value:,}" if new_value is not None else str(None)
        self._log.info(
            f"Set MAX_NOTIONAL_PER_ORDER: {instrument_id} {new_value_str}",
            color=LogColor.BLUE,
        )

# -- RISK SETTINGS --------------------------------------------------------------------------------

    cpdef tuple max_order_submit_rate(self):
        """
        Return the current maximum order submit rate limit setting.

        Returns
        -------
        (int, timedelta)
            The limit per timedelta interval.

        """
        return (
            self._order_submit_throttler.limit,
            self._order_submit_throttler.interval,
        )

    cpdef tuple max_order_modify_rate(self):
        """
        Return the current maximum order modify rate limit setting.

        Returns
        -------
        (int, timedelta)
            The limit per timedelta interval.

        """
        return (
            self._order_modify_throttler.limit,
            self._order_modify_throttler.interval,
        )

    cpdef dict max_notionals_per_order(self):
        """
        Return the current maximum notionals per order settings.

        Returns
        -------
        dict[InstrumentId, Decimal]

        """
        return self._max_notional_per_order.copy()

    cpdef object max_notional_per_order(self, InstrumentId instrument_id):
        """
        Return the current maximum notional per order for the given instrument ID.

        Returns
        -------
        Decimal or ``None``

        """
        return self._max_notional_per_order.get(instrument_id)

# -- ABSTRACT METHODS -----------------------------------------------------------------------------

    cpdef void _on_start(self):
        pass  # Optionally override in subclass

    cpdef void _on_stop(self):
        pass  # Optionally override in subclass

# -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------

    cpdef void _start(self):
        # Do nothing else for now
        self._on_start()

    cpdef void _stop(self):
        # Do nothing else for now
        self._on_stop()

    cpdef void _reset(self):
        self.command_count = 0
        self.event_count = 0
        self._order_submit_throttler.reset()
        self._order_modify_throttler.reset()

    cpdef void _dispose(self):
        pass
        # Nothing to dispose for now

# -- COMMAND HANDLERS -----------------------------------------------------------------------------

    cpdef void _execute_command(self, Command command):
        if self.debug:
            self._log.debug(f"{RECV}{CMD} {command}", LogColor.MAGENTA)

        self.command_count += 1

        if isinstance(command, SubmitOrder):
            self._handle_submit_order(command)
        elif isinstance(command, SubmitOrderList):
            self._handle_submit_order_list(command)
        elif isinstance(command, ModifyOrder):
            self._handle_modify_order(command)
        else:
            self._log.error(f"Cannot handle command: {command}")

    cpdef void _handle_submit_order(self, SubmitOrder command):
        if self.is_bypassed:
            # Perform no further risk checks or throttling
            self._send_to_execution(command)
            return

        cdef Order order = command.order

        # Check reduce only
        cdef Position position

        if command.position_id is not None:
            if order.is_reduce_only:
                position = self._cache.position(command.position_id)

                if position is None or not order.would_reduce_only(position.side, position.quantity):
                    self._deny_command(
                        command=command,
                        reason=f"Reduce only order would increase position {command.position_id!r}",
                    )
                    return  # Denied

        # Get instrument for order
        cdef Instrument instrument = self._cache.instrument(order.instrument_id)

        if instrument is None:
            self._deny_command(
                command=command,
                reason=f"Instrument for {order.instrument_id} not found",
            )
            return  # Denied

        ########################################################################
        # PRE-TRADE ORDER(S) CHECKS
        ########################################################################
        if not self._check_order(instrument, order):
            return  # Denied

        if not self._check_orders_risk(instrument, [order]):
            return # Denied

        self._execution_gateway(instrument, command)

    cpdef void _handle_submit_order_list(self, SubmitOrderList command):
        if self.is_bypassed:
            # Perform no further risk checks or throttling
            self._send_to_execution(command)
            return

        # Get instrument for orders
        cdef Instrument instrument = self._cache.instrument(command.instrument_id)

        if instrument is None:
            self._deny_command(
                command=command,
                reason=f"no instrument found for {command.instrument_id}",
            )
            return  # Denied

        ########################################################################
        # PRE-TRADE ORDER(S) CHECKS
        ########################################################################
        for order in command.order_list.orders:
            if not self._check_order(instrument, order):
                return  # Denied

        if not self._check_orders_risk(instrument, command.order_list.orders):
            # Deny all orders in list
            self._deny_order_list(command.order_list, "OrderList {command.order_list.id.to_str()} DENIED")
            return # Denied

        self._execution_gateway(instrument, command)

    cpdef void _handle_modify_order(self, ModifyOrder command):
        ########################################################################
        # VALIDATE COMMAND
        ########################################################################
        cdef Order order = self._cache.order(command.client_order_id)

        if order is None:
            self._log.error(
                f"ModifyOrder DENIED: Order with {command.client_order_id!r} not found",
            )
            return  # Denied
        elif order.is_closed_c():
            self._reject_modify_order(
                order=order,
                reason=f"Order with {command.client_order_id!r} already closed",
            )
            return  # Denied
        elif order.is_pending_cancel_c():
            self._reject_modify_order(
                order=order,
                reason=f"Order with {command.client_order_id!r} already pending cancel",
            )
            return  # Denied

        # Get instrument for orders
        cdef Instrument instrument = self._cache.instrument(command.instrument_id)

        if instrument is None:
            self._reject_modify_order(
                order=order,
                reason=f"no instrument found for {command.instrument_id}",
            )
            return  # Denied

        cdef str risk_msg = None

        # Check price
        risk_msg = self._check_price(instrument, command.price)

        if risk_msg:
            self._reject_modify_order(order=order, reason=risk_msg)
            return  # Denied

        # Check trigger
        risk_msg = self._check_price(instrument, command.trigger_price)

        if risk_msg:
            self._reject_modify_order(order=order, reason=risk_msg)
            return  # Denied

        # Check quantity
        risk_msg = self._check_quantity(instrument, command.quantity, order.is_quote_quantity)

        if risk_msg:
            self._reject_modify_order(order=order, reason=risk_msg)
            return  # Denied

        # Check TradingState
        if self.trading_state == TradingState.HALTED:
            self._reject_modify_order(
                order=order,
                reason="TradingState is HALTED",
            )
            return  # Denied
        elif self.trading_state == TradingState.REDUCING:
            if command.quantity and command.quantity > order.quantity:
                if order.is_buy_c() and self._portfolio.is_net_long(instrument.id):
                    self._reject_modify_order(
                        order=order,
                        reason="TradingState is REDUCING and update will increase exposure",
                    )
                    return  # Denied
                elif order.is_sell_c() and self._portfolio.is_net_short(instrument.id):
                    self._reject_modify_order(
                        order=order,
                        reason="TradingState is REDUCING and update will increase exposure",
                    )
                    return  # Denied

        self._order_modify_throttler.send(command)

# -- PRE-TRADE CHECKS -----------------------------------------------------------------------------

    cpdef bint _check_order(self, Instrument instrument, Order order):
        ########################################################################
        # VALIDATION CHECKS
        ########################################################################

        if self.debug:
            self._log.debug(f"Validating {order}", LogColor.MAGENTA)

        if not self._check_order_price(instrument, order):
            return False  # Denied

        if not self._check_order_quantity(instrument, order):
            return False  # Denied

        if order.time_in_force == TimeInForce.GTD:
            if order.expire_time_ns <= self._clock.timestamp_ns():
                self._deny_order(
                    order=order,
                    reason=f"GTD {unix_nanos_to_dt(order.expire_time_ns)} already passed",
                )
                return False  # Denied

        return True  # Check passed

    cpdef bint _check_order_price(self, Instrument instrument, Order order):
        ########################################################################
        # CHECK PRICE
        ########################################################################
        cdef str risk_msg = None

        if order.has_price_c():
            risk_msg = self._check_price(instrument, order.price)

            if risk_msg:
                self._deny_order(order=order, reason=risk_msg)
                return False  # Denied

        ########################################################################
        # CHECK TRIGGER
        ########################################################################
        if order.has_trigger_price_c():
            risk_msg = self._check_price(instrument, order.trigger_price)

            if risk_msg:
                self._deny_order(order=order, reason=f"trigger {risk_msg}")
                return False  # Denied

        return True  # Passed

    cpdef bint _check_order_quantity(self, Instrument instrument, Order order):
        cdef str risk_msg = self._check_quantity(instrument, order.quantity, order.is_quote_quantity)

        if risk_msg:
            self._deny_order(order=order, reason=risk_msg)
            return False  # Denied

        return True  # Passed

    cpdef bint _check_orders_risk(self, Instrument instrument, list orders):
        ########################################################################
        # RISK CHECKS
        ########################################################################

        cdef QuoteTick last_quote = None
        cdef TradeTick last_trade = None
        cdef Price last_px = None
        cdef Money free

        # Determine max notional
        cdef Money max_notional = None
        max_notional_setting: Decimal | None = self._max_notional_per_order.get(instrument.id)

        if max_notional_setting:
            # TODO: Improve efficiency of this
            max_notional = Money(float(max_notional_setting), instrument.quote_currency)

        # Get account for risk checks
        cdef Account account = self._cache.account_for_venue(instrument.id.venue)

        if account is None:
            self._log.debug(f"Cannot find account for venue {instrument.id.venue}")
            return True  # TODO: Temporary early return until handling routing/multiple venues

        if account.is_margin_account:
            return True  # TODO: Determine risk controls for margin

        cdef bint allow_borrowing = isinstance(account, CashAccount) and account.allow_borrowing

        free = account.balance_free(instrument.quote_currency)

        if self.debug:
            self._log.debug(f"Free: {free!r}", LogColor.MAGENTA)

        # Get net LONG position quantity for this instrument (for position-reducing sell checks),
        # accounting for already submitted (but unfilled) SELL orders to prevent overselling.
        cdef list[Position] open_longs = self._cache.positions_open(
            None,
            instrument.id,
            None,
            PositionSide.LONG,
        )
        cdef Quantity net_long_qty = Quantity.zero_c(instrument.size_precision)
        cdef Position position
        for position in open_longs:
            net_long_qty = Quantity.from_raw_c(
                net_long_qty._mem.raw + position.quantity._mem.raw,
                instrument.size_precision,
            )

        # Get pending (open) SELL orders for this instrument
        cdef list open_sell_orders = self._cache.orders_open(
            None,
            instrument.id,
            None,
            OrderSide.SELL,
        )
        cdef Quantity submitted_sell_qty = Quantity.zero_c(instrument.size_precision)
        cdef Order open_order
        for open_order in open_sell_orders:
            submitted_sell_qty = Quantity.from_raw_c(
                submitted_sell_qty._mem.raw + open_order.leaves_qty._mem.raw,
                instrument.size_precision,
            )

        # Available quantity is long position minus already submitted sells
        cdef Quantity available_long_qty
        if submitted_sell_qty._mem.raw >= net_long_qty._mem.raw:
            available_long_qty = Quantity.zero_c(instrument.size_precision)
        else:
            available_long_qty = Quantity.from_raw_c(
                net_long_qty._mem.raw - submitted_sell_qty._mem.raw,
                instrument.size_precision,
            )

        if self.debug and net_long_qty._mem.raw > 0:
            self._log.debug(
                f"Net LONG qty: {net_long_qty}, submitted sells: {submitted_sell_qty}, available: {available_long_qty}",
                LogColor.MAGENTA,
            )

        # Track cumulative sell quantity to determine position-reducing vs position-opening sells
        cdef Quantity cum_sell_qty = Quantity.zero_c(instrument.size_precision)

        cdef:
            Order order
            Money notional
            Money cum_notional_buy = None
            Money cum_notional_sell = None
            Money order_balance_impact = None
            Money cash_value = None
            Currency base_currency = None
            double xrate
            Quantity effective_quantity
            Price effective_price
            bint is_position_reducing_sell
            Quantity pending_sell_qty
        for order in orders:
            if self.debug:
                self._log.debug(f"Pre-trade risk check: {order}", LogColor.MAGENTA)

            if order.order_type == OrderType.MARKET or order.order_type == OrderType.MARKET_TO_LIMIT:
                if last_px is None:
                    # Determine entry price
                    last_quote = self._cache.quote_tick(instrument.id)

                    if last_quote is not None:
                        if order.side == OrderSide.BUY:
                            last_px = last_quote.ask_price
                        elif order.side == OrderSide.SELL:
                            last_px = last_quote.bid_price
                        else:  # pragma: no cover (design-time error)
                            raise RuntimeError(f"invalid `OrderSide`")
                    else:
                        last_trade = self._cache.trade_tick(instrument.id)

                        if last_trade is not None:
                            last_px = last_trade.price
                        else:
                            self._log.warning(
                                f"Cannot check MARKET order risk: no prices for {instrument.id}",
                            )
                            continue  # Cannot check order risk
            elif order.order_type == OrderType.STOP_MARKET or order.order_type == OrderType.MARKET_IF_TOUCHED:
                last_px = order.trigger_price
            elif order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
                if order.trigger_price is None:
                    # Validate trailing offset type is supported
                    if order.trailing_offset_type not in (TrailingOffsetType.PRICE, TrailingOffsetType.BASIS_POINTS, TrailingOffsetType.TICKS):
                        self._deny_order(
                            order=order,
                            reason=f"UNSUPPORTED_TRAILING_OFFSET_TYPE: {trailing_offset_type_to_str(order.trailing_offset_type)}",
                        )
                        return False

                    last_trade = None
                    last_quote = None

                    if order.trigger_type == TriggerType.BID_ASK:
                        last_quote = self._cache.quote_tick(instrument.id)
                        if last_quote is None:
                            self._log.warning(
                                f"Cannot check {order_type_to_str(order.order_type)} order risk: no trigger price set and no bid/ask quotes available for {instrument.id}",
                            )
                            continue
                        last_px = TrailingStopCalculator.calculate_with_bid_ask(
                            price_increment=instrument.price_increment,
                            trailing_offset_type=order.trailing_offset_type,
                            side=order.side,
                            offset=float(order.trailing_offset),
                            bid=last_quote.bid_price,
                            ask=last_quote.ask_price,
                        )
                    else:
                        last_trade = self._cache.trade_tick(instrument.id)
                        if last_trade is not None:
                            last_px = TrailingStopCalculator.calculate_with_last(
                                price_increment=instrument.price_increment,
                                trailing_offset_type=order.trailing_offset_type,
                                side=order.side,
                                offset=float(order.trailing_offset),
                                last=last_trade.price,
                            )
                        elif order.trigger_type == TriggerType.LAST_OR_BID_ASK:
                            # Fallback to bid/ask when no trade data available
                            last_quote = self._cache.quote_tick(instrument.id)
                            if last_quote is None:
                                self._log.warning(
                                    f"Cannot check {order_type_to_str(order.order_type)} order risk: no trigger price set and no market data available for {instrument.id}",
                                )
                                continue
                            last_px = TrailingStopCalculator.calculate_with_bid_ask(
                                price_increment=instrument.price_increment,
                                trailing_offset_type=order.trailing_offset_type,
                                side=order.side,
                                offset=float(order.trailing_offset),
                                bid=last_quote.bid_price,
                                ask=last_quote.ask_price,
                            )
                        else:
                            self._log.warning(
                                f"Cannot check {order_type_to_str(order.order_type)} order risk: no trigger price set and no market data available for {instrument.id}",
                            )
                            continue
                else:
                    last_px = order.trigger_price
            else:
                last_px = order.price

            # For quote quantity limit orders, use worst-case execution price
            if (
                order.is_quote_quantity
                and not instrument.is_inverse
                and (order.order_type == OrderType.LIMIT or order.order_type == OrderType.STOP_LIMIT)
            ):
                # Get current market price for worst-case execution
                last_quote = self._cache.quote_tick(instrument.id)
                if last_quote is not None:
                    if order.side == OrderSide.BUY:
                        # BUY: could execute at best ask if below limit (more quantity)
                        effective_price = last_px if last_px < last_quote.ask_price else last_quote.ask_price
                    elif order.side == OrderSide.SELL:
                        # SELL: could execute at best bid if above limit (but less quantity, so use limit)
                        effective_price = last_px if last_px > last_quote.bid_price else last_quote.bid_price
                    else:
                        effective_price = last_px
                else:
                    effective_price = last_px  # No market data, use limit price
            else:
                effective_price = last_px

            # Convert quote quantity to base quantity if needed for balance calculations
            if order.is_quote_quantity and not instrument.is_inverse:
                effective_quantity = instrument.calculate_base_quantity(order.quantity, effective_price)

                if self.debug:
                    self._log.debug(f"Converted quote quantity {order.quantity} to base quantity {effective_quantity}", LogColor.MAGENTA)
            else:
                effective_quantity = order.quantity

            # Check min/max quantity against effective quantity
            if instrument.max_quantity and effective_quantity > instrument.max_quantity:
                self._deny_order(
                    order=order,
                    reason=f"QUANTITY_EXCEEDS_MAXIMUM: effective_quantity={effective_quantity}, max_quantity={instrument.max_quantity}",
                )
                return False  # Denied

            if instrument.min_quantity and effective_quantity < instrument.min_quantity:
                self._deny_order(
                    order=order,
                    reason=f"QUANTITY_BELOW_MINIMUM: effective_quantity={effective_quantity}, min_quantity={instrument.min_quantity}",
                )
                return False  # Denied

            notional = instrument.notional_value(effective_quantity, last_px, use_quote_for_inverse=True)

            if self.debug:
                self._log.debug(f"Notional: {notional!r}", LogColor.MAGENTA)

            if max_notional and notional._mem.raw > max_notional._mem.raw:
                self._deny_order(
                    order=order,
                    reason=f"NOTIONAL_EXCEEDS_MAX_PER_ORDER: max_notional={max_notional}, notional={notional}",
                )
                return False  # Denied

            # Check MIN notional instrument limit
            if (
                instrument.min_notional is not None
                and instrument.min_notional.currency == notional.currency
                and notional._mem.raw < instrument.min_notional._mem.raw
            ):
                self._deny_order(
                    order=order,
                    reason=f"NOTIONAL_LESS_THAN_MIN_FOR_INSTRUMENT: min_notional={instrument.min_notional} , notional={notional}",
                )
                return False  # Denied

            # Check MAX notional instrument limit
            if (
                instrument.max_notional is not None
                and instrument.max_notional.currency == notional.currency
                and notional._mem.raw > instrument.max_notional._mem.raw
            ):
                self._deny_order(
                    order=order,
                    reason=f"NOTIONAL_GREATER_THAN_MAX_FOR_INSTRUMENT: max_notional={instrument.max_notional}, notional={notional}",
                )
                return False  # Denied

            order_balance_impact = account.balance_impact(instrument, effective_quantity, last_px, order.side)

            if self.debug:
                self._log.debug(f"Balance impact: {order_balance_impact!r}", LogColor.MAGENTA)

            # Skip balance check when borrowing is enabled (e.g. spot margin trading)
            if not allow_borrowing and free is not None and (free._mem.raw + order_balance_impact._mem.raw) < 0:
                self._deny_order(
                    order=order,
                    reason=f"NOTIONAL_EXCEEDS_FREE_BALANCE: free={free}, balance_impact={order_balance_impact}",
                )
                return False  # Denied

            if base_currency is None:
                base_currency = instrument.get_base_currency()

            if order.is_buy_c():
                if cum_notional_buy is None:
                    cum_notional_buy = Money(-order_balance_impact, order_balance_impact.currency)
                else:
                    cum_notional_buy._mem.raw += -order_balance_impact._mem.raw

                if self.debug:
                    self._log.debug(f"Cumulative notional BUY: {cum_notional_buy!r}")

                if not allow_borrowing and free is not None and cum_notional_buy._mem.raw > free._mem.raw:
                    self._deny_order(
                        order=order,
                        reason=f"CUM_NOTIONAL_EXCEEDS_FREE_BALANCE: free={free}, cum_notional={cum_notional_buy}",
                    )
                    return False  # Denied
            elif order.is_sell_c():
                pending_sell_qty = Quantity.from_raw_c(
                    cum_sell_qty._mem.raw + effective_quantity._mem.raw,
                    instrument.size_precision,
                )
                is_position_reducing_sell = (
                    order.is_reduce_only
                    or pending_sell_qty._mem.raw <= available_long_qty._mem.raw
                )
                cum_sell_qty = pending_sell_qty

                if is_position_reducing_sell:
                    if self.debug:
                        self._log.debug(
                            "Position-reducing SELL skips balance check",
                            LogColor.MAGENTA,
                        )
                    continue

                if account.base_currency is not None:
                    if cum_notional_sell is None:
                        cum_notional_sell = Money(order_balance_impact, order_balance_impact.currency)
                    else:
                        cum_notional_sell._mem.raw += order_balance_impact._mem.raw

                    if self.debug:
                        self._log.debug(f"Cumulative notional SELL: {cum_notional_sell!r}")
                    if not allow_borrowing and free is not None and cum_notional_sell._mem.raw > free._mem.raw:
                        self._deny_order(
                            order=order,
                            reason=f"CUM_NOTIONAL_EXCEEDS_FREE_BALANCE: free={free}, cum_notional={cum_notional_sell}",
                        )
                        return False  # Denied
                elif base_currency is not None and account.type == AccountType.CASH:
                    cash_value = Money(effective_quantity.as_f64_c(), base_currency)
                    free = account.balance_free(base_currency)

                    if self.debug:
                        total = account.balance_total(base_currency)
                        locked = account.balance_locked(base_currency)
                        self._log.debug(f"Cash value: {cash_value!r}", LogColor.MAGENTA)
                        self._log.debug(f"Total: {total!r}", LogColor.MAGENTA)
                        self._log.debug(f"Locked: {locked!r}", LogColor.MAGENTA)
                        self._log.debug(f"Free: {free!r}", LogColor.MAGENTA)

                    if cum_notional_sell is None:
                        cum_notional_sell = cash_value
                    else:
                        cum_notional_sell._mem.raw += cash_value._mem.raw

                    if self.debug:
                        self._log.debug(f"Cumulative notional SELL: {cum_notional_sell!r}")
                    if not allow_borrowing and free is not None and cum_notional_sell._mem.raw > free._mem.raw:
                        self._deny_order(
                            order=order,
                            reason=f"CUM_NOTIONAL_EXCEEDS_FREE_BALANCE: free={free}, cum_notional={cum_notional_sell}",
                        )
                        return False  # Denied

        # Finally
        return True  # Passed

    cpdef str _check_price(self, Instrument instrument, Price price):
        if price is None:
            # Nothing to check
            return None

        if price.precision > instrument.price_precision:
            # Check failed
            return f"price {price} invalid (precision {price.precision} > {instrument.price_precision})"

        if instrument.instrument_class not in NEGATIVE_PRICE_INSTRUMENT_CLASSES:
            if price.raw_int_c() <= 0:
                # Check failed
                return f"price {price} invalid (not positive)"

    cpdef str _check_quantity(self, Instrument instrument, Quantity quantity, bint is_quote_quantity=False):
        if quantity is None:
            # Nothing to check
            return None

        if quantity._mem.precision > instrument.size_precision:
            # Check failed
            return f"quantity {quantity} invalid (precision {quantity._mem.precision} > {instrument.size_precision})"

        # Skip min/max checks for quote quantities (they will be checked in _check_orders_risk using effective_quantity)
        if is_quote_quantity:
            return None

        if instrument.max_quantity and quantity > instrument.max_quantity:
            # Check failed
            return f"quantity {quantity} invalid (> maximum trade size of {instrument.max_quantity})"

        if instrument.min_quantity and quantity < instrument.min_quantity:
            # Check failed
            return f"quantity {quantity} invalid (< minimum trade size of {instrument.min_quantity})"

# -- DENIALS --------------------------------------------------------------------------------------

    cpdef void _deny_command(self, TradingCommand command, str reason):
        if isinstance(command, SubmitOrder):
            self._deny_order(command.order, reason=reason)
        elif isinstance(command, SubmitOrderList):
            self._deny_order_list(command.order_list, reason=reason)
        else:  # pragma: no cover (design-time error)
            raise RuntimeError(f"Cannot deny command {command}")  # pragma: no cover (design-time error)

    # Needs to be `cpdef` due being called from throttler
    cpdef void _deny_new_order(self, TradingCommand command):
        if isinstance(command, SubmitOrder):
            self._deny_order(command.order, reason="Exceeded MAX_ORDER_SUBMIT_RATE")
        elif isinstance(command, SubmitOrderList):
            self._deny_order_list(command.order_list, reason="Exceeded MAX_ORDER_SUBMIT_RATE")

    # Needs to be `cpdef` due being called from throttler
    cpdef void _deny_modify_order(self, ModifyOrder command):
        cdef Order order = self._cache.order(command.client_order_id)

        if order is None:
            self._log.error(f"Order with {command.client_order_id!r} not found")
            return

        self._reject_modify_order(order, reason="Exceeded MAX_ORDER_MODIFY_RATE")

    cpdef void _deny_order(self, Order order, str reason):
        self._log.warning(f"SubmitOrder for {order.client_order_id.to_str()} DENIED: {reason}")

        if order is None:
            # Nothing to deny
            return

        if order.status_c() != OrderStatus.INITIALIZED:
            # Already denied or duplicated (INITIALIZED -> DENIED only valid state transition)
            return

        if not self._cache.order_exists(order.client_order_id):
            self._cache.add_order(order)

        # Generate event
        cdef OrderDenied denied = OrderDenied(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            reason=reason,
            event_id=UUID4(),
            ts_init=self._clock.timestamp_ns(),
        )

        self._msgbus.send(endpoint="ExecEngine.process", msg=denied)

    cpdef void _deny_order_list(self, OrderList order_list, str reason):
        cdef Order order
        for order in order_list.orders:
            if not order.is_closed_c():
                self._deny_order(order=order, reason=reason)

# -- EGRESS ---------------------------------------------------------------------------------------

    cpdef void _execution_gateway(self, Instrument instrument, TradingCommand command):
        # Check TradingState
        cdef Order order

        if self.trading_state == TradingState.HALTED:
            if isinstance(command, SubmitOrder):
                self._deny_command(
                    command=command,
                    reason=f"TradingState.HALTED",
                )
                return  # Denied
            elif isinstance(command, SubmitOrderList):
                self._deny_order_list(
                    order_list=command.order_list,
                    reason="TradingState.HALTED",
                )
                return  # Denied
        elif self.trading_state == TradingState.REDUCING:
            if isinstance(command, SubmitOrder):
                order = command.order

                if order.is_buy_c() and self._portfolio.is_net_long(instrument.id):
                    self._deny_command(
                        command=command,
                        reason=f"BUY when TradingState.REDUCING and LONG {instrument.id}",
                    )
                    return  # Denied
                elif order.is_sell_c() and self._portfolio.is_net_short(instrument.id):
                    self._deny_command(
                        command=command,
                        reason=f"SELL when TradingState.REDUCING and SHORT {instrument.id}",
                    )
                    return  # Denied
            elif isinstance(command, SubmitOrderList):
                for order in command.order_list.orders:
                    if order.is_buy_c() and self._portfolio.is_net_long(instrument.id):
                        self._deny_order_list(
                            order_list=command.order_list,
                            reason=f"OrderList contains BUY when TradingState.REDUCING and LONG {instrument.id}",
                        )
                        return  # Denied
                    elif order.is_sell_c() and self._portfolio.is_net_short(instrument.id):
                        self._deny_order_list(
                            order_list=command.order_list,
                            reason=f"OrderList contains SELL when TradingState.REDUCING and SHORT {instrument.id}",
                        )
                        return  # Denied

        # All checks passed: send to ORDER_RATE throttler
        self._order_submit_throttler.send(command)

    # Needs to be `cpdef` due being called from throttler
    cpdef void _send_to_execution(self, TradingCommand command):
        self._msgbus.send(endpoint="ExecEngine.execute", msg=command)

    cpdef void _reject_modify_order(self, Order order, str reason):
        # Generate event
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        cdef OrderModifyRejected denied = OrderModifyRejected(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id,
            reason=reason,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

        self._msgbus.send(endpoint="ExecEngine.process", msg=denied)

# -- EVENT HANDLERS -------------------------------------------------------------------------------

    cpdef void _handle_event(self, Event event):
        if self.debug:
            self._log.debug(f"{RECV}{EVT} {event}", LogColor.MAGENTA)
        self.event_count += 1

</document_content>
</document>
<document index="2513">
<source>nautilus_trader/risk/sizing.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from decimal import Decimal

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.model.instruments.base cimport Instrument
from nautilus_trader.model.objects cimport Money
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity


cdef class PositionSizer:
    """
    The base class for all position sizers.

    Parameters
    ----------
    instrument : Instrument
        The instrument for position sizing.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(self, Instrument instrument not None):
        self.instrument = instrument

    cpdef void update_instrument(self, Instrument instrument):
        """
        Update the internal instrument with the given instrument.

        Parameters
        ----------
        instrument : Instrument
            The instrument for the update.

        Raises
        ------
        ValueError
            If `instrument` does not equal the currently held instrument.

        """
        Condition.not_none(instrument, "instrument")
        Condition.equal(self.instrument.id, instrument.id, "instrument.id", "instrument.id")

        self.instrument = instrument

    cpdef Quantity calculate(
        self,
        Price entry,
        Price stop_loss,
        Money equity,
        risk: Decimal,
        commission_rate: Decimal = Decimal(0),
        exchange_rate: Decimal = Decimal(1),
        hard_limit: Decimal | None = None,
        unit_batch_size: Decimal = Decimal(1),
        int units=1,
    ):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `calculate` must be implemented in the subclass")  # pragma: no cover

    cdef object _calculate_risk_ticks(self, Price entry, Price stop_loss):
        return abs(entry - stop_loss) / self.instrument.price_increment

    cdef object _calculate_riskable_money(
            self,
            equity: Decimal,
            risk: Decimal,
            commission_rate: Decimal,
    ):
        if equity <= 0:
            return Decimal(0)
        risk_money: Decimal = equity * risk
        commission: Decimal = risk_money * commission_rate * 2  # (round turn)

        return risk_money - commission


cdef class FixedRiskSizer(PositionSizer):
    """
    Provides position sizing calculations based on a given risk.

    Parameters
    ----------
    instrument : Instrument
        The instrument for position sizing.
    """

    def __init__(self, Instrument instrument not None):
        super().__init__(instrument)

    cpdef Quantity calculate(
        self,
        Price entry,
        Price stop_loss,
        Money equity,
        risk: Decimal,
        commission_rate: Decimal = Decimal(0),
        exchange_rate: Decimal = Decimal(1),
        hard_limit: Decimal | None = None,
        unit_batch_size: Decimal=Decimal(1),
        int units=1,
    ):
        """
        Calculate the position size quantity.

        Parameters
        ----------
        entry : Price
            The entry price.
        stop_loss : Price
            The stop loss price.
        equity : Money
            The account equity.
        risk : Decimal
            The risk percentage.
        exchange_rate : Decimal
            The exchange rate for the instrument quote currency vs account currency.
        commission_rate : Decimal
            The commission rate (>= 0).
        hard_limit : Decimal, optional
            The hard limit for the total quantity (>= 0).
        unit_batch_size : Decimal
            The unit batch size (> 0).
        units : int
            The number of units to batch the position into (> 0).

        Raises
        ------
        ValueError
            If `risk_bp` is not positive (> 0).
        ValueError
            If `xrate` is not positive (> 0).
        ValueError
            If `commission_rate` is negative (< 0).
        ValueError
            If `hard_limit` is not ``None`` and is not positive (> 0).
        ValueError
            If `unit_batch_size` is not positive (> 0).
        ValueError
            If `units` is not positive (> 0).

        Returns
        -------
        Quantity

        """
        Condition.not_none(equity, "equity")
        Condition.not_none(entry, "price_entry")
        Condition.not_none(stop_loss, "price_stop_loss")
        Condition.type(risk, Decimal, "risk")
        Condition.positive(risk, "risk")
        Condition.type(exchange_rate, Decimal, "exchange_rate")
        Condition.not_negative(exchange_rate, "xrate")
        Condition.type(commission_rate, Decimal, "commission_rate")
        Condition.not_negative(commission_rate, "commission_rate")
        if hard_limit is not None:
            Condition.positive(hard_limit, "hard_limit")
        Condition.type(unit_batch_size, Decimal, "unit_batch_size")
        Condition.not_negative(unit_batch_size, "unit_batch_size")
        Condition.positive_int(units, "units")

        if exchange_rate == 0:
            return self.instrument.make_qty(0)

        risk_points: Decimal = self._calculate_risk_ticks(entry, stop_loss)
        risk_money: Decimal = self._calculate_riskable_money(equity.as_decimal(), risk, commission_rate)

        if risk_points <= 0:
            # Divide by zero protection
            return self.instrument.make_qty(0)

        # Calculate position size
        position_size: Decimal = ((risk_money / exchange_rate) / risk_points) / self.instrument.price_increment

        # Limit size on hard limit
        if hard_limit is not None:
            position_size = min(position_size, hard_limit)

        # Batch into units
        position_size_batched: Decimal = max(Decimal(0), position_size / units)

        if unit_batch_size > 0:
            # Round position size to nearest unit batch size
            position_size_batched = (position_size_batched // unit_batch_size) * unit_batch_size

        # Limit size on max trade size
        final_size: Decimal = min(position_size_batched, self.instrument.max_quantity)

        return Quantity(final_size, precision=self.instrument.size_precision)

</document_content>
</document>
<document index="2527">
<source>nautilus_trader/serialization/base.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

from typing import Any
from typing import Callable

from nautilus_trader.common.messages cimport ComponentStateChanged
from nautilus_trader.common.messages cimport ShutdownSystem
from nautilus_trader.common.messages cimport TradingStateChanged
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.execution.messages cimport BatchCancelOrders
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport GenerateExecutionMassStatus
from nautilus_trader.execution.messages cimport GenerateFillReports
from nautilus_trader.execution.messages cimport GenerateOrderStatusReport
from nautilus_trader.execution.messages cimport GenerateOrderStatusReports
from nautilus_trader.execution.messages cimport GeneratePositionStatusReports
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport QueryAccount
from nautilus_trader.execution.messages cimport QueryOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport InstrumentClose
from nautilus_trader.model.data cimport InstrumentStatus
from nautilus_trader.model.data cimport OrderBookDelta
from nautilus_trader.model.data cimport OrderBookDeltas
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.events.account cimport AccountState
from nautilus_trader.model.events.order cimport OrderAccepted
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderCancelRejected
from nautilus_trader.model.events.order cimport OrderDenied
from nautilus_trader.model.events.order cimport OrderEmulated
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderModifyRejected
from nautilus_trader.model.events.order cimport OrderPendingCancel
from nautilus_trader.model.events.order cimport OrderPendingUpdate
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderReleased
from nautilus_trader.model.events.order cimport OrderSubmitted
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.events.position cimport PositionChanged
from nautilus_trader.model.events.position cimport PositionClosed
from nautilus_trader.model.events.position cimport PositionOpened
from nautilus_trader.model.instruments.betting cimport BettingInstrument
from nautilus_trader.model.instruments.binary_option cimport BinaryOption
from nautilus_trader.model.instruments.cfd cimport Cfd
from nautilus_trader.model.instruments.commodity cimport Commodity
from nautilus_trader.model.instruments.crypto_future cimport CryptoFuture
from nautilus_trader.model.instruments.crypto_option cimport CryptoOption
from nautilus_trader.model.instruments.crypto_perpetual cimport CryptoPerpetual
from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
from nautilus_trader.model.instruments.equity cimport Equity
from nautilus_trader.model.instruments.futures_contract cimport FuturesContract
from nautilus_trader.model.instruments.futures_spread cimport FuturesSpread
from nautilus_trader.model.instruments.index cimport IndexInstrument
from nautilus_trader.model.instruments.option_contract cimport OptionContract
from nautilus_trader.model.instruments.option_spread cimport OptionSpread
from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument

from nautilus_trader.execution.reports import ExecutionMassStatus
from nautilus_trader.execution.reports import FillReport
from nautilus_trader.execution.reports import OrderStatusReport
from nautilus_trader.execution.reports import PositionStatusReport


# Default mappings for Nautilus objects
_OBJECT_TO_DICT_MAP: dict[str, Callable[[None], dict]] = {
    CancelOrder.__name__: CancelOrder.to_dict_c,
    CancelAllOrders.__name__: CancelAllOrders.to_dict_c,
    BatchCancelOrders.__name__: BatchCancelOrders.to_dict_c,
    GenerateFillReports.__name__: GenerateFillReports.to_dict_c,
    GenerateOrderStatusReport.__name__: GenerateOrderStatusReport.to_dict_c,
    GenerateOrderStatusReports.__name__: GenerateOrderStatusReports.to_dict_c,
    GeneratePositionStatusReports.__name__: GeneratePositionStatusReports.to_dict_c,
    GenerateExecutionMassStatus.__name__: GenerateExecutionMassStatus.to_dict_c,
    SubmitOrder.__name__: SubmitOrder.to_dict_c,
    SubmitOrderList.__name__: SubmitOrderList.to_dict_c,
    ModifyOrder.__name__: ModifyOrder.to_dict_c,
    QueryAccount.__name__: QueryAccount.to_dict_c,
    QueryOrder.__name__: QueryOrder.to_dict_c,
    ShutdownSystem.__name__: ShutdownSystem.to_dict_c,
    ComponentStateChanged.__name__: ComponentStateChanged.to_dict_c,
    TradingStateChanged.__name__: TradingStateChanged.to_dict_c,
    AccountState.__name__: AccountState.to_dict_c,
    OrderAccepted.__name__: OrderAccepted.to_dict_c,
    OrderCancelRejected.__name__: OrderCancelRejected.to_dict_c,
    OrderCanceled.__name__: OrderCanceled.to_dict_c,
    OrderDenied.__name__: OrderDenied.to_dict_c,
    OrderEmulated.__name__: OrderEmulated.to_dict_c,
    OrderExpired.__name__: OrderExpired.to_dict_c,
    OrderFilled.__name__: OrderFilled.to_dict_c,
    OrderInitialized.__name__: OrderInitialized.to_dict_c,
    OrderPendingCancel.__name__: OrderPendingCancel.to_dict_c,
    OrderPendingUpdate.__name__: OrderPendingUpdate.to_dict_c,
    OrderRejected.__name__: OrderRejected.to_dict_c,
    OrderReleased.__name__: OrderReleased.to_dict_c,
    OrderSubmitted.__name__: OrderSubmitted.to_dict_c,
    OrderTriggered.__name__: OrderTriggered.to_dict_c,
    OrderModifyRejected.__name__: OrderModifyRejected.to_dict_c,
    OrderUpdated.__name__: OrderUpdated.to_dict_c,
    PositionOpened.__name__: PositionOpened.to_dict_c,
    PositionChanged.__name__: PositionChanged.to_dict_c,
    PositionClosed.__name__: PositionClosed.to_dict_c,
    SyntheticInstrument.__name__: SyntheticInstrument.to_dict_c,
    BettingInstrument.__name__: BettingInstrument.to_dict_c,
    BinaryOption.__name__: BinaryOption.to_dict_c,
    Cfd.__name__: Cfd.to_dict_c,
    Commodity.__name__: Commodity.to_dict_c,
    CryptoFuture.__name__: CryptoFuture.to_dict_c,
    CryptoOption.__name__: CryptoOption.to_dict_c,
    CryptoPerpetual.__name__: CryptoPerpetual.to_dict_c,
    CurrencyPair.__name__: CurrencyPair.to_dict_c,
    Equity.__name__: Equity.to_dict_c,
    FuturesContract.__name__: FuturesContract.to_dict_c,
    FuturesSpread.__name__: FuturesSpread.to_dict_c,
    IndexInstrument.__name__: IndexInstrument.to_dict_c,
    OptionContract.__name__: OptionContract.to_dict_c,
    OptionSpread.__name__: OptionSpread.to_dict_c,
    OrderBookDelta.__name__: OrderBookDelta.to_dict_c,
    OrderBookDeltas.__name__: OrderBookDeltas.to_dict_c,
    TradeTick.__name__: TradeTick.to_dict_c,
    QuoteTick.__name__: QuoteTick.to_dict_c,
    Bar.__name__: Bar.to_dict_c,
    InstrumentStatus.__name__: InstrumentStatus.to_dict_c,
    InstrumentClose.__name__: InstrumentClose.to_dict_c,
    OrderStatusReport.__name__: OrderStatusReport.to_dict,
    FillReport.__name__: FillReport.to_dict,
    PositionStatusReport.__name__: PositionStatusReport.to_dict,
    ExecutionMassStatus.__name__: ExecutionMassStatus.to_dict,
}


# Default mappings for Nautilus objects
_OBJECT_FROM_DICT_MAP: dict[str, Callable[[dict], Any]] = {
    CancelOrder.__name__: CancelOrder.from_dict_c,
    CancelAllOrders.__name__: CancelAllOrders.from_dict_c,
    BatchCancelOrders.__name__: BatchCancelOrders.from_dict_c,
    GenerateFillReports.__name__: GenerateFillReports.from_dict_c,
    GenerateOrderStatusReport.__name__: GenerateOrderStatusReport.from_dict_c,
    GenerateOrderStatusReports.__name__: GenerateOrderStatusReports.from_dict_c,
    GeneratePositionStatusReports.__name__: GeneratePositionStatusReports.from_dict_c,
    GenerateExecutionMassStatus.__name__: GenerateExecutionMassStatus.from_dict_c,
    SubmitOrder.__name__: SubmitOrder.from_dict_c,
    SubmitOrderList.__name__: SubmitOrderList.from_dict_c,
    ModifyOrder.__name__: ModifyOrder.from_dict_c,
    QueryAccount.__name__: QueryAccount.from_dict_c,
    QueryOrder.__name__: QueryOrder.from_dict_c,
    ShutdownSystem.__name__: ShutdownSystem.from_dict_c,
    ComponentStateChanged.__name__: ComponentStateChanged.from_dict_c,
    TradingStateChanged.__name__: TradingStateChanged.from_dict_c,
    AccountState.__name__: AccountState.from_dict_c,
    OrderAccepted.__name__: OrderAccepted.from_dict_c,
    OrderCancelRejected.__name__: OrderCancelRejected.from_dict_c,
    OrderCanceled.__name__: OrderCanceled.from_dict_c,
    OrderDenied.__name__: OrderDenied.from_dict_c,
    OrderEmulated.__name__: OrderEmulated.from_dict_c,
    OrderExpired.__name__: OrderExpired.from_dict_c,
    OrderFilled.__name__: OrderFilled.from_dict_c,
    OrderInitialized.__name__: OrderInitialized.from_dict_c,
    OrderPendingCancel.__name__: OrderPendingCancel.from_dict_c,
    OrderPendingUpdate.__name__: OrderPendingUpdate.from_dict_c,
    OrderReleased.__name__: OrderReleased.from_dict_c,
    OrderRejected.__name__: OrderRejected.from_dict_c,
    OrderSubmitted.__name__: OrderSubmitted.from_dict_c,
    OrderTriggered.__name__: OrderTriggered.from_dict_c,
    OrderModifyRejected.__name__: OrderModifyRejected.from_dict_c,
    OrderUpdated.__name__: OrderUpdated.from_dict_c,
    PositionOpened.__name__: PositionOpened.from_dict_c,
    PositionChanged.__name__: PositionChanged.from_dict_c,
    PositionClosed.__name__: PositionClosed.from_dict_c,
    SyntheticInstrument.__name__: SyntheticInstrument.from_dict_c,
    BettingInstrument.__name__: BettingInstrument.from_dict_c,
    BinaryOption.__name__: BinaryOption.from_dict_c,
    Cfd.__name__: Cfd.from_dict_c,
    Commodity.__name__: Commodity.from_dict_c,
    CryptoFuture.__name__: CryptoFuture.from_dict_c,
    CryptoOption.__name__: CryptoOption.from_dict_c,
    CryptoPerpetual.__name__: CryptoPerpetual.from_dict_c,
    CurrencyPair.__name__: CurrencyPair.from_dict_c,
    Equity.__name__: Equity.from_dict_c,
    FuturesContract.__name__: FuturesContract.from_dict_c,
    FuturesSpread.__name__: FuturesSpread.from_dict_c,
    IndexInstrument.__name__: IndexInstrument.from_dict_c,
    OptionContract.__name__: OptionContract.from_dict_c,
    OptionSpread.__name__: OptionSpread.from_dict_c,
    OrderBookDelta.__name__: OrderBookDelta.from_dict_c,
    OrderBookDeltas.__name__: OrderBookDeltas.from_dict_c,
    TradeTick.__name__: TradeTick.from_dict_c,
    QuoteTick.__name__: QuoteTick.from_dict_c,
    Bar.__name__: Bar.from_dict_c,
    InstrumentStatus.__name__: InstrumentStatus.from_dict_c,
    InstrumentClose.__name__: InstrumentClose.from_dict_c,
    OrderStatusReport.__name__: OrderStatusReport.from_dict,
    FillReport.__name__: FillReport.from_dict,
    PositionStatusReport.__name__: PositionStatusReport.from_dict,
    ExecutionMassStatus.__name__: ExecutionMassStatus.from_dict,
}


_EXTERNAL_PUBLISHABLE_TYPES = {
    str,
    int,
    float,
    bytes,
    SubmitOrder,
    SubmitOrderList,
    ModifyOrder,
    CancelOrder,
    CancelAllOrders,
    BatchCancelOrders,
    GenerateFillReports,
    GenerateOrderStatusReport,
    GenerateOrderStatusReports,
    GeneratePositionStatusReports,
    GenerateExecutionMassStatus,
    QueryAccount,
    QueryOrder,
    ShutdownSystem,
    ComponentStateChanged,
    TradingStateChanged,
    AccountState,
    OrderAccepted,
    OrderCancelRejected,
    OrderCanceled,
    OrderDenied,
    OrderEmulated,
    OrderExpired,
    OrderFilled,
    OrderInitialized,
    OrderPendingCancel,
    OrderPendingUpdate,
    OrderReleased,
    OrderRejected,
    OrderSubmitted,
    OrderTriggered,
    OrderModifyRejected,
    OrderUpdated,
    PositionOpened,
    PositionChanged,
    PositionClosed,
    SyntheticInstrument,
    BettingInstrument,
    BinaryOption,
    Cfd,
    Commodity,
    CryptoFuture,
    CryptoOption,
    CryptoPerpetual,
    CurrencyPair,
    Equity,
    FuturesContract,
    FuturesSpread,
    IndexInstrument,
    OptionContract,
    OptionSpread,
    OrderBookDelta,
    OrderBookDeltas,
    TradeTick,
    QuoteTick,
    Bar,
    InstrumentStatus,
    InstrumentClose,
    OrderStatusReport,
    FillReport,
    PositionStatusReport,
    ExecutionMassStatus,
}


cpdef void register_serializable_type(
    cls: type,
    to_dict: Callable[[Any], dict[str, Any]],
    from_dict: Callable[[dict[str, Any]], Any],
):
    """
    Register the given type with the global serialization type maps.

    The `type` will also be registered as an external publishable type and
    will be published externally on the message bus unless also added to
    the `MessageBusConfig.types_filter`.

    Parameters
    ----------
    cls : type
        The type to register.
    to_dict : Callable[[Any], dict[str, Any]]
        The delegate to instantiate a dict of primitive types from an object.
    from_dict : Callable[[dict[str, Any]], Any]
        The delegate to instantiate an object from a dict of primitive types.

    Raises
    ------
    TypeError
        If `to_dict` or `from_dict` are not of type `Callable`.
    KeyError
        If `type` already registered with the global type maps.

    """
    Condition.callable(to_dict, "to_dict")
    Condition.callable(from_dict, "from_dict")
    Condition.not_in(cls.__name__, _OBJECT_TO_DICT_MAP, "cls.__name__", "_OBJECT_TO_DICT_MAP")
    Condition.not_in(cls.__name__, _OBJECT_FROM_DICT_MAP, "cls.__name__", "_OBJECT_FROM_DICT_MAP")

    _OBJECT_TO_DICT_MAP[cls.__name__] = to_dict
    _OBJECT_FROM_DICT_MAP[cls.__name__] = from_dict
    _EXTERNAL_PUBLISHABLE_TYPES.add(cls)


cdef class Serializer:
    """
    The base class for all serializers.

    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """

    def __init__(self):
        super().__init__()

    cpdef bytes serialize(self, object obj):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `serialize` must be implemented in the subclass")  # pragma: no cover

    cpdef object deserialize(self, bytes obj_bytes):
        """Abstract method (implement in subclass)."""
        raise NotImplementedError("method `deserialize` must be implemented in the subclass")  # pragma: no cover

</document_content>
</document>
<document index="2529">
<source>nautilus_trader/serialization/serializer.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

import re
from typing import Any

import pandas as pd
import pytz
from msgspec import msgpack

from nautilus_trader.common.config import msgspec_encoding_hook as _base_msgspec_encoding_hook

from libc.stdint cimport uint64_t

from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.serialization.base cimport _OBJECT_FROM_DICT_MAP
from nautilus_trader.serialization.base cimport _OBJECT_TO_DICT_MAP
from nautilus_trader.serialization.base cimport Serializer


cdef tuple[str, int, float, bool] _PRIMITIVES = (str, int, float, bool)


cdef class MsgSpecSerializer(Serializer):
    """
    Provides a serializer for either the 'MessagePack' or 'JSON' specifications.

    Parameters
    ----------
    encoding : Callable
        The msgspec encoding type.
    timestamps_as_str : bool, default False
        If the serializer converts `uint64_t` timestamps to integer strings on serialization,
        and back to `uint64_t` on deserialization.
    timestamps_as_iso8601 : bool, default False
        If the serializer converts `uint64_t` timestamps to ISO 8601 strings on serialization,
        and back to `uint64_t` on deserialization.
    """

    def __init__(
        self,
        encoding,
        bint timestamps_as_str = False,
        bint timestamps_as_iso8601 = False,
    ):
        self._encode = encoding.encode
        self._decode = encoding.decode
        self.timestamps_as_str = timestamps_as_str
        self.timestamps_as_iso8601 = timestamps_as_iso8601

    cpdef bytes serialize(self, object obj):
        """
        Serialize the given object to `MessagePack` specification bytes.

        Parameters
        ----------
        obj : object
            The object to serialize.

        Returns
        -------
        bytes

        Raises
        ------
        RuntimeError
            If `obj` cannot be serialized.

        """
        Condition.not_none(obj, "obj")

        cdef dict obj_dict
        if isinstance(obj, dict):
            obj_dict = obj
        else:
            delegate = _OBJECT_TO_DICT_MAP.get(type(obj).__name__)
            if delegate is None:
                if isinstance(obj, _PRIMITIVES):
                    return self._encode(obj, enc_hook=_serializer_encoding_hook)
                else:
                    raise RuntimeError(f"cannot serialize object: unrecognized type {type(obj)}")
            obj_dict = delegate(obj)

        cdef dict timestamp_kvs = {
            k: v for k, v in obj_dict.items() if k in ("expire_time_ns") or re.match(r"^ts_", k)
        }

        cdef str key
        if self.timestamps_as_iso8601:
            for key, value in timestamp_kvs.items():
                if value is None:
                    continue
                timestamp = pd.Timestamp(value, unit="ns", tz=pytz.utc)
                obj_dict[key] = timestamp.isoformat().replace("+00:00", "Z")
        elif self.timestamps_as_str:
            for key, value in timestamp_kvs.items():
                if value is not None:
                    obj_dict[key] = str(value)

        return self._encode(obj_dict, enc_hook=_serializer_encoding_hook)

    cpdef object deserialize(self, bytes obj_bytes):
        """
        Deserialize the given `MessagePack` specification bytes to an object.

        Parameters
        ----------
        obj_bytes : bytes
            The object bytes to deserialize.

        Returns
        -------
        Instrument

        Raises
        ------
        RuntimeError
            If `obj_bytes` cannot be deserialized.

        """
        Condition.not_none(obj_bytes, "obj_bytes")

        cdef dict obj_dict = self._decode(obj_bytes)  # type: dict[str, Any]
        cdef dict timestamp_kvs = {
            k: v for k, v in obj_dict.items() if k in ("expire_time_ns") or re.match(r"^ts_", k)
        }

        cdef:
            str key
            uint64_t value_uint64
        if self.timestamps_as_iso8601 or self.timestamps_as_str:
            for key, value in timestamp_kvs.items():
                if value is None:
                    continue
                if re.match(r"^\d+$", value):  # Check if value is an integer-like string
                    value_uint64 = int(value)
                    obj_dict[key] = value_uint64
                else:  # Else assume the value is ISO 8601 format
                    value_uint64 = pd.Timestamp(value, tz=pytz.utc).value
                    obj_dict[key] = value_uint64

        cdef str obj_type = obj_dict.get("type")
        if obj_type is None:
            return obj_dict

        delegate = _OBJECT_FROM_DICT_MAP.get(obj_type)
        if delegate is None:
            return obj_dict

        return delegate(obj_dict)


def _serializer_encoding_hook(obj: Any) -> Any:
    if isinstance(obj, pd.Timestamp):
        return obj.value
    if isinstance(obj, pd.Timedelta):
        return obj.value
    return _base_msgspec_encoding_hook(obj)

</document_content>
</document>
<document index="2572">
<source>nautilus_trader/trading/strategy.pyx</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#  https://nautechsystems.io
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may not use this file except in compliance with the License.
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# -------------------------------------------------------------------------------------------------

"""
This module defines a trading strategy class which allows users to implement
their own customized trading strategies

A user can inherit from `Strategy` and optionally override any of the
"on" named event methods. The class is not entirely initialized in a stand-alone
way, the intended usage is to pass strategies to a `Trader` so that they can be
fully "wired" into the platform. Exceptions will be raised if a `Strategy`
attempts to operate without a managing `Trader` instance.

"""

from nautilus_trader.trading.config import ImportableStrategyConfig
from nautilus_trader.trading.config import StrategyConfig

from libc.stdint cimport uint64_t

from nautilus_trader.cache.base cimport CacheFacade
from nautilus_trader.cache.cache cimport Cache
from nautilus_trader.common.actor cimport Actor
from nautilus_trader.common.component cimport EVT
from nautilus_trader.common.component cimport RECV
from nautilus_trader.common.component cimport Clock
from nautilus_trader.common.component cimport LogColor
from nautilus_trader.common.component cimport Logger
from nautilus_trader.common.component cimport MessageBus
from nautilus_trader.common.component cimport TimeEvent
from nautilus_trader.common.factories cimport OrderFactory
from nautilus_trader.core.correctness cimport Condition
from nautilus_trader.core.fsm cimport InvalidStateTrigger
from nautilus_trader.core.message cimport Event
from nautilus_trader.core.rust.common cimport ComponentState
from nautilus_trader.core.rust.model cimport OrderStatus
from nautilus_trader.core.rust.model cimport TimeInForce
from nautilus_trader.core.rust.model cimport TriggerType
from nautilus_trader.core.uuid cimport UUID4
from nautilus_trader.execution.messages cimport BatchCancelOrders
from nautilus_trader.execution.messages cimport CancelAllOrders
from nautilus_trader.execution.messages cimport CancelOrder
from nautilus_trader.execution.messages cimport ModifyOrder
from nautilus_trader.execution.messages cimport QueryAccount
from nautilus_trader.execution.messages cimport QueryOrder
from nautilus_trader.execution.messages cimport SubmitOrder
from nautilus_trader.execution.messages cimport SubmitOrderList
from nautilus_trader.model.data cimport Bar
from nautilus_trader.model.data cimport BarType
from nautilus_trader.model.data cimport QuoteTick
from nautilus_trader.model.data cimport TradeTick
from nautilus_trader.model.events.order cimport OrderAccepted
from nautilus_trader.model.events.order cimport OrderCanceled
from nautilus_trader.model.events.order cimport OrderCancelRejected
from nautilus_trader.model.events.order cimport OrderDenied
from nautilus_trader.model.events.order cimport OrderEmulated
from nautilus_trader.model.events.order cimport OrderEvent
from nautilus_trader.model.events.order cimport OrderExpired
from nautilus_trader.model.events.order cimport OrderFilled
from nautilus_trader.model.events.order cimport OrderInitialized
from nautilus_trader.model.events.order cimport OrderModifyRejected
from nautilus_trader.model.events.order cimport OrderPendingCancel
from nautilus_trader.model.events.order cimport OrderPendingUpdate
from nautilus_trader.model.events.order cimport OrderRejected
from nautilus_trader.model.events.order cimport OrderReleased
from nautilus_trader.model.events.order cimport OrderSubmitted
from nautilus_trader.model.events.order cimport OrderTriggered
from nautilus_trader.model.events.order cimport OrderUpdated
from nautilus_trader.model.events.position cimport PositionChanged
from nautilus_trader.model.events.position cimport PositionClosed
from nautilus_trader.model.events.position cimport PositionEvent
from nautilus_trader.model.events.position cimport PositionOpened
from nautilus_trader.model.functions cimport oms_type_from_str
from nautilus_trader.model.functions cimport order_side_to_str
from nautilus_trader.model.functions cimport order_status_to_str
from nautilus_trader.model.functions cimport position_side_to_str
from nautilus_trader.model.identifiers cimport AccountId
from nautilus_trader.model.identifiers cimport ClientOrderId
from nautilus_trader.model.identifiers cimport ExecAlgorithmId
from nautilus_trader.model.identifiers cimport InstrumentId
from nautilus_trader.model.identifiers cimport PositionId
from nautilus_trader.model.identifiers cimport StrategyId
from nautilus_trader.model.identifiers cimport TraderId
from nautilus_trader.model.objects cimport Price
from nautilus_trader.model.objects cimport Quantity
from nautilus_trader.model.orders.base cimport LIMIT_ORDER_TYPES
from nautilus_trader.model.orders.base cimport STOP_ORDER_TYPES
from nautilus_trader.model.orders.base cimport Order
from nautilus_trader.model.orders.list cimport OrderList
from nautilus_trader.model.orders.market cimport MarketOrder
from nautilus_trader.model.position cimport Position
from nautilus_trader.portfolio.base cimport PortfolioFacade


cdef class Strategy(Actor):
    """
    The base class for all trading strategies.

    This class allows traders to implement their own customized trading strategies.
    A trading strategy can configure its own order management system type, which
    determines how positions are handled by the `ExecutionEngine`.

    Strategy OMS (Order Management System) types:
     - ``UNSPECIFIED``: No specific type has been configured, will therefore
       default to the native OMS type for each venue.
     - ``HEDGING``: A position ID will be assigned for each new position which
       is opened per instrument.
     - ``NETTING``: There will only be a single position for the strategy per
       instrument. The position ID naming convention is `{instrument_id}-{strategy_id}`.

    Parameters
    ----------
    config : StrategyConfig, optional
        The trading strategy configuration.

    Raises
    ------
    TypeError
        If `config` is not of type `StrategyConfig`.

    Warnings
    --------
    - This class should not be used directly, but through a concrete subclass.
    - Do not call components such as `clock` and `logger` in the `__init__` prior to registration.
    """

    def __init__(self, config: StrategyConfig | None = None):
        if config is None:
            config = StrategyConfig()
        Condition.type(config, StrategyConfig, "config")

        super().__init__()
        # Assign strategy ID after base class initialized
        component_id = type(self).__name__ if config.strategy_id is None else config.strategy_id
        self.id = StrategyId(f"{component_id}-{config.order_id_tag}")
        self.order_id_tag = str(config.order_id_tag)
        self.use_uuid_client_order_ids = config.use_uuid_client_order_ids
        self.use_hyphens_in_client_order_ids = config.use_hyphens_in_client_order_ids
        self._log = Logger(name=component_id)

        oms_type = config.oms_type or OmsType.UNSPECIFIED
        if isinstance(oms_type, str):
            oms_type = oms_type_from_str(config.oms_type.upper())

        # Configuration
        self._log_events = config.log_events
        self._log_commands = config.log_commands
        self._log_rejected_due_post_only_as_warning = config.log_rejected_due_post_only_as_warning
        self.config = config
        self.oms_type = <OmsType>oms_type
        self.external_order_claims = self._parse_external_order_claims(config.external_order_claims)
        self.manage_contingent_orders = config.manage_contingent_orders
        self.manage_gtd_expiry = config.manage_gtd_expiry

        # Public components
        self.clock = self._clock
        self.cache: Cache = None   # Initialized when registered
        self.portfolio = None      # Initialized when registered
        self.order_factory = None  # Initialized when registered

        # Order management
        self._manager = None       # Initialized when registered

        # Register warning events
        self.register_warning_event(OrderDenied)
        self.register_warning_event(OrderRejected)
        self.register_warning_event(OrderCancelRejected)
        self.register_warning_event(OrderModifyRejected)

    def _parse_external_order_claims(
        self,
        config_claims: list[str] | None,
    ) -> list[InstrumentId]:
        if config_claims is None:
            return []

        order_claims: list[InstrumentId] = []
        for instrument_id in config_claims:
            if isinstance(instrument_id, str):
                instrument_id = InstrumentId.from_str(instrument_id)
            order_claims.append(instrument_id)

        return order_claims

    def to_importable_config(self) -> ImportableStrategyConfig:
        """
        Returns an importable configuration for this strategy.

        Returns
        -------
        ImportableStrategyConfig

        """
        return ImportableStrategyConfig(
            strategy_path=self.fully_qualified_name(),
            config_path=self.config.fully_qualified_name(),
            config=self.config.dict(),
        )

# -- REGISTRATION ---------------------------------------------------------------------------------

    cpdef void on_start(self):
        # Should override in subclass
        self.log.warning(
            "The `Strategy.on_start` handler was called when not overridden. "
            "It's expected that any actions required when starting the strategy "
            "occur here, such as subscribing/requesting data",
        )

    cpdef void on_stop(self):
        # Should override in subclass
        self.log.warning(
            "The `Strategy.on_stop` handler was called when not overridden. "
            "It's expected that any actions required when stopping the strategy "
            "occur here, such as unsubscribing from data",
        )

    cpdef void on_resume(self):
        # Should override in subclass
        self.log.warning(
            "The `Strategy.on_resume` handler was called when not overridden. "
            "It's expected that any actions required when resuming the strategy "
            "following a stop occur here"
        )

    cpdef void on_reset(self):
        # Should override in subclass
        self.log.warning(
            "The `Strategy.on_reset` handler was called when not overridden. "
            "It's expected that any actions required when resetting the strategy "
            "occur here, such as resetting indicators and other state"
        )

# -- REGISTRATION ---------------------------------------------------------------------------------

    cpdef void register(
        self,
        TraderId trader_id,
        PortfolioFacade portfolio,
        MessageBus msgbus,
        CacheFacade cache,
        Clock clock,
    ):
        """
        Register the strategy with a trader.

        Parameters
        ----------
        trader_id : TraderId
            The trader ID for the strategy.
        portfolio : PortfolioFacade
            The read-only portfolio for the strategy.
        msgbus : MessageBus
            The message bus for the strategy.
        cache : CacheFacade
            The read-only cache for the strategy.
        clock : Clock
            The clock for the strategy.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(trader_id, "trader_id")
        Condition.not_none(portfolio, "portfolio")
        Condition.not_none(msgbus, "msgbus")
        Condition.not_none(cache, "cache")
        Condition.not_none(clock, "clock")

        self.register_base(
            portfolio=portfolio,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
        )

        self.order_factory = OrderFactory(
            trader_id=self.trader_id,
            strategy_id=self.id,
            clock=clock,
            cache=cache,
            use_uuid_client_order_ids=self.use_uuid_client_order_ids,
            use_hyphens_in_client_order_ids=self.use_hyphens_in_client_order_ids
        )

        self._manager = OrderManager(
            clock=clock,
            msgbus=msgbus,
            cache=cache,
            component_name=type(self).__name__,
            active_local=False,
            submit_order_handler=None,
            cancel_order_handler=self.cancel_order,
            modify_order_handler=self.modify_order,
            debug=False,  # Set True for debugging
            log_events=self._log_events,
            log_commands=self._log_commands,
        )

        # Required subscriptions
        self._msgbus.subscribe(topic=f"events.order.{self.id}", handler=self.handle_event)
        self._msgbus.subscribe(topic=f"events.position.{self.id}", handler=self.handle_event)

    cpdef void change_id(self, StrategyId strategy_id):
        """
        Change the strategies identifier to the given `strategy_id`.

        Parameters
        ----------
        strategy_id : StrategyId
            The new strategy ID to change to.

        """
        Condition.not_none(strategy_id, "strategy_id")

        self.id = strategy_id

    cpdef void change_order_id_tag(self, str order_id_tag):
        """
        Change the order identifier tag to the given `order_id_tag`.

        Parameters
        ----------
        order_id_tag : str
            The new order ID tag to change to.

        """
        Condition.valid_string(order_id_tag, "order_id_tag")

        self.order_id_tag = order_id_tag

# -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------

    cpdef void _start(self):
        # Log configuration
        self._log.info(f"{self.config.oms_type=}", LogColor.BLUE)
        self._log.info(f"{self.config.external_order_claims=}", LogColor.BLUE)
        self._log.info(f"{self.config.manage_gtd_expiry=}", LogColor.BLUE)

        cdef set client_order_ids = self.cache.client_order_ids(
            venue=None,
            instrument_id=None,
            strategy_id=self.id,
        )

        cdef set order_list_ids = self.cache.order_list_ids(
            venue=None,
            instrument_id=None,
            strategy_id=self.id,
        )

        cdef int order_id_count = len(client_order_ids)
        cdef int order_list_id_count = len(order_list_ids)
        self.order_factory.set_client_order_id_count(order_id_count)
        self.log.info(
            f"Set ClientOrderIdGenerator client_order_id count to {order_id_count}",
            LogColor.BLUE,
        )
        self.order_factory.set_order_list_id_count(order_list_id_count)
        self.log.info(
            f"Set ClientOrderIdGenerator order_list_id count to {order_list_id_count}",
            LogColor.BLUE,
        )

        cdef list open_orders = self.cache.orders_open(
            venue=None,
            instrument_id=None,
            strategy_id=self.id,
        )

        if self.manage_gtd_expiry:
            for order in open_orders:
                if order.time_in_force == TimeInForce.GTD:
                    if self._clock.timestamp_ns() >= order.expire_time_ns:
                        self.cancel_order(order)
                        continue
                    if not self._has_gtd_expiry_timer(order.client_order_id):
                        self._set_gtd_expiry(order)

        self.on_start()

    cpdef void _reset(self):
        if self.order_factory:
            self.order_factory.reset()

        self._indicators.clear()
        self._indicators_for_quotes.clear()
        self._indicators_for_trades.clear()
        self._indicators_for_bars.clear()

        if self._manager:
            self._manager.reset()

        self.on_reset()

# -- ABSTRACT METHODS -----------------------------------------------------------------------------

    cpdef void on_order_event(self, OrderEvent event):
        """
        Actions to be performed when running and receives an order event.

        Parameters
        ----------
        event : OrderEvent
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_initialized(self, OrderInitialized event):
        """
        Actions to be performed when running and receives an order initialized event.

        Parameters
        ----------
        event : OrderInitialized
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_denied(self, OrderDenied event):
        """
        Actions to be performed when running and receives an order denied event.

        Parameters
        ----------
        event : OrderDenied
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_emulated(self, OrderEmulated event):
        """
        Actions to be performed when running and receives an order emulated event.

        Parameters
        ----------
        event : OrderEmulated
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_released(self, OrderReleased event):
        """
        Actions to be performed when running and receives an order released event.

        Parameters
        ----------
        event : OrderReleased
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_submitted(self, OrderSubmitted event):
        """
        Actions to be performed when running and receives an order submitted event.

        Parameters
        ----------
        event : OrderSubmitted
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_rejected(self, OrderRejected event):
        """
        Actions to be performed when running and receives an order rejected event.

        Parameters
        ----------
        event : OrderRejected
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_accepted(self, OrderAccepted event):
        """
        Actions to be performed when running and receives an order accepted event.

        Parameters
        ----------
        event : OrderAccepted
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_canceled(self, OrderCanceled event):
        """
        Actions to be performed when running and receives an order canceled event.

        Parameters
        ----------
        event : OrderCanceled
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_expired(self, OrderExpired event):
        """
        Actions to be performed when running and receives an order expired event.

        Parameters
        ----------
        event : OrderExpired
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_triggered(self, OrderTriggered event):
        """
        Actions to be performed when running and receives an order triggered event.

        Parameters
        ----------
        event : OrderTriggered
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_pending_update(self, OrderPendingUpdate event):
        """
        Actions to be performed when running and receives an order pending update event.

        Parameters
        ----------
        event : OrderPendingUpdate
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_pending_cancel(self, OrderPendingCancel event):
        """
        Actions to be performed when running and receives an order pending cancel event.

        Parameters
        ----------
        event : OrderPendingCancel
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_modify_rejected(self, OrderModifyRejected event):
        """
        Actions to be performed when running and receives an order modify rejected event.

        Parameters
        ----------
        event : OrderModifyRejected
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_cancel_rejected(self, OrderCancelRejected event):
        """
        Actions to be performed when running and receives an order cancel rejected event.

        Parameters
        ----------
        event : OrderCancelRejected
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_updated(self, OrderUpdated event):
        """
        Actions to be performed when running and receives an order updated event.

        Parameters
        ----------
        event : OrderUpdated
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_order_filled(self, OrderFilled event):
        """
        Actions to be performed when running and receives an order filled event.

        Parameters
        ----------
        event : OrderFilled
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_position_event(self, PositionEvent event):
        """
        Actions to be performed when running and receives a position event.

        Parameters
        ----------
        event : PositionEvent
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_position_opened(self, PositionOpened event):
        """
        Actions to be performed when running and receives a position opened event.

        Parameters
        ----------
        event : PositionOpened
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_position_changed(self, PositionChanged event):
        """
        Actions to be performed when running and receives a position changed event.

        Parameters
        ----------
        event : PositionChanged
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

    cpdef void on_position_closed(self, PositionClosed event):
        """
        Actions to be performed when running and receives a position closed event.

        Parameters
        ----------
        event : PositionClosed
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        # Optionally override in subclass

# -- TRADING COMMANDS -----------------------------------------------------------------------------

    cpdef void submit_order(
        self,
        Order order,
        PositionId position_id = None,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Submit the given order with optional position ID, execution algorithm
        and routing instructions.

        A `SubmitOrder` command will be created and sent to **either** an
        `ExecAlgorithm`, the `OrderEmulator` or the `RiskEngine` (depending whether
        the order is emulated and/or has an `exec_algorithm_id` specified).

        If the client order ID is duplicate, then the order will be denied.

        Parameters
        ----------
        order : Order
            The order to submit.
        position_id : PositionId, optional
            The position ID to submit the order against. If a position does not
            yet exist, then any position opened will have this identifier assigned.
        client_id : ClientId, optional
            The specific execution client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        Raises
        ------
        ValueError
            If `order.status` is not ``INITIALIZED``.

        Warning
        -------
        If a `position_id` is passed and a position does not yet exist, then any
        position opened by the order will have this position ID assigned. This may
        not be what you intended.

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(order, "order")
        if order._fsm.state != OrderStatus.INITIALIZED:  # Check predicate first for efficiency
            Condition.is_true(
                order.status_c() == OrderStatus.INITIALIZED,
                f"Invalid order status on submit: expected 'INITIALIZED', was '{order.status_string_c()}'",
            )

        # Publish initialized event
        self._msgbus.publish_c(
            topic=f"events.order.{order.strategy_id.to_str()}",
            msg=order.init_event_c(),
        )

        # Check for duplicate client order ID
        if self.cache.order_exists(order.client_order_id):
            self._deny_order(order, f"duplicate {repr(order.client_order_id)}")
            return

        self.cache.add_order(order, position_id, client_id)

        cdef SubmitOrder command = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            order=order,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            position_id=position_id,
            client_id=client_id,
            params=params,
        )

        if self.manage_gtd_expiry and order.time_in_force == TimeInForce.GTD:
            self._set_gtd_expiry(order)

        # Route order
        if order.emulation_trigger != TriggerType.NO_TRIGGER:
            self._manager.send_emulator_command(command)
        elif order.exec_algorithm_id is not None:
            self._manager.send_algo_command(command, order.exec_algorithm_id)
        else:
            self._manager.send_risk_command(command)

    cpdef void submit_order_list(
        self,
        OrderList order_list,
        PositionId position_id = None,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Submit the given order list with optional position ID, execution algorithm
        and routing instructions.

        A `SubmitOrderList` command will be created and sent to **either** the
        `OrderEmulator`, or the `RiskEngine` (depending whether an order is emulated).

        If the order list ID is duplicate, or any client order ID is duplicate,
        then all orders will be denied.

        Parameters
        ----------
        order_list : OrderList
            The order list to submit.
        position_id : PositionId, optional
            The position ID to submit the order against. If a position does not
            yet exist, then any position opened will have this identifier assigned.
        client_id : ClientId, optional
            The specific execution client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        Raises
        ------
        ValueError
            If any `order.status` is not ``INITIALIZED``.

        Warning
        -------
        If a `position_id` is passed and a position does not yet exist, then any
        position opened by an order will have this position ID assigned. This may
        not be what you intended.

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(order_list, "order_list")

        cdef Order order
        for order in order_list.orders:
            Condition.equal(order.status_c(), OrderStatus.INITIALIZED, "order", "order_status")
            # Publish initialized event
            self._msgbus.publish_c(
                topic=f"events.order.{order.strategy_id.to_str()}",
                msg=order.init_event_c(),
            )

        # Check for duplicate order list ID
        if self.cache.order_list_exists(order_list.id):
            self._deny_order_list(
                order_list,
                reason=f"duplicate {repr(order_list.id)}",
            )
            return

        self.cache.add_order_list(order_list)

        # Check for duplicate client order IDs
        for order in order_list.orders:
            if self.cache.order_exists(order.client_order_id):
                for order in order_list.orders:
                    self._deny_order(
                        order,
                        reason=f"duplicate {repr(order.client_order_id)}",
                    )
                return

        for order in order_list.orders:
            self.cache.add_order(order, position_id, client_id)

        cdef SubmitOrderList command = SubmitOrderList(
            trader_id=self.trader_id,
            strategy_id=self.id,
            order_list=order_list,
            position_id=position_id,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            client_id=client_id,
            params=params,
        )

        if self.manage_gtd_expiry:
            for order in command.order_list.orders:
                if order.time_in_force == TimeInForce.GTD:
                    self._set_gtd_expiry(order)

        # Route order
        if command.has_emulated_order:
            self._manager.send_emulator_command(command)
        elif order_list.first.exec_algorithm_id is not None:
            self._manager.send_algo_command(command, order_list.first.exec_algorithm_id)
        else:
            self._manager.send_risk_command(command)

    cpdef void modify_order(
        self,
        Order order,
        Quantity quantity = None,
        Price price = None,
        Price trigger_price = None,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Modify the given order with optional parameters and routing instructions.

        An `ModifyOrder` command will be created and then sent to **either** the
        `OrderEmulator` or the `RiskEngine` (depending on whether the order is emulated).

        At least one value must differ from the original order for the command to be valid.

        Will use an Order Cancel/Replace Request (a.k.a Order Modification)
        for FIX protocols, otherwise if order update is not available for
        the API, then will cancel and replace with a new order using the
        original `ClientOrderId`.

        Parameters
        ----------
        order : Order
            The order to update.
        quantity : Quantity, optional
            The updated quantity for the given order.
        price : Price, optional
            The updated price for the given order (if applicable).
        trigger_price : Price, optional
            The updated trigger price for the given order (if applicable).
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        Raises
        ------
        ValueError
            If `price` is not ``None`` and order does not have a `price`.
        ValueError
            If `trigger` is not ``None`` and order does not have a `trigger_price`.

        Warnings
        --------
        If the order is already closed or at `PENDING_CANCEL` status
        then the command will not be generated, and a warning will be logged.

        References
        ----------
        https://www.onixs.biz/fix-dictionary/5.0.SP2/msgType_G_71.html

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(order, "order")

        cdef ModifyOrder command = self._create_modify_order(
            order=order,
            quantity=quantity,
            price=price,
            trigger_price=trigger_price,
            client_id=client_id,
            params=params,
        )
        if command is None:
            return

        if order.is_emulated_c():
            self._manager.send_emulator_command(command)
        else:
            self._manager.send_risk_command(command)

    cpdef void cancel_order(self, Order order, ClientId client_id = None, dict[str, object] params = None):
        """
        Cancel the given order with optional routing instructions.

        A `CancelOrder` command will be created and then sent to **either** the
        `OrderEmulator` or the `ExecutionEngine` (depending on whether the order is emulated).

        Parameters
        ----------
        order : Order
            The order to cancel.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(order, "order")

        cdef CancelOrder command = self._create_cancel_order(
            order=order,
            client_id=client_id,
            params=params,
        )
        if command is None:
            return

        if order.is_emulated_c() or order.emulation_trigger != TriggerType.NO_TRIGGER:
            self._manager.send_emulator_command(command)
        elif order.exec_algorithm_id is not None and order.is_active_local_c():
            self._manager.send_algo_command(command, order.exec_algorithm_id)
        else:
            self._manager.send_exec_command(command)

        # Cancel any GTD expiry timer
        if self.manage_gtd_expiry:
            if order.time_in_force == TimeInForce.GTD and self._has_gtd_expiry_timer(order.client_order_id):
                self.cancel_gtd_expiry(order)

    cpdef void cancel_orders(self, list orders, ClientId client_id = None, dict[str, object] params = None):
        """
        Batch cancel the given list of orders with optional routing instructions.

        For each order in the list, a `CancelOrder` command will be created and added to a
        `BatchCancelOrders` command. This command is then sent to the `ExecutionEngine`.

        Logs an error if the `orders` list contains local/emulated orders.

        Parameters
        ----------
        orders : list[Order]
            The orders to cancel.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        Raises
        ------
        ValueError
            If `orders` is empty.
        TypeError
            If `orders` contains a type other than `Order`.

        """
        Condition.not_empty(orders, "orders")
        Condition.list_type(orders, Order, "orders")

        cdef list cancels = []

        cdef:
            Order order
            Order first = None
            CancelOrder cancel
        for order in orders:
            if first is None:
                first = order
            else:
                if first.instrument_id != order.instrument_id:
                    self._log.error(
                        "Cannot cancel all orders: instrument_id mismatch "
                        f"{first.instrument_id} vs {order.instrument_id}",
                    )
                    return
                if order.is_emulated_c():
                    self._log.error(
                        "Cannot include emulated orders in a batch cancel"
                    )
                    return

            cancel = self._create_cancel_order(
                order=order,
                client_id=client_id,
            )
            if cancel is None:
                continue
            cancels.append(cancel)

        if not cancels:
            self._log.warning("Cannot send `BatchCancelOrders`, no valid cancel commands")
            return

        cdef command = BatchCancelOrders(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=first.instrument_id,
            cancels=cancels,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            client_id=client_id,
            params=params,
        )

        self._manager.send_exec_command(command)

    cpdef void cancel_all_orders(
        self,
        InstrumentId instrument_id,
        OrderSide order_side = OrderSide.NO_ORDER_SIDE,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        """
        Cancel all orders for this strategy for the given instrument ID.

        A `CancelAllOrders` command will be created and then sent to **both** the
        `OrderEmulator` and the `ExecutionEngine`.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the orders to cancel.
        order_side : OrderSide, default ``NO_ORDER_SIDE`` (both sides)
            The side of the orders to cancel.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(instrument_id, "instrument_id")

        cdef list open_orders = self.cache.orders_open(
            venue=None,  # Faster query filtering
            instrument_id=instrument_id,
            strategy_id=self.id,
            side=order_side,
        )

        cdef list emulated_orders = self.cache.orders_emulated(
            venue=None,  # Faster query filtering
            instrument_id=instrument_id,
            strategy_id=self.id,
            side=order_side,
        )

        cdef str order_side_str = " " + order_side_to_str(order_side) if order_side != OrderSide.NO_ORDER_SIDE else ""
        if not open_orders and not emulated_orders:
            self.log.info(
                f"No {instrument_id.to_str()} open or emulated{order_side_str} "
                f"orders to cancel")
            return

        cdef int open_count = len(open_orders)
        if open_count:
            self.log.info(
                f"Canceling {open_count} open{order_side_str} "
                f"{instrument_id.to_str()} order{'' if open_count == 1 else 's'}",
            )

        cdef int emulated_count = len(emulated_orders)
        if emulated_count:
            self.log.info(
                f"Canceling {emulated_count} emulated{order_side_str} "
                f"{instrument_id.to_str()} order{'' if emulated_count == 1 else 's'}",
            )

        cdef:
            OrderPendingCancel event
            Order order
        for order in open_orders + emulated_orders:
            if order.status_c() == OrderStatus.INITIALIZED or order.is_emulated_c():
                continue
            event = self._generate_order_pending_cancel(order)
            try:
                order.apply(event)
            except InvalidStateTrigger as e:
                self._log.warning(f"InvalidStateTrigger: {e}, did not apply {event}")
                continue

            self.cache.update_order(order)

        # Cancel all execution algorithm orders
        cdef set exec_algorithm_ids = self.cache.exec_algorithm_ids()

        cdef:
            ExecAlgorithmId exec_algorithm_id
        for exec_algorithm_id in exec_algorithm_ids:
            exec_algorithm_orders = self.cache.orders_for_exec_algorithm(exec_algorithm_id)
            for order in exec_algorithm_orders:
                if order.strategy_id == self.id and not order.is_closed_c():
                    self.cancel_order(order)

        cdef CancelAllOrders command

        if open_count > 0:
            command = CancelAllOrders(
                trader_id=self.trader_id,
                strategy_id=self.id,
                instrument_id=instrument_id,
                order_side=order_side,
                command_id=UUID4(),
                ts_init=self.clock.timestamp_ns(),
                client_id=client_id,
                params=params,
            )
            self._manager.send_exec_command(command)

        if emulated_count > 0:
            command = CancelAllOrders(
                trader_id=self.trader_id,
                strategy_id=self.id,
                instrument_id=instrument_id,
                order_side=order_side,
                command_id=UUID4(),
                ts_init=self.clock.timestamp_ns(),
                client_id=client_id,
                params=params,
            )
            self._manager.send_emulator_command(command)

    cpdef void close_position(
        self,
        Position position,
        ClientId client_id = None,
        list[str] tags = None,
        TimeInForce time_in_force = TimeInForce.GTC,
        bint reduce_only = True,
        bint quote_quantity = False,
        dict[str, object] params = None,
    ):
        """
        Close the given position.

        A closing `MarketOrder` for the position will be created, and then sent
        to the `ExecutionEngine` via a `SubmitOrder` command.

        Parameters
        ----------
        position : Position
            The position to close.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        tags : list[str], optional
            The tags for the market order closing the position.
        time_in_force : TimeInForce, default ``GTC``
            The time in force for the market order closing the position.
        reduce_only : bool, default True
            If the market order to close the position should carry the 'reduce-only' execution instruction.
            Optional, as not all venues support this feature.
        quote_quantity : bool, default False
            If the order quantity should be interpreted as quoted (e.g. in USDT for ETH-USDT).
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(position, "position")
        Condition.not_none(self.trader_id, "self.trader_id")
        Condition.not_none(self.order_factory, "self.order_factory")

        if position.is_closed_c():
            self.log.warning(
                f"Cannot close position "
                f"(the position is already closed), {position}"
            )
            return  # Invalid command

        # Create closing order
        cdef MarketOrder order = self.order_factory.market(
            instrument_id=position.instrument_id,
            order_side=Order.closing_side_c(position.side),
            quantity=position.quantity,
            time_in_force=time_in_force,
            reduce_only=reduce_only,
            quote_quantity=quote_quantity,
            exec_algorithm_id=None,
            exec_algorithm_params=None,
            tags=tags,
        )

        self.submit_order(order, position_id=position.id, client_id=client_id, params=params)

    cpdef void close_all_positions(
        self,
        InstrumentId instrument_id,
        PositionSide position_side = PositionSide.NO_POSITION_SIDE,
        ClientId client_id = None,
        list[str] tags = None,
        TimeInForce time_in_force = TimeInForce.GTC,
        bint reduce_only = True,
        bint quote_quantity = False,
        dict[str, object] params = None,
    ):
        """
        Close all positions for the given instrument ID for this strategy.

        Parameters
        ----------
        instrument_id : InstrumentId
            The instrument for the positions to close.
        position_side : PositionSide, default ``NO_POSITION_SIDE`` (both sides)
            The side of the positions to close.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        tags : list[str], optional
            The tags for the market orders closing the positions.
        time_in_force : TimeInForce, default ``GTC``
            The time in force for the market orders closing the positions.
        reduce_only : bool, default True
            If the market orders to close positions should carry the 'reduce-only' execution instruction.
            Optional, as not all venues support this feature.
        quote_quantity : bool, default False
            If the order quantity is denominated in the quote currency.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        # instrument_id can be None
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")

        cdef list positions_open = self.cache.positions_open(
            venue=None,  # Faster query filtering
            instrument_id=instrument_id,
            strategy_id=self.id,
            side=position_side,
        )

        cdef str position_side_str = " " + position_side_to_str(position_side) if position_side != PositionSide.NO_POSITION_SIDE else ""
        if not positions_open:
            self.log.info(
                f"No {instrument_id.to_str()} open{position_side_str} positions to close",
            )
            return

        cdef int count = len(positions_open)
        self.log.info(
            f"Closing {count} open{position_side_str} position{'' if count == 1 else 's'}",
        )

        cdef Position position
        for position in positions_open:
            self.close_position(
                position,
                client_id,
                tags,
                time_in_force,
                reduce_only,
                quote_quantity,
                params,
            )

    cpdef void query_account(self, AccountId account_id, ClientId client_id = None, dict[str, object] params = None):
        """
        Query the account with optional routing instructions.

        A `QueryAccount` command will be created and then sent to the
        `ExecutionEngine`.

        Parameters
        ----------
        account_id : AccountId
            The account to query.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")

        cdef QueryAccount command = QueryAccount(
            trader_id=self.trader_id,
            account_id=account_id,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            client_id=client_id,
            params=params,
        )

        self._manager.send_exec_command(command)

    cpdef void query_order(self, Order order, ClientId client_id = None, dict[str, object] params = None):
        """
        Query the given order with optional routing instructions.

        A `QueryOrder` command will be created and then sent to the
        `ExecutionEngine`.

        Logs an error if no `VenueOrderId` has been assigned to the order.

        Parameters
        ----------
        order : Order
            The order to query.
        client_id : ClientId, optional
            The specific client ID for the command.
            If ``None`` then will be inferred from the venue in the instrument ID.
        params : dict[str, Any], optional
            Additional parameters potentially used by a specific client.

        """
        Condition.is_true(self.trader_id is not None, "The strategy has not been registered")
        Condition.not_none(order, "order")

        cdef QueryOrder command = QueryOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            client_id=client_id,
            params=params,
        )

        self._manager.send_exec_command(command)

    cdef ModifyOrder _create_modify_order(
        self,
        Order order,
        Quantity quantity = None,
        Price price = None,
        Price trigger_price = None,
        ClientId client_id = None,
        dict[str, object] params = None,
    ):
        cdef bint updating = False  # Set validation flag (must become true)

        if quantity is not None and quantity != order.quantity:
            updating = True

        if price is not None:
            Condition.is_true(
                order.order_type in LIMIT_ORDER_TYPES,
                fail_msg=f"{order.type_string_c()} orders do not have a LIMIT price",
            )
            if price != order.price:
                updating = True

        if trigger_price is not None:
            Condition.is_true(
                order.order_type in STOP_ORDER_TYPES,
                fail_msg=f"{order.type_string_c()} orders do not have a STOP trigger price",
            )
            if trigger_price != order.trigger_price:
                updating = True

        if not updating:
            price_str = f", {order.price=}" if order.has_price_c() else ""
            trigger_str = f", {order.trigger_price=}" if order.has_trigger_price_c() else ""
            self.log.error(
                "Cannot create command ModifyOrder: "
                f"{quantity=}, {price=}, {trigger_price=} were either None "
                f"or the same as existing values: {order.quantity=}{price_str}{trigger_str}",
            )
            return None  # Cannot send command

        if order.is_closed_c() or order.is_pending_cancel_c():
            self.log.warning(
                f"Cannot create command ModifyOrder: "
                f"state is {order.status_string_c()}, {order}",
            )
            return None  # Cannot send command

        cdef OrderPendingUpdate event
        if not order.is_active_local_c():
            # Generate and apply event
            event = self._generate_order_pending_update(order)
            try:
                order.apply(event)
            except InvalidStateTrigger as e:
                self._log.warning(f"InvalidStateTrigger: {e}, did not apply {event}")
                return None  # Cannot send command

            self.cache.update_order(order)

            # Publish event
            self._msgbus.publish_c(
                topic=f"events.order.{order.strategy_id.to_str()}",
                msg=event,
            )

        return ModifyOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            quantity=quantity,
            price=price,
            trigger_price=trigger_price,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            client_id=client_id,
            params=params,
        )

    cdef CancelOrder _create_cancel_order(self, Order order, ClientId client_id = None, dict[str, object] params = None):
        if order.is_closed_c() or order.is_pending_cancel_c():
            self.log.warning(
                f"Cannot cancel order: state is {order.status_string_c()}, {order}",
            )
            return None  # Cannot send command

        cdef OrderStatus order_status = order.status_c()

        cdef OrderPendingCancel event
        if not order.is_active_local_c():
            # Generate and apply event
            event = self._generate_order_pending_cancel(order)
            try:
                order.apply(event)
            except InvalidStateTrigger as e:
                self._log.warning(f"InvalidStateTrigger: {e}, did not apply {event}")
                return None  # Cannot send command

            self.cache.update_order(order)

            # Publish event
            self._msgbus.publish_c(
                topic=f"events.order.{order.strategy_id.to_str()}",
                msg=event,
            )

        return CancelOrder(
            trader_id=self.trader_id,
            strategy_id=self.id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            command_id=UUID4(),
            ts_init=self.clock.timestamp_ns(),
            client_id=client_id,
            params=params,
        )

    cpdef void cancel_gtd_expiry(self, Order order):
        """
        Cancel the managed GTD expiry for the given order.

        If there is no current GTD expiry timer, then an error will be logged.

        Parameters
        ----------
        order : Order
            The order to cancel the GTD expiry for.

        """
        Condition.not_none(order, "order")

        cdef str timer_name = self._get_gtd_expiry_timer_name(order.client_order_id)
        cdef str expire_time_str = f" @ {order.expire_time.isoformat()}" if hasattr(order, "expire_time") else ""

        if timer_name not in self._clock.timer_names:
            self._log.error(f"Cannot find managed GTD timer for order {order.client_order_id!r}")
            return

        self._log.info(
            f"Canceling managed GTD expiry timer for {order.client_order_id}{expire_time_str}",
            LogColor.BLUE,
        )
        self._clock.cancel_timer(name=timer_name)

    cdef str _get_gtd_expiry_timer_name(self, ClientOrderId client_order_id):
        return f"GTD-EXPIRY:{client_order_id.to_str()}"

    cdef bint _has_gtd_expiry_timer(self, ClientOrderId client_order_id):
        cdef str timer_name = self._get_gtd_expiry_timer_name(client_order_id)
        return timer_name in self._clock.timer_names

    cdef void _set_gtd_expiry(self, Order order):
        cdef str timer_name = self._get_gtd_expiry_timer_name(order.client_order_id)
        self._clock.set_time_alert_ns(
            name=timer_name,
            alert_time_ns=order.expire_time_ns,
            callback=self._expire_gtd_order,
        )

        self._log.info(
            f"Set managed GTD expiry timer for {order.client_order_id} @ {order.expire_time.isoformat()}",
            LogColor.BLUE,
        )

    cpdef void _expire_gtd_order(self, TimeEvent event):
        cdef ClientOrderId client_order_id = ClientOrderId(event.to_str().partition(":")[2])
        cdef Order order = self.cache.order(client_order_id)
        if order is None:
            self._log.warning(
                f"Order with {repr(client_order_id)} not found in the cache to apply {event}"
            )

        if order.is_closed_c():
            self._log.warning(f"GTD expired order {order.client_order_id} was already closed")
            return  # Already closed

        self._log.info(f"Expiring GTD order {order.client_order_id}", LogColor.BLUE)
        self.cancel_order(order)

    # -- HANDLERS -------------------------------------------------------------------------------------

    cpdef void handle_event(self, Event event):
        """
        Handle the given event.

        If state is ``RUNNING`` then passes to `on_event`.

        Parameters
        ----------
        event : Event
            The event received.

        Warnings
        --------
        System method (not intended to be called by user code).

        """
        Condition.not_none(event, "event")

        if type(event) in self._warning_events and not (
            isinstance(event, OrderRejected) and event.due_post_only and not self._log_rejected_due_post_only_as_warning
        ):
            self.log.warning(f"{RECV}{EVT} {event}")
        elif self._log_events:
            self.log.info(f"{RECV}{EVT} {event}")

        cdef Order order
        if self.manage_gtd_expiry and isinstance(event, OrderEvent):
            order = self.cache.order(event.client_order_id)
            if order is not None and order.is_closed_c() and self._has_gtd_expiry_timer(order.client_order_id):
                self.cancel_gtd_expiry(order)

        if self._fsm.state != ComponentState.RUNNING:
            return

        if self.manage_contingent_orders and self._manager is not None:
            self._manager.handle_event(event)

        try:
            # Send to specific event handler
            if isinstance(event, OrderInitialized):
                self.on_order_initialized(event)
                self.on_order_event(event)
            elif isinstance(event, OrderDenied):
                self.on_order_denied(event)
                self.on_order_event(event)
            elif isinstance(event, OrderEmulated):
                self.on_order_emulated(event)
                self.on_order_event(event)
            elif isinstance(event, OrderReleased):
                self.on_order_released(event)
                self.on_order_event(event)
            elif isinstance(event, OrderSubmitted):
                self.on_order_submitted(event)
                self.on_order_event(event)
            elif isinstance(event, OrderRejected):
                self.on_order_rejected(event)
                self.on_order_event(event)
            elif isinstance(event, OrderAccepted):
                self.on_order_accepted(event)
                self.on_order_event(event)
            elif isinstance(event, OrderCanceled):
                self.on_order_canceled(event)
                self.on_order_event(event)
            elif isinstance(event, OrderExpired):
                self.on_order_expired(event)
                self.on_order_event(event)
            elif isinstance(event, OrderTriggered):
                self.on_order_triggered(event)
                self.on_order_event(event)
            elif isinstance(event, OrderPendingUpdate):
                self.on_order_pending_update(event)
                self.on_order_event(event)
            elif isinstance(event, OrderPendingCancel):
                self.on_order_pending_cancel(event)
                self.on_order_event(event)
            elif isinstance(event, OrderModifyRejected):
                self.on_order_modify_rejected(event)
                self.on_order_event(event)
            elif isinstance(event, OrderCancelRejected):
                self.on_order_cancel_rejected(event)
                self.on_order_event(event)
            elif isinstance(event, OrderUpdated):
                self.on_order_updated(event)
                self.on_order_event(event)
            elif isinstance(event, OrderFilled):
                self.on_order_filled(event)
                self.on_order_event(event)
            elif isinstance(event, PositionOpened):
                self.on_position_opened(event)
                self.on_position_event(event)
            elif isinstance(event, PositionChanged):
                self.on_position_changed(event)
                self.on_position_event(event)
            elif isinstance(event, PositionClosed):
                self.on_position_closed(event)
                self.on_position_event(event)

            # Always send to general event handler
            self.on_event(event)
        except Exception as e:  # pragma: no cover
            self.log.exception(f"Error on handling {repr(event)}", e)
            raise

# -- EVENTS ---------------------------------------------------------------------------------------

    cdef OrderDenied _generate_order_denied(self, Order order, str reason):
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        return OrderDenied(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            reason=reason,
            event_id=UUID4(),
            ts_init=ts_now,
        )

    cdef OrderPendingUpdate _generate_order_pending_update(self, Order order):
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        return OrderPendingUpdate(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

    cdef OrderPendingCancel _generate_order_pending_cancel(self, Order order):
        cdef uint64_t ts_now = self._clock.timestamp_ns()
        return OrderPendingCancel(
            trader_id=order.trader_id,
            strategy_id=order.strategy_id,
            instrument_id=order.instrument_id,
            client_order_id=order.client_order_id,
            venue_order_id=order.venue_order_id,
            account_id=order.account_id,
            event_id=UUID4(),
            ts_event=ts_now,
            ts_init=ts_now,
        )

    cdef void _deny_order(self, Order order, str reason):
        self._log.error(f"Order denied: {reason}")

        if not self.cache.order_exists(order.client_order_id):
            self.cache.add_order(order)

        # Generate event
        cdef OrderDenied event = self._generate_order_denied(order, reason)

        try:
            order.apply(event)
        except InvalidStateTrigger as e:
            self._log.warning(f"InvalidStateTrigger: {e}, did not apply {event}")
            return

        self.cache.update_order(order)

        # Publish denied event
        self._msgbus.publish_c(
            topic=f"events.order.{order.strategy_id.to_str()}",
            msg=event,
        )

    cdef void _deny_order_list(self, OrderList order_list, str reason):
        cdef Order order
        for order in order_list.orders:
            if not order.is_closed_c():
                self._deny_order(order=order, reason=reason)

</document_content>
</document></documents>